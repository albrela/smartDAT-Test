<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<manifest xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="..\doc\CrownManifest.xsd">
    <declaration>
        <enum name="EthernetInterfaces" type="string">
            <item name="Ethernet 1">ETH1</item>
            <item name="Ethernet 2">ETH2</item>
            <item name="Ethernet 3">ETH3</item>
            <item name="Ethernet 4">ETH4</item>
        </enum>
        <enum name="EtherNetIPInterfaces">
            <item name="FBUS" desc="Communication Processor on P1 and P2">FBUS</item>
        </enum>
        <enum name="ProfinetIOInterfaces">
            <item name="FBUS" desc="Communication Processor on P1 and P2">FBUS</item>
        </enum>
        <enum name="MountedDrives">
            <item name="RAM" desc="RAM drive which uses available memory. If written full the device crashes with out-of-memory-error.">/ram</item>
            <item name="SDCARD" desc="SDCARD slot /sdcard/0">/sdcard/0</item>
        </enum>
        <enum name="StorageDevices">
            <item desc="SDCARD slot /sdcard/0">SDCARD</item>
        </enum>
        <enum name="RemoteScannerInterfaces">
            <item desc="Default">ETHERNET</item>
            <item>SERIAL</item>
        </enum>
        <enum name="SerialComTypes">
            <item>RS232</item>
            <item desc="Default">RS422</item>
            <item>RS485</item>
        </enum>
        <enum name="SerialPorts">
            <item name="SERIAL 1">SER1</item>
            <item name="INC 1">INC1</item>
        </enum>
        <enum name="SerialPortConnectors">
            <item name="SER1" desc="SERIAL">SER1</item>
        </enum>
        <enum name="IncrementPortConnectors">
            <item name="INC1" desc="INC 1">INC1</item>
        </enum>
        <enum name="Mode">
            <item desc="Increment In">IncIn</item>
            <item desc="Increment Out">IncOut</item>
        </enum>
        <enum name="SensorNetworks">
            <item name="CAN" desc="CAN bus connector">CAN</item>
        </enum>
        <enum name="LEDs" type="string">
            <item name="Result" desc="Supported Colors: red, green, blue, fuchsia, yellow, aqua, white">LED_RESULT</item>
            <item name="Funct 1" desc="Supported Colors: red, green, blue, fuchsia, yellow, aqua, white">LED_FUNC_1</item>
            <item name="Funct 2" desc="Supported Colors: red, green, blue, fuchsia, yellow, aqua, white">LED_FUNC_2</item>
            <item name="System Ready" desc="Supported Colors: red, green, blue, fuchsia, yellow, aqua, white">LED_SYS_RDY</item>
            <item name="Remote" desc="Supported Colors: red, green, blue, fuchsia, yellow, aqua, white">LED_REMOTE</item>
        </enum>
        <enum name="IncrementSources">
            <item name="CAN 1" desc="Increment distributed on CAN bus">CAN1</item>
            <item name="Encoder.Decoder 1" desc="Instance of Encoder.Decoder in the ControlFlow">ENC1</item>
            <item name="Encoder.Decoder 2" desc="Instance of Encoder.Decoder in the ControlFlow">ENC2</item>
            <item name="Local" desc="Internal increment tick generation">LOCAL</item>
        </enum>
        <enum name="EncoderIncrementSources">
            <item name="Encoder.Decoder 1" desc="Instance of Encoder.Decoder in the ControlFlow">ENC1</item>
            <item name="Encoder.Decoder 2" desc="Instance of Encoder.Decoder in the ControlFlow">ENC2</item>
        </enum>
        <enum name="EncoderGeneratorSources">
            <item name="Encoder.Decoder 1" desc="Instance of Encoder.Decoder in the ControlFlow">ENC1</item>
            <item name="Encoder.Decoder 2" desc="Instance of Encoder.Decoder in the ControlFlow">ENC2</item>
            <item name="Local" desc="Internal increment tick generation">LOCAL</item>
            <item name="Conveyor" desc="Generator follows the increment speed of the conveyor">CONV</item>
        </enum>
        <enum name="EncoderDecoderInstance">
            <item name="Decoder 1">DEC1</item>
            <item name="Decoder 2">DEC2</item>
        </enum>
        <enum name="EncoderGeneratorInstance">
            <item name="Generator 1">GEN1</item>
            <item name="Generator 2">GEN2</item>
            <item name="Generator 3">GEN3</item>
        </enum>
        <enum name="DigitalInPorts">
            <item name="Digital In 1">DI1</item>
            <item name="Digital In 2">DI2</item>
            <item name="Digital In 3">DI3</item>
            <item name="Digital In 4">DI4</item>
            <item name="Sensor 1 Input 1">S1DI1</item>
            <item name="Sensor 1 Input 2">S1DI2</item>
            <item name="Sensor 2 Input 1">S2DI1</item>
            <item name="Sensor 2 Input 2">S2DI2</item>
            <item name="Sensor 3 Input 1">S3DI1</item>
            <item name="Sensor 3 Input 2">S3DI2</item>
            <item name="Sensor 4 Input 1">S4DI1</item>
            <item name="Sensor 4 Input 2">S4DI2</item>
            <item name="Sensor 5 Input 1">S5DI1</item>
            <item name="Sensor 5 Input 2">S5DI2</item>
            <item name="Sensor 5 Input 3">S5DI3</item>
            <item name="Sensor 6 Input 1">S6DI1</item>
            <item name="Sensor 6 Input 2">S6DI2</item>
            <item name="Sensor 6 Input 3">S6DI3</item>
        </enum>
        <enum name="DigitalOutPorts">
            <item name="Digital Out 3">DO3</item>
            <item name="Digital Out 4">DO4</item>
            <item name="Sensor 1 Output 1">S1DO1</item>
            <item name="Sensor 2 Output 1">S2DO1</item>
            <item name="Sensor 3 Output 1">S3DO1</item>
            <item name="Sensor 4 Output 1">S4DO1</item>
            <item name="Sensor 5 Output 1">S5DO1</item>
            <item name="Sensor 5 Output 2">S5DO2</item>
            <item name="Sensor 6 Output 1">S6DO1</item>
            <item name="Sensor 6 Output 2">S6DO2</item>
        </enum>
        <enum name="PowerConnectors">
            <item name="IN Main" desc="IN Main">INMAIN</item>
            <item name="Inc 1" desc="Incremental 1">INC1</item>
            <item name="Serial 1" desc="Serial 1">SER1</item>
            <item name="CAN 1" desc="CAN 1">CAN1</item>
            <item name="S 1" desc="Sensor 1">S1</item>
            <item name="S 2" desc="Sensor 2">S2</item>
            <item name="S 3" desc="Sensor 3">S3</item>
            <item name="S 4" desc="Sensor 4">S4</item>
            <item name="S 5" desc="Sensor 5">S5</item>
            <item name="S 6" desc="Sensor 6">S6</item>
            <item name="Ethernet 1" desc="Ethernet 1">POE1</item>
            <item name="Ethernet 2" desc="Ethernet 2">POE2</item>
            <item name="Ethernet 3" desc="Ethernet 3">POE3</item>
            <item name="Ethernet 4" desc="Ethernet 4">POE4</item>
        </enum>
        <enum name="PowerGateConnectors">
            <item name="S 5" desc="Sensor 5">S5</item>
            <item name="S 6" desc="Sensor 6">S6</item>
        </enum>
        <enum name="PWMGeneratorInstance">
            <item name="PWM 1">PWM1</item>
            <item name="PWM 2">PWM2</item>
        </enum>
        <enum name="Switches">
            <item name="Rotary Switch" desc="Rotary Switch">ROTARY</item>
        </enum>
        <enum name="TemperatureSensors">
            <item name="CPU_BOARD_FRONT">CPU_BOARD_FRONT</item>
            <item name="CPU_BOARD_CPU1">CPU_BOARD_CPU1</item>
            <item name="CPU_BOARD_CPU2">CPU_BOARD_CPU2</item>
            <item name="CPU_BOARD_COPROC">CPU_BOARD_COPROC</item>
            <item name="CPU_BOARD_COPROCRAM">CPU_BOARD_COPROCRAM</item>
            <item name="CPU_BOARD_PSU">CPU_BOARD_PSU</item>
            <item name="CPU_BOARD_PHY_TOP">CPU_BOARD_PHY_TOP</item>
            <item name="INTERFACE_BOARD_CENTER">INTERFACE_BOARD_CENTER</item>
            <item name="INTERFACE_BOARD_FPGA">INTERFACE_BOARD_FPGA</item>
            <item name="INTERFACE_BOARD_NETX">INTERFACE_BOARD_NETX</item>
            <item name="INTERFACE_BOARD_12V_SUPPLY">INTERFACE_BOARD_12V_SUPPLY</item>
            <item name="INTERFACE_BOARD_RTC_BATTERY">INTERFACE_BOARD_RTC_BATTERY</item>
            <item name="INTERFACE_BOARD_IN_DEVICE">INTERFACE_BOARD_IN_DEVICE</item>
            <item name="INTERFACE_BOARD_INC_1">INTERFACE_BOARD_INC_1</item>
            <item name="INTERFACE_BOARD_SERIAL_1">INTERFACE_BOARD_SERIAL_1</item>
            <item name="INTERFACE_BOARD_CAN_1">INTERFACE_BOARD_CAN_1</item>
            <item name="INTERFACE_BOARD_S1">INTERFACE_BOARD_S1</item>
            <item name="INTERFACE_BOARD_S2">INTERFACE_BOARD_S2</item>
            <item name="INTERFACE_BOARD_S3">INTERFACE_BOARD_S3</item>
            <item name="INTERFACE_BOARD_S4">INTERFACE_BOARD_S4</item>
            <item name="INTERFACE_BOARD_S5">INTERFACE_BOARD_S5</item>
            <item name="INTERFACE_BOARD_S6">INTERFACE_BOARD_S6</item>
        </enum>
        <enum name="IOLinkMasterPorts">
            <item desc="IOLink on Sensor 1 connector">S1</item>
            <item desc="IOLink on Sensor 2 connector">S2</item>
            <item desc="IOLink on Sensor 3 connector">S3</item>
            <item desc="IOLink on Sensor 4 connector">S4</item>
        </enum>
        <enum name="FPGA.DeviceID" type="string">
            <item name="FPGA1">FPGA1</item>
        </enum>
        <feature name="Engine.Flows"/>
        <feature name="Engine.Flows"/>
        <feature name="Engine.Flows"/>
        <feature name="Engine.Flows"/>
        <feature name="Engine.Scripts"/>
        <feature name="Engine.Flows"/>
        <feature name="Engine.Parameters"/>
        <feature name="Engine.Pages"/>
        <feature name="Engine.Natives"/>
        <feature name="Engine.Java"/>
    </declaration>
    <application name="SIM">
        <crown name="HMI">
            <trait>hidden</trait>
            <serves>
                <function name="GetLEDStates">
                    <desc>Get current state of all LED's.</desc>
                    <sample for="lua">state, activity, red, green, blue = HMI.GetLEDStates()</sample>
                    <return name="state" type="int" desc="Bitfield with state (on/off) for each LED."/>
                    <return name="activity" type="int" desc="Bitfield with activity state for each LED."/>
                    <return name="red" type="int" desc="Bitfield to switch red LED part on/off for each LED."/>
                    <return name="green" type="int" desc="Bitfield to switch green LED part on/off for each LED."/>
                    <return name="blue" type="int" desc="Bitfield to switch blue LED part on/off for each LED."/>
                </function>
                <function name="StartLEDTest">
                    <desc>Start LED Test. Set all LEDs to HIGH.</desc>
                    <sample for="lua">HMI.StartLEDTest()</sample>
                </function>
                <function name="StopLEDTest">
                    <desc>Stop LED Test. Set all LEDs to prior state.</desc>
                    <sample for="lua">HMI.StopLEDTest()</sample>
                </function>
                <function name="SetLEDTestPattern">
                    <desc>Switches the LED test pattern.</desc>
                    <sample for="lua">HMI.SetLEDTestPattern(1)</sample>
                    <param name="pattern" type="int" desc="The identifier of LED pattern to be shown."/>
                </function>
            </serves>
        </crown>
        <crown name="Docker">
            <trait>released</trait>
            <crown name="Image">
                <trait>released</trait>
                <desc>Provied functionality to load and save Docker images.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a handle to load and save docker images</desc>
                        <sample for="lua">local docker = Docker.Image.create()</sample>
                        <return name="handle" type="handle" alias="Docker.Image" desc="The handle for a docker image"/>
                    </function>
                    <function name="load">
                        <desc>Load an image from a tar archive. Depending on the size of the image, this command will block the script for a while.
Since only one image could be loaded or committed at a time, this function could also block another app which calls Docker.Image.load or Docker.Container.commit.</desc>
                        <sample for="lua">local success = Docker.Image.load("resources/my-container.tar")</sample>
                        <param name="handle" type="handle" alias="Docker.Image" desc="The handle for a docker image"/>
                        <param name="imagePath" type="string" desc="Path to a docker image to load"/>
                        <return name="success" type="bool" desc="True on success, false otherwise"/>
                    </function>
                    <function name="save">
                        <desc>Save an image to a tar archive.</desc>
                        <sample for="lua">local success = Docker.Image.save("public/my-container.tar")</sample>
                        <param name="handle" type="handle" alias="Docker.Image" desc="The handle for a docker image"/>
                        <param name="imagePath" type="string" desc="Path to store the docker image"/>
                        <return name="success" type="bool" desc="True on success, false otherwise"/>
                    </function>
                </serves>
            </crown>
            <crown name="Container">
                <trait>released</trait>
                <desc>Provied functionality to orchestrate Docker containers on the device.</desc>
                <serves>
                    <event name="OnLog">
                        <desc>The OnLog event reports any log message from the running container.</desc>
                        <param name="handle" type="handle" alias="Docker.Container" desc="The instance handle of Docker."/>
                        <param name="logMessage" type="string" desc="Log message."/>
                        <param name="processID" type="int" desc="Process ID."/>
                    </event>
                    <event name="OnSpawn">
                        <desc>The OnSpawn event will notify as soon as the container is running.</desc>
                        <param name="handle" type="handle" alias="Docker.Container" desc="The instance handle of Docker."/>
                        <param name="processID" type="int" desc="Process ID of the container main process."/>
                    </event>
                    <event name="OnStop">
                        <desc>The OnStop event will be triggered if a container has finished/stopped its work.</desc>
                        <param name="handle" type="handle" alias="Docker.Container" desc="The instance handle of Docker."/>
                        <param name="logMessage" type="string" desc="Message which describes the event that occurred."/>
                        <param name="processID" type="int" desc="Process ID."/>
                    </event>
                    <function name="create">
                        <desc>Creates a handle to orchestrate docker containers</desc>
                        <sample for="lua">local docker = Docker.Container.create()</sample>
                        <return name="handle" type="handle" alias="Docker.Container" desc="The handle for interacting with a docker session"/>
                    </function>
                    <function name="run">
                        <desc>Spawn a docker container.</desc>
                        <sample for="lua">local success = Docker.Container.run(handle, runConfig)</sample>
                        <param name="handle" type="handle" alias="Docker.Container" desc="The handle for interacting with a docker session"/>
                        <param name="runConfig" type="handle" alias="Docker.Container.RunConfig" desc="RunConfig handle"/>
                        <return name="processID" type="int" desc="The ID of the spawned process; -1 if failed."/>
                    </function>
                    <function name="exec">
                        <desc>Spawn a process in a running container.</desc>
                        <sample for="lua">local success = Docker.Container.exec(handle, execConfig)</sample>
                        <param name="handle" type="handle" alias="Docker.Container" desc="The handle for interacting with a docker session"/>
                        <param name="execConfig" type="handle" alias="Docker.Container.ExecConfig" desc="ExecConfig handle"/>
                        <return name="processID" type="int" desc="The ID of the spawned process; -1 if failed."/>
                    </function>
                    <function name="cp">
                        <desc>Copy files/folders between a container and the local filesystem</desc>
                        <sample for="lua">local success = Docker.Container.cp(handle, "resources/file", "file")</sample>
                        <param name="handle" type="handle" alias="Docker.Container" desc="The handle for interacting with a docker session"/>
                        <param name="src" type="string" desc="Source path"/>
                        <param name="dst" type="string" desc="Destination path"/>
                        <param name="fromContainer" type="bool" multiplicity="?" desc="If true, src is container; false otherwise."/>
                        <return name="success" type="bool" desc="True on success, false otherwise."/>
                    </function>
                    <function name="commit">
                        <desc>Create a new image from a container's changes. Since only one image could be loaded or committed at a time, this function could be blocked by another app which calls Docker.Image.load or Docker.Container.commit.</desc>
                        <sample for="lua">local imageHandle = Docker.Container.commit(handle, "imageName")</sample>
                        <param name="handle" type="handle" alias="Docker.Container" desc="The handle for interacting with a docker session"/>
                        <param name="imageName" type="string" desc="The name of the new image"/>
                        <return name="imageHandle" type="handle" alias="Docker.Image" desc="Handle on success, nil otherwise"/>
                    </function>
                    <function name="stop">
                        <desc>Stop a running container</desc>
                        <sample for="lua"> local success = Docker.Container.stop(handle)</sample>
                        <param name="handle" type="handle" alias="Docker.Container" desc="The handle for interacting with a docker session"/>
                        <return name="success" type="bool" desc="True on success, false otherwise"/>
                    </function>
                    <function name="register">
                        <desc>This function is used to register for any event of the handle.</desc>
                        <param name="handle" type="handle" alias="Docker.Container" desc="The instance handle of Docker."/>
                        <param name="eventname" type="string" desc="The event to register to"/>
                        <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                        <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                    </function>
                    <function name="deregister">
                        <desc>This function is used to deregister from any registered event of the handle.</desc>
                        <param name="handle" type="handle" alias="Docker.Container" desc="The instance handle of Docker."/>
                        <param name="eventname" type="string" desc="The event to deregister from"/>
                        <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                        <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                    </function>
                </serves>
                <crown name="RunConfig">
                    <trait>released</trait>
                    <desc>Object that describes the docker run properties.</desc>
                    <enum name="CAPABILITY" type="string">
                        <item name="AUDIT_WRITE" desc="Write records to kernel auditing log. (default)">AUDIT_WRITE</item>
                        <item name="CHOWN" desc="Make arbitrary changes to file UIDs and GIDs. (default)">CHOWN</item>
                        <item name="DAC_OVERRIDE" desc="Bypass file read, write, and execute permission checks. (default)">DAC_OVERRIDE</item>
                        <item name="FOWNER" desc="Bypass permission checks on operations that normally require the file system UID of the process to match the UID of the file. (default)">FOWNER</item>
                        <item name="FSETID" desc="Don’t clear set-user-ID and set-group-ID permission bits when a file is modified. (default)">FSETID</item>
                        <item name="KILL" desc="Bypass permission checks for sending signals. (default)">KILL</item>
                        <item name="MKNOD" desc="Create special files using mknod. (default)">MKNOD</item>
                        <item name="NET_BIND_SERVICE" desc="Bind a socket to internet domain privileged ports (port numbers less than 1024). (default)">NET_BIND_SERVICE</item>
                        <item name="NET_RAW" desc="Use RAW and PACKET sockets. (default)">NET_RAW</item>
                        <item name="SETFCAP" desc="Set file capabilities. (default)">SETFCAP</item>
                        <item name="SETGID" desc="Make arbitrary manipulations of process GIDs and supplementary GID list. (default)">SETGID</item>
                        <item name="SETPCAP" desc="Modify process capabilities. (default)">SETPCAP</item>
                        <item name="SETUID" desc="Make arbitrary manipulations of process UIDs. (default)">SETUID</item>
                        <item name="SYS_CHROOT" desc="Use chroot, change root directory. (default)">SYS_CHROOT</item>
                        <item name="AUDIT_CONTROL" desc="Enable and disable kernel auditing; change auditing filter rules; retrieve auditing status and filtering rules.">AUDIT_CONTROL</item>
                        <item name="AUDIT_READ" desc="Allow reading the audit log via multicast netlink socket.">AUDIT_READ</item>
                        <item name="BLOCK_SUSPEND" desc="Allow preventing system suspends.">BLOCK_SUSPEND</item>
                        <item name="DAC_READ_SEARCH" desc="Bypass file read permission checks and directory read and execute permission checks.">DAC_READ_SEARCH</item>
                        <item name="IPC_LOCK" desc="Lock memory (mlock, mlockall, mmap, shmctl).">IPC_LOCK</item>
                        <item name="IPC_OWNER" desc="Bypass permission checks for operations on System V IPC objects.">IPC_OWNER</item>
                        <item name="LEASE" desc="Establish leases on arbitrary files.">LEASE</item>
                        <item name="LINUX_IMMUTABLE" desc="Set the FS_APPEND_FL and FS_IMMUTABLE_FL i-node flags.">LINUX_IMMUTABLE</item>
                        <item name="MAC_ADMIN" desc="Allow MAC configuration or state changes. Implemented for the Smack LSM.">MAC_ADMIN</item>
                        <item name="MAC_OVERRIDE" desc="Override Mandatory Access Control (MAC). Implemented for the Smack Linux Security Module (LSM).">MAC_OVERRIDE</item>
                        <item name="NET_ADMIN" desc="Perform various network-related operations.">NET_ADMIN</item>
                        <item name="NET_BROADCAST" desc="Make socket broadcasts, and listen to multicasts.">NET_BROADCAST</item>
                        <item name="SYS_ADMIN" desc="Perform a range of system administration operations.">SYS_ADMIN</item>
                        <item name="SYS_NICE" desc="Raise process nice value (nice, setpriority) and change the nice value for arbitrary processes.">SYS_NICE</item>
                        <item name="SYS_PACCT" desc="Use acct, switch process accounting on or off.">SYS_PACCT</item>
                        <item name="SYS_PTRACE" desc="Trace arbitrary processes using ptrace.">SYS_PTRACE</item>
                        <item name="SYS_RAWIO" desc="Perform I/O port operations (iopl and ioperm).">SYS_RAWIO</item>
                        <item name="SYS_RESOURCE" desc="Override resource Limits.">SYS_RESOURCE</item>
                        <item name="SYS_TIME" desc="Set system clock (settimeofday, stime, adjtimex); set real-time (hardware) clock.">SYS_TIME</item>
                        <item name="SYS_TTY_CONFIG" desc="Use vhangup; employ various privileged ioctl operations on virtual terminals.">SYS_TTY_CONFIG</item>
                        <item name="SYSLOG" desc="Perform privileged syslog operations.">SYSLOG</item>
                        <item name="WAKE_ALARM" desc="Trigger something that will wake up the system.">WAKE_ALARM</item>
                    </enum>
                    <enum name="IPC_MODE" type="string">
                        <item name="NONE" desc="Own private IPC namespace, with /dev/shm not mounted.">none</item>
                        <item name="PRIVATE" desc="Own private IPC namespace.">private</item>
                        <item name="SHAREABLE" desc="Own private IPC namespace, with a possibility to share it with other containers.">shareable</item>
                        <item name="CONTAINER" desc="Join another (“shareable”) container’s IPC namespace.">container</item>
                        <item name="HOST" desc="Use the host system’s IPC namespace.">host</item>
                    </enum>
                    <serves>
                        <function name="listDevices">
                            <desc>Return a list of allowed devices to access in a container.</desc>
                            <sample for="lua">success = Docker.Container.RunConfig.listDevices()</sample>
                            <return name="list" type="string" multiplicity="*" desc="List of device names."/>
                        </function>
                        <function name="listVolumes">
                            <desc>Return a list of allowed volumes to access in a container.</desc>
                            <sample for="lua">success = Docker.Container.RunConfig.listVolumes()</sample>
                            <return name="list" type="string" multiplicity="*" desc="List of volume names."/>
                        </function>
                        <function name="listExtraCaps">
                            <desc>Return a list of additional capabilities which could be applied to a container.</desc>
                            <sample for="lua">success = Docker.Container.RunConfig.listExtraCaps()</sample>
                            <return name="list" type="string" multiplicity="*" desc="List of caps."/>
                        </function>
                        <function name="listDroppedCaps">
                            <desc>Return a list of capabilities which are dropped at the start time of container.</desc>
                            <sample for="lua">success = Docker.Container.RunConfig.listDroppedCaps()</sample>
                            <return name="list" type="string" multiplicity="*" desc="List of caps."/>
                        </function>
                        <function name="create">
                            <desc></desc>
                            <sample for="lua">cmd = Docker.Container.RunConfig.create()</sample>
                            <return name="handle" type="handle" alias="Docker.Container.RunConfig" desc="The new RunConfig handle"/>
                        </function>
                        <function name="setImage">
                            <desc>Set the docker image to use.</desc>
                            <sample for="lua">success = Docker.Container.RunConfig.setImage(handle, image)</sample>
                            <param name="handle" type="handle" alias="Docker.Container.RunConfig" desc="The instance to be used."/>
                            <param name="image" type="handle" alias="Docker.Image" desc="The docker image to use."/>
                            <return name="success" type="bool" desc="True on success, false otherwise."/>
                        </function>
                        <function name="setIPC">
                            <desc>Set the IPC mode "none", "private", "shareable", "container" or "host".
If "container" is selected, the second parameter is the handle to the container to join. Default mode is "private".</desc>
                            <sample for="lua">success = Docker.Container.RunConfig.setIPC(handle, "container", containerHandle)</sample>
                            <param name="handle" type="handle" alias="Docker.Container.RunConfig" desc="The instance to be used."/>
                            <param name="mode" type="enum" ref="Docker.Container.RunConfig.IPC_MODE" desc="The IPC mode."/>
                            <param name="container" type="handle" multiplicity="[?*]" alias="Docker.Container" desc="Optional: the container to join."/>
                            <return name="success" type="bool" desc="True on success, false otherwise."/>
                        </function>
                        <function name="attachTTY">
                            <desc>Attach a tty to the process. This option could be used to keep the container running.</desc>
                            <sample for="lua">success = Docker.Container.RunConfig.attachTTY(handle, attachTTY)</sample>
                            <param name="handle" type="handle" alias="Docker.Container.RunConfig" desc="The instance to be used."/>
                            <param name="attachTTY" type="bool" desc="Attach tty (Default false)."/>
                        </function>
                        <function name="setWorkdir">
                            <desc>Set the workdir where to start the defined command.</desc>
                            <sample for="lua">success = Docker.Container.RunConfig.setWorkdir(handle, "/tmp/workdir")</sample>
                            <param name="handle" type="handle" alias="Docker.Container.RunConfig" desc="The instance to be used."/>
                            <param name="workdir" type="string" desc="The workdir to use."/>
                            <return name="success" type="bool" desc="True on success, false otherwise."/>
                        </function>
                        <function name="setUser">
                            <desc>Set the user or uid to use in the container (format: name|uid[:group|gid]).</desc>
                            <sample for="lua">success = Docker.Container.RunConfig.setUser(handle, "root")</sample>
                            <param name="handle" type="handle" alias="Docker.Container.RunConfig" desc="The instance to be used."/>
                            <param name="user" type="string" desc="The user to use."/>
                            <return name="success" type="bool" desc="True on success, false otherwise."/>
                        </function>
                        <function name="setNetwork">
                            <desc>Set the network interface to use.</desc>
                            <sample for="lua">success = Docker.Container.RunConfig.setNetwork(handle, "eth2")</sample>
                            <param name="handle" type="handle" alias="Docker.Container.RunConfig" desc="The instance to be used."/>
                            <param name="interface" type="string" desc="The network interface to use."/>
                            <return name="success" type="bool" desc="True on success, false otherwise."/>
                        </function>
                        <function name="setCommand">
                            <desc>Set the command to execute in the container.</desc>
                            <sample for="lua">success = Docker.Container.RunConfig.setCommand(handle, "echo hello_world")</sample>
                            <param name="handle" type="handle" alias="Docker.Container.RunConfig" desc="The instance to be used."/>
                            <param name="command" type="string" desc="The command to execute."/>
                            <param name="parameters" type="string" multiplicity="[?*]" desc="Optional parameter strings for the command."/>
                            <return name="success" type="bool" desc="True on success, false otherwise."/>
                        </function>
                        <function name="addMount">
                            <desc>Add a mount point.</desc>
                            <sample for="lua">success = Docker.Container.RunConfig.addMount(handle, "/public/host/dir", "/container/path")</sample>
                            <param name="handle" type="handle" alias="Docker.Container.RunConfig" desc="The instance to be used."/>
                            <param name="hostPath" type="string" desc="The host path."/>
                            <param name="containerPath" type="string" desc="The container path."/>
                            <return name="success" type="bool" desc="True on success, false otherwise."/>
                        </function>
                        <function name="addEnv">
                            <desc>Add a environment variable.</desc>
                            <sample for="lua">success = Docker.Container.RunConfig.addEnv(handle, "VARNAME", "value")</sample>
                            <param name="handle" type="handle" alias="Docker.Container.RunConfig" desc="The instance to be used."/>
                            <param name="varName" type="string" desc="The env variable name."/>
                            <param name="varValue" type="string" desc="The env variable value."/>
                            <return name="success" type="bool" desc="True on success, false otherwise."/>
                        </function>
                        <function name="addPortMap">
                            <desc>Add a mapping for a port.</desc>
                            <sample for="lua">success = Docker.Container.RunConfig.addPortMap(handle, "8080:80/tcp")</sample>
                            <param name="handle" type="handle" alias="Docker.Container.RunConfig" desc="The instance to be used."/>
                            <param name="portMap" type="string" desc="The port mapping."/>
                            <return name="success" type="bool" desc="True on success, false otherwise."/>
                        </function>
                        <function name="addDevice">
                            <desc>Add a device to the container. Docker.Container.RunConfig.listDevices() will list the available devices.</desc>
                            <sample for="lua">success = Docker.Container.RunConfig.addDevice(handle, "USB")</sample>
                            <param name="handle" type="handle" alias="Docker.Container.RunConfig" desc="The instance to be used."/>
                            <param name="dev" type="string" desc="The device to add."/>
                            <return name="success" type="bool" desc="True on success, false otherwise."/>
                        </function>
                        <function name="addVolume">
                            <desc>Add a volume to the container. Docker.Container.RunConfig.listVolumes() will list the available volumes.</desc>
                            <sample for="lua">success = Docker.Container.RunConfig.addVolume(handle, "SHM")</sample>
                            <param name="handle" type="handle" alias="Docker.Container.RunConfig" desc="The instance to be used."/>
                            <param name="dev" type="string" desc="The volume to add."/>
                            <return name="success" type="bool" desc="True on success, false otherwise."/>
                        </function>
                        <function name="addCap">
                            <desc>Add a container capability.</desc>
                            <sample for="lua">success = Docker.Container.RunConfig.addCap(handle, "SYS_ADMIN")</sample>
                            <param name="handle" type="handle" alias="Docker.Container.RunConfig" desc="The instance to be used."/>
                            <param name="cap" type="enum" ref="Docker.Container.RunConfig.CAPABILITY" desc="The capability."/>
                            <return name="success" type="bool" desc="True on success, false otherwise."/>
                        </function>
                        <function name="dropCap">
                            <desc>Drop a container capability.</desc>
                            <sample for="lua">success = Docker.Container.RunConfig.dropCap(handle, "SYS_ADMIN")</sample>
                            <param name="handle" type="handle" alias="Docker.Container.RunConfig" desc="The instance to be used."/>
                            <param name="cap" type="string" desc="The capability."/>
                            <return name="success" type="bool" desc="True on success, false otherwise."/>
                        </function>
                    </serves>
                </crown>
                <crown name="ExecConfig">
                    <trait>released</trait>
                    <desc>Object that describes the docker exec properties.</desc>
                    <serves>
                        <function name="create">
                            <desc></desc>
                            <sample for="lua">handle = Docker.Container.ExecConfig.create()</sample>
                            <return name="handle" type="handle" alias="Docker.Container.ExecConfig" desc="The new Exec handle"/>
                        </function>
                        <function name="attachTTY">
                            <desc>Attach a tty to the process.</desc>
                            <sample for="lua">success = Docker.Container.ExecConfig.attachTTY(handle, attachTTY)</sample>
                            <param name="handle" type="handle" alias="Docker.Container.ExecConfig" desc="The instance to be used."/>
                            <param name="attachTTY" type="bool" desc="Attach tty (Default false)."/>
                        </function>
                        <function name="setWorkdir">
                            <desc>Set the workdir where to start the defined command.</desc>
                            <sample for="lua">success = Docker.Container.ExecConfig.setWorkdir(handle, "/tmp/workdir")</sample>
                            <param name="handle" type="handle" alias="Docker.Container.ExecConfig" desc="The instance to be used."/>
                            <param name="workdir" type="string" desc="The workdir to use."/>
                            <return name="success" type="bool" desc="True on success, false otherwise."/>
                        </function>
                        <function name="setUser">
                            <desc>Set the user or uid to use in the container (format: name|uid[:group|gid]).</desc>
                            <sample for="lua">success = Docker.Container.ExecConfig.setUser(handle, "root")</sample>
                            <param name="handle" type="handle" alias="Docker.Container.ExecConfig" desc="The instance to be used."/>
                            <param name="user" type="string" desc="The user to use."/>
                            <return name="success" type="bool" desc="True on success, false otherwise."/>
                        </function>
                        <function name="setCommand">
                            <desc>Set the command to execute in the container.</desc>
                            <sample for="lua">success = Docker.Container.ExecConfig.setCommand(handle, "echo hello_world")</sample>
                            <param name="handle" type="handle" alias="Docker.Container.ExecConfig" desc="The instance to be used."/>
                            <param name="command" type="string" desc="The command to execute."/>
                            <param name="parameters" type="string" multiplicity="[?*]" desc="Optional parameter strings for the command."/>
                            <return name="success" type="bool" desc="True on success, false otherwise."/>
                        </function>
                        <function name="addEnv">
                            <desc>Add a environment variable.</desc>
                            <sample for="lua">success = Docker.Container.ExecConfig.addEnv(handle, "VARNAME", "value")</sample>
                            <param name="handle" type="handle" alias="Docker.Container.ExecConfig" desc="The instance to be used."/>
                            <param name="varName" type="string" desc="The env variable name."/>
                            <param name="varValue" type="string" desc="The env variable value."/>
                            <return name="success" type="bool" desc="True on success, false otherwise."/>
                        </function>
                    </serves>
                </crown>
            </crown>
        </crown>
        <crown name="Connector">
            <trait>released</trait>
            <desc>Contains CROWNs to access connectors at the device</desc>
            <serves/>
            <uses/>
            <crown name="Serial">
                <trait>released</trait>
                <desc>Represents the input/output pins of a SERIAL plug.</desc>
                <serves>
                    <event name="OnReceive">
                        <include>ctrl-flow</include>
                        <desc>Link the pins in the FPGA's IO-multiplexer.</desc>
                        <sample for="lua">Connector.Serial.OnReceive(handle, A_in, B_in)</sample>
                        <param name="handle" type="handle" alias="Connector.Serial" desc="The instance handle to use"/>
                        <param name="A_in" type="bool" desc="Input on pin pair 1/2"/>
                        <param name="B_in" type="bool" desc="Input on pin pair 3/4"/>
                    </event>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">handle = Connector.Serial.create("SER1")</sample>
                        <param name="portName" type="enum" ref="SerialPortConnectors" desc="The devices identifier of the connector (e.g. SER1)"/>
                        <return name="handle" type="handle" alias="Connector.Serial" desc="Handle to the new instance"/>
                    </function>
                    <function name="setTermination">
                        <desc>Enable internal termination</desc>
                        <sample for="lua">Connector.Serial.setTermination(handle, true)</sample>
                        <param name="handle" type="handle" alias="Connector.Serial" desc="The instance handle to use"/>
                        <param name="terminated" type="bool" desc="true to enable internal termination, false to disable"/>
                    </function>
                    <function name="transmit">
                        <include>ctrl-flow</include>
                        <desc>Link the pins in the FPGA's IO-multiplexer.</desc>
                        <sample for="lua">Connector.Serial.transmit(handle, TX)</sample>
                        <param name="handle" type="handle" alias="Connector.Serial" desc="The instance handle to use"/>
                        <param name="A_out" type="bool" desc="Output on pin pair 1/2"/>
                        <param name="B_out" type="bool" desc="Output on pin pair 3/4"/>
                    </function>
                </serves>
                <uses/>
            </crown>
            <crown name="PWM">
                <crown name="Generator">
                    <trait>hidden</trait>
                    <serves>
                        <event name="OnDutyCycle">
                            <include>ctrl-flow</include>
                            <exclude>script</exclude>
                            <desc>Link the pins in the FPGA's IO-multiplexer.</desc>
                            <sample for="lua">Connector.PWM.Generator.OnDutyCycle(handle, pwmSignal)</sample>
                            <param name="handle" type="handle" alias="Connector.PWM.Generator" desc="The instance handle to use"/>
                            <param name="pwmSignal" type="bool" desc="The PWM signal"/>
                        </event>
                        <function name="create">
                            <desc>Creates a new instance.</desc>
                            <sample for="lua">handle = Connector.PWM.Generator.create()</sample>
                            <return name="handle" type="handle" alias="Connector.PWM.Generator" desc="Handle to the new instance"/>
                        </function>
                        <function name="setDutyCycle">
                            <desc>Duty cycle in percent.</desc>
                            <sample for="lua">Connector.PWM.Generator.setDutyCycle(handle, dutyCycle)</sample>
                            <param name="handle" type="handle" alias="Connector.PWM.Generator" desc="The instance handle to use"/>
                            <param name="dutyCycle" type="int" desc="The new duty cycle value in percent. Default is 0."/>
                        </function>
                        <function name="setFrequency">
                            <desc>Signal frequency in Hz.</desc>
                            <sample for="lua">Connector.PWM.Generator.setFrequency(handle, frequency)</sample>
                            <param name="handle" type="handle" alias="Connector.PWM.Generator" desc="The instance handle to use"/>
                            <param name="frequency" type="int" desc="The frequency in Hz (382 Hz ... 25 MHz). Default is 1000."/>
                        </function>
                    </serves>
                </crown>
            </crown>
            <crown name="Frequency">
                <crown name="Analyzer">
                    <trait>hidden</trait>
                    <serves>
                        <function name="measure">
                            <include>ctrl-flow</include>
                            <exclude>script</exclude>
                            <desc>Link the pins in the FPGA's IO-multiplexer.</desc>
                            <sample for="lua">Connector.Frequency.Analyzer.measure(handle, pulseSignal)</sample>
                            <param name="handle" type="handle" alias="Connector.Frequency.Analyzer" desc="The instance handle to use"/>
                            <param name="pulseSignal" type="bool" desc="The pulse signal to measure"/>
                        </function>
                        <function name="create">
                            <desc>Creates a new instance.</desc>
                            <sample for="lua">handle = Connector.Frequency.Analyzer.create()</sample>
                            <return name="handle" type="handle" alias="Connector.Frequency.Analyzer" desc="Handle to the new instance"/>
                        </function>
                        <function name="setSampleRate">
                            <desc>Duty cycle in percent.</desc>
                            <sample for="lua">Connector.Frequency.Analyzer.setSampleRate(handle, sampleRate)</sample>
                            <param name="handle" type="handle" alias="Connector.Frequency.Analyzer" desc="The instance handle to use"/>
                            <param name="sampleRate" type="int" desc="The new sample rate for the analyzer. Default is 1 Hz."/>
                        </function>
                    </serves>
                </crown>
            </crown>
            <crown name="DigitalIn">
                <trait>released</trait>
                <desc>Provides functionality to control a digital input port at the device</desc>
                <enum name="SignalLogic">
                    <item name="Active high" desc="Active high signal logic is used">ACTIVE_HIGH</item>
                    <item name="Active low" desc="Active low signal logic is used">ACTIVE_LOW</item>
                </enum>
                <enum name="DebounceMode">
                    <item name="Time in ms" desc="Time based with milliseconds value">TIME_MS</item>
                    <item name="Increment in ticks" desc="Increment based with ticks as value">INCREMENT_TICK</item>
                </enum>
                <serves>
                    <event name="OnChange">
                        <include>ctrl-flow</include>
                        <include>data-flow</include>
                        <desc>This event is triggered whenever the input port changes its state.
The new state is provided as parameter.
If there is a new registration done on this event, the current state is also notified.
Please note that there might be state changes missed by the implementation in overload situations and the same state might be notified twice.</desc>
                        <sample for="lua">Connector.DigitalIn.register(handle, "OnChange", "MyApp.handleChange")</sample>
                        <param name="handle" type="handle" alias="Connector.DigitalIn" desc="Unique handle to the port"/>
                        <param name="newState" type="bool" desc="The state of the level signal"/>
                    </event>
                    <event name="OnChangeStamped">
                        <include>data-flow</include>
                        <desc>This event is triggered whenever the input port changes its state.
The new state and exact increment and timestamp are provided as parameter.
If there is a new registration done on this event, the current state is also notified.
Please note that there might be state changes missed by the implementation in overload situations and the same state might be notified twice.</desc>
                        <sample for="lua">Connector.DigitalIn.register(handle, "OnChangeStamped", "MyApp.handleChangeStamped")</sample>
                        <param name="handle" type="handle" alias="Connector.DigitalIn" desc="Unique handle to the port"/>
                        <param name="newState" type="bool" desc="The state of the level signal"/>
                        <param name="timeOfStateChange" type="int" desc="The timestamp in microseconds the state of the signal changed"/>
                        <param name="incrementOfStateChange" type="int" desc="The increment stamp in ticks the state of the signal changed"/>
                    </event>
                    <function name="create">
                        <desc>Creates a digital input port with the given name if exists and not already in use.</desc>
                        <sample for="lua">handle = Connector.DigitalIn.create("DI1")</sample>
                        <param name="portName" type="enum" ref="DigitalInPorts" desc="The devices identifier of the digital input port (e.g. DI1)"/>
                        <return name="handle" type="handle" multiplicity="?" alias="Connector.DigitalIn" desc="Unique handle for the port. Nil if not available or already in use."/>
                    </function>
                    <function name="setLogic">
                        <desc>Sets the pin inversion of the port to ACTIVE_HIGH or ACTIVE_LOW. Default is ACTIVE_HIGH.</desc>
                        <sample for="lua">Connector.DigitalIn.setLogic(handle, "ACTIVE_HIGH")</sample>
                        <param name="handle" type="handle" alias="Connector.DigitalIn" desc="Unique handle to the port"/>
                        <param name="newLogic" type="enum" ref="SignalLogic" desc="ACTIVE_HIGH or ACTIVE_LOW"/>
                    </function>
                    <function name="setDebounceMode">
                        <desc>The debounce mode to set for this port so that the input signal is debounced. Default is time based.</desc>
                        <sample for="lua">Connector.DigitalIn.setDebounceMode(handle, "TIME_MS")</sample>
                        <param name="handle" type="handle" alias="Connector.DigitalIn" desc="Unique handle to the port"/>
                        <param name="newMode" type="enum" ref="DebounceMode" desc="The debounce mode to use"/>
                    </function>
                    <function name="setDebounceValue">
                        <desc>The debounce value to use for the debounce mode. Meaning of the value is dependent on the DebounceMode which is set.
Default is zero which means no debouncing at all.</desc>
                        <sample for="lua">Connector.DigitalIn.setDebounceValue(handle, 10)</sample>
                        <param name="handle" type="handle" alias="Connector.DigitalIn" desc="Unique handle to the port"/>
                        <param name="newValue" type="int" desc="The debounce value to use. Is dependent on the DebounceMode which is set."/>
                    </function>
                    <function name="register">
                        <desc>This function is used to register for any event of the handle.</desc>
                        <param name="handle" type="handle" alias="Connector.DigitalIn" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to register to"/>
                        <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                        <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                    </function>
                    <function name="deregister">
                        <desc>This function is used to deregister from any registered event of the handle.</desc>
                        <param name="handle" type="handle" alias="Connector.DigitalIn" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to deregister from"/>
                        <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                        <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                    </function>
                    <function name="get">
                        <desc>Returns the current activation state of the specified input port.</desc>
                        <sample for="lua">local isActive = Connector.DigitalIn.get(handle)</sample>
                        <param name="handle" type="handle" alias="Connector.DigitalIn" desc="Unique handle to the port."/>
                        <return name="isActive" type="bool" desc="True if input port is active, false if inactive."/>
                    </function>
                </serves>
            </crown>
            <crown name="DigitalOut">
                <trait>released</trait>
                <desc>Provides functionality to control a digital output port at the device</desc>
                <enum name="SignalLogic">
                    <item name="Active high" desc="Active high signal logic is used">ACTIVE_HIGH</item>
                    <item name="Active low" desc="Active low signal logic is used">ACTIVE_LOW</item>
                </enum>
                <enum name="PortOutputMode">
                    <item name="High-side" desc="Digital port works as high-side (PNP) output">HIGH_SIDE</item>
                    <item name="Low-side" desc="Digital port works as low-side (NPN) output">LOW_SIDE</item>
                    <item name="Push-pull" desc="Digital port works as push-pull output">PUSH_PULL</item>
                </enum>
                <enum name="ActivationMode">
                    <item name="Time in ms" desc="Time based with milliseconds value">TIME_MS</item>
                    <item name="Increment in ticks" desc="Increment based with ticks as value">INCREMENT_TICK</item>
                </enum>
                <serves>
                    <function name="create">
                        <desc>Creates a digital output port with the given name if exists and not already in use.</desc>
                        <sample for="lua">handle = Connector.DigitalOut.create("DO1")</sample>
                        <param name="portName" type="enum" ref="DigitalOutPorts" desc="The devices identifier of the digital output port (e.g. DO1)"/>
                        <return name="handle" type="handle" multiplicity="?" alias="Connector.DigitalOut" desc="Unique handle for the port. Nil if not available or already in use."/>
                    </function>
                    <function name="setLogic">
                        <desc>Sets the pin inversion of the port to ACTIVE_HIGH or ACTIVE_LOW. Default is ACTIVE_HIGH.</desc>
                        <sample for="lua">Connector.DigitalOut.setLogic(handle, "ACTIVE_HIGH")</sample>
                        <param name="handle" type="handle" alias="Connector.DigitalOut" desc="Unique handle to the port"/>
                        <param name="value" type="enum" ref="SignalLogic" desc="ACTIVE_HIGH or ACTIVE_LOW"/>
                    </function>
                    <function name="setPortOutputMode">
                        <desc>Sets the hardware driver mode of the port: HighSide, LowSide or PushPull.</desc>
                        <sample for="lua">Connector.DigitalOut.setPortOutputMode(handle, "HIGH_SIDE")</sample>
                        <param name="handle" type="handle" alias="Connector.DigitalOut" desc="Unique handle to the port"/>
                        <param name="value" type="enum" ref="PortOutputMode" desc="Port output mode."/>
                    </function>
                    <function name="setActivationMode">
                        <desc>The activation mode to set for this port so that the port is automatically reset after a given time. Default is time based.</desc>
                        <sample for="lua">Connector.DigitalOut.setActivationMode(handle, "TIME_MS")</sample>
                        <param name="handle" type="handle" alias="Connector.DigitalOut" desc="Unique handle to the port"/>
                        <param name="value" type="enum" ref="ActivationMode" desc="The activation mode to use"/>
                    </function>
                    <function name="setActivationValue">
                        <desc>The activation value to set for this port. Meaning of the value is dependent on the ActivationMode which is set.
Default is zero which means not automatically reset.</desc>
                        <sample for="lua">Connector.DigitalOut.setActivationValue(handle, 100)</sample>
                        <param name="handle" type="handle" alias="Connector.DigitalOut" desc="Unique handle to the port"/>
                        <param name="value" type="int" desc="The activation value to use. Is dependent on the ActivationMode which is set."/>
                    </function>
                    <function name="set">
                        <include>ctrl-flow</include>
                        <include>data-flow</include>
                        <desc>Sets the port state to the given value.</desc>
                        <sample for="lua">Connector.DigitalOut.set(handle, level)</sample>
                        <param name="handle" type="handle" alias="Connector.DigitalOut" desc="Unique handle to the port"/>
                        <param name="newState" type="bool" desc="The new state of the level signal"/>
                    </function>
                </serves>
            </crown>
            <crown name="Increment">
                <trait>released</trait>
                <desc>Represents the input/output pins of an INC plug.</desc>
                <serves>
                    <event name="OnReceive">
                        <include>ctrl-flow</include>
                        <exclude>script</exclude>
                        <desc>Link the pins in the FPGA's IO-multiplexer.</desc>
                        <sample for="lua">Connector.Increment.OnReceive(handle, A_in, B_in)</sample>
                        <param name="handle" type="handle" alias="Connector.Increment" desc="The instance handle to use"/>
                        <param name="A_in" type="bool" desc="Input on pin pair 1/2"/>
                        <param name="B_in" type="bool" desc="Input on pin pair 3/4"/>
                    </event>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">handle = Connector.Increment.create("INC1")</sample>
                        <param name="portName" type="enum" ref="IncrementPortConnectors" desc="The devices identifier of the connector (e.g. INC1)"/>
                        <return name="handle" type="handle" alias="Connector.Increment" desc="Handle to the new instance"/>
                    </function>
                    <function name="setTermination">
                        <desc>Enable internal termination</desc>
                        <sample for="lua">Connector.Increment.setTermination(handle, true)</sample>
                        <param name="handle" type="handle" alias="Connector.Increment" desc="The instance handle to use"/>
                        <param name="terminated" type="bool" desc="true to enable internal termination, false to disable"/>
                    </function>
                    <function name="transmit">
                        <include>ctrl-flow</include>
                        <exclude>script</exclude>
                        <desc>Link the pins in the FPGA's IO-multiplexer.</desc>
                        <sample for="lua">Connector.Increment.transmit(handle, A_out, B_out)</sample>
                        <param name="handle" type="handle" alias="Connector.Increment" desc="The instance handle to use"/>
                        <param name="A_out" type="bool" desc="Output on pin pair 1/2"/>
                        <param name="B_out" type="bool" desc="Output on pin pair 3/4"/>
                    </function>
                    <function name="getName">
                        <trait>hidden</trait>
                        <desc>Get generator name.</desc>
                        <sample for="lua">name = Connector.Increment.getName(handle)</sample>
                        <param name="handle" type="handle" alias="Connector.Increment" desc="The instance handle to use"/>
                        <return name="name" type="string" desc="Connector.Increment name."/>
                    </function>
                </serves>
            </crown>
            <crown name="Power">
                <trait>released</trait>
                <desc>Functions and events for controlling the power connector and querying its status.</desc>
                <serves>
                    <event name="OnSwitched">
                        <desc>This event is triggered when the power connector changes its state, i.e. from ON to OFF or vice versa.</desc>
                        <sample for="lua">Connector.Power.register(handle, "OnSwitched", "handleOnSwitched")</sample>
                        <param name="handle" type="handle" alias="Connector.Power" desc="Unique handle to the Power Connector"/>
                        <param name="powerState" type="bool" desc="Power state of the power plug socket"/>
                    </event>
                    <event name="OnOverload">
                        <desc>This event is triggered when the sum of external devices connected to the "power strip" of this device consume too much power. Check the documentation for information on which connector is supplied by which power strip.</desc>
                        <sample for="lua">Connector.Power.register(handle, "OnOverload", "handleOnOverload")</sample>
                        <param name="handle" type="handle" alias="Connector.Power" desc="Unique handle to the Power Connector"/>
                    </event>
                    <function name="create">
                        <desc>Creates a new instance if the connector exists and isn't already in use.</desc>
                        <sample for="lua">handle = Connector.Power.create("INMAIN")</sample>
                        <param name="powerName" type="enum" ref="PowerConnectors" desc="The identifier of the connector"/>
                        <return name="handle" type="handle" multiplicity="?" alias="Connector.Power" desc="Handle to the new instance. Nil if not available or already in use."/>
                    </function>
                    <function name="register">
                        <desc>This function is used to register for any event of the handle.</desc>
                        <param name="handle" type="handle" alias="Connector.Power" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to register to"/>
                        <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                        <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                    </function>
                    <function name="deregister">
                        <desc>This function is used to deregister from any registered event of the handle.</desc>
                        <param name="handle" type="handle" alias="Connector.Power" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to deregister from"/>
                        <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                        <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                    </function>
                    <function name="enable">
                        <desc>Set the power connector to the desired state, i.e. ON (true) or OFF (false).</desc>
                        <sample for="lua">Connector.Power.enable(handle, true)</sample>
                        <param name="handle" type="handle" alias="Connector.Power" desc="Unique handle to the Power Connector"/>
                        <param name="powerState" type="bool" desc="The new power state to set"/>
                    </function>
                    <function name="isEnabled">
                        <desc>Get the power connector state, i.e. ON (true) or OFF (false).</desc>
                        <sample for="lua">isEnabled = Connector.Power.isEnabled(handle)</sample>
                        <param name="handle" type="handle" alias="Connector.Power" desc="Unique handle to the Power Connector"/>
                        <return name="status" type="bool" desc="True if ON, false if OFF."/>
                    </function>
                    <function name="getValues">
                        <desc>Get power values of the power connector at the last update interval.</desc>
                        <sample for="lua">power, voltage, current = Connector.Power.getValues(handle)</sample>
                        <param name="handle" type="handle" alias="Connector.Power" desc="Unique handle to the Power Connector"/>
                        <return name="powerValue" type="float" desc="Power Value in Watt."/>
                        <return name="voltageValue" type="float" multiplicity="?" desc="Voltage Value in Volt. Can be nil."/>
                        <return name="currentValue" type="float" multiplicity="?" desc="Current Value in Ampere. Can be nil."/>
                    </function>
                </serves>
                <crown name="Gate">
                    <trait>released</trait>
                    <exclude>script</exclude>
                    <desc>The Connector.Power.Gate function can switch the 24 V power output in a fast way (e.g. illumination control).</desc>
                    <serves>
                        <function name="create">
                            <desc>Creates a new instance.</desc>
                            <sample for="lua">handle = Connector.Power.Gate.create("S5")</sample>
                            <param name="InstanceName" type="enum" ref="PowerGateConnectors" desc="The identifier of the connector (e.g. S5)"/>
                            <return name="handle" type="handle" alias="Connector.Power.Gate" desc="Handle to the new instance."/>
                        </function>
                        <function name="enable">
                            <include>ctrl-flow</include>
                            <desc>Set the desired state (true: ON, false: OFF). This has only an effect, if the power on this connector has been enabled in the script first!</desc>
                            <sample for="lua">Connector.Power.Gate.enable(handle, true)</sample>
                            <param name="handle" type="handle" alias="Connector.Power.Gate" desc="Unique handle to the Power Connector"/>
                            <param name="powerState" type="bool" desc="The new power state to set"/>
                        </function>
                    </serves>
                </crown>
            </crown>
        </crown>
        <crown name="FieldBus">
            <trait>released</trait>
            <desc>Provides field bus access. This API is intended for field bus slave devices and allows them exchange data with a PLC. It works for all field bus protocols like PROFINET, EtherNet/IP and EtherCAT. Which field bus protocols are actually available depends on the device. How to enable the field bus functionality or select a specific protocol is also device specific. Some devices offer these settings via the SOPAS Engineering Tool. There is no possibility to select the protocol via this API. To integrate the device into PLC projects you need an appropriate device description file. These are available via the SICK support portal. - PROFINET: GSDML file - EtherNet/IP: EDS file - EtherCat: ESI file Devices which implement this API offer two independent ways to communicate process data with a PLC: - For each direction (output from PLC to device and input from device to PLC), there is a field "ControlBits" with a length of 16 bits. These fields can be used freely by your application, there is no predefined meaning for the individual bits. - The rest of the cyclic process data can be used in two different modes: - In Confirmed Messaging mode, it is used as a transfer channel for the SICK Confirmed Messaging protocol. This protocol allows to send arbitrary strings in both directions. The protocol can also handle strings that are longer than the size of the cyclic process data. This works by splitting them up in several fragments which are transferred and acknowledged sequentially. To use this channel from the PLC side, SICK offers ready-to-use function blocks for Confirmed Messaging for various PLCs. - In Raw mode, the user receives and sets the process data directly without any protocol.</desc>
            <enum name="CreateMode">
                <item name="Explicit Open" desc="Only create the handle, but do not automatically open communication. Communication must be started explicitly using the function open.">EXPLICIT_OPEN</item>
                <item name="Automatic Open" desc="Create the handle and automatically open the communication">AUTOMATIC_OPEN</item>
            </enum>
            <enum name="TransmissionMode">
                <item name="Confirmed Messaging" desc="Transmission mode using the SICK Confirmed Messaging protocol to transfer and fragment process data">CONFIRMED_MESSAGING</item>
                <item name="Raw" desc="Transmission mode without any protocol">RAW</item>
            </enum>
            <enum name="Ports">
                <item name="Interface" desc="Interface">INTERFACE</item>
                <item name="P1" desc="Port 1">P1</item>
                <item name="P2" desc="Port 2">P2</item>
            </enum>
            <serves>
                <event name="OnNewData">
                    <desc>This event is thrown when new data has been received from the PLC through the field bus.</desc>
                    <param name="handle" type="handle" alias="FieldBus" desc="The FieldBus handle"/>
                    <param name="data" type="binary" desc=""/>
                </event>
                <event name="OnControlBitsOutChanged">
                    <desc>This event is thrown when the control bits set by the PLC have changed.</desc>
                    <param name="handle" type="handle" alias="FieldBus" desc="The FieldBus handle"/>
                    <param name="ctrlBits" type="int" desc="ctrl bits out"/>
                </event>
                <function name="create">
                    <desc>Creates a new instance. This can fail if field bus functionality is disabled in the device. Some devices offer a switch to enable and select the type of field bus via the SOPAS Engineering Tool.</desc>
                    <sample for="lua">busHandle = FieldBus.create()</sample>
                    <param name="mode" type="enum" multiplicity="?" ref="CreateMode" desc="Optional create mode. Default is 'AUTOMATIC_OPEN'."/>
                    <return name="handle" type="handle" multiplicity="?" alias="FieldBus" desc="The new FieldBus. nil if FieldBus is disabled."/>
                </function>
                <function name="setMode">
                    <desc>Sets the transmission mode. It only works, if the Fieldbus.create function has been called with the parameter "EXPLICIT_OPEN". Default is "CONFIRMED_MESSAGING". See also Fieldbus.CreateMode enumeration.</desc>
                    <sample for="lua">FieldBus.setMode(busHandle, "RAW")</sample>
                    <param name="handle" type="handle" alias="FieldBus" desc="The FieldBus handle"/>
                    <param name="mode" type="enum" ref="TransmissionMode" desc="Transmission mode"/>
                </function>
                <function name="setHandshakeMode">
                    <trait>hidden</trait>
                    <desc>Activates/Deactivates the handshake mode for "CONFIRMED_MESSAGING" and the retransmission of packages. If the handshake mode is enabled, the communication partner receiving the telegram needs to acknowledge it as soon as it has processed the telegram and is ready to receive a telegram with the next message or the next fragment. On the other side, the sender of the telegram must wait until it has received the acknowledgment before it can send a telegram with the next message or the next fragment. Note that when handshake mode is disabled, fragmentation is not supported.</desc>
                    <sample for="lua">FieldBus.setHandshakeMode(busHandle, handshakeActive)</sample>
                    <param name="handle" type="handle" alias="FieldBus" desc="The FieldBus handle"/>
                    <param name="handshakeActive" type="bool" desc="Activates/Deactivates the handshake mode."/>
                </function>
                <function name="open">
                    <desc>Starts the communication to the field bus. This function only has to be called when the handle was created with CreateMode "EXPLICIT_OPEN". Otherwise, open is done automatically on handle create.</desc>
                    <sample for="lua">FieldBus.open(busHandle)</sample>
                    <param name="handle" type="handle" alias="FieldBus" desc="The FieldBus handle"/>
                </function>
                <function name="close">
                    <desc>Stops communication to the field bus</desc>
                    <sample for="lua">FieldBus.close(busHandle)</sample>
                    <param name="handle" type="handle" alias="FieldBus" desc="The FieldBus handle"/>
                </function>
                <function name="transmit">
                    <desc>Transmits data through the field bus to the PLC. This function does not affect the control bits, only the rest of the cyclic process data. Behavior depends on transmission mode (see function setMode): In mode RAW: Directly set the parameter data as cyclic process data. If data is too long to be transmitted according to the current PLC connection settings, the data is trunacated. This function returns the actual number of bytes that were transmitted. In mode CONFIRMED_MESSAGING: - If there is no connection to a PLC, the function fails and returns immediately with return value 0. - If there is a connection to a PLC, the function returns after transmission of the data starts. The function might block for up to 10 seconds if it is not possible to start sending immediately. This is the case if other data from previous calls to transmit is still being transmitted or if the PLC did not confirm a previous transmit yet. If it is not possible to start sending in 10 seconds, the function fails with return value 0. - The function does not wait till the transmission of the data is complete. - The function does not wait for the confirmation from the PLC.</desc>
                    <sample for="lua">bytesTransmitted = FieldBus.transmit(busHandle, "Hello PLC")</sample>
                    <param name="handle" type="handle" alias="FieldBus" desc="The FieldBus handle"/>
                    <param name="data" type="binary" desc="The data which is to be transmitted. Up to 4094 bytes can be transmitted with a single call. If the size is larger, only the first 4094 bytes will be transmitted."/>
                    <return name="numberOfBytesTransmitted" type="int" desc="Number of bytes transmitted; 0 if transmit failed."/>
                </function>
                <function name="writeControlBitsIn">
                    <desc>Sets and transmits the value of the control bits to the PLC</desc>
                    <sample for="lua">FieldBus.writeControlBitsIn(busHandle, controlBits, bitMask)</sample>
                    <param name="handle" type="handle" alias="FieldBus" desc="The FieldBus handle"/>
                    <param name="controlBits" type="int" desc="The control bits to write"/>
                    <param name="bitMask" type="int" desc="The bitmask to use"/>
                </function>
                <function name="readControlBitsIn">
                    <desc>Gets the current value of the control bits transmitted to the PLC</desc>
                    <sample for="lua">local controlBitsIn = FieldBus.readControlBitsIn(busHandle)</sample>
                    <param name="handle" type="handle" alias="FieldBus" desc="The FieldBus handle"/>
                    <return name="controlBitsIn" type="int" desc="the control bits"/>
                </function>
                <function name="readControlBitsOut">
                    <desc>Gets the current value of the control bits received from the PLC</desc>
                    <sample for="lua">local controlBitsOut = FieldBus.readControlBitsOut(busHandle)</sample>
                    <param name="handle" type="handle" alias="FieldBus" desc="The FieldBus handle"/>
                    <return name="controlBitsOut" type="int" desc="the control bits"/>
                </function>
                <function name="register">
                    <desc>This function is used to register for events from the FieldBus</desc>
                    <sample for="lua">Fieldbus.register(handle, 'OnNewData', callback)</sample>
                    <param name="handle" type="handle" alias="FieldBus" desc=""/>
                    <param name="eventname" type="string" desc="The event to register to"/>
                    <param name="callback" type="string" alias="function" desc="Function name to call when an event occurs"/>
                    <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                </function>
                <function name="deregister">
                    <desc>This function is used to deregister from any registered event of the handle.</desc>
                    <param name="handle" type="handle" alias="FieldBus" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to deregister from"/>
                    <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                    <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                </function>
            </serves>
            <uses/>
            <crown name="Config">
                <trait>released</trait>
                <desc>Global configuration for the FieldBus API. This is  handle independent.</desc>
                <enum name="FieldbusProtocol">
                    <item name="ProfinetIO" desc="Profinet IO">PROFINETIO</item>
                    <item name="EtherNetIP" desc="EtherNet / IP">ETHERNETIP</item>
                </enum>
                <serves>
                    <function name="setProtocol">
                        <desc>Sets the fieldbus protocol to be used.
This parameter is not stored permanently. The procotol is always undefined until this function is called.
The protocol used is evaluated at the time either the FieldBus.create(AUTOMATIC_OPEN) or the FieldBus.open function is executed. After that, the protocol cannot be changed anymore until the handle created by FieldBus.create has been destroyed or after the FieldBus.close function has been called.</desc>
                        <param name="protocol" type="enum" ref="FieldbusProtocol" desc="The protocol to be used."/>
                        <return name="success" type="bool" desc="True if the Protocol could be set successfully. False otherwise."/>
                    </function>
                    <function name="getProtocol">
                        <desc>Gets the protocol used.</desc>
                        <return name="protocol" type="enum" multiplicity="?" ref="FieldbusProtocol" desc="The current protocol used."/>
                    </function>
                </serves>
                <crown name="ProfinetIO">
                    <trait>released</trait>
                    <desc>Profinet IO configuration.</desc>
                    <serves>
                        <event name="OnInterfaceConfigChanged">
                            <desc>This event is notified when the address, that is, the interface configuration, of the device has changed.</desc>
                            <param name="ipAddress" type="string" desc="Currently active (applied) IP address"/>
                            <param name="subnetMask" type="string" desc="Currently active (applied) subnet mask"/>
                            <param name="gateway" type="string" desc="Currently active (applied) gateway address"/>
                            <param name="remanent" type="bool" desc="True if the network configuration tool sets the current IP address settings permanently, that is, it will be reloaded after a restart of the device."/>
                        </event>
                        <event name="OnDeviceNameChanged">
                            <desc>This event is notified when the name of the device has changed.</desc>
                            <param name="deviceName" type="string" desc="Currently active name of the device"/>
                            <param name="remanent" type="bool" desc="True if the network configuration tool sets the current name of the device permanently, that is, it will be reloaded after a restart of the device."/>
                        </event>
                        <event name="OnFieldbusStorageRequest">
                            <desc>This event is thrown when the fieldbus (stack) needs to store data permanently, for example address data or device name.
The implementation of this event is mandatory since the fieldbus (stack) needs to store fieldbus specific data permanently which will be loaded after restart. This is a requirement to pass the certification tests.
See the component's documentation for an example implementation.</desc>
                            <param name="storageHandle" type="handle" alias="FieldBus.StorageRequest" desc="Object containing the data to be saved or loaded"/>
                        </event>
                        <function name="applyConfig">
                            <links>FieldBus.Config.ProfinetIO.setDeviceName,FieldBus.Config.ProfinetIO.setInterfaceConfig</links>
                            <desc>Applies the address data, previously set. Notice that the PLC and/or the fieldbus decides if and when the data is stored permanently and may override your changes.
The function applyConfig may lead in some implementations to a reboot of the communication controller. The application may however want to store the data permanently. In that case, use this function carefully so that you do not lose any changes or store unwanted temporary data.</desc>
                            <return name="success" type="bool" desc="True if successful. False if an error occurred."/>
                        </function>
                        <function name="storeConfig">
                            <links>FieldBus.Config.ProfinetIO.applyConfig</links>
                            <desc>Stores the address data, previously applied with the function applyConfig.</desc>
                            <return name="success" type="bool" desc="True if successful. False if an error occurred."/>
                        </function>
                        <function name="getMACAddress">
                            <desc>Returns the MAC address of the specified port.</desc>
                            <param name="port" type="enum" ref="Ports" desc="The interface to get the MAC address from."/>
                            <return name="macAddress" type="string" multiplicity="?" desc="The MAC address of the specified interface. Notation is six groups of two hexadecimal digits separated by hyphens, e.g. '01-23-45-67-89-AB'. Nil if the port does not exist."/>
                        </function>
                        <function name="setDeviceName">
                            <links>FieldBus.Config.ProfinetIO.getDeviceName,FieldBus.Config.ProfinetIO.applyConfig</links>
                            <desc>Sets the name of the device in the Profinet network. This value will be applied after calling the function ProfinetIO.applyConfig.</desc>
                            <param name="deviceName" type="string" desc="Device name to be applied. Needs to be a valid Profinet device name, otherwise the value will be rejected."/>
                            <return name="success" type="bool" desc="True if successful. False if an error occurred or the name is invalid."/>
                        </function>
                        <function name="getDeviceName">
                            <links>FieldBus.Config.ProfinetIO.setDeviceName</links>
                            <desc>Gets the name of the device in the Profinet network. This value will be applied after calling the function ProfinetIO.Device.applyConfig.</desc>
                            <return name="deviceName" type="string" desc="Device name to be applied. Needs to be a valid Profinet device name, otherwise the value will be rejected."/>
                            <return name="remanent" type="bool" desc="True if the network configuration tool set the current IP address settings permanently, that is, it will be reloaded after a restart of the device."/>
                        </function>
                        <function name="setInterfaceConfig">
                            <links>FieldBus.Config.ProfinetIO.applyConfig</links>
                            <desc>Sets the device's IP data used in the Profinet network. The values will be applied after calling the function ProfinetIO.Device.applyConfig.</desc>
                            <param name="ipAddress" type="string" desc="IP address to be applied. Needs to be a valid IP address."/>
                            <param name="netmask" type="string" desc="Subnet mask to be applied."/>
                            <param name="gateway" type="string" multiplicity="?" desc="Address of the gateway to be applied. Needs to be a valid IP address. Optional argument."/>
                            <return name="success" type="bool" desc="True if successful. False if an error occurred."/>
                        </function>
                        <function name="getInterfaceConfig">
                            <desc>Gets the device's IP data used in the Profinet network. The values will be applied after calling the function ProfinetIO.Device.applyConfig.</desc>
                            <return name="ipAddress" type="string" desc="Currently active (applied) IP address."/>
                            <return name="subnetMask" type="string" desc="Currently active (applied) subnet mask."/>
                            <return name="gateway" type="string" desc="Currently active (applied) gateway address."/>
                            <return name="remanent" type="bool" desc="True if the network configuration tool set the current IP address settings permanently, that is, it will be reloaded after a restart of the device."/>
                        </function>
                        <function name="getDapImHardwareRev">
                            <desc>Gets the hardware revision as used for the DAP (device access point) used in the I&amp;M0 data.</desc>
                            <return name="hardwareRev" type="int" desc="Hardware revision of this I&amp;M0 data."/>
                        </function>
                        <function name="getDapImSoftwareRev">
                            <desc>Gets the software revision for the DAP (device access point) used in the I&amp;M0 data.</desc>
                            <return name="swRevPrefix" type="string" desc="Prefix character of the software revision of this I&amp;M0 data."/>
                            <return name="swRevFuncEnhancement" type="int" desc="Functional enhancement identifier of the software revision of this I&amp;M0 data."/>
                            <return name="swRevBugFix" type="int" desc="Bug fix identifier of the software revision of this I&amp;M0 data."/>
                            <return name="swRevInternalChange" type="int" desc="Internal change identifier of the software revision of this I&amp;M0 data."/>
                        </function>
                        <function name="getDapImTagFunction">
                            <links>FieldBus.Config.ProfinetIO.setDapImTagFunction</links>
                            <desc>Gets the function tag (a.k.a. 'plant designation') as used for the DAP's (device access point)  I&amp;M1 data.</desc>
                            <return name="tagFunction" type="string" desc="Function tag of this I&amp;M1 data."/>
                        </function>
                        <function name="setDapImTagFunction">
                            <links>FieldBus.Config.ProfinetIO.getDapImTagFunction,FieldBus.Config.ProfinetIO.storeDapImData</links>
                            <desc>Sets the function tag (a.k.a. 'plant designation') forthe DAP's (device access point) I&amp;M1 data.
The value will take effect on the fieldbus but only stored permanently after calling the function storeDapImData.</desc>
                            <param name="tagFunction" type="string" desc="Function tag to use for this I&amp;M1 data. String with 32 visible characters. Will be filled with blanks automatically if shorter."/>
                            <return name="success" type="bool" desc="True if successful. False if an error occurred."/>
                        </function>
                        <function name="getDapImTagLocation">
                            <links>FieldBus.Config.ProfinetIO.setDapImTagLocation</links>
                            <desc>Gets the location tag (a.k.a. 'location identifier') as used for the DAP's (device access point)  I&amp;M1 data.</desc>
                            <return name="tagLocation" type="string" desc="Location tag of this I&amp;M1 data."/>
                        </function>
                        <function name="setDapImTagLocation">
                            <links>FieldBus.Config.ProfinetIO.getDapImTagLocation,FieldBus.Config.ProfinetIO.storeDapImData</links>
                            <desc>Sets the location tag (a.k.a. 'location identifier') forthe DAP's (device access point) I&amp;M1 data.
The value will take effect on the fieldbus but only stored permanently after calling the function storeDapImData.</desc>
                            <param name="tagLocation" type="string" desc="Location tag to use for this I&amp;M1 data. String with 22 visible characters. Will be filled with blanks automatically if shorter."/>
                            <return name="success" type="bool" desc="True if successful. False if an error occurred."/>
                        </function>
                        <function name="getDapImInstallDate">
                            <links>FieldBus.Config.ProfinetIO.setDapImInstallDate</links>
                            <desc>Gets the installation date as used for the DAP's (device access point) I&amp;M2 data.</desc>
                            <return name="installDate" type="string" desc="Installation date of this I&amp;M2 data."/>
                        </function>
                        <function name="setDapImInstallDate">
                            <links>FieldBus.Config.ProfinetIO.getDapImInstallDate,FieldBus.Config.ProfinetIO.storeDapImData</links>
                            <desc>Sets the installation date for the DAP's (device access point)  I&amp;M2 data.
The value will take effect on the fieldbus immediately, but is only stored permanently after calling the function storeDapImData.</desc>
                            <param name="installDate" type="string" desc="Installation date to use for this I&amp;M2 data. String encoding the date and time (optional) in accordance with ISO 8601, thus in the format 'YYYY-MM-DD[ HH:MM:SS]'. Will be filled with blanks automatically if time is omitted."/>
                            <return name="success" type="bool" desc="True if successful. False if an error occurred."/>
                        </function>
                        <function name="getDapImDescriptor">
                            <links>FieldBus.Config.ProfinetIO.setDapImDescriptor</links>
                            <desc>Gets the descriptor (a.k.a. 'comment') as used for the DAP's (device access point) I&amp;M3 data.</desc>
                            <return name="descriptor" type="string" desc="Descriptor of this I&amp;M3 data."/>
                        </function>
                        <function name="setDapImDescriptor">
                            <links>FieldBus.Config.ProfinetIO.getDapImDescriptor,FieldBus.Config.ProfinetIO.storeDapImData</links>
                            <desc>Sets the descriptor (comment) for the DAP's (device access point) I&amp;M3 data.
The value will take effect on the fieldbus immediately, but is only stored permanently after calling the function storeDapImData.</desc>
                            <param name="descriptor" type="string" desc="Descriptor to use for this I&amp;M3 data. String with 54 visible characters. Will be filled with blanks automatically if shorter."/>
                            <return name="success" type="bool" desc="True if successful. False if an error occurred."/>
                        </function>
                        <function name="storeDapImData">
                            <desc>Stores the current values of the I&amp;M data of the DAP permanently.</desc>
                            <return name="success" type="bool" desc="True if successful. False if an error occurred."/>
                        </function>
                    </serves>
                </crown>
                <crown name="EtherNetIP">
                    <trait>released</trait>
                    <desc>EtherNet/IP configuration.</desc>
                    <enum name="AddressingMode">
                        <item name="DHCP" desc="Get IP-address via DHCP">DHCP</item>
                        <item name="BOOTP" desc="Get IP-address via BOOTP">BOOTP</item>
                        <item name="STATIC" desc="Statically set the IP-address">STATIC</item>
                    </enum>
                    <serves>
                        <event name="OnAddressingModeChanged">
                            <desc>This event is notified when the addressing mode of the EtherNet/IP adapter has changed.</desc>
                            <param name="addressingMode" type="enum" ref="FieldBus.Config.EtherNetIP.AddressingMode" desc="Addressing mode for the ip parameters."/>
                        </event>
                        <event name="OnInterfaceConfigChanged">
                            <desc>This event is notified when the address of the EtherNet/IP adapter has changed.</desc>
                            <param name="ipAddress" type="string" desc="IP address."/>
                            <param name="netmask" type="string" desc="Subnetmask."/>
                            <param name="gateway" type="string" desc="Gateway IP address."/>
                            <param name="nameServer" type="string" multiplicity="?" desc="Primary name server."/>
                            <param name="nameServer2" type="string" multiplicity="?" desc="Secondary name server."/>
                            <param name="domainName" type="string" multiplicity="?" desc="Default domain name."/>
                        </event>
                        <event name="OnFieldbusStorageRequest">
                            <desc>This event is thrown when the fieldbus (stack) needs to store data permanently, for example address data or device name.
The implementation of this event is mandatory since the fieldbus (stack) needs to store fieldbus specific data permanently which will be loaded after restart. This is a requirement to pass the certification tests.
See the component's documentation for an example implementation.</desc>
                            <param name="storageHandle" type="handle" alias="FieldBus.StorageRequest" desc="Object containing the data to be saved or loaded"/>
                        </event>
                        <function name="getMACAddress">
                            <desc>Returns the MAC address of the of current fieldbus implementation.</desc>
                            <return name="macAddress" type="string" multiplicity="?" desc="The MAC address of the specified interface. Notation is six groups of two hexadecimal digits separated by hyphens, e.g. '01-23-45-67-89-AB'. Nil if interface is currently a bridged interface or if the interface does not exist."/>
                        </function>
                        <function name="setInterfaceConfig">
                            <desc>Sets the IP data. This value corresponds to the attribute 5, 'Interface configuration', in the TCP/IP object.</desc>
                            <param name="ipAddress" type="string" desc="IP address."/>
                            <param name="netmask" type="string" desc="Subnetmask."/>
                            <param name="gateway" type="string" multiplicity="?" desc="Gateway IP address."/>
                            <param name="nameServer" type="string" multiplicity="?" desc="Primary name server."/>
                            <param name="nameServer2" type="string" multiplicity="?" desc="Secondary name server."/>
                            <param name="domainName" type="string" multiplicity="?" desc="Default domain name."/>
                            <return name="success" type="bool" desc="True if successful. False if an error occurred."/>
                        </function>
                        <function name="getInterfaceConfig">
                            <desc>Gets the IP data used in the EtherNet/IP network. This value corresponds to the attribute 5, 'Interface configuration', in the TCP/IP object.</desc>
                            <return name="ipAddress" type="string" desc="Current IP address."/>
                            <return name="netmask" type="string" desc="Current subnet mask."/>
                            <return name="gateway" type="string" desc="Currently active ateway address."/>
                            <return name="nameServer" type="string" desc="Current primary name server."/>
                            <return name="nameServer2" type="string" desc="Current secondary name server."/>
                            <return name="domainName" type="string" desc="Current default domain name."/>
                        </function>
                        <function name="setAddressingMode">
                            <desc>Sets the addressing mode for the ip-address assignment. This value corresponds to the attribute 3, 'Configuration control', in the TCP/IP object.
If set to STATIC, you also need to set valid address values using the function setInterfaceConfig.</desc>
                            <param name="addressingMode" type="enum" ref="FieldBus.Config.EtherNetIP.AddressingMode" desc="Addressing mode for the ip parameters."/>
                            <return name="success" type="bool" desc="True if successful. False if an error occurred."/>
                        </function>
                        <function name="getAddressingMode">
                            <desc>Gets the addressing mode used for the ip-address assignment. This value corresponds to the attribute 3, 'Configuration control', in the TCP/IP object.</desc>
                            <return name="addressingMode" type="enum" ref="FieldBus.Config.EtherNetIP.AddressingMode" desc="Current addressing mode for the ip parameters."/>
                        </function>
                    </serves>
                </crown>
            </crown>
            <crown name="StorageRequest">
                <trait>released</trait>
                <enum name="StorageOperation">
                    <item name="Load" desc="Load from permanent storage.">LOAD</item>
                    <item name="Save" desc="Save to permanent storage.">SAVE</item>
                </enum>
                <serves>
                    <function name="notifyResult">
                        <desc>Notifies the result of the operation.
For example, if a SAVE operation failed, the application shall notify a result with 'false'.</desc>
                        <sample for="lua">StorageRequest.notifyResult(storageHandle, true)</sample>
                        <param name="handle" type="handle" alias="FieldBus.StorageRequest" desc="Storage handle"/>
                        <param name="success" type="bool" desc="True if the data could be saved or loaded. False if an error occurred."/>
                    </function>
                    <function name="getOperation">
                        <desc>Gets the type of the current StorageRequest, e.g. LOAD or SAVE.</desc>
                        <sample for="lua">operation = StorageRequest.getOperation(storageHandle)</sample>
                        <param name="handle" type="handle" alias="FieldBus.StorageRequest" desc="Storage handle"/>
                        <return name="operation" type="enum" ref="StorageOperation" desc="Operation type"/>
                    </function>
                    <function name="getData">
                        <desc>Gets the data received in the StorageRequest. This data should be saved for example to a file if the StorageRequest is of the type SAVE.</desc>
                        <sample for="lua">data = StorageRequest.getData(storageHandle)</sample>
                        <param name="handle" type="handle" alias="FieldBus.StorageRequest" desc="Storage handle"/>
                        <return name="data" type="binary" desc="Data of the StorageRequest"/>
                    </function>
                    <function name="setData">
                        <desc>Sets the data to the StorageRequest.
This function is used in a LOAD operation to send the data back to the component that sent the StorageRequest. This data is usually loaded from a file.</desc>
                        <sample for="lua">StorageRequest.setData(storageHandle, data)</sample>
                        <param name="handle" type="handle" alias="FieldBus.StorageRequest" desc="Storage handle"/>
                        <param name="data" type="binary" desc="Data from the application"/>
                        <return name="success" type="bool" desc="True if successful. False if an error occurred."/>
                    </function>
                </serves>
            </crown>
            <crown name="Debug">
                <trait>hidden</trait>
                <desc>Hidden crown for insertion of debug settings and information in case of investigation needs concerning a released device.</desc>
                <enum name="LogMessageType">
                    <item name="STATE_MACHINE" desc="State machine state transitions and additional information">STATE_MACHINE</item>
                    <item name="ASYNC_HANDLING" desc="Asynchronous data objects handling">ASYNC_HANDLING</item>
                    <item name="IM_DATA_PNIO" desc="Information about I&amp;M data and handling w/ ProfinetIO">IM_DATA_PNIO</item>
                    <item name="STACK_IMPL_API" desc="Handling of the stack implementation's API">STACK_IMPL_API</item>
                    <item name="STACK_IMPL_API_DETAIL" desc="Details on the handling of the stack implementation's API">STACK_IMPL_API_DETAIL</item>
                    <item name="CIFX_MSG_DETAIL" desc="Detailed handling of messages/packet resources on cifX-level">CIFX_MSG_DETAIL</item>
                    <item name="PROCESS_DATA_CFG_AND_EVENTS" desc="PD config and selected events - might result in heavy logging activity!!!">PROCESS_DATA_CFG_AND_EVENTS</item>
                    <item name="ADDRESS_DATA" desc="Address data handling">ADDRESS_DATA</item>
                    <item name="STORAGE_DATA" desc="Storage data handling">STORAGE_DATA</item>
                    <item name="ACYCLIC_SERVICES" desc="Handling of acyclic (read/write) services">ACYCLIC_SERVICES</item>
                    <item name="CONNECTION_DETAILS" desc="Information of connection details and handling">CONNECTION_DETAILS</item>
                    <item name="FB_OBJECTS_CFG" desc="Declaration, initialization and handling of Fieldbus objects">FB_OBJECTS_CFG</item>
                    <item name="ALL" desc="Mask ALL debug types">ALL</item>
                </enum>
                <enum name="LogOnOff">
                    <item name="OFF" desc="Switch OFF">OFF</item>
                    <item name="ON" desc="Switch ON">ON</item>
                </enum>
                <serves>
                    <function name="setLogging">
                        <desc>Activates/deactivates the selected log message type.</desc>
                        <sample for="lua">FieldBus.Debug.setLogging("ALL", "ON")</sample>
                        <param name="msgType" type="enum" ref="LogMessageType" desc="The log message type to be activated/deactivated."/>
                        <param name="activation" type="enum" ref="LogOnOff" desc="'ON' or 'OFF' to either activate or deactivate debugging for the given type."/>
                    </function>
                    <function name="loggerOutput">
                        <desc>Activates/deactivates printing generated debug output via logging mechanism.</desc>
                        <sample for="lua">FieldBus.Debug.loggerOutput("ON")</sample>
                        <param name="activation" type="enum" ref="LogOnOff" desc="'ON' or 'OFF' to either activate or deactivate logging debug messages."/>
                    </function>
                </serves>
                <crown name="App">
                    <trait>hidden</trait>
                    <desc>Hidden crown for executing internally installed Apps.</desc>
                    <serves>
                        <function name="start">
                            <desc>Starts the selected internal app</desc>
                            <sample for="lua">result = FieldBus.Debug.App.start("SIM2000STE")</sample>
                            <param name="appName" type="string" desc="Name (identifier) of the app to be started"/>
                            <return name="success" type="bool" desc="True if successfully started the selected app. False if an error occurred."/>
                        </function>
                        <function name="stop">
                            <desc>Stops the selected internal app</desc>
                            <sample for="lua">result = FieldBus.Debug.App.stop("SIM2000STE")</sample>
                            <param name="appName" type="string" desc="Name (identifier) of the app to be stopped"/>
                            <return name="success" type="bool" desc="True if successfully stopped the selected app. False if an error occurred."/>
                        </function>
                        <function name="getList">
                            <desc>Returns a list of all installed internal apps</desc>
                            <sample for="lua">appList = FieldBus.Debug.App.getList()</sample>
                            <return name="success" type="string" multiplicity="*" desc="List of the installed apps."/>
                        </function>
                    </serves>
                </crown>
            </crown>
        </crown>
        <crown name="FanControl">
            <trait>hidden</trait>
            <serves>
                <function name="getFrequency">
                    <desc>Get the input frequency.</desc>
                    <sample for="lua">FanControl.getFrequency()</sample>
                    <return name="frequency" type="int" desc="The measured input frequency."/>
                </function>
                <function name="setError">
                    <desc>Enable/disable the error state.</desc>
                    <sample for="lua">FanControl.setError()</sample>
                    <param name="enable" type="bool" desc="Enable/disable the error state."/>
                </function>
                <function name="setWarning">
                    <desc>nable/disable the warning state.</desc>
                    <sample for="lua">FanControl.getFrequency()</sample>
                    <param name="enable" type="bool" desc="Enable/disable the warning state."/>
                </function>
                <function name="incrementOperatingHours">
                    <desc>Increment the fan operating hours value.</desc>
                    <sample for="lua">FanControl.getFrequency()</sample>
                </function>
            </serves>
        </crown>
        <crown name="DateTime">
            <trait>released</trait>
            <desc>Provides functions to get date and time as well as conversion routines.</desc>
            <serves>
                <function name="create">
                    <desc>Returns the current date and time as DateTime object. Only has valid time if the device supports it, otherwise time since bootup.</desc>
                    <sample for="lua">local now = DateTime.create()</sample>
                    <return name="dateTime" type="object" alias="DateTime" desc="The current date and time as DateTime object"/>
                </function>
                <function name="createFromUnixTime">
                    <links>DateTime.getUnixTime</links>
                    <desc>Returns the DateTime object which corresponds to the input Unix time (number of seconds since the "epoch" (Jan 1, 1970) in UTC)
Milliseconds are set to 0.</desc>
                    <sample for="lua">
local now = DateTime.createFromUnixTime(DateTime.getUnixTime())
local epoch = DateTime.createFromUnixTime(0)
          </sample>
                    <param name="unixTime" type="int" desc="The Unix time"/>
                    <return name="dateTime" type="object" alias="DateTime" desc="DateTime object which corresponds to the input Unix time"/>
                </function>
                <function name="createFromTimestamp">
                    <links>DateTime.getTimestamp</links>
                    <desc>Returns the DateTime object which corresponds to the input timestamp in milliseconds since bootup.</desc>
                    <sample for="lua">
local now = DateTime.createFromTimestamp(DateTime.getTimestamp())
local bootup = DateTime.createFromTimestamp(0)
          </sample>
                    <param name="timestamp" type="int" desc="The input timestamp"/>
                    <return name="dateTime" type="object" alias="DateTime" desc="DateTime object which corresponds to the input timestamp"/>
                </function>
                <function name="toString">
                    <desc>Gets a user-friendly string description of a DateTime object (UTC time according to the ISO 8601 time representation).</desc>
                    <sample for="lua">str = DateTime.toString(dateTime)</sample>
                    <param name="dateTime" type="const object" alias="DateTime" desc="The DateTime object."/>
                    <return name="str" type="string" desc="User-friendly description of a DateTime object."/>
                </function>
                <function name="getTime">
                    <desc>Returns the current time in format "hh:mm:ss.msecs". Only has valid time if the device supports it, otherwise time since bootup.</desc>
                    <sample for="lua">local time = DateTime.getTime()</sample>
                    <return name="time" type="string" desc="Format: &quot;hh:mm:ss.msecs&quot;"/>
                </function>
                <function name="getDate">
                    <desc>Returns the current date in format "Jan..Dec dd yyyy". Only has valid time if the device supports it, otherwise time since bootup.</desc>
                    <sample for="lua">local time = DateTime.getDate()</sample>
                    <return name="date" type="string" desc="Format: &quot;Jan..Dec dd yyyy&quot;"/>
                </function>
                <function name="setDateTime">
                    <desc>Sets the system time in either UTC (Coordinated Universal Time) or local time.
Attention: The system behaviour might be affected if changing the time too often, so use with care.
The usage of NTPClient is generally more recommended.
Please also take care when setting local time (not UTC) to an interval where daylight saving time changes to non daylight saving time (mostly in autumn).
The results when setting to that time interval are undefined, because the time interval repeats a second time during the transition (for example 2:59:58, 2:59:59, 2:00:00, 2:00:01, ..., 2:59:58, 2:59:59, 3:00:00) so the time values are ambiguous.</desc>
                    <sample for="lua">DateTime.setDateTime(2016, 1, 15, 14, 30, 10, true)</sample>
                    <param name="year" type="int" desc="Year to set, range: 1970..2037"/>
                    <param name="month" type="int" desc="Month to set, range: 1..12"/>
                    <param name="day" type="int" desc="Day to set, range: 1..31"/>
                    <param name="hour" type="int" desc="Hour to set, range: 0..23"/>
                    <param name="minute" type="int" desc="Minute to set, range: 0..59"/>
                    <param name="second" type="int" desc="Second to set, range: 0..59"/>
                    <param name="asUTC" type="bool" multiplicity="?" desc="True to set in UTC, false to set in local time. Defaults to false (local time)."/>
                    <return name="success" type="bool" desc="If true, the time was set successfully"/>
                </function>
                <function name="getDateTime">
                    <desc>Returns the current date plus time in format "Jan..Dec dd yyyy hh:mm:ss.msecs. This is the same like concatenating the strings returned by getDate and getTime with a space delimiter, but a call to getDateTime is atomic and also works when date/time overflows whereas two calls to getDate and getTime are not guaranteed to fit together because some time could pass by between the calls.</desc>
                    <sample for="lua">local dateTime = DateTime.getDateTime()</sample>
                    <return name="datetime" type="string" desc="Format: &quot;Jan..Dec dd yyyy hh:mm:ss.msecs&quot;"/>
                </function>
                <function name="getTimestamp">
                    <desc>Returns the system timestamp in milliseconds since bootup.</desc>
                    <sample for="lua">local timestamp = DateTime.getTimestamp()</sample>
                    <return name="timestamp" type="int" desc="Stamp in milliseconds"/>
                </function>
                <function name="getTimestampMicroseconds">
                    <desc>Returns the system timestamp in microseconds since bootup.</desc>
                    <sample for="lua">local timestamp = DateTime.getTimestampMicroseconds()</sample>
                    <return name="timestamp" type="int" desc="Stamp in microseconds"/>
                </function>
                <function name="getUnixTime">
                    <desc>Returns the current time as number of seconds since the "epoch" (Jan 1, 1970) in UTC (Coordinated Universal Time).
The returned value can directly be used to perform arithmetic and calculate time values.</desc>
                    <sample for="lua">local unixTime = DateTime.getUnixTime()</sample>
                    <return name="unixtime" type="int" desc="The Unix time"/>
                </function>
                <function name="getDateTimeValuesUTC">
                    <desc>Returns the individual parts (day, month, year, hour, minute, second, millisecond) of the system time in UTC (Coordinated Universal Time).</desc>
                    <sample for="lua">local day, month, year, hour, minute, second, millisecond = DateTime.getDateTimeValuesUTC()</sample>
                    <return name="day" type="int" desc="Day"/>
                    <return name="month" type="int" desc="Month"/>
                    <return name="year" type="int" desc="Year"/>
                    <return name="hour" type="int" desc="Hour"/>
                    <return name="minute" type="int" desc="Minute"/>
                    <return name="second" type="int" desc="Second"/>
                    <return name="millisecond" type="int" desc="Millisecond"/>
                </function>
                <function name="getDateTimeValuesLocal">
                    <desc>Returns the individual parts (day, month, year, hour, minute, second, millisecond) of the system time in local time.</desc>
                    <sample for="lua">local day, month, year, hour, minute, second, millisecond = DateTime.getDateTimeValuesLocal()</sample>
                    <return name="day" type="int" desc="Day"/>
                    <return name="month" type="int" desc="Month"/>
                    <return name="year" type="int" desc="Year"/>
                    <return name="hour" type="int" desc="Hour"/>
                    <return name="minute" type="int" desc="Minute"/>
                    <return name="second" type="int" desc="Second"/>
                    <return name="millisecond" type="int" desc="Millisecond"/>
                </function>
                <function name="calcLocalFromUTC">
                    <trait>deprecated</trait>
                    <desc>Converts Unix time to local time and generates a string like the one returned by getDateTime().
This function is deprecated, please use formatUnixTime() instead.</desc>
                    <sample for="lua">local dateTime = DateTime.calcLocalFromUTC(DateTime.getUnixTime() + 10) -- Date and Time 10 seconds in the future</sample>
                    <param name="unixUTCTime" type="int" desc="The Unix time"/>
                    <return name="dateTime" type="string" multiplicity="?" desc="Format: &quot;Jan..Dec dd yyyy hh:mm:ss&quot; or nil for invalid Unix time input"/>
                </function>
                <function name="formatUnixTime">
                    <desc>Generates a string like the one returned by getDateTime() for the input Unix time.</desc>
                    <sample for="lua">
local localTime = DateTime.formatUnixTime(DateTime.getUnixTime(), false)
local epoch = DateTime.formatUnixTime(0, true)
          </sample>
                    <param name="unixTime" type="int" desc="The Unix time"/>
                    <param name="asUTC" type="bool" multiplicity="?" desc="True to return UTC, false to convert to local time. Defaults to false (local time)."/>
                    <return name="dateTime" type="string" multiplicity="?" desc="Format: &quot;Jan..Dec dd yyyy hh:mm:ss&quot; or nil for invalid Unix time input"/>
                </function>
                <function name="convertUnixTime">
                    <desc>Returns the individual parts (day, month, year, hour, minute, second) of an input Unix time.</desc>
                    <sample for="lua">local day, month, year, hour, minute, second = DateTime.convertUnixTime(DateTime.getUnixTime())</sample>
                    <param name="unixTime" type="int" desc="The Unix time"/>
                    <param name="asUTC" type="bool" multiplicity="?" desc="True to return UTC, false to convert to local time. Defaults to false (local time)."/>
                    <return name="day" type="int" desc="Day"/>
                    <return name="month" type="int" desc="Month"/>
                    <return name="year" type="int" desc="Year"/>
                    <return name="hour" type="int" desc="Hour"/>
                    <return name="minute" type="int" desc="Minute"/>
                    <return name="second" type="int" desc="Second"/>
                </function>
                <function name="formatTimestamp">
                    <desc>Generates a string like the one returned by getDateTime() for the time which is calculated from the input timestamp in milliseconds since bootup.</desc>
                    <sample for="lua">
local localTime  = DateTime.formatTimestamp(DateTime.getTimestamp())
local bootupTime = DateTime.formatTimestamp(0)
          </sample>
                    <param name="timestamp" type="int" desc="The input timestamp"/>
                    <param name="asUTC" type="bool" multiplicity="?" desc="True to return UTC, false to convert to local time. Defaults to false (local time)."/>
                    <return name="dateTime" type="string" multiplicity="?" desc="Format: &quot;Jan..Dec dd yyyy hh:mm:ss.msecs&quot; or nil for invalid Unix time input"/>
                </function>
                <function name="convertTimestamp">
                    <desc>Returns the individual parts (day, month, year, hour, minute, second, millisecond) of the time which is calculated from the input timestamp in milliseconds since bootup.</desc>
                    <sample for="lua">local day, month, year, hour, minute, second, millisecond = DateTime.convertTimestamp(DateTime.getTimestamp())</sample>
                    <param name="timestamp" type="int" desc="The input timestamp"/>
                    <param name="asUTC" type="bool" multiplicity="?" desc="True to return UTC, false to convert to local time. Defaults to false (local time)."/>
                    <return name="day" type="int" desc="Day"/>
                    <return name="month" type="int" desc="Month"/>
                    <return name="year" type="int" desc="Year"/>
                    <return name="hour" type="int" desc="Hour"/>
                    <return name="minute" type="int" desc="Minute"/>
                    <return name="second" type="int" desc="Second"/>
                    <return name="millisecond" type="int" desc="Millisecond"/>
                </function>
                <function name="calcDayOfWeek">
                    <desc>Calculates the day of the week in the current time zone as integer (Sunday=0, Monday=1, Tuesday=2, ..., Saturday=6. The returned value can be used as key to a table mapping the values to strings if desired (see the example). The return value is a number because of different country-local requirements: In some countries, Sunday is the first day of the week, in some others it's the Monday. Also, the names of the days may differ. The convention Sunday=0, Monday=1 is derived from the standard C library convention of day of week numbers.
For invalid Unix time input the function returns nil.</desc>
                    <sample for="lua">
local dayStrEnglish = {} -- English day names
dayStrEnglish[0] = "Sun"
dayStrEnglish[1] = "Mon"
dayStrEnglish[2] = "Tue"
dayStrEnglish[3] = "Wed"
dayStrEnglish[4] = "Thu"
dayStrEnglish[5] = "Fri"
dayStrEnglish[6] = "Sat"
dayStrGerman = {} -- German day names
dayStrGerman[0] = "So"
dayStrGerman[1] = "Mo"
dayStrGerman[2] = "Di"
dayStrGerman[3] = "Mi"
dayStrGerman[4] = "Do"
dayStrGerman[5] = "Fr"
dayStrGerman[6] = "Sa"
local currentDayAsNumber = DateTime.calcDayOfWeek(DateTime.getUnixTime())
local currentDayInEnglish = dayStrEnglish[currentDayAsNumber]
local currentDayInGerman  = dayStrGerman[currentDayAsNumber]
          </sample>
                    <param name="unixUTCTime" type="int" desc="The Unix input time"/>
                    <return name="dayNr" type="int" multiplicity="?" desc="Number of the current day of week or nil in case of invalid input"/>
                </function>
                <function name="setTimeZone">
                    <desc>Sets the time zone of the system.
The time zone is encoded in the IANA tz database format. A current list can be looked up from http://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
Time zones do not change the system clock which always runs in UTC, but they change how dates and times are interpreted in a locally dependent way. The functions getDateTime(), getDate() and getTime() will return different values when the time zone is overwritten.
Note that time zones are subject to political changes, so in the future, time zones of some countries may change even if that is rather unlikely.
Not each operating system supports each time zone. So, always check the return code of this function. If the call is unsuccessful, you may need another compatible time zone name or you will need to update your device firmware to fit to the new zones.
The Windows version of this function uses a mapping provided by unicode.org, browsable under http://www.unicode.org/cldr/charts/latest/supplemental/zone_tzid.html, so the IANA names can be universally used for each underlying operating system.</desc>
                    <sample for="lua">local result = DateTime.setTimeZone("America/New_York")</sample>
                    <param name="timeZoneString" type="string" desc="The time zone string in IANA tz database format"/>
                    <return name="success" type="bool" desc="If true, the time zone was set successfully"/>
                </function>
                <function name="getTimeZone">
                    <desc>Returns the currently set time zone in IANA tz database format.
The function queries the underlying operating system for the current time zone and returns the corresponding string.
When the time zone is not available, or could not be translated into the IANA format, or is not implemented on the operating system, an empty string is returned.
When using DateTime.setTimeZone(), the returned string of this function may be different to one set before because the IANA format allows various synonyms for time zones. But it is assured that the returned string describes a time zone that is a synonym to the last one passed to setTimeZone() even if it is different. For example, the result may be "Europe/Vienna" even when "Europe/Berlin" was passed to setTimeZone() because both cities are located in the same time zone.</desc>
                    <sample for="lua">local currentZone = DateTime.getTimeZone()</sample>
                    <return name="timeZone" type="string" desc="The currently set time zone or an empty string if getting is not possible"/>
                </function>
                <function name="isTimeSet">
                    <desc>Returns whether the system time has been set (by NTP or some other service) since bootup, so the getDate/Time() calls deliver reliable results.</desc>
                    <sample for="lua">local timeSetSinceBootUp = DateTime.isTimeSet()</sample>
                    <return name="isSet" type="bool" desc="true when the system date has been set minimum once since bootup"/>
                </function>
            </serves>
        </crown>
        <crown name="Timer">
            <trait>released</trait>
            <desc>Provides Timers which can expire and call automatically callbacks.
Timers can run once or automatically periodic</desc>
            <serves>
                <event name="OnExpired">
                    <desc>This event is notified every time the timer expires</desc>
                    <sample for="lua">Timer.register(handle, "OnExpired", "handleExpired")</sample>
                    <param name="handle" type="handle" alias="Timer" desc="This is a handle event and must be registered on the handle"/>
                </event>
                <function name="create">
                    <desc>Sets up a timer with a specific expiration timer time after which the specified callback function is called automatically. Timer needs to be started explicitly.</desc>
                    <sample for="lua">handle = Timer.create()</sample>
                    <return name="handle" type="handle" alias="Timer" desc="Unique handle for the timer"/>
                </function>
                <function name="setExpirationTime">
                    <desc>Sets the expiration time of the timer in milliseconds. Default is 5000. New time is used next time calling start().</desc>
                    <sample for="lua">Timer.setExpirationTime(handle, 5000)</sample>
                    <param name="handle" type="handle" alias="Timer" desc="The instance handle to use"/>
                    <param name="timeMS" type="int" desc="The expire time of the timer in milliseconds. Must be greater than 0."/>
                </function>
                <function name="setPeriodic">
                    <desc>Sets the timer to periodic. Default is not periodic.</desc>
                    <sample for="lua">Timer.setPeriodic(handle, true)</sample>
                    <param name="handle" type="handle" alias="Timer" desc="The instance handle to use"/>
                    <param name="isPeriodic" type="bool" desc="True if timer occurs periodically until it is stopped or destroyed. Default is false."/>
                </function>
                <function name="register">
                    <desc>This function is used to register for any event of the handle.</desc>
                    <param name="handle" type="handle" alias="Timer" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to register to"/>
                    <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                    <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                </function>
                <function name="deregister">
                    <desc>This function is used to deregister from any registered event of the handle.</desc>
                    <param name="handle" type="handle" alias="Timer" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to deregister from"/>
                    <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                    <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                </function>
                <function name="start">
                    <desc>Starts the timer</desc>
                    <sample for="lua">Timer.start(handle)</sample>
                    <param name="handle" type="handle" alias="Timer" desc="The instance to use"/>
                </function>
                <function name="stop">
                    <desc>Stops the timer</desc>
                    <sample for="lua">Timer.stop(handle)</sample>
                    <param name="handle" type="handle" alias="Timer" desc="The instance to use"/>
                </function>
                <function name="isRunning">
                    <desc>Queries if the timer is currently running. Note that isRunning() will return false for a non-periodic timer that has already expired.</desc>
                    <sample for="lua">running = Timer.isRunning(handle)</sample>
                    <param name="handle" type="handle" alias="Timer" desc="The instance to use"/>
                    <return name="running" type="bool" desc="True if the timer is running, false if not"/>
                </function>
            </serves>
        </crown>
        <crown name="Container">
            <trait>released</trait>
            <desc>An associative container storing all kind of CROWN datatypes (like objects, strings, booleans etc.).

Each item in the container is identified using a string name as key.
One item in the container can represent both a single value as well as vectors.

Adding to the container is done using a general purpose add()-function.

For retrieval of items there are more options:
There is a general purpose get() function that provides the item, but type checking of the obtained instance must be done by the user.
There is a set of typed functions for retrieving items from the container which check that the item to be retrieved also has the expected type.

Internally, the implementation uses a hash map for fast value access.
The order of adding items is not relevant.

Access to the container is thread-safe.</desc>
            <enum name="ItemTypes">
                <desc>The different types of which one item in the container can be. Matches the existing framework types.</desc>
                <item name="object" desc="Only non-const object">OBJECT</item>
                <item name="const object" desc="Matches also non-const objects">CONST_OBJECT</item>
                <item name="float">FLOAT</item>
                <item name="integer">INT</item>
                <item name="bool">BOOL</item>
                <item name="string">STRING</item>
                <item name="binary">BINARY</item>
            </enum>
            <serves>
                <function name="create">
                    <desc>Creates a new container.</desc>
                    <return name="container" type="object" alias="Container" desc="The new container."/>
                </function>
                <function name="add">
                    <desc>Adds an item to the container.
The item can be a float, integer, bool, string or any object. Only works with non-const objects, for const-objects use the "addConst"-function.
If an item with the same name already exists in the container, the function returns false.
The container itself cannot be added as item.</desc>
                    <param name="container" type="object" alias="Container" desc="Container instance."/>
                    <param name="name" type="string" desc="Name of the item. Must not be empty."/>
                    <param name="item" type="auto" multiplicity="[1+]" desc="Item to add to the container. Nil value is not possible."/>
                    <param name="itemType" type="enum" multiplicity="?" ref="ItemTypes" desc="Can be specified to set explicitly the type name for the item which should be added. An attempt is made to convert the item to this target type."/>
                    <return name="success" type="bool" desc="Returns true if successfully added. False if item already exists or item type does not match."/>
                </function>
                <function name="addConst">
                    <desc>Adds a const item to the container.
The item can be a float, integer, bool, string or any object. Objects can be non-const or const and are forced to be const inside the container.
If an item with the same name already exists in the container, the function returns false.
The container itself cannot be added as item.</desc>
                    <param name="container" type="object" alias="Container" desc="Container instance."/>
                    <param name="name" type="string" desc="Name of the item. Must not be empty."/>
                    <param name="item" type="const auto" multiplicity="[1+]" desc="Item to add to the container. Nil value is not possible."/>
                    <param name="itemType" type="enum" multiplicity="?" ref="ItemTypes" desc="Can be specified to set explicitly the type name for the item which should be added. An attempt is made to convert the item to this target type."/>
                    <return name="success" type="bool" desc="Returns true if successfully added. False if item already exists or item type does not match."/>
                </function>
                <function name="update">
                    <desc>Updates an existing item in the container.
The item can be a float, integer, bool, string or any object. Only works with non-const objects, for const-objects use the "updateConst"-function.
If an item with the name does not exist in the container, the function returns false.
If the existing item has a different type than specified, the function returns false.
The container itself cannot be set as item.</desc>
                    <param name="container" type="object" alias="Container" desc="Container instance."/>
                    <param name="name" type="string" desc="Name of the item. Must not be empty."/>
                    <param name="item" type="auto" multiplicity="[1+]" desc="Item to update in the container. Nil value is not possible."/>
                    <param name="itemType" type="enum" multiplicity="?" ref="ItemTypes" desc="Can be specified to set explicitly the type name for the item which should be updated. An attempt is made to convert the item to this target type."/>
                    <return name="success" type="bool" desc="Returns true if successfully updated. False if item does not exist or item type does not match."/>
                </function>
                <function name="updateConst">
                    <desc>Updates an existing const item in the container.
The item can be a float, integer, bool, string or any object. Objects can be non-const or const, and are forced to be const inside the container.
If an item with the name does not exist in the container, the function returns false.
If the existing item has a different type than specified, the function returns false.
The container itself cannot be set as item.</desc>
                    <param name="container" type="object" alias="Container" desc="Container instance."/>
                    <param name="name" type="string" desc="Name of the item. Must not be empty."/>
                    <param name="item" type="const auto" multiplicity="[1+]" desc="Item to update in the container. Nil value is not possible."/>
                    <param name="itemType" type="enum" multiplicity="?" ref="ItemTypes" desc="Can be specified to set explicitly the type name for the item which should be updated. An attempt is made to convert the item to this target type."/>
                    <return name="success" type="bool" desc="Returns true if successfully updated. False if item does not exist or item type does not match."/>
                </function>
                <function name="get">
                    <desc>Get any item from the container.
No type-checking is done on the item to get, it can be an integer, float, bool, object etc., or a vector of such types. To get a const-object value use the "getConst"-function.
It is up to the user to make sure that the returned value is of the correct type before further usage.</desc>
                    <param name="container" type="const object" alias="Container" desc="Container instance."/>
                    <param name="name" type="string" desc="Name of the item."/>
                    <param name="itemType" type="enum" multiplicity="?" ref="ItemTypes" desc="Can be specified to explicitly get the item only if the type matches. If the item type does not match, nil is returned."/>
                    <return name="item" type="auto" multiplicity="[?*]" desc="Returns item if retrieval was successful, otherwise nil."/>
                </function>
                <function name="getConst">
                    <desc>Get any item from the container as const.
No type-checking is done on the item to get, it can be an integer, float, bool, object etc., or a vector of such types. Objects can be non-const or const and are always returned as const object.
It is up to the user to make sure that the returned value is of the correct type before further usage.</desc>
                    <param name="container" type="const object" alias="Container" desc="Container instance."/>
                    <param name="name" type="string" desc="Name of the item."/>
                    <param name="itemType" type="enum" multiplicity="?" ref="ItemTypes" desc="Can be specified to explicitly get the item only if the type matches. If the item type does not match, nil is returned."/>
                    <return name="item" type="const auto" multiplicity="[?*]" desc="Returns item if retrieval was successful, otherwise nil."/>
                </function>
                <function name="list">
                    <desc>Gets a list of all key names in the container in alphabetical order.</desc>
                    <param name="container" type="const object" alias="Container" desc="Container instance."/>
                    <return name="item" type="string" multiplicity="+" desc="A string vector with the names of all items in the container in alphabetical order."/>
                </function>
                <function name="remove">
                    <desc>Removes an item from the container.
If there is no item with the provided key string, nothing is done and false is returned.</desc>
                    <param name="container" type="object" alias="Container" desc="Container instance."/>
                    <param name="name" type="string" desc="Name of the item to remove."/>
                    <return name="success" type="bool" desc="Returns true if item existed and was removed, false if item did not exist."/>
                </function>
                <function name="clear">
                    <desc>Clears the entire container.</desc>
                    <param name="container" type="object" alias="Container" desc="Container instance."/>
                </function>
                <function name="toString">
                    <desc>Returns a string representation of the content of the container.</desc>
                    <param name="container" type="const object" alias="Container" desc="Container instance."/>
                    <return name="description" type="string" desc="User-friendly description of the container."/>
                </function>
                <function name="isEmpty">
                    <desc>Checks if the container is empty.</desc>
                    <param name="container" type="const object" alias="Container" desc="Container instance."/>
                    <return name="result" type="bool" desc="True if the container is empty."/>
                </function>
                <function name="getSize">
                    <desc>Returns the number of items in the container.</desc>
                    <param name="container" type="const object" alias="Container" desc="Container instance."/>
                    <return name="size" type="int" desc="Number of items in the container."/>
                </function>
                <function name="exists">
                    <desc>Checks if an item with the provided key string exists in the container.</desc>
                    <param name="container" type="const object" alias="Container" desc="Container instance."/>
                    <param name="name" type="string" desc="Name of the item to check."/>
                    <return name="result" type="bool" desc="True if the Container contains an item with the provided key name."/>
                </function>
                <function name="isSingle">
                    <desc>Checks if the item with the provided key string is a single instance, as opposed to a vector-valued instance.</desc>
                    <param name="container" type="const object" alias="Container" desc="Container instance."/>
                    <param name="name" type="string" desc="Name of the item to check."/>
                    <return name="result" type="bool" desc="True if the item with the provided key name is a single instance. False if it is a vector valued instance or if the key name does not exist."/>
                </function>
                <function name="isVector">
                    <desc>Checks if the item with the provided key string is a vector-valued instance, as opposed to a single instance.</desc>
                    <param name="container" type="const object" alias="Container" desc="Container instance."/>
                    <param name="name" type="string" desc="Name of the item to check."/>
                    <return name="result" type="bool" desc="True if the item with the provided key name is a vector-valued instance. False if it is a single instance or if the key name does not exist."/>
                </function>
                <function name="isType">
                    <desc>Checks if the item with the specified key string is of the specified type.</desc>
                    <param name="container" type="const object" alias="Container" desc="Container instance."/>
                    <param name="name" type="string" desc="Name of the item to check."/>
                    <param name="type" type="enum" ref="ItemTypes" desc="The type name to compare against."/>
                    <return name="result" type="bool" multiplicity="?" desc="True if the item with the provided key name is of the queried type. False if it the type is wrong. Nil if the key name does not exist."/>
                </function>
                <function name="getType">
                    <desc>Returns a the enum string type definition of the underlying type of the item.</desc>
                    <param name="container" type="const object" alias="Container" desc="Container instance."/>
                    <param name="name" type="string" desc="Name of the item to check."/>
                    <return name="type" type="enum" multiplicity="?" ref="ItemTypes" desc="The string describing the type. Will be nil if the key name is not found."/>
                </function>
            </serves>
        </crown>
        <crown name="Engine">
            <trait>released</trait>
            <desc>Provides functionality to control the AppEngine of the device and use the AppEngine framework.</desc>
            <serves>
                <event name="OnLoading">
                    <trait>hidden</trait>
                    <desc>Event usable for system apps, which are not reloaded during development.
This is useful so that they know when a loading of apps is started, so that they could e.g. reset theirself</desc>
                    <sample for="lua">Script.register("Engine.OnLoading", "MyApp.OnLoading")</sample>
                </event>
                <event name="OnStarted">
                    <desc>Startup event of the application which is notified once after startup after all apps have been fully loaded.
This should be used by apps which are dependent on other apps to make sure that everything is fully loaded.
The event is also notified if the apps are reloaded externally or over the Engine.reloadApps function.</desc>
                    <sample for="lua">Script.register("Engine.OnStarted", "MyApp.handleOnStarted")</sample>
                </event>
                <function name="reloadApps">
                    <desc>Reloads all applications of the AppEngine.
Function will not return on target hardware and directly reloads. On the emulator the function may return.
This function can be used to reset all applications and start them again like if rebooting but without full powercycle.
This function can only be used after the "Engine.OnStarted" event has been notified to prevent endless reload loops in global scope.</desc>
                    <sample for="lua">Engine.reloadApps()</sample>
                </function>
                <function name="reboot">
                    <desc>Reboots the device over power cycle directly.
Function will NOT return on target hardware.
On the emulator the function always returns and logs a warning that reboot is not possible on emulator.

This function can only be used after the "Engine.OnStarted" event has been notified to prevent endless reboot loops in global scope. Before the event the function call is ignored.

During the first 30 seconds after the "Engine.OnStarted" event the reboot action keeps pending so that an endless reboot loop is prevented.
Every 5 seconds there is a log that a reboot is pending, so that the app developer has time to connect and stop the apps.</desc>
                    <sample for="lua">Engine.reboot("the concrete reboot reason")</sample>
                    <param name="reason" type="string" multiplicity="?" desc="Optional string describing the reason for reboot"/>
                </function>
                <function name="shutdown">
                    <trait>hidden</trait>
                    <desc>Shuts the engine executable down.
Function is possible in emulator and target mode.
Is useful also in target mode e.g. if AppEngine is used for batch processing.
If used accidentally in target mode, there will be a watchdog reboot by the system.</desc>
                    <sample for="lua">Engine.shutdown(0)</sample>
                    <param name="result" type="int" multiplicity="?" desc="The return value of the application"/>
                </function>
                <function name="getCommandLineArguments">
                    <trait>hidden</trait>
                    <desc>Returns the command line arguments of the engine.
This function only works for the emulator and not on target hardware.</desc>
                    <sample for="lua">local args = Engine.getCommandLineArguments()</sample>
                    <return name="cmdLineArgs" type="string" multiplicity="*" desc="The list of the single arguments"/>
                </function>
                <function name="isEmulator">
                    <desc>This function return true if the current engine is just an emulator engine and not a real device.</desc>
                    <return name="isEmulator" type="bool" desc="True if the current device is an emulator"/>
                </function>
                <function name="getVersion">
                    <desc>Returns the AppEngine version of this device</desc>
                    <return name="engineVersion" type="string" desc="The AppEngine version of this device"/>
                </function>
                <function name="getFirmwareVersion">
                    <desc>Returns the device firmware version of this engine</desc>
                    <return name="firmwareVersion" type="string" desc="The device firmware version of this engine"/>
                </function>
                <function name="getTypeName">
                    <desc>Returns the device type name of this engine</desc>
                    <return name="typeName" type="string" desc="The device type name of this engine"/>
                </function>
                <function name="getTypeCode">
                    <desc>Returns the device type code of this engine</desc>
                    <return name="typeCode" type="string" desc="The device type code of this engine"/>
                </function>
                <function name="getPartNumber">
                    <desc>Returns the device part number of this engine</desc>
                    <return name="partNumber" type="string" desc="The device part number of this engine"/>
                </function>
                <function name="getSerialNumber">
                    <desc>Returns the device serial number of this engine as string</desc>
                    <return name="serialNumber" type="string" desc="The device serial number of this engine as string"/>
                </function>
                <function name="getEnumValues">
                    <desc>Returns all enum values of an enum defined in the manifest as a vector sorted alphabetically.</desc>
                    <sample for="lua">local enumValTable = Engine.getEnumValues("Log.Level")</sample>
                    <param name="enumName" type="string" desc="The full CROWN enum name to return its values"/>
                    <return name="enumVals" type="string" multiplicity="*" desc="The sorted vector of enum values or nil if enum does not exist"/>
                </function>
                <function name="getCrowns">
                    <desc>Returns the list of all crowns which are available in the engine as vector sorted alphabetically.
The domain filter like 'ctrl-flow' can be specified, to only return CROWNs which are relevant for the specified domain. The CROWN can also be relevant if there is just one function or event specified as include.
Available domain filters:
- ctrl-flow
- data-flow
- script
- remote
- java</desc>
                    <sample for="lua">local crownList = Engine.getCrowns()</sample>
                    <param name="domainFilter" type="string" multiplicity="?" desc="If specified, only returns the crowns which have an include specified to the domain like 'ctrl-flow' and no exclude is defined to it. See manifest scheme for all available include-domains."/>
                    <return name="crownVector" type="string" multiplicity="+" desc="The sorted vector for all full-qualified crown names"/>
                </function>
                <function name="getCrownAsXML">
                    <desc>Returns the manifest xml snippet of the specified CROWN as xml string.
Sub-CROWNs are NOT included.
Output string starts and ends with the "crown" xml tag.
The name of the crown is only the sub-crown name and NOT the full qualified crown name. E.g. requested crown name is "NameA.NameB.NameC", output xml crown name is only "NameC".</desc>
                    <sample for="lua">local manifestString = Engine.getCrownAsXML("TheCrownName")</sample>
                    <param name="crownName" type="string" desc="The full CROWN name to return the manifest"/>
                    <return name="manifestXml" type="string" multiplicity="?" desc="The manifest xml snippet of the CROWN or nil if CROWN does not exist"/>
                </function>
                <function name="listApps">
                    <desc>Returns the names of all apps currently in the engine.</desc>
                    <return name="appList" type="string" multiplicity="+" desc="List of app names"/>
                </function>
                <function name="getCurrentAppName">
                    <desc>Get the name of the app from which this function is called.</desc>
                    <sample for="lua">local name = Engine.getCurrentAppName()</sample>
                    <return name="name" type="string" multiplicity="?" desc="The name of the app or nil if app context is not available."/>
                </function>
                <function name="getCurrentAppVersion">
                    <desc>Get the version of the app from which this function is called.</desc>
                    <sample for="lua">local version = Engine.getCurrentAppVersion()</sample>
                    <return name="version" type="string" multiplicity="?" desc="The version of the app or nil if app context is not available."/>
                </function>
                <function name="crashOutOfMemory">
                    <trait>hidden</trait>
                    <desc>Creates an OuOfMemory-Exception.</desc>
                    <sample for="lua">Engine.crashOutOfMemory()</sample>
                </function>
                <function name="crashStackOverflow">
                    <trait>hidden</trait>
                    <desc>Creates an StackOverflow-Exception.</desc>
                    <sample for="lua">Engine.crashStackOverflow()</sample>
                </function>
                <function name="crashSegmentationFault">
                    <trait>hidden</trait>
                    <desc>Creates an SegmentationFault-Exception.</desc>
                    <sample for="lua">Engine.crashSegmentationFault()</sample>
                </function>
                <function name="loadFlow">
                    <trait>hidden</trait>
                    <desc>Loads a flow and returns an object for it. As long as the object is held, the flow is active.
The flow should be loaded from the "resources" folder.</desc>
                    <sample for="lua">flowObj = Engine.loadFlow("/resources/myflow.cflow")</sample>
                    <param name="flowFile" type="string" desc="The location of the flow file to load. Should be located in resources folder. Must be .cflow or .dflow extension."/>
                    <return name="flowObject" type="object" multiplicity="?" desc="This object needs to be held to keep the flow active. Nil if not possible or file does not exist."/>
                </function>
                <function name="checkForAllServed">
                    <desc>Checks all API all manifests if they are all served and warns the not served one as a warning log.
This is useful to verify that there isn't any API in any manifest which isn't served.</desc>
                    <return name="allServed" type="bool" desc="Returns true if all API is served. False if there is one or more API which is not served."/>
                </function>
            </serves>
            <crown name="WebServer">
                <trait>released</trait>
                <desc>Provides functions for managing the engine's embedded webserver.</desc>
                <serves>
                    <function name="setEnabled">
                        <desc>Enable or disable the engine's embedded webserver. If disabled the device page will not be accessible any more. REST and websocket communication is no longer possible.</desc>
                        <sample for="lua">Engine.WebServer.setEnabled(false)</sample>
                        <param name="enabled" type="bool" desc="True to enable, false to disable."/>
                    </function>
                    <function name="setCrownEndpointEnabled">
                        <desc>Enable or disable the CROWN endpoint of the engine's embedded webserver. If the endpoint is disabled REST and websocket communication on the URL 'api/crown' is no longer possible. Accessibility of the device page and communication via the 'api' URL is not affected, however.</desc>
                        <sample for="lua">Engine.WebServer.setCrownEndpointEnabled(false)</sample>
                        <param name="enabled" type="bool" desc="True to enable, false to disable."/>
                    </function>
                </serves>
            </crown>
            <crown name="FunctionBinding">
                <trait>released</trait>
                <desc>Serves a new function and allows binding to an existing function including mapping the parameters and results to the target function call.
This is useful e.g. to bind handle based function to a static function and allow calling them from a Flow block, but still configure it conveniently from a script.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">-- Create a simple binding to a handle-based function binding and register it at a provider:
handle = Engine.FunctionBinding.create()
handle:setFunction("Algo.process", algoHandle) -- The algoHandle is the handle to the sample function "Algo.process"
-- register the handle function at a provider:
SomeProvider.register(provHandle,  "OnSomeEvent", handle:serve() )</sample>
                        <return name="handle" type="handle" alias="Engine.FunctionBinding" desc="Handle to the new instance"/>
                    </function>
                    <function name="setFunction">
                        <desc>Sets the target function name to call.
If the function is handle based, the handle can be passed as second parameter to this function, so that it is automatically set as first parameter for every function call.
If a handle is set, the bindParameters function operates only on the function parameters after the handle, so the handle is implicitly added every time. The handle is hold as long as the FunctionBinding exists.</desc>
                        <sample for="lua">-- Static function:
Engine.FunctionBinding.setFunction(handle, "Algo.function")
-- Handle based function:
Engine.FunctionBinding.setFunction(handle, "Algo.function", algoHandle)</sample>
                        <param name="handle" type="handle" alias="Engine.FunctionBinding" desc="The instance to use"/>
                        <param name="functionName" type="string" desc="The function name which is called by this binding"/>
                        <param name="functionHandle" type="handle" multiplicity="?" desc="The optional handle which is automatically set as first parameter to every function call. The handle is hold as long as the FunctionBinding exists."/>
                    </function>
                    <function name="bindParameters">
                        <desc>Adds parameter binding definitions. Could be called several times and adds them to the already bound ones.
If not called at all, the parameters are directly mapped.
The binding is specified from the binding served function to the target function.
A binding definition could be a position info or any other fix value.
A position binding definition is done as string with a "$" as prefix like "$1".
A position binding definition could be also the manifest parameter name of the served function.
A fix value binding could be any CROWN type. If it should be a string starting with "$", then the first $ needs to be escaped to don't be interpreted as position binding.</desc>
                        <sample for="lua">-- Maps to the target function:
-- second parameter of the function call as first parameter
-- first parameter of the function call as second parameter
-- integer value "1" as third parameter
-- content of lua variable "obj"
-- boolean value "true"
Engine.FunctionBinding.bindParameters(handle, "$2", "$1", 1, obj, true)</sample>
                        <param name="handle" type="handle" alias="Engine.FunctionBinding" desc="The instance to use"/>
                        <param name="binding1" type="auto" multiplicity="[1+]" desc="One binding definition"/>
                        <param name="binding2" type="auto" multiplicity="[?*]" desc="second binding definition (optional)"/>
                        <param name="binding3" type="auto" multiplicity="[?*]" desc="third binding definition (optional)"/>
                        <param name="binding4" type="auto" multiplicity="[?*]" desc="fourth binding definition (optional)"/>
                        <param name="binding5" type="auto" multiplicity="[?*]" desc="fifth binding definition (optional)"/>
                        <param name="binding6" type="auto" multiplicity="[?*]" desc="sixth binding definition (optional)"/>
                        <param name="binding7" type="auto" multiplicity="[?*]" desc="seventh binding definition (optional)"/>
                        <return name="success" type="bool" desc="True if binding was correctly specified and is added"/>
                    </function>
                    <function name="bindResults">
                        <desc>Adds result binding definitions. Could be called several times and adds them to the already bound ones.
If not called at all, the parameters are directly mapped.
The binding is specified from the target function to the binding served function.
A binding definition could be a position info or any other fix value.
A position binding definition is done as string with a "$" as prefix like "$1".
A position binding definition could be also the manifest result name of the target function.
A fix value binding could be any CROWN type. If it should be a string starting with "$", then the first $ needs to be escaped to don't be interpreted as position binding.</desc>
                        <sample for="lua">Engine.FunctionBinding.bindResults(handle, "$2", "$1", 1, obj, true)</sample>
                        <param name="handle" type="handle" alias="Engine.FunctionBinding" desc="The instance to use"/>
                        <param name="binding1" type="auto" multiplicity="[1+]" desc="One binding definition"/>
                        <param name="binding2" type="auto" multiplicity="[?*]" desc="second binding definition (optional)"/>
                        <param name="binding3" type="auto" multiplicity="[?*]" desc="third binding definition (optional)"/>
                        <param name="binding4" type="auto" multiplicity="[?*]" desc="fourth binding definition (optional)"/>
                        <param name="binding5" type="auto" multiplicity="[?*]" desc="fifth binding definition (optional)"/>
                        <param name="binding6" type="auto" multiplicity="[?*]" desc="sixth binding definition (optional)"/>
                        <param name="binding7" type="auto" multiplicity="[?*]" desc="seventh binding definition (optional)"/>
                        <return name="success" type="bool" desc="True if binding was correctly specified and is added"/>
                    </function>
                    <function name="serve">
                        <desc>Serves a new function with the binding and returns true if successfully served.
After this call the function can be called by others.
If a function name is specified, the function must be available in the manifest.
If no function name is specified, it generates an unique one and returns it. This is useful to directly bind a function call without having it in the manifest.</desc>
                        <sample for="lua">Engine.FunctionBinding.serve(handle, "MyCrown.newFunction")</sample>
                        <param name="handle" type="handle" alias="Engine.FunctionBinding" desc="The instance to use"/>
                        <param name="serveFuncName" type="string" multiplicity="?" desc="The function name including the crown name which should be served by this binding"/>
                        <return name="success" type="bool" desc="Returns true if successfully served. False if already served by someone else"/>
                        <return name="genServedFuncName" type="string" multiplicity="?" desc="If no function name was specified as parameter, a generated unique one is returned"/>
                    </function>
                    <function name="lock">
                        <desc>Locks all further function calls and makes them return instead of calling the target function.
This is useful e.g. to reconfigure handle which is bound to the function call.
Attention: Take care to keep the locking time as less as possible.</desc>
                        <sample for="lua">Engine.FunctionBinding.lock(handle)</sample>
                        <param name="handle" type="handle" alias="Engine.FunctionBinding" desc="The instance to use"/>
                    </function>
                    <function name="unlock">
                        <desc>Sets the target function to call.</desc>
                        <sample for="lua">Engine.FunctionBinding.unlock(handle)</sample>
                        <param name="handle" type="handle" alias="Engine.FunctionBinding" desc="The instance to use"/>
                    </function>
                </serves>
            </crown>
            <crown name="EventBinding">
                <trait>released</trait>
                <desc>Serves a new event and allows binding to an existing event including mapping the parameters to the new event notify.
This is useful e.g. to bind handle based events to a static events and allow registration to them from a Flow block, but still configure it conveniently from a script.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">-- Create a simple binding to a handle-based event binding:
handle = Engine.EventBinding.create()
handle:setEvent("Provider.OnSomeEvent", providerHandle) -- The providerHandle is the handle to the sample provider "Provider.OnSomeEvent"
-- Serve the new event. After that the event is directly active and will be notified if the bound event is notified:
handle:serve("MyCrown.OnMyEvent")</sample>
                        <return name="handle" type="handle" alias="Engine.EventBinding" desc="Handle to the new instance"/>
                    </function>
                    <function name="setEvent">
                        <desc>Sets the bound event name to register to.
If the event is handle based, the handle can be passed as second parameter to this function, so that the binding is done on the event on that handle.
If a handle is set, the bindParameters function operates only on the event parameters after the handle. The handle is hold as long as the EventBinding exists.</desc>
                        <sample for="lua">-- Static event:
Engine.EventBinding.setEvent(handle, "Provider.OnEvent")
-- Handle based event:
Engine.EventBinding.setEvent(handle, "Provider.OnEvent", providerHandle)</sample>
                        <param name="handle" type="handle" alias="Engine.EventBinding" desc="The instance to use"/>
                        <param name="eventName" type="string" desc="The event name which is used for registration"/>
                        <param name="eventHandle" type="handle" multiplicity="?" desc="The optional handle on which the event should be registered. The handle is hold as long as the EventBinding exists."/>
                    </function>
                    <function name="bindParameters">
                        <desc>Adds parameter binding definitions. Could be called several times and adds them to the already bound ones.
If not called at all, the parameters are directly mapped.
The binding is specified from the registered event to the binding served event.
A binding definition could be a position info or any other fix value.
A position binding definition is done as string with a "$" as prefix like "$1".
A position binding definition could be also the manifest parameter name of the served event.
A fix value binding could be any CROWN type. If it should be a string starting with "$", then the first $ needs to be escaped to don't be interpreted as position binding.</desc>
                        <sample for="lua">-- Maps to the target event:
-- second parameter of the event notify as first parameter
-- first parameter of the event notify as second parameter
-- integer value "1" as third parameter
-- content of lua variable "obj"
-- boolean value "true"
Engine.EventBinding.bindParameters(handle, "$2", "$1", 1, obj, true)</sample>
                        <param name="handle" type="handle" alias="Engine.EventBinding" desc="The instance to use"/>
                        <param name="binding1" type="auto" multiplicity="[1+]" desc="One binding definition"/>
                        <param name="binding2" type="auto" multiplicity="[?*]" desc="second binding definition (optional)"/>
                        <param name="binding3" type="auto" multiplicity="[?*]" desc="third binding definition (optional)"/>
                        <param name="binding4" type="auto" multiplicity="[?*]" desc="fourth binding definition (optional)"/>
                        <param name="binding5" type="auto" multiplicity="[?*]" desc="fifth binding definition (optional)"/>
                        <param name="binding6" type="auto" multiplicity="[?*]" desc="sixth binding definition (optional)"/>
                        <param name="binding7" type="auto" multiplicity="[?*]" desc="seventh binding definition (optional)"/>
                        <return name="success" type="bool" desc="True if binding was correctly specified and is added"/>
                    </function>
                    <function name="serve">
                        <desc>Serves a new event with the binding and returns true if successfully served.
After this call the event can be registered by others and might get directly notified.
If a event name is specified, the event must be available in the manifest.
If no event name is specified, it generates an unique one and returns it. This is useful to directly bind a event notify without having it in the manifest.</desc>
                        <sample for="lua">Engine.EventBinding.serve(handle, "MyCrown.OnMyEvent")</sample>
                        <param name="handle" type="handle" alias="Engine.EventBinding" desc="The instance to use"/>
                        <param name="serveEventName" type="string" multiplicity="?" desc="The event name including the crown name which should be served by this binding"/>
                        <return name="success" type="bool" desc="Returns true if successfully served. False if already served by someone else"/>
                        <return name="genServedEventName" type="string" multiplicity="?" desc="If no event name was specified as parameter, a generated unique one is returned"/>
                    </function>
                    <function name="getNotifyFunction">
                        <desc>Returns the function name which is served and can be called to trigger manually a notify on the served event.
This function name is also used internally to register at the bound event.
Might be useful to trigger event notifies manually.</desc>
                        <sample for="lua">eventNotifyFuncName = Engine.EventBinding.getNotifyFunction(handle)</sample>
                        <param name="handle" type="handle" alias="Engine.EventBinding" desc="The instance to use"/>
                        <return name="servedFunction" type="string" multiplicity="?" desc="The function name of the function to notify the event."/>
                    </function>
                </serves>
            </crown>
            <crown name="AsyncFunction">
                <trait>released</trait>
                <desc>Executes a CROWN function call in an underlying separate thread.
There is one thread per AsyncFunction instance. Multiple launches on an AsyncFunction instance are queued up and executed after each other.
This is useful to execute functions in parallel to better benefit from multiple cores available on the target hardware.
Every function launch returns a Future-handle which identifies the function call.
The results can be retrieved by calling the blocking function "wait" on the Future-handle or by registering to the event "OnFinished" to retrieve the function results asynchronously.</desc>
                <serves>
                    <event name="OnFinished">
                        <desc>This event is triggered on every function async call completion.
The future handle is passed as parameter to get the function result.
This is useful to receive the function results asynchronously instead of using the blocking Future.wait function.</desc>
                        <sample for="lua">Engine.AsyncFunction.register(handle, "OnFinished", "handleResult")</sample>
                        <param name="handle" type="handle" alias="Engine.AsyncFunction" desc="Unique handle to the channel"/>
                        <param name="futureHandle" type="handle" alias="Engine.AsyncFunction.Future" desc="The future object identifying the function call"/>
                    </event>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">-- Create a simple async function call to a handle-based function and wait for its result:
asyncHandle = Engine.AsyncFunction.create()
asyncHandle:setFunction("Algo.function", algoHandle)
futureHandle = asyncHandle:call(p1, p2, p3)
r1, r2, r3 = futureHandle:wait()</sample>
                        <return name="handle" type="handle" alias="Engine.AsyncFunction" desc="Handle to the new instance"/>
                    </function>
                    <function name="setFunction">
                        <desc>Sets the target CROWN function name to call in the async function call execution.
If the CROWN function is handle based, the handle can be passed as second parameter to this function, so that it is automatically set as first parameter for every function call.
The handle is hold as long as the AsyncFunction exists.</desc>
                        <sample for="lua">-- Static function:
Engine.AsyncFunction.setFunction(handle, "Algo.function")
-- Handle based function:
Engine.AsyncFunction.setFunction(handle, "Algo.function", algoHandle)</sample>
                        <param name="handle" type="handle" alias="Engine.AsyncFunction" desc="The instance to use"/>
                        <param name="functionName" type="string" desc="The function name which is called by this async function instance"/>
                        <param name="functionHandle" type="handle" multiplicity="?" desc="The optional handle which is automatically set as first parameter to every function call. The handle is held as long as the AsyncFunction exists."/>
                    </function>
                    <function name="launch">
                        <desc>Starts a new call on the async handle with the specified parameters.
This function directly returns a handle to an Engine.AsyncFunction.Future instance.
Use this Future instance to wait for the function to be completed and get their result.
Alternatively register to the "OnFinished" event to get the future objects notified there for each completed call.
Multiple calls can be spawned at once. They are executed after each other.</desc>
                        <sample for="lua">Engine.AsyncFunction.launch(handle, param1, param2, param3)</sample>
                        <param name="handle" type="handle" alias="Engine.AsyncFunction" desc="The instance to use"/>
                        <param name="param1" type="auto" multiplicity="[?*]" desc="First parameter for the async function call (optional)"/>
                        <param name="param2" type="auto" multiplicity="[?*]" desc="second parameter for the async function call (optional)"/>
                        <param name="param3" type="auto" multiplicity="[?*]" desc="third parameter for the async function call (optional)"/>
                        <param name="param4" type="auto" multiplicity="[?*]" desc="fourth parameter for the async function call (optional)"/>
                        <param name="param5" type="auto" multiplicity="[?*]" desc="fifth parameter for the async function call (optional)"/>
                        <param name="param6" type="auto" multiplicity="[?*]" desc="sixth parameter for the async function call (optional)"/>
                        <param name="param7" type="auto" multiplicity="[?*]" desc="seventh parameter for the async function call (optional)"/>
                        <return name="futureHandle" type="handle" multiplicity="?" alias="Engine.AsyncFunction.Future" desc="The future handle to wait for the result of the async function call. Can be nil if there was an internal error while launching the function call or no function was set."/>
                    </function>
                    <function name="register">
                        <desc>This function is used to register for any event of the handle.</desc>
                        <param name="handle" type="handle" alias="Engine.AsyncFunction" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to register to"/>
                        <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                        <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                    </function>
                    <function name="deregister">
                        <desc>This function is used to deregister from any registered event of the handle.</desc>
                        <param name="handle" type="handle" alias="Engine.AsyncFunction" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to deregister from"/>
                        <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                        <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                    </function>
                </serves>
                <crown name="Future">
                    <trait>released</trait>
                    <desc>Is returned by the Engine.AsyncFunction.launch function to control the async function execution like to wait for the result.
To cancel a queued up function execution, call the abandon function.</desc>
                    <serves>
                        <function name="wait">
                            <desc>Blocks and waits until the corresponding async function call finishes with optional timeout.
Returns the result values of the function which was called asynchronously.</desc>
                            <sample for="lua">res1, res2, res3 = Engine.AsyncFunction.Future.wait(handle)</sample>
                            <param name="handle" type="handle" alias="Engine.AsyncFunction.Future" desc="The instance to use"/>
                            <param name="timeoutMs" type="int" multiplicity="?" desc="The time in ms to wait for the function call to finish"/>
                            <return name="result1" type="auto" multiplicity="[?*]" desc="First result of the async function call (optional)"/>
                            <return name="result2" type="auto" multiplicity="[?*]" desc="second result of the async function call (optional)"/>
                            <return name="result3" type="auto" multiplicity="[?*]" desc="third result of the async function call (optional)"/>
                            <return name="result4" type="auto" multiplicity="[?*]" desc="fourth result of the async function call (optional)"/>
                            <return name="result5" type="auto" multiplicity="[?*]" desc="fifth result of the async function call (optional)"/>
                            <return name="result6" type="auto" multiplicity="[?*]" desc="sixth result of the async function call (optional)"/>
                            <return name="result7" type="auto" multiplicity="[?*]" desc="seventh result of the async function call (optional)"/>
                        </function>
                        <function name="isFinished">
                            <desc>Can be used to poll if the async function execution is finished.</desc>
                            <sample for="lua">bIsFinished = Engine.AsyncFunction.Future.isFinished(handle)</sample>
                            <param name="handle" type="handle" alias="Engine.AsyncFunction.Future" desc="The instance to use"/>
                            <return name="isFinished" type="bool" desc="True if the function execution is finished. False if not."/>
                        </function>
                        <function name="isFailed">
                            <desc>If the function call is finished, this function can be used to check, if there was an error calling the function asynchronously.
A fail might happen, if the function to be called was not valid (not served) or the function parameters/return values were not correct.</desc>
                            <sample for="lua">isFailed = Engine.AsyncFunction.Future.isFailed(futureHandle)</sample>
                            <param name="handle" type="handle" alias="Engine.AsyncFunction.Future" desc="The instance to use"/>
                            <return name="isFailed" type="bool" desc="True if the function execution was failed. False if called successfully or not finished."/>
                        </function>
                        <function name="abandon">
                            <desc>Throws the async function execution and its result away.
If the function execution is still queued, it will not be executed.
If it is currently already running, the result of it will be abandoned.</desc>
                            <sample for="lua">Engine.AsyncFunction.Future.abandon(futureHandle)</sample>
                            <param name="handle" type="handle" alias="Engine.AsyncFunction.Future" desc="The instance to use"/>
                        </function>
                    </serves>
                </crown>
            </crown>
            <crown name="SyncEvent">
                <trait>released</trait>
                <desc>Registers for the specified event and queues up all event occurrences.
The user can synchronously wait for the event occurrence and their event parameters.
There is an internal queue used which queues all events up.
This is useful if the user needs to get the status of an event at a specified position during processing.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">-- Create a simple sync event and 
handle = Engine.SyncEvent.create()
handle:setEvent("Provider.OnEvent", provHandle)
handle:open()
r1, r2, r3 = handle:wait()</sample>
                        <return name="handle" type="handle" alias="Engine.SyncEvent" desc="Handle to the new instance"/>
                    </function>
                    <function name="setEvent">
                        <desc>Sets the event name to register to.
If the event is handle based, the handle can be passed as second parameter to this function, so that the event is registered at the handle.
The handle is hold as long as the SyncEvent exists.
This function is also optional. If not called, the user can directly use the open function and use the returned function name to manually enqueue to the queue or register manually at events.</desc>
                        <sample for="lua">-- Static event:
Engine.SyncEvent.setEvent(handle, "Provider.OnEvent")
-- Handle based event:
Engine.SyncEvent.setEvent(handle, "Provider.OnEvent", providerHandle)</sample>
                        <param name="handle" type="handle" alias="Engine.SyncEvent" desc="The instance to use"/>
                        <param name="eventName" type="string" desc="The event name which is used for registration"/>
                        <param name="eventHandle" type="handle" multiplicity="?" desc="The optional handle on which the event should be registered. The handle is hold as long as the SyncEvent exists."/>
                    </function>
                    <function name="setMaxQueueSize">
                        <desc>Sets the maximum queue size of the internal event queue.
Per default the queue is set to infinite size (=0).
If the max queue size is reached, the oldest element is discarded per default. To change that behaviour use the setDiscardIfFull-Function.</desc>
                        <sample for="lua">Engine.SyncEvent.setMaxQueueSize(handle, 10)</sample>
                        <param name="handle" type="handle" alias="Engine.SyncEvent" desc="The instance to use"/>
                        <param name="maxQueueSize" type="int" desc="The max number of events to queue. Per default 0 (=infinite)"/>
                    </function>
                    <function name="setDiscardIfFull">
                        <desc>Sets the behaviour for adding events to the queue if the queue is full.
Per default the oldest element is discarded.
To discard the newest to be added element, call this function with parameter true.</desc>
                        <sample for="lua">Engine.SyncEvent.setDiscardIfFull(handle, true)</sample>
                        <param name="handle" type="handle" alias="Engine.SyncEvent" desc="The instance to use"/>
                        <param name="bDiscardIfFull" type="bool" desc="Set to true to discard the newest item which is currently added instead of discarding the oldest element"/>
                    </function>
                    <function name="open">
                        <desc>Opens the internal queue by registering for the event which was set before.
After this call the events are received and queue internally up.
Returns true if the it was successfully registered and opened.
Additionally it returns the internal served function name which also can be used manually by the user to enqueue the event.</desc>
                        <sample for="lua">bSuccess, enqueueFunc = Engine.SyncEvent.open(handle)</sample>
                        <param name="handle" type="handle" alias="Engine.SyncEvent" desc="The instance to use"/>
                        <return name="success" type="bool" desc="True if successfully registered and opened. False if e.g. the event handle was not valid and registering was not possible or the event name was not valid"/>
                        <return name="enqueueFunctionName" type="string" multiplicity="?" desc="If successfully opened, the function name is returned here to manually enqueue to the event queue or register at further events"/>
                    </function>
                    <function name="close">
                        <desc>Closes the internal queue and removes the registrations on the event.
All currently queued events are discarded.</desc>
                        <sample for="lua">Engine.SyncEvent.close(handle)</sample>
                        <param name="handle" type="handle" alias="Engine.SyncEvent" desc="The instance to use"/>
                    </function>
                    <function name="getSize">
                        <desc>Returns the current number of queued calls.
Pay attention that directly during returning from this function there might be events already added again.</desc>
                        <sample for="lua">local queueSize = Engine.SyncEvent.getSize(handle)</sample>
                        <param name="handle" type="handle" alias="Engine.SyncEvent" desc="The instance to use"/>
                        <return name="queueSize" type="int" desc="The current number of queues which are queued in the internal queue"/>
                    </function>
                    <function name="clear">
                        <desc>Clears all currently queued events.
Pay attention that directly during returning from this function there might be events already added again.</desc>
                        <sample for="lua">Engine.SyncEvent.clear(handle)</sample>
                        <param name="handle" type="handle" alias="Engine.SyncEvent" desc="The instance to use"/>
                    </function>
                    <function name="wait">
                        <desc>Blocks and waits until there is an event in the queue with optional timeout.
Returns the parameter values of the event which was called received.
If there is already an event queued, this function directly returns.</desc>
                        <sample for="lua"></sample>
                        <param name="handle" type="handle" alias="Engine.SyncEvent" desc="The instance to use"/>
                        <param name="timeoutMs" type="int" multiplicity="?" desc="The time in ms to wait for the function call to finish"/>
                        <return name="result1" type="auto" multiplicity="[?*]" desc="First result of the async function call (optional)"/>
                        <return name="result2" type="auto" multiplicity="[?*]" desc="second result of the async function call (optional)"/>
                        <return name="result3" type="auto" multiplicity="[?*]" desc="third result of the async function call (optional)"/>
                        <return name="result4" type="auto" multiplicity="[?*]" desc="fourth result of the async function call (optional)"/>
                        <return name="result5" type="auto" multiplicity="[?*]" desc="fifth result of the async function call (optional)"/>
                        <return name="result6" type="auto" multiplicity="[?*]" desc="sixth result of the async function call (optional)"/>
                        <return name="result7" type="auto" multiplicity="[?*]" desc="seventh result of the async function call (optional)"/>
                    </function>
                    <function name="poll">
                        <desc>Polls and returns the event parameters if there is already an event queued.
Returns nothing if there was no event queued.</desc>
                        <sample for="lua"></sample>
                        <param name="handle" type="handle" alias="Engine.SyncEvent" desc="The instance to use"/>
                        <return name="result1" type="auto" multiplicity="[?*]" desc="First result of the async function call (optional)"/>
                        <return name="result2" type="auto" multiplicity="[?*]" desc="second result of the async function call (optional)"/>
                        <return name="result3" type="auto" multiplicity="[?*]" desc="third result of the async function call (optional)"/>
                        <return name="result4" type="auto" multiplicity="[?*]" desc="fourth result of the async function call (optional)"/>
                        <return name="result5" type="auto" multiplicity="[?*]" desc="fifth result of the async function call (optional)"/>
                        <return name="result6" type="auto" multiplicity="[?*]" desc="sixth result of the async function call (optional)"/>
                        <return name="result7" type="auto" multiplicity="[?*]" desc="seventh result of the async function call (optional)"/>
                    </function>
                </serves>
            </crown>
            <crown name="Event">
                <trait>released</trait>
                <desc>This is a generic block to map to an flow input or output event.
It can register to events so that it can be used as input block,
or it can notify an event so that it can be used as output block.
It supports level and dirac signals.</desc>
                <serves>
                    <event name="OnEvent">
                        <include>ctrl-flow</include>
                        <include>data-flow</include>
                        <desc>Register to the specified event name and provides its occurrences as signal.
If the event has no bool parameter, it is a dirac event.
if the event has a bool parameter, it is a level event.</desc>
                        <sample for="lua">Engine.Event.OnEvent(handle, signal)</sample>
                        <param name="handle" type="handle" alias="Engine.Event" desc=""/>
                        <param name="signal" type="bool" desc="The level/Dirac signal which is triggered by every event occurrence. If registered event has a bool parameter, the value is provided as level."/>
                    </event>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">handle = Engine.Event.create()</sample>
                        <return name="handle" type="handle" alias="Engine.Event" desc="Handle to the new instance"/>
                    </function>
                    <function name="setEventName">
                        <desc>Name of the event to which the block registers to (OnEvent-event) or which the block notifies (notify-function).
The event has to exist in the manifest in both cases.
If it is a level-based event, it must have one bool parameter declared in the manifest.
If it is a dirac-based event, it must have no parameter declared in the manifest.</desc>
                        <sample for="lua">Engine.Event.setEventName(handle, eventName)</sample>
                        <param name="handle" type="handle" alias="Engine.Event" desc=""/>
                        <param name="eventName" type="string" desc=""/>
                    </function>
                    <function name="notify">
                        <include>ctrl-flow</include>
                        <include>data-flow</include>
                        <desc>Notifies the specified event name.
The event has to be added by the user to the manifest.</desc>
                        <sample for="lua">Engine.Event.notify(handle, signal)</sample>
                        <param name="handle" type="handle" alias="Engine.Event" desc=""/>
                        <param name="signal" type="bool" desc="The level/Dirac signal which triggers the event notify."/>
                    </function>
                </serves>
            </crown>
        </crown>
        <crown name="Flow">
            <trait>released</trait>
            <desc>Functionality to dynamically create and control Flows on demand.
This is the dynamic feature to the static possibility of adding flow files to an app.

A flow can be created using the addBlock()-functions.
The start-function runs the current created flow configuration.
Further changes using the add- or remove-functions don't influence the current running flow.

It can only be fully checked if the wiring if the blocks is correct when the flow is started.

Parameters of the blocks can be updated on the fly using the updateParameter()-function.</desc>
            <enum name="FlowType">
                <item name="DataFlow (Default)">DFLOW</item>
                <item name="ControlFlow">CFLOW</item>
            </enum>
            <enum name="BlockType">
                <item name="Function">FUNCTION</item>
                <item name="Provider">PROVIDER</item>
                <item name="Consumer">CONSUMER</item>
            </enum>
            <serves>
                <function name="create">
                    <desc>Creates a new instance.</desc>
                    <return name="handle" type="handle" alias="Flow" desc="Handle to the new instance"/>
                </function>
                <function name="setType">
                    <desc>Sets the type of the flow.
Default is "DataFlow".</desc>
                    <param name="handle" type="handle" alias="Flow" desc="The instance to use"/>
                    <param name="flowType" type="enum" ref="FlowType" desc="The flow type to set."/>
                </function>
                <function name="addBlock">
                    <desc>Adds a new function block to the flow instance.
A function block calls a CROWN function and offers its parameters as block inputs and return values as block outputs.</desc>
                    <param name="handle" type="handle" alias="Flow" desc="The instance to use"/>
                    <param name="blockName" type="string" desc="The name of the new block"/>
                    <param name="functionName" type="string" desc="The CROWN function name to call in by block. This must be a manifested CROWN function so that the parameters and return value information is present."/>
                    <return name="success" type="bool" desc="True if successfully added. False if there is already a block with that name, or CROWN function does not exist."/>
                </function>
                <function name="addProviderBlock">
                    <desc>Adds a new provider block to the flow instance.
A provider block can register to an existing specified CROWN event and offers the event parameters as block output.
It can also serve a new CROWN function, which can be called and its parameters are offered as block output. In this case the user has to add the function in the manifest first.</desc>
                    <param name="handle" type="handle" alias="Flow" desc="The instance to use"/>
                    <param name="blockName" type="string" desc="The name of the new block"/>
                    <param name="eventName" type="string" desc="The CROWN event (or function name) the block uses. This must be a manifested CROWN event (or function) so that the parameters information is present."/>
                    <return name="success" type="bool" desc="True if successfully added. False if there is already a block with that name, or CROWN event (or function) does not exist."/>
                </function>
                <function name="addConsumerBlock">
                    <desc>Adds a new consumer block to the flow instance.
A consumer block can call an existing specified CROWN function and offers its parameters as block input.
It can also serve a new CROWN event and notify the block parameters as event. In this case the user has to add the event in the manifest first.</desc>
                    <param name="handle" type="handle" alias="Flow" desc="The instance to use"/>
                    <param name="blockName" type="string" desc="The name of the new block"/>
                    <param name="functionName" type="string" desc="The CROWN function (or event name) the block uses. This must be a manifested CROWN function (or event) so that the parameters information is present."/>
                    <return name="success" type="bool" desc="True if successfully added. False if there is already a block with that name, or CROWN function (or event) does not exist."/>
                </function>
                <function name="removeBlock">
                    <desc>Removes any kind of block with the specified name including its parameters.
Also removes all links from and to the block.</desc>
                    <param name="handle" type="handle" alias="Flow" desc="The instance to use"/>
                    <param name="blockName" type="string" desc="The name of the block to remove."/>
                    <return name="success" type="bool" desc="True if successfully removed. False if a block with that name did not exist."/>
                </function>
                <function name="hasBlock">
                    <desc>Returns true if a block with the specified name exists.</desc>
                    <param name="handle" type="handle" alias="Flow" desc="The instance to use"/>
                    <param name="blockName" type="string" desc="The name of the block to remove."/>
                    <return name="success" type="bool" desc="True if successfully block exists."/>
                </function>
                <function name="getBlockDescription">
                    <desc>Returns the type and function/event description of a block.
If there is no block like specified, nothing is returned.</desc>
                    <param name="handle" type="handle" alias="Flow" desc="The instance to use"/>
                    <param name="blockName" type="string" desc="The name of the block to remove."/>
                    <return name="blockType" type="enum" ref="BlockType" desc="The type of the block"/>
                    <return name="functionEvent" type="string" desc="The function or event which is assigned to the block"/>
                </function>
                <function name="listBlocks">
                    <desc>Returns a list of existing block names sorted alphabetically.</desc>
                    <param name="handle" type="handle" alias="Flow" desc="The instance to use"/>
                    <return name="blockNames" type="string" multiplicity="+" desc="List of block names in the current flow"/>
                </function>
                <function name="setCreationParameter">
                    <desc>Sets the specified creation parameter name with the value to the specified block as block creation parameter.
The creation parameter is needed if the block maps to handle-based CROWNs which need a parameter for their handle create()-function.
If the parameter was already set, it is overwritten.
If the flow is already loaded this only gets active after re-loading the flow.</desc>
                    <param name="handle" type="handle" alias="Flow" desc="The instance to use"/>
                    <param name="blockName" type="string" desc="The name of the block to set the parameter to."/>
                    <param name="paramValue" type="string" desc="The parameter value as string to be set as handle-based block creation parameter."/>
                    <return name="success" type="bool" desc="True if successfully set. False if a block with that name did not exist."/>
                </function>
                <function name="getCreationParameter">
                    <desc>Returns the value of the specified creation parameter name of the specified block which is used as block creation parameter.
If there is no block like specified, nothing is returned.</desc>
                    <param name="handle" type="handle" alias="Flow" desc="The instance to use"/>
                    <param name="blockName" type="string" desc="The name of the block to set the parameter to."/>
                    <return name="paramValue" type="string" multiplicity="?" desc="The parameter value as string which is set as handle-based block creation parameter."/>
                </function>
                <function name="listInitialParameters">
                    <desc>Returns a list of initial parameters of the specified block sorted alphabetically.</desc>
                    <param name="handle" type="handle" alias="Flow" desc="The instance to use"/>
                    <param name="blockName" type="string" desc="The name of the block to get the parameters list from."/>
                    <return name="parameterNames" type="string" multiplicity="*" desc="List of parameter names of the specified block."/>
                </function>
                <function name="setInitialParameter">
                    <desc>Sets the specified initial parameter name with the value to the specified block as initial value while loading the flow.
If the parameter was already set, it is overwritten.
If the flow is already loaded this only gets active after re-loading the flow.</desc>
                    <param name="handle" type="handle" alias="Flow" desc="The instance to use"/>
                    <param name="blockName" type="string" desc="The name of the block to set the parameter to."/>
                    <param name="paramName" type="string" desc="The name of the parameter to set."/>
                    <param name="paramValue" type="auto" multiplicity="[1+]" desc="The parameter value as string, bool, int or float (single or vector value) to be set as block parameter."/>
                    <return name="success" type="bool" desc="True if successfully set. False if a block with that name did not exist."/>
                </function>
                <function name="getInitialParameter">
                    <desc>Returns the initial value of the specified initial parameter name of the specified block which is used loading the flow.
If there is no block or parameter like specified, nothing is returned.
The manifest info for the corresponding set-parameter-function for the block has to be available so that the correct type is returned, otherwise only the string value of the parameter is returned.</desc>
                    <param name="handle" type="handle" alias="Flow" desc="The instance to use"/>
                    <param name="blockName" type="string" desc="The name of the block to get the parameter from."/>
                    <param name="paramName" type="string" desc="The name of the parameter to get."/>
                    <return name="paramValue" type="auto" multiplicity="[?*]" desc="The parameter value as string, bool, int or float (single or vector value) which is set to the block parameter or nil if block or parameter does not exist."/>
                </function>
                <function name="removeInitialParameter">
                    <desc>Removes the specified initial parameter from the specified block.
If the flow is already loaded this only gets active after re-loading the flow.</desc>
                    <param name="handle" type="handle" alias="Flow" desc="The instance to use"/>
                    <param name="blockName" type="string" desc="The name of the block to remove."/>
                    <param name="paramName" type="string" desc="The name of the parameter to remove."/>
                    <return name="success" type="bool" desc="True if successfully removed. False if a block with that name did not exist."/>
                </function>
                <function name="updateParameter">
                    <desc>Updates the specified parameter name with the value to the specified block during running of the flow.
This only works if the flow is currently loaded.
The new value will become active after the current running flow finishes processing.
This function will block until the parameter is set.</desc>
                    <param name="handle" type="handle" alias="Flow" desc="The instance to use"/>
                    <param name="blockName" type="string" desc="The name of the block to set the parameter to."/>
                    <param name="paramName" type="string" desc="The name of the parameter to set."/>
                    <param name="paramValue" type="auto" multiplicity="[1+]" desc="The parameter value as string, bool, int or float (single or vector value) to be set as block parameter."/>
                    <return name="success" type="bool" desc="True if successfully updated. False if a block with that name did not exist or parameter of the block does not exist or flow isn't currently loaded or parameter value cannot be applied."/>
                </function>
                <function name="addLink">
                    <desc>Adds a link from a source block to a target block.
The port name or port index must be appended separated by a colon. If no port name/index is specified, the first port of the block is used.
Port names are the CROWN manifest parameter and return value names.
During start of the flow it is detected whether the link can be established.
The function fails if a block does not exist in the flow. A wrong port name is only detected during start of the flow.</desc>
                    <param name="handle" type="handle" alias="Flow" desc="The instance to use"/>
                    <param name="fromBlockPort" type="string" desc="The name of the block to create the link from. The port name or port index must be appended separated by a colon. If no port name/index is specified, the first port of the block is used."/>
                    <param name="toBlockPort" type="string" desc="The name of the block to create the link to. The port name or port index must be appended separated by a colon. If no port name/index is specified, the first port of the block is used."/>
                    <return name="success" type="bool" desc="True if successfully added the link. False if link already exists or a block or port does not exist."/>
                </function>
                <function name="removeLink">
                    <desc>Removes an existing link from the a source block to a target block.
If the source and target block ports are not specified, all links which exist between the blocks are removed.</desc>
                    <param name="handle" type="handle" alias="Flow" desc="The instance to use"/>
                    <param name="fromBlockPort" type="string" desc="The name of the block to create the link from. The port name or port index must be appended separated by a colon. If no port name/index is specified, the first port of the block is used."/>
                    <param name="toBlockPort" type="string" desc="The name of the block to create the link to. The port name or port index must be appended separated by a colon. If no port name/index is specified, the first port of the block is used."/>
                    <return name="success" type="bool" desc="True if successfully removed the link. False if the link did not exist."/>
                </function>
                <function name="listLinks">
                    <desc>Returns two lists with infos about the existing links (in random order).
Both lists are of the same size and each entry relates to the entries in the other lists at the same index.</desc>
                    <param name="handle" type="handle" alias="Flow" desc="The instance to use"/>
                    <return name="fromBlockPort" type="string" multiplicity="+" desc="The list of block names to link from. There can be a port name or port index appended separated by a colon."/>
                    <return name="toBlockPort" type="string" multiplicity="+" desc="The list of block names to link to. There can be a port name or port index appended separated by a colon."/>
                </function>
                <function name="save">
                    <desc>Saves the current flow configuration as flow file to the specified file path</desc>
                    <param name="handle" type="handle" alias="Flow" desc="The instance to use"/>
                    <param name="filePath" type="string" desc="The file path to save the flow to."/>
                    <return name="success" type="bool" desc="True if successfully saved to the file."/>
                </function>
                <function name="load">
                    <desc>Loads a flow configuration from the specified file-path.
Always clears the existing configuration.</desc>
                    <param name="handle" type="handle" alias="Flow" desc="The instance to use"/>
                    <param name="filePath" type="string" desc="The file path to load the flow from."/>
                    <return name="success" type="bool" desc="True if successfully loaded to the file."/>
                </function>
                <function name="start">
                    <desc>Starts the flow with the current configuration.
If the flow is already running it is stopped first.
The flow doesn't run if there was any warning during building up the flow and the function returns false.
See warning logs for more info what went wrong.
Possible problems to start a flow:
- A block cannot be created because the mapped API function/event does not exist or the handle for it cannot be created.
- A link cannot be established, e.g. possibly due to invalid block port names.</desc>
                    <param name="handle" type="handle" alias="Flow" desc="The instance to use"/>
                    <return name="success" type="bool" desc="True if successfully started the flow"/>
                </function>
                <function name="stop">
                    <desc>Stops the current running flow and release all internal data and references.</desc>
                    <param name="handle" type="handle" alias="Flow" desc="The instance to use"/>
                </function>
            </serves>
        </crown>
        <crown name="LED">
            <trait>released</trait>
            <desc>Access to the LEDs of the device to change their mode.
Can be used to activate or deactivate LEDs.
If LED support for colors might be possible, there is the function setColor which can be used to change the LED color.</desc>
            <serves>
                <function name="create">
                    <desc>Creates a handle for the LED if exists and not already in use.</desc>
                    <sample for="lua">handle = LED.create("LED_1")</sample>
                    <param name="ledName" type="enum" ref="LEDs" desc="The name of the LED to use"/>
                    <return name="handle" type="handle" multiplicity="?" alias="LED" desc="Unique handle for the LED. Nil if not available or already in use."/>
                </function>
                <function name="activate">
                    <desc>Sets the LED to active.
Some LEDs might deactivate theirself after a max. possible active time (e.g. 10 secs). This depends on the concrete LED.</desc>
                    <sample for="lua">LED.activate(handle)</sample>
                    <param name="handle" type="handle" alias="LED" desc="Unique handle to the LED"/>
                    <param name="activeTimeMs" type="int" multiplicity="?" desc="The time the LED is active. Per default stays active forever or might be deactivated after the max. possible active time of the LED (see concrete LED documentation)"/>
                </function>
                <function name="deactivate">
                    <desc>Sets the LED to inactive.</desc>
                    <sample for="lua">LED.deactivate(handle)</sample>
                    <param name="handle" type="handle" alias="LED" desc="Unique handle to the LED"/>
                </function>
                <function name="blink">
                    <desc>Sets the LED to blinking mode so that it is automatically set to active and inactive for the specified times.</desc>
                    <sample for="lua">LED.blink(handle, 600, 300)</sample>
                    <param name="handle" type="handle" alias="LED" desc="Unique handle of the LED"/>
                    <param name="pulsTimeMs" type="int" desc="The time the LED is active"/>
                    <param name="pauseTimeMs" type="int" multiplicity="?" desc="The time the LED is inactive. If not specified, the pulseTimeMs is also used as pauseTimeMs."/>
                </function>
                <function name="setColor">
                    <desc>If the LED supports multiple colors it could be set here.
If LED is already activated, the color is switched directly.
Default is set all to full color (white or the only color the LED supports).
The possible colors of the LED could be get known from the device manual.</desc>
                    <sample for="lua">by name: LED.setColor(handle, "red")
by RGB value: LED.setColor(handle, {255,0,0} )
by RGB state: LED.setColor(handle, {true,false,false} )</sample>
                    <param name="handle" type="handle" alias="LED" desc="Unique handle of the LED"/>
                    <param name="color" type="auto" multiplicity="[1+]" desc="Flexible parameter to set the color. Could be a name of a color, a single int RGB value (e.g. 0x123456) or a vector of three ints for each part of the RGB value."/>
                </function>
            </serves>
        </crown>
        <crown name="File">
            <trait>released</trait>
            <desc>Provides file operation functions.
The application has access to different folders on the filesystem of the device.

There are the following app related paths:
- The "resources" folder is read-only and can be used to read app resources like parameter files, images etc.
- The "private" directory can be used to store persistent app data privately. This data is backup-ed with together with the app.
- The "public" directory can be used for shared access with other applications. All applications have access to this folder.

The "private" and "public" folders should only be used as persistent storage and NOT to continuously process data.
ATTENTION: The underlying hardware could get broken if overused!
Consider to use API functions which don't use files or use the ram filesystem mounted drive of the device.

Additionally it is possible to access the mounted drives of a device.
Which mounted drives are available is defined by the device in a CROWN enum named "MountedDrives".
E.g. there could be a path "/usb/0" for the first USB drive, or "/sdcard/0" for the first SD Card drive.</desc>
            <serves>
                <function name="open">
                    <desc>Opens a file specified by a path and mode.

The path must start with "resources", "public", "private" or with a mounted drive name like "ram", "usb" or "sdcard" (depends on the "MountedDrives" enum of the device).

The mode specifies if it is for reading or writing and if it is in ASCII or binary mode (standard POSIX modes).
The file is created if it does not exist and is opened for writing.

Returns a handle if successful, which needs to be used for further file functions.

Open for reading might fail if the file does not exist or is already opened for writing.
Open for writing might fail if the file is already opened for reading or writing, or if the "resources" folder is opened for writing (which is read-only).</desc>
                    <sample for="lua">local handle = File.open("/private/myfile.txt", "wb")</sample>
                    <param name="filePath" type="string" desc="The path to the file that is to be opened"/>
                    <param name="mode" type="string" desc="Use &quot;r&quot; or &quot;rb&quot; for reading, &quot;w&quot; or &quot;wb&quot; for writing, &quot;a&quot; or &quot;ab&quot; for append; &quot;b&quot; means binary, without &quot;b&quot; the OS could change control characters like CR or LF. Same syntax like in C fopen()"/>
                    <return name="handle" type="handle" multiplicity="?" alias="File" desc="An indicator for accessing the file. Is nil if failed. See File CROWN description for error info."/>
                </function>
                <function name="close">
                    <desc>Closes a file identified by a handle.
If not explicitly called, the file is automatically closed on destruction of the handle.</desc>
                    <sample for="lua">File.close(handle)</sample>
                    <param name="handle" type="handle" alias="File" desc="The filehandle of an opened file."/>
                </function>
                <function name="getPath">
                    <desc>Returns the path of the file handle with which it was opened.</desc>
                    <sample for="lua">local path = File.getPath(handle)</sample>
                    <param name="handle" type="handle" alias="File" desc="The filehandle of an opened file."/>
                    <return name="filePath" type="string" multiplicity="?" desc="The path to the file that was opened. Nil if file handle is not open."/>
                </function>
                <function name="write">
                    <desc>Writes to a file identified by a handle.</desc>
                    <sample for="lua">local success = File.write(handle, "Hello")</sample>
                    <param name="handle" type="handle" alias="File" desc="The filehandle of an opened file."/>
                    <param name="data" type="binary" desc="The data to write into the file"/>
                    <return name="success" type="bool" desc="True if the data was successfully written to the file."/>
                </function>
                <function name="read">
                    <desc>Reads data from a file identified by a handle.
The number of bytes to read can be specified.
Continuous calls to read continue to read at the current position.
If a read returns a binary of size 0, then there is no more data to read.</desc>
                    <sample for="lua">local data = File.read(handle, length)</sample>
                    <param name="handle" type="handle" alias="File" desc="The filehandle of an opened file."/>
                    <param name="length" type="int" multiplicity="?" desc="The number of bytes to read. Read the whole file if not specified or zero."/>
                    <return name="data" type="binary" multiplicity="?" desc="The data which was read from the file. Is nil if the file isn't opened. Binary size is 0 if there is nothing more to read."/>
                </function>
                <function name="seek">
                    <desc>Places the file pointer at the specified position.
The next read will start at this position.</desc>
                    <sample for="lua">local success = File.seek(handle, 15)</sample>
                    <param name="handle" type="handle" alias="File" desc="The filehandle of an opened file."/>
                    <param name="position" type="int" desc="The position to jump to in the file."/>
                    <return name="success" type="bool" desc="True if seeking in the file was successful."/>
                </function>
                <function name="position">
                    <desc>Returns the current position of the file pointer.</desc>
                    <sample for="lua">local position = File.position(handle)</sample>
                    <param name="handle" type="handle" alias="File" desc="The filehandle of an opened file."/>
                    <return name="position" type="int" desc="The current position of the file pointer."/>
                </function>
                <function name="exists">
                    <desc>Checks if the given path or file exists.
The path must start with "resources", "public", "private" or with a mounted drive name like "ram", "usb" or "sdcard" (depends on the "MountedDrives" enum of the device).</desc>
                    <sample for="lua">local bExists = File.exists("/private/myfile.txt")</sample>
                    <param name="fileName" type="string" desc="The path to the file/folder that is to be checked"/>
                    <return name="result" type="bool" desc="true if success"/>
                </function>
                <function name="mkdir">
                    <desc>Creates a new folder specified by a path.
The path must start with "public", "private" or with a mounted drive name like "ram", "usb" or "sdcard" (depends on the "MountedDrives" enum of the device).</desc>
                    <sample for="lua">local success = File.mkdir("/private/myfolder")</sample>
                    <param name="fileName" type="string" desc="The path to the folder that is to be created"/>
                    <return name="success" type="bool" desc="true if success or already exists. false if not possible or is already a file."/>
                </function>
                <function name="del">
                    <desc>Deletes a file or folder specified by a path.
The path must start with "public", "private" or with a mounted drive name like "ram", "usb" or "sdcard" (depends on the "MountedDrives" enum of the device).
Deleting the "public", "private" or mounted drive itself is not allowed and returns false. Their contents can be deleted by iterating on their elements.</desc>
                    <sample for="lua">local success = File.del("/private/myfile.txt")</sample>
                    <param name="fileName" type="string" desc="The path to the file/folder that is to be deleted"/>
                    <return name="success" type="bool" desc="true if success"/>
                </function>
                <function name="isdir">
                    <desc>Checks if the given path is a folder.
The path must start with "resources", "public", "private"or with a mounted drive name like "ram", "usb" or "sdcard" (depends on the "MountedDrives" enum of the device).</desc>
                    <sample for="lua">local isDir = File.isdir("/private/myfile.txt")</sample>
                    <param name="fileName" type="string" desc="The path to the file/folder that is to be deleted"/>
                    <return name="result" type="bool" desc="true if success"/>
                </function>
                <function name="size">
                    <desc>Returns the size of a file.
The path must start with "resources", "public", "private" or with a mounted drive name like "ram", "usb" or "sdcard" (depends on the "MountedDrives" enum of the device).</desc>
                    <sample for="lua">local fileSize = File.size("/private/myfile.txt")</sample>
                    <param name="fileName" type="string" desc="The path to the file"/>
                    <return name="fileSize" type="int" desc="size of file"/>
                </function>
                <function name="list">
                    <desc>Lists all files and subdirectories in the specified directory non-recursively.
The path must start with "resources", "public", "private" or with a mounted drive name like "ram", "usb" or "sdcard" (depends on the "MountedDrives" enum of the device).
Returns a list of file and directory names in the specified path.</desc>
                    <sample for="lua">local fileList = File.list("/private/", "*.png")</sample>
                    <param name="filePath" type="string" desc="The path to the folder to list"/>
                    <param name="filter" type="string" multiplicity="?" desc="A string to filter the results of the listing. Wildcards can be used."/>
                    <return name="list" type="string" multiplicity="*" desc="The list of file and directory names. Nil if specified filePath does not exist or is not a directory."/>
                </function>
                <function name="listRecursive">
                    <desc>Lists all files and subdirectories in the specified directory recursively (without empty folders).
The path must start with "resources", "public", "private" or with a mounted drive name like "ram", "usb" or "sdcard" (depends on the "MountedDrives" enum of the device).
Returns a list of file and directory names in the specified path.</desc>
                    <sample for="lua">local fileList = File.listRecursive("/private/")</sample>
                    <param name="filePath" type="string" desc="The path to the folder to list"/>
                    <return name="list" type="string" multiplicity="*" desc="The list of file and directory names including the relative path to the specified directory. Nil if specified filePath does not exist or is not a directory."/>
                </function>
                <function name="copy">
                    <desc>Copies the specified file or full path to another file or path.
If the target file exists it is overwritten.
If the target path exists it is integrated in the target structure.</desc>
                    <sample for="lua">local success = File.copy("/private/sourcefile.txt", "/private/targetfile.txt")</sample>
                    <param name="fileSourcePath" type="string" desc="The path to copy from"/>
                    <param name="fileTargetPath" type="string" desc="The path to copy to"/>
                    <return name="success" type="bool" desc="True if successful, false if source path does not exist or cannot overwrite new files."/>
                </function>
                <function name="move">
                    <desc>Moves the specified file or full path to another file or path.
If the target file exists it is overwritten.
If the target path exists it is integrated in the target structure.
If moving fails, parts of the source path may still exist, and the target path may be inconsistent or incomplete.</desc>
                    <sample for="lua">local success = File.move("/private/sourcefile.txt", "/private/targetfile.txt")</sample>
                    <param name="fileSourcePath" type="string" desc="The path to move from"/>
                    <param name="fileTargetPath" type="string" desc="The path to move to"/>
                    <return name="success" type="bool" desc="true if success. false if source path does not exist or cannot overwrite new files."/>
                </function>
                <function name="extractPathElements">
                    <desc>Splits the specified path string into its elements path, file basename and file extension.</desc>
                    <sample for="lua">local path, basename, extension = File.extractPathElements("/private/thefile.txt")</sample>
                    <param name="filePath" type="string" desc="The path string to extract from"/>
                    <return name="path" type="string" desc="The path of the file"/>
                    <return name="basename" type="string" desc="The base name of the file"/>
                    <return name="extension" type="string" desc="The file extension of the file"/>
                </function>
                <function name="getDiskUsage">
                    <desc>Returns the usage of a specific path.</desc>
                    <sample for="lua">local usage = File.getDiskUsage("/public")</sample>
                    <param name="path" type="string" desc="The path to get the usage from."/>
                    <return name="usedBytes" type="int" multiplicity="?" desc="The bytes used in the path."/>
                </function>
                <function name="getDiskFree">
                    <desc>Returns the remaining space of a specific path.</desc>
                    <sample for="lua">local free = File.getDiskFree("/public")</sample>
                    <param name="path" type="string" desc="The name of the path to get the free space from."/>
                    <return name="freeBytes" type="int" multiplicity="?" desc="The available bytes in the path."/>
                </function>
            </serves>
            <crown name="Archive">
                <trait>released</trait>
                <desc>Contains functionality to pack/unpack files as an archive.</desc>
                <crown name="ZIP">
                    <trait>released</trait>
                    <desc>File Archive functionality to work with ZIP files.
An archiver instance works with one ZIP archive at a time. To handle multiple ZIPs at a time, create multiple instances of the archiver.
Loaded or added files must exist and are kept locked by this API until the handle is destroyed or close function is called.
Both inflated and deflated ZIP archives can be read. ZIP file writing supports only inflated archives.</desc>
                    <enum name="Compression">
                        <item name="Store only, no compression">STORE</item>
                        <item name="Fastest compression">FAST</item>
                        <item name="Default compression">DEFAULT</item>
                        <item name="Best compression, slowest">BEST</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <desc>Creates a new ZIP archive instance to work on archives.</desc>
                            <sample for="lua">local handle = File.Archive.ZIP.create()</sample>
                            <return name="handle" type="handle" alias="File.Archive.ZIP" desc="The instance handle for the ZIP archiver"/>
                        </function>
                        <function name="load">
                            <desc>Loads a zip archive from the specified file.
The loaded file keeps locked until this class loads another zip file or close function is called.
If loading fails a previously loaded zip file state is cleared.</desc>
                            <sample for="lua">local success = File.Archive.ZIP.load(handle, "/private/load.zip")</sample>
                            <param name="handle" type="handle" alias="File.Archive.ZIP" desc="The instance handle for the ZIP archiver"/>
                            <param name="sourceFilePath" type="string" desc="The path to the zip file that is to be loaded. E.g. '/private/load.zip'"/>
                            <return name="success" type="bool" desc="True if successfully loaded the zip. False if file does not exist or is no zip file"/>
                        </function>
                        <function name="save">
                            <desc>Saves the current zip file state to the specified file path.
Any existing file is overwritten.</desc>
                            <sample for="lua">local success = File.Archive.ZIP.save(handle, "/private/save.zip")</sample>
                            <param name="handle" type="handle" alias="File.Archive.ZIP" desc="The instance handle for the ZIP archiver"/>
                            <param name="targetFilePath" type="string" desc="The path to which the zip file is saved. E.g. '/private/save.zip'"/>
                            <return name="success" type="bool" desc="True if successfully saved the zip file to the filesystem"/>
                        </function>
                        <function name="deserialize">
                            <desc>Loads a zip archive from the specified binary buffer.
This is useful if zip file is already present in memory so that it does not need to be stored to file to load it.
E.g. if the zip file content is directly received from a TCPIP client or similar.</desc>
                            <sample for="lua">local success = File.Archive.ZIP.deserialize(handle, buffer)</sample>
                            <param name="handle" type="handle" alias="File.Archive.ZIP" desc="The instance handle for the ZIP archiver"/>
                            <param name="archiveBuffer" type="binary" desc="The binary buffer containing the whole archive."/>
                            <return name="success" type="bool" desc="True if successfully loaded the zip. False if the buffer content is not valid or no zip file."/>
                        </function>
                        <function name="serialize">
                            <desc>Returns the current zip file state as content of a binary buffer.
This is useful if the zip file needs to be in memory so that it could be directly used for further processing.
E.g. if the zip file content is directly sent to TCPIP client or similar.</desc>
                            <sample for="lua">local buffer = File.Archive.ZIP.serialize(handle)</sample>
                            <param name="handle" type="handle" alias="File.Archive.ZIP" desc="The instance handle for the ZIP archiver"/>
                            <return name="archiveBuffer" type="binary" desc="The binary buffer containing the whole archive. The buffer could be empty on error."/>
                        </function>
                        <function name="add">
                            <desc>Adds a file or whole directory from the filesystem to the archive.
The specified file needs to exist and is locked until this class loads another zip file or close function is called.
If there is already a file or folder with that archive path, it is overwritten.</desc>
                            <sample for="lua">local success = File.Archive.ZIP.add(handle, "/private/sourceFile.txt", "archiveFolder/archiveFile.txt")</sample>
                            <param name="handle" type="handle" alias="File.Archive.ZIP" desc="The instance handle for the ZIP archiver"/>
                            <param name="sourceFilePath" type="string" desc="The path to the file or directory which should be added. E.g. '/private/sourceFile.txt'"/>
                            <param name="archiveFilePath" type="string" desc="The path in the archive to which the file or directory should be added. Must be a full file path including file name. Sub-directories are created automatically. Existing file is overwritten. Leave empty to add to root directory of the archive. E.g. 'archiveFolder/archiveFile.txt'"/>
                            <return name="success" type="bool" desc="True if successfully added the file. False if the file does not exist."/>
                        </function>
                        <function name="extract">
                            <desc>Extracts a file from the archive to the filesystem.</desc>
                            <sample for="lua">local success = File.Archive.ZIP.extract(handle, "archiveFolder/archiveFile.txt", "/private/targetFile.txt")</sample>
                            <param name="handle" type="handle" alias="File.Archive.ZIP" desc="The instance handle for the ZIP archiver"/>
                            <param name="archiveFilePath" type="string" desc="The path in the archive from which the file or directory should be extracted. E.g. 'archiveFolder/archiveFile.txt'. Leave empty to extract whole archive."/>
                            <param name="targetFilePath" type="string" desc="The path to the file or directory which should be extracted to. Sub-directories are created automatically. E.g. '/private/targetFile.txt'"/>
                            <return name="success" type="bool" desc="True if successfully extracted the file. False if the file does not exist or could not extracted to the target path or password does not work on the file."/>
                        </function>
                        <function name="write">
                            <desc>Adds a single file from the specified binary buffer.
This is useful if the file is already present in memory so that it does not need to be stored to a file to add it. E.g. if the zip file is directly received from a TCPIP client or similar.
If there is already a file or folder with that archive path, it is overwritten.</desc>
                            <sample for="lua">local success = File.Archive.ZIP.write(handle, buffer, "archiveFolder/archiveFile.txt")</sample>
                            <param name="handle" type="handle" alias="File.Archive.ZIP" desc="The instance handle for the ZIP archiver"/>
                            <param name="fileBuffer" type="binary" desc="The binary buffer containing the zip file."/>
                            <param name="archiveFilePath" type="string" desc="The path in the archive to which the file or directory should be added. Must be a full file path including file name. Sub-directories are created automatically. Existing file is overwritten. E.g. 'archiveFolder/archiveFile.txt'"/>
                            <return name="success" type="bool" desc="True if successfully added the file."/>
                        </function>
                        <function name="read">
                            <desc>Extracts a single file from the archive and returns it as binary buffer.
This is useful if the file needs to be in memory so that it could be directly used for further processing.
E.g. if the zip file is directly sent to TCPIP client or similar.</desc>
                            <sample for="lua">local buffer = File.Archive.ZIP.read(handle, "archiveFolder/archiveFile.txt")</sample>
                            <param name="handle" type="handle" alias="File.Archive.ZIP" desc="The instance handle for the ZIP archiver"/>
                            <param name="archiveFilePath" type="string" desc="The path in the archive from which the file or directory should be extracted. E.g. 'archiveFolder/archiveFile.txt'"/>
                            <return name="fileBuffer" type="binary" multiplicity="?" desc="The binary buffer containing the zip file. Nil on error if file does not exist or password does not work on the file."/>
                        </function>
                        <function name="del">
                            <desc>Deletes a file or whole directory (including added files all sub-directories) from the archive.
If the archive is afterwards saved or serialized, the specified archive path will not be part of it.</desc>
                            <sample for="lua">local success = File.Archive.ZIP.del(handle, "archiveFolder/archiveFile.txt")</sample>
                            <param name="handle" type="handle" alias="File.Archive.ZIP" desc="The instance handle for the ZIP archiver"/>
                            <param name="archiveFilePath" type="string" desc="The path in the archive which should be deleted. E.g. 'archiveFolder/archiveFile.txt'"/>
                            <return name="success" type="bool" desc="True if successfully deleted the file or folder. False if there was nothing found in the archive path to delete."/>
                        </function>
                        <function name="mkdir">
                            <desc>Creates an empty folder.
If there is already a file or folder with that archive path, it is overwritten.
Remember that files to be added don't need a folder to be created first, so this function is only if there should be an empty folder in the archive.
If it is a sub path, it creates the whole folder.</desc>
                            <sample for="lua">local success = File.Archive.ZIP.mkdir(handle, "archiveFolder/newFolder")</sample>
                            <param name="handle" type="handle" alias="File.Archive.ZIP" desc="The instance handle for the ZIP archiver"/>
                            <param name="archiveFilePath" type="string" desc="The path in the archive which should be created as folder. E.g. 'archiveFolder/newFolder'"/>
                            <return name="success" type="bool" desc="True if successfully created the new folder."/>
                        </function>
                        <function name="list">
                            <desc>Lists the content from the current loaded archive.
The paths are relative and therefore don't start with a leading "/".</desc>
                            <sample for="lua">local fileList = File.Archive.ZIP.list(handle)</sample>
                            <param name="handle" type="handle" alias="File.Archive.ZIP" desc="The instance handle for the ZIP archiver"/>
                            <return name="content" type="string" multiplicity="+" desc="List of file paths in the current loaded archive"/>
                        </function>
                        <function name="setCompression">
                            <desc>Sets the compression level to use for adding/writing new files to the archive.
The deflate compression method is used.
If not called, the default level is just to store the files without compression.
The function can be called between add/write calls to change the compression level used for files. If not called before the last set value is used implicitly.
Files, which are loaded from an existing archive, keep their compression and cannot be changed (Need to be removed and added again).</desc>
                            <sample for="lua">File.Archive.ZIP.setCompression(handle, "BEST")</sample>
                            <param name="handle" type="handle" alias="File.Archive.ZIP" desc="The instance handle for the ZIP archiver"/>
                            <param name="complevel" type="enum" ref="Compression" desc="The level used for compression"/>
                        </function>
                        <function name="setPassword">
                            <desc>Sets the password used for decryption/encryption during accessing and writing the archive. Only the load/save and deserialize/serialize functions use the current set password.
If not called, there is no password used.
The password is globally set for all operations for the whole archive content.
It is NOT possible to set passwords per file. Also if the to be loaded file uses different passwords per file, it currently isn't possible to be loaded.</desc>
                            <sample for="lua">File.Archive.ZIP.setPassword(handle, "mypassword")</sample>
                            <param name="handle" type="handle" alias="File.Archive.ZIP" desc="The instance handle for the ZIP archiver"/>
                            <param name="password" type="string" desc="Sets the password used for accessing and writing the archive. If empty, not password is used."/>
                        </function>
                        <function name="setComment">
                            <desc>Sets the global archive comment text used for saving/serializing the archive.</desc>
                            <param name="handle" type="handle" alias="File.Archive.ZIP" desc="The instance handle for the ZIP archiver"/>
                            <param name="comment" type="string" desc="The comment text which is set on the archive"/>
                        </function>
                        <function name="getComment">
                            <desc>If an archive is loaded, return the current comment set on the loaded archive.
If the setComment function was used, it still returns the comment of the loaded archive and not the one which is newly set.</desc>
                            <param name="handle" type="handle" alias="File.Archive.ZIP" desc="The instance handle for the ZIP archiver"/>
                            <return name="comment" type="string" multiplicity="?" desc="The comment text is set on the loaded archive. Nil if there is no loaded archive."/>
                        </function>
                        <function name="test">
                            <desc>Fully tests and verifies the currently loaded archive. Needs some time and fully reads the file.
1. Tests if the set password works with all files
2. Reads all content and verifies their CRC32 checksums
3. Verifies the file infos and the central directory</desc>
                            <param name="handle" type="handle" alias="File.Archive.ZIP" desc="The instance handle for the ZIP archiver"/>
                            <return name="valid" type="bool" multiplicity="?" desc="True if the archive is valid. False if one validation step has failed or no archive is loaded."/>
                        </function>
                    </serves>
                </crown>
            </crown>
            <crown name="StorageDevice">
                <trait>released</trait>
                <desc>Manage storage devices and mountpoints on Linux-based devices.</desc>
                <enum name="PartitionType">
                    <desc>Supported partition types</desc>
                    <item name="Unknown" desc="Unknown partition type">UNKNOWN</item>
                    <item name="Linux" desc="Partition type 83">LINUX</item>
                    <item name="Windows" desc="Partition type 11">WINDOWS</item>
                </enum>
                <enum name="FileSystemType">
                    <desc>Supported filesystem types</desc>
                    <item name="ext3" desc="ext3 filesystem">FS_EXT3</item>
                    <item name="FAT32" desc="FAT32 filesystem">FS_FAT32</item>
                </enum>
                <enum name="ErrorReason">
                    <desc>Supported error reasons returned by GetLastError()</desc>
                    <item name="errSuccess" desc="No error">SUCCESS</item>
                    <item name="errParamError" desc="Invalid parameter value">PARAM_ERROR</item>
                    <item name="errPartitionMounted" desc="Partition is already mounted">PARTITION_MOUNTED</item>
                    <item name="errGenericSystemError" desc="Generic error of operating system calls">GENERIC_SYSTEM_ERROR</item>
                    <item name="errDeviceNotPresent" desc="Storage device is not present">DEVICE_NOT_PRESENT</item>
                    <item name="errInternal" desc="Internal error of the file system management API">INTERNAL</item>
                </enum>
                <serves>
                    <event name="OnPlugged">
                        <desc>Event that is notified when the removable device is plugged</desc>
                        <param name="handle" type="handle" alias="File.StorageDevice" desc="The instance handle for the storage device"/>
                    </event>
                    <event name="OnUnplugged">
                        <desc>Event that is notified when the removable device is unplugged</desc>
                        <param name="handle" type="handle" alias="File.StorageDevice" desc="The instance handle for the storage device"/>
                    </event>
                    <function name="register">
                        <desc>This function is used to register for any event of the handle.</desc>
                        <param name="handle" type="handle" alias="File.StorageDevice" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to register to"/>
                        <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                        <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                    </function>
                    <function name="deregister">
                        <desc>This function is used to deregister from any registered event of the handle.</desc>
                        <param name="handle" type="handle" alias="File.StorageDevice" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to deregister from"/>
                        <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                        <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                    </function>
                    <function name="create">
                        <desc>Create a handle referencing the given storage device. If the ID is unknown (i.e. not in the list of supported IDs for the device), nil is returned. Handles to storage devices can be created no matter if the device is currently present or not.</desc>
                        <sample for="lua">handle = StorageDevice.create('SDCARD0')</sample>
                        <param name="deviceId" type="enum" ref="StorageDevices" desc="Device ID as specified in the device manifest"/>
                        <return name="handle" type="handle" multiplicity="?" alias="File.StorageDevice" desc="Handle to the storage device"/>
                    </function>
                    <function name="getVendor">
                        <desc>Return the vendor of the storage device</desc>
                        <sample for="lua">vendor = File.StorageDevice.getVendor(handle)</sample>
                        <param name="handle" type="handle" alias="File.StorageDevice" desc="The instance handle for the storage device"/>
                        <return name="success" type="bool" desc="Success of the function call. For more information use getLastError()"/>
                        <return name="vendor" type="string" multiplicity="?" desc="Vendor of device. In case of failure nil"/>
                    </function>
                    <function name="getID">
                        <desc>Return the unique ID of the storage device</desc>
                        <sample for="lua">deviceID = File.StorageDevice.getID(handle)</sample>
                        <param name="handle" type="handle" alias="File.StorageDevice" desc="The instance handle for the storage device"/>
                        <return name="success" type="bool" desc="Success of the function call. For more information use getLastError()"/>
                        <return name="deviceId" type="enum" multiplicity="?" ref="StorageDevices" desc="Unique identification of device. In case of failure nil"/>
                    </function>
                    <function name="getSize">
                        <desc>Return the size of the storage device in MB</desc>
                        <sample for="lua">size = File.StorageDevice.getSize(handle)</sample>
                        <param name="handle" type="handle" alias="File.StorageDevice" desc="The instance handle for the storage device"/>
                        <return name="success" type="bool" desc="Success of the function call. For more information use getLastError()"/>
                        <return name="size" type="int" multiplicity="?" desc="Size in MB. In case of failure nil"/>
                    </function>
                    <function name="isRemovable">
                        <desc>Return whether the storage device is removable</desc>
                        <sample for="lua">storageCanBeRemoved = File.StorageDevice.isRemovable(handle)</sample>
                        <param name="handle" type="handle" alias="File.StorageDevice" desc="The instance handle for the storage device"/>
                        <return name="isRemovable" type="bool" desc="True for removable storage devices"/>
                    </function>
                    <function name="isPresent">
                        <desc>Return whether the storage device is present. For removable devices this is true if they are plugged in</desc>
                        <sample for="lua">storageAccessible = File.StorageDevice.isPresent(handle)</sample>
                        <param name="handle" type="handle" alias="File.StorageDevice" desc="The instance handle for the storage device"/>
                        <return name="isAccessible" type="bool" desc="True if the device is present/plugged in, false if not."/>
                    </function>
                    <function name="getPartitionList">
                        <desc>Return all paritions of the given device.</desc>
                        <sample for="lua">
deviceID = 'SDCARD0'
handle = StorageDevice.create(deviceID)
print('Device has following partitions:')
for index, partitionNum in ipairs(File.StorageDevice.getPartitionList(handle)) do
  print(' Partition:', partitionNum) 
end
            </sample>
                        <param name="handle" type="handle" alias="File.StorageDevice" desc="The instance handle for the storage device"/>
                        <return name="success" type="bool" desc="Success of partition creation. For more information use getLastError()"/>
                        <return name="partitionNumber" type="int" multiplicity="+" desc="Return list of partition numbers"/>
                    </function>
                    <function name="getPartitionDescription">
                        <desc>Return offset, size and the type of the given partition. For a invalid partitionNumber, Nil is returned for offset, size and partitionType</desc>
                        <sample for="lua">success, offset, size, partitionType = File.StorageDevice.getPartitionDescription(handle, 2)</sample>
                        <param name="handle" type="handle" alias="File.StorageDevice" desc="The instance handle for the storage device"/>
                        <param name="partitionNumber" type="int" desc="Identification of the partition"/>
                        <return name="success" type="bool" desc="Success of the function call. For more information use getLastError()"/>
                        <return name="offset" type="int" multiplicity="?" desc="offset of partition start in byte"/>
                        <return name="size" type="int" multiplicity="?" desc="size of partition in byte"/>
                        <return name="partitionType" type="enum" multiplicity="?" ref="PartitionType" desc="Type of partition"/>
                    </function>
                    <function name="addPartition">
                        <desc>Add a partition. The returned partition number is the first free partition number. Only four primary partitions are supported.</desc>
                        <sample for="lua">success, partitionNumber = File.StorageDevice.addPartition(handle, 300, 500, 'LINUX')</sample>
                        <param name="handle" type="handle" alias="File.StorageDevice" desc="The instance handle for the storage device"/>
                        <param name="offsetMb" type="int" desc="Offset of the partition in MB"/>
                        <param name="sizeMb" type="int" desc="Size of the partition in MB"/>
                        <param name="partitionType" type="enum" ref="PartitionType" desc="Type of the partition"/>
                        <return name="success" type="bool" desc="Success of partition creation. For more information use getLastError()"/>
                        <return name="partitionNumber" type="int" multiplicity="?" desc="The number of the created partition. In case of a error Nil is returned"/>
                    </function>
                    <function name="formatPartition">
                        <desc>Format a partition. Returns when formatting is finished. Use Engine.AsyncFunction to run formatting asynchronous</desc>
                        <sample for="lua">
local formatAsync = Engine.AsyncFunction.create()
formatAsync:setFunction('File.StorageDevice.formatPartition')
-- Start formatting
future = formatAsync:launch(handle, 2, "FS_EXT3")
-- Wait for the asyc function to finish 
success = future:wait()
            </sample>
                        <param name="handle" type="handle" alias="File.StorageDevice" desc="The instance handle for the storage device"/>
                        <param name="partitionNumber" type="int" desc="Partition that is used"/>
                        <param name="filesystemtype" type="enum" ref="FileSystemType" desc="type of filesystem to format with"/>
                        <return name="success" type="bool" desc="True if the operation finished successfully. For more information use getLastError()"/>
                    </function>
                    <function name="checkPartition">
                        <desc>Check the given partition. The typ of the file system is determined automatically. Returns when the check has finished. Use Engine.AsyncFunction to run the check asynchronous</desc>
                        <sample for="lua">
local checkAsync = Engine.AsyncFunction.create()
checkAsync:setFunction('File.StorageDevice.checkPartition')
-- Start checking
future = checkAsync:launch(handle, 2)
-- Wait for the asyc function to finish 
success, errorText = future:wait()            
            </sample>
                        <param name="handle" type="handle" alias="File.StorageDevice" desc="The instance handle for the storage device"/>
                        <param name="partitionNumber" type="int" desc="Partition that is used"/>
                        <return name="success" type="bool" desc="True if the operation finished successfully. For more information use getLastError()"/>
                        <return name="resultCode" type="int" desc="The result code returned by the check operation"/>
                    </function>
                    <function name="repairPartition">
                        <desc>Repair the given partition. The typ of the file system is determined automatically. Returns when repairing has finished. Use Engine.AsyncFunction to run repairing asynchronous</desc>
                        <sample for="lua">
local repairAsync = Engine.AsyncFunction.create()
repairAsync:setFunction('File.StorageDevice.repairPartition')
-- Start repairing
future = repairAsync:launch(handle, 2)
-- Wait for the asyc function to finish 
success = future:wait()            
            </sample>
                        <param name="handle" type="handle" alias="File.StorageDevice" desc="The instance handle for the storage device"/>
                        <param name="partitionNumber" type="int" desc="Partition that is used"/>
                        <return name="success" type="bool" desc="True if the operation finished successfully. For more information use getLastError()"/>
                        <return name="resultCode" type="int" desc="The result code returned by the check operation"/>
                    </function>
                    <function name="deletePartition">
                        <desc>Delete the given partition and mark as free space.</desc>
                        <sample for="lua">success = File.StorageDevice.deletePartition(handle, 2)</sample>
                        <param name="handle" type="handle" alias="File.StorageDevice" desc="The instance handle for the storage device"/>
                        <param name="partitionNumber" type="int" desc="Partition that is used"/>
                        <return name="success" type="bool" desc="Success whether the operation could be performed. For more information use getLastError()"/>
                    </function>
                    <function name="getLastError">
                        <desc>Returns the reason of the on the last error</desc>
                        <sample for="lua">errorReason = File.StorageDevice.getLastError(handle)</sample>
                        <param name="handle" type="handle" alias="File.StorageDevice" desc="The instance handle for the storage device"/>
                        <return name="errorReason" type="enum" ref="ErrorReason" desc="Reason of the last occured error"/>
                    </function>
                    <function name="getLastErrorText">
                        <desc>Return textual information on the last error</desc>
                        <sample for="lua">errorText = File.StorageDevice.getLastErrorText(handle)</sample>
                        <param name="handle" type="handle" alias="File.StorageDevice" desc="The instance handle for the storage device"/>
                        <return name="errorText" type="string" multiplicity="?" desc="Text describing the last occured error"/>
                    </function>
                </serves>
            </crown>
            <crown name="MountPoint">
                <trait>released</trait>
                <desc>Mount OS filesystems into the App filesystem tree.</desc>
                <enum name="NetFsType" trait="hidden">
                    <desc>Defines the supported network file systems</desc>
                    <item name="cifs" desc="Common Internet File System. Earlier called SMB">CIFS</item>
                    <item name="nfs" desc="Network File System ">NFS</item>
                </enum>
                <serves>
                    <function name="create">
                        <desc>Create a handle for the given mountpoint. The mounted device will be automatically unmounted when this handle is destroyed.
In case the path to mount is invalid, Nil is returned</desc>
                        <sample for="lua">local handle = File.MountPoint.create('/public/storage')</sample>
                        <param name="path" type="string" desc="Path of mountpoint. Directory within the App file system, where to mount the file system."/>
                        <return name="handle" type="handle" multiplicity="?" alias="File.MountPoint" desc="The handle of the MountPoint instance"/>
                    </function>
                    <function name="mountLocal">
                        <desc>Mount the given partition of a local storage device. Detects the supported file system types automatically</desc>
                        <sample for="lua">success = File.MountPoint.mountLocal(handle, storageHandle, 2)</sample>
                        <param name="handle" type="handle" alias="File.MountPoint" desc="The handle of the MountPoint instance"/>
                        <param name="storageHandle" type="handle" alias="File.StorageDevice" desc="Handle of the StorageDevice"/>
                        <param name="partitionNumber" type="int" desc="Number of the partition to mount"/>
                        <return name="success" type="bool" desc="Success of mounting"/>
                    </function>
                    <function name="mountMemory">
                        <desc>Mount the given amount of memory as tempfs</desc>
                        <sample for="lua">success = File.MountPoint.mountMemory(handle, 100)</sample>
                        <param name="handle" type="handle" alias="File.MountPoint" desc="The handle of the MountPoint instance"/>
                        <param name="size" type="int" desc="Size in MB for memory"/>
                        <return name="success" type="bool" desc="Success of mounting"/>
                    </function>
                    <function name="mountNet">
                        <trait>hidden</trait>
                        <desc>Mount the given network resource</desc>
                        <sample for="lua">success = File.MountPoint.mountNet(handle, 'CIFS', '192.168.0.10', 'share')</sample>
                        <param name="handle" type="handle" alias="File.MountPoint" desc="The handle of the MountPoint instance"/>
                        <param name="type" type="enum" ref="NetFsType" desc="supported network file system"/>
                        <param name="host" type="string" desc="Host of the network resource"/>
                        <param name="directory" type="string" desc="Name of the share or directory"/>
                        <param name="user" type="string" multiplicity="?" desc="Name of the user if credentials are needed"/>
                        <param name="passwd" type="string" multiplicity="?" desc="Password of the user if credentials are needed"/>
                        <return name="success" type="bool" desc="Success of mounting"/>
                    </function>
                    <function name="unmount">
                        <desc>Remove the mounted filesystem of the App file system</desc>
                        <sample for="lua">success = File.MountPoint.unmount(handle)</sample>
                        <param name="handle" type="handle" alias="File.MountPoint" desc="The handle of the MountPoint instance"/>
                        <return name="success" type="bool" desc="Success of unmounting"/>
                    </function>
                    <function name="getLastError">
                        <desc>Returns the reason of the on the last error</desc>
                        <sample for="lua">errorReason = File.MountPoint.getLastError(handle)</sample>
                        <param name="handle" type="handle" alias="File.MountPoint" desc="The handle of the MountPoint instance"/>
                        <return name="errorReason" type="enum" ref="File.StorageDevice.ErrorReason" desc="Reason of the last occured error"/>
                    </function>
                    <function name="getLastErrorText">
                        <desc>Return textual information on the last error</desc>
                        <sample for="lua">errorText = File.MountPoint.getLastErrorText(handle)</sample>
                        <param name="handle" type="handle" alias="File.MountPoint" desc="The handle of the MountPoint instance"/>
                        <return name="errorText" type="string" multiplicity="?" desc="Text describing the last occured error"/>
                    </function>
                </serves>
            </crown>
        </crown>
        <crown name="Parameters">
            <trait>released</trait>
            <desc>Provides access to parameters of the current application and the device parameters.
This CROWN implements the AppSpace Parameters component. Read more about Parameters in the AppSpace documentation.
Parameters could be basic types (int, bool, ...) which can be accessed over "Parameters.get" and "Parameters.set" in this case.
Parameters could be complex types (array, struct, ...) which can be accessed over "Parameters.getNode" and "Parameters.setNode" in this case.
Complex parameters are represented as "Parameters.Node" object and can be accessed and navigated over its functions.</desc>
            <serves>
                <event name="OnParametersChanged">
                    <desc>This event is notified when the parameters of the application or the device might have changed.
There is no information if parameters are really changed or which parameters are changed.
This event might also be notified even when no parameters were changed at all.
The user has to read its parameters using the "Parameters.get" function and detect himself if it has changed.</desc>
                </event>
                <event name="OnParametersSaved">
                    <desc>This event is notified when the parameters were stored permanently.
A save permanent is triggered by the API function "Parameters.savePermanent" or over the command interface.</desc>
                </event>
                <event name="OnParametersLoaded">
                    <desc>This event is notified when the parameters were restored from permanent storage.
A load permanent is triggered by the API function "Parameters.loadPermanent" or over the command interface.</desc>
                </event>
                <event name="OnAllDefaultsLoaded">
                    <desc>This event is notified when the all parameter default values were loaded.
A all-defaults-loading can be triggered by the API function "Parameters.loadAllDefaults" and over the command interface.</desc>
                </event>
                <function name="get">
                    <desc>Returns the value of the specified parameter.
Please note that all parameter repositories of the device are considered, not only application parameters.
This function can also access just one leaf of a complex parameter by addressing over xPath syntax. The numbers used for array access are interpreted as hex-numbers.
If read fails function returns nothing.
It can fail if the parameter is not existing or it has a complex type.
If it has a complex type please use the "Parameters.getNode" function.</desc>
                    <sample for="lua">-- Usage possibilities:
local theParam = Parameters.get("LocationName") -- single string parameter get
local subValue = Parameters.get("MyParameter/subValue") -- get over xpath
local arrayValue = Parameters.get("MyArray[0]") -- get first array value</sample>
                    <param name="varName" type="string" desc="The name (not the communication name!) or path of the parameter to be read, if the parameter comes from generated code (SRT), the communication name must be used (and no path at all)."/>
                    <return name="varValue" type="auto" multiplicity="[?*]" desc="The value(s) of the parameter. Nil if parameter does not exist or type not possible. The type which is returned depends on the value of the parameter."/>
                </function>
                <function name="set">
                    <desc>Sets the value of the specified parameter.
Please note that all parameter repositories of the device are considered, not only application parameters.
This function can also access just one leaf of a complex parameter by addressing over xPath syntax. The numbers used for array access are interpreted as hex-numbers.
If set fails the function returns false.
Parameter values are directly updated and CoLa events are directly fired (also if the values are identical), but device parameters are not directly activated. Therefore if device parameters have been changed, the "Parameters.apply" function needs to be called so that they get active.</desc>
                    <sample for="lua">-- Usage possibilities:
local bSuccess = Parameters.set("LocationName", "Mydevice") -- set single string parameter value
local bSuccess = Parameters.set("MyParameter/memberString", "stringValue") -- set sub parameter value
local bSuccess = Parameters.set("MyArray[0]", 123) -- set first array value</sample>
                    <param name="varName" type="string" desc="The name (not the communication name!) or path of the parameter to be written, if the parameter comes from generated code (SRT), the communication name must be used (and no path at all)."/>
                    <param name="varValue" type="auto" multiplicity="[1+]" desc="The value(s) of the parameter."/>
                    <return name="success" type="bool" desc="True if successfully set. False if parameter does not exist or type does not match the parameter declaration"/>
                </function>
                <function name="getNode">
                    <desc>Returns a copy of the parameter as "Parameters.Node" to navigate in the parameter structure.
This function can also access just one leaf of a complex parameter by addressing over xPath syntax. The numbers used for array access are interpreted as hex-numbers.
The return object is a copy of the current parameter values. If it is changed, the "Parameters.setNode" function has to be called with the object.</desc>
                    <sample for="lua">-- Get a parameter node, get all member nodes of it and print how much nodes the parameter has:
local theNode = Parameters.getNode("MyComplexParameter")
local subNodes = Parameters.Node.getNode(theNode)
print("Number of subnodes in MyComplexParameter: " .. ##subNodes)</sample>
                    <param name="varName" type="string" desc="The name (and not the communicationa name!) or path of the parameter to be get"/>
                    <return name="nodeObjectCopy" type="object" multiplicity="?" alias="Parameters.Node" desc="The copy of the node object of the parameter or nil if parameter does not exist"/>
                </function>
                <function name="setNode">
                    <desc>Sets the value of the specified parameters as "Parameters.Node".
This function can also access just one leaf of a complex parameter by addressing over xPath syntax. The numbers used for array access are interpreted as hex-numbers.
The specified node content and structure has to match the parameter declaration. A matching node for a parameter can be get over "Parameters.getNode".
If set fails the function returns false.
Parameter values are directly updated and CoLa events are directly fired (also if the values are identical), but device parameters are not directly activated. Therefore if device parameters have been changed, the "Parameters.apply" function needs to be called so that they get active.</desc>
                    <sample for="lua">-- Get a parameter node, modify it and write the whole parameter:
local theNode = Parameters.getNode("MyComplexParameter")
Parameters.Node.set(theNode, "memberString", "stringValue")
Parameters.setNode("MyComplexParameter", theNode)</sample>
                    <param name="varName" type="string" desc="The name (and not the communicationa name!) or path of the parameter to be written"/>
                    <param name="nodeObject" type="const object" alias="Parameters.Node" desc="The node object with the new values. The node structure has to match the parameter"/>
                    <return name="success" type="bool" desc="True if successfully set. False if parameter does not exist or node structure does not match the parameter declaration"/>
                </function>
                <function name="apply">
                    <desc>Parameters of the device are not automatically activated when calling the Parameters.set/setNode function.
This function has to be called after using the "Parameters.set" or "Parameters.setNode" function so that they are applied on the device.
Please note that the parameters are not directly updated if this function returns.
The event "Parameters.OnParametersChanged" is triggered after calling this function when the parameters are updated to inform the device and other applications.</desc>
                    <sample for="lua">Parameters.apply()</sample>
                </function>
                <function name="savePermanent">
                    <desc>This function stores the current parameter values of all applications and the device permanently.
The values of the permanent stored parameters are automatically loaded on bootup of the device again.
This function blocks until the storing is done.</desc>
                    <sample for="lua">Parameters.savePermanent()</sample>
                </function>
                <function name="loadPermanent">
                    <desc>This function restores all current permanent stored values of all application and device parameters.
Per default a permanent load is done automatically on bootup of the device.
This function blocks until the restoring is done.
apply is called on the parameters, hence the restored values are set active at the parameters.</desc>
                    <sample for="lua">Parameters.loadPermanent()</sample>
                </function>
                <function name="loadAllDefaults">
                    <desc>Loads the default values of all parameters of the device.
It affects all parameters of all apps as well as the parameters of the device. Concretely this function sets all parameters to factory defaults.
This function does NOT do a save permanent.</desc>
                    <sample for="lua">Parameters.loadAllDefaults()</sample>
                </function>
                <function name="loadDefault">
                    <desc>Loads the default value of the specified app parameter.
This function does NOT work with device parameters, only with app parameters.</desc>
                    <sample for="lua">Parameters.loadDefault("MyParameter")</sample>
                    <param name="varName" type="string" desc="The name or path of the parameter to be load the default value"/>
                    <return name="success" type="bool" desc="True if successfully restored the default value- False on error or block does not exist"/>
                </function>
                <function name="loadBlockDefaults">
                    <desc>Loads the default values of all app parameters in the specified block of all loaded parameter files.
This function does NOT work with device parameters, only with app parameters.</desc>
                    <param name="blockName" type="string" desc="The name of the block in the app parameters file(s)"/>
                    <return name="success" type="bool" desc="True if successfully restored the default values for the block(s). False on error or block does not exist in no parameters file"/>
                </function>
            </serves>
            <crown name="Node">
                <trait>released</trait>
                <desc>A "Parameters.Node" object represents a parameter composition or one leaf of it.
If can be used to navigate in the tree of the complex parameter to access or modify values.
A node cannot be created by this CROWN, but it is returned e.g. from "Parameters.getNode".</desc>
                <serves>
                    <function name="get">
                        <desc>Gets the single value or all values of this node or of a child node addressed by a relativePath.
This function can also access just one leaf of a complex parameter by addressing over xPath syntax. The numbers used for array access are interpreted as hex-numbers.
If the accessed leaf is a struct or array, then use the getNode()-function instead.</desc>
                        <sample for="lua">-- Usage possibilities:
local singleValue = Parameters.Node.get(node) -- if the node is a single value get it
local singleSubValue = Parameters.Node.get(node, "subValue") -- get the member value "subValue" of this node if it is a struct
local arraySubValue = Parameters.Node.get(node, "subArray") -- get all the member array values of member "subArray" if it is a struct
local arrayValue = Parameters.Node.get(node, "[0]") -- get the first index value of an array node. Index number is interpreted as hex-number.
local singleSubArrayValue = Parameters.Node.get(node, "subMember/subArray[0]") -- get the first value of the subArray which is member of the subMember struct. Index number is interpreted as hex-number.</sample>
                        <param name="nodeObject" type="const object" alias="Parameters.Node" desc="The instance of the object to use"/>
                        <param name="relativePath" type="string" multiplicity="?" desc="The name or relativePath to access. Nil if accessing this node"/>
                        <return name="varValue" type="auto" multiplicity="[?*]" desc="The value(s) of the parameter. Nil if parameter does not exist or type not possible. The type which is returned depends on the value of the parameter."/>
                    </function>
                    <function name="set">
                        <desc>Sets the single value or all values of this node or of a child node addressed by a relativePath.
This function can also access just one leaf of a complex parameter by addressing over xPath syntax. The numbers used for array access are interpreted as hex-numbers.
If set fails the function returns false.</desc>
                        <sample for="lua">-- Usage possibilities:
local bSuccess = Parameters.Node.set(node, "stringValue") -- Set a single value to this node if it is a string parameter node
local bSuccess = Parameters.Node.set(node, "stringValue", "memberString") -- Set a value to one member of this node if it is a struct</sample>
                        <param name="nodeObject" type="object" alias="Parameters.Node" desc="The instance of the object to use"/>
                        <param name="varValue" type="auto" multiplicity="[1+]" desc="The value(s) of the parameter. Nil if parameter does not exist or type not possible. The type has to match the declaration of the parameter."/>
                        <param name="relativePath" type="string" multiplicity="?" desc="The name or relativePath to access. Nil if accessing this node"/>
                        <return name="success" type="bool" desc="True if successfully set. False if parameter does not exist or type does not match the parameter declaration"/>
                    </function>
                    <function name="getNode">
                        <desc>Gets a copy of a single node of this node or of a child node addressed by a relativePath.
This function can also access just one leaf of a complex parameter by addressing over xPath syntax. The numbers used for array access are interpreted as hex-numbers.</desc>
                        <sample for="lua">-- Usage possibilities:
local subNode = Parameters.Node.getNode(node, "childName") -- get one member node named "childName"
local subArraynode = Parameters.Node.getNode(node, "subMember/subArray[0]") -- get the first value of the subArray which is member of subMember struct. Index number is interpreted as hex-number.</sample>
                        <param name="nodeObject" type="const object" alias="Parameters.Node" desc="The instance of the object to use"/>
                        <param name="relativePath" type="string" multiplicity="?" desc="The name or relativePath to access. Nil if accessing this node"/>
                        <return name="nodeObjectCopy" type="object" multiplicity="?" alias="Parameters.Node" desc="The copy of the node object of the parameter or nil if parameter does not exist"/>
                    </function>
                    <function name="setNode">
                        <desc>Sets the single node of this node or of a child node addressed by a relativePath.
This function can also access just one leaf of a complex parameter by addressing over xPath syntax. The numbers used for array access are interpreted as hex-numbers.
The specified node content and structure has to match the current node parameter declaration.
If set fails the function returns false.</desc>
                        <sample for="lua">-- Usage possibilities:
local bSuccess = Parameters.Node.setNode(node, otherNode) -- sets the values of another node to this one</sample>
                        <param name="nodeObject" type="object" alias="Parameters.Node" desc="The instance of the object to use"/>
                        <param name="valueObject" type="const object" alias="Parameters.Node" desc="The node object with the new values. The node structure has to match the parameter. Values are copied to the nodeObject."/>
                        <param name="relativePath" type="string" multiplicity="?" desc="The name or relativePath to access. Nil if accessing this node"/>
                        <return name="success" type="bool" desc="True if successfully set. False if parameter does not exist or node structure does not match the parameter declaration"/>
                    </function>
                    <function name="getAllNodes">
                        <desc>Gets copies of all children nodes of this node or of a child node addressed by a relativePath.
This function can also access just one leaf of a complex parameter by addressing over xPath syntax. The numbers used for array access are interpreted as hex-numbers.
It is possible to get the children of structs and arrays.</desc>
                        <sample for="lua">-- Usage possibilities:
local subNodes = Parameters.Node.getAllNodes(node) -- get all sub nodes of the node
local subNodes = Parameters.Node.getAllNodes(node, "subMember") -- get all member nodes of a sub struct</sample>
                        <param name="nodeObject" type="const object" alias="Parameters.Node" desc="The instance of the object to use"/>
                        <param name="relativePath" type="string" multiplicity="?" desc="The name or relativePath to access. Nil if accessing this node"/>
                        <return name="nodeObjectCopies" type="object" multiplicity="*" alias="Parameters.Node" desc="The copies of the node objects of the parameter or nil if parameter does not exist"/>
                    </function>
                    <function name="setAllNodes">
                        <desc>Sets all specified nodes as children to this node or to a child node addressed by a relativePath.
This function can also access just one leaf of a complex parameter by addressing over xPath syntax. The numbers used for array access are interpreted as hex-numbers.
The specified node content and structure has to match the current node parameter declaration.
It is possible to set the children of structs and arrays.
If set fails the function returns false. This node can be inconsistent in case of fail.</desc>
                        <sample for="lua">-- Usage possibilities:
local bSuccess = Parameters.Node.setAllNodes(node, nodeVector) -- set the nodes of the vector to this one</sample>
                        <param name="nodeObject" type="object" alias="Parameters.Node" desc="The instance of the object to use"/>
                        <param name="valueObject" type="const object" multiplicity="+" alias="Parameters.Node" desc="The node objects with the new values. The node structure has to match the parameter. Values are copied to the nodeObject."/>
                        <param name="relativePath" type="string" multiplicity="?" desc="The name or relativePath to access. Nil if accessing this node"/>
                        <return name="success" type="bool" desc="True if successfully set. False if parameter does not exist or node structure does not match the parameter declaration"/>
                    </function>
                    <function name="setArraySize">
                        <desc>Sets the size of this node if it is an array and the size or the array is declared as flexible</desc>
                        <sample for="lua">Parameters.Node.setArraySize(node, 5)</sample>
                        <param name="nodeObject" type="object" alias="Parameters.Node" desc="The instance of the object to use"/>
                        <param name="size" type="int" desc="The new size of the array"/>
                        <param name="relativePath" type="string" multiplicity="?" desc="The name or relativePath to access. Nil if accessing this node"/>
                        <return name="success" type="bool" desc="True if successful set. False if array size does not match the parameter declaration."/>
                    </function>
                    <function name="getArraySize">
                        <desc>Returns the size if this node is an array.
If it is a flexible array, then the current size is returned.</desc>
                        <sample for="lua">local arrSize = Parameters.Node.getArraySize(node)</sample>
                        <param name="nodeObject" type="const object" alias="Parameters.Node" desc="The instance of the object to use"/>
                        <param name="relativePath" type="string" multiplicity="?" desc="The name or relativePath to access. Nil if accessing this node"/>
                        <return name="size" type="int" multiplicity="?" desc="The current size of the array. Nil if it is not an array"/>
                    </function>
                </serves>
            </crown>
            <crown name="Listener">
                <trait>released</trait>
                <desc>Provides functionality to register for or poll changes of parameter values.
One listener could listen to several parameters by using the add()-function multiple times.
The user could register for an OnChanged-event to get every write to a listened parameter.
Alternatively it could only use isChanged()- and clearChanged()-functions and e.g. call them during 'Engine.OnStarted' event handling.
This functionality does NOT work with device parameters, only with app parameters.</desc>
                <serves>
                    <event name="OnChanged">
                        <desc>Is notified if the value of the parameters has changed or is written with the same value</desc>
                        <sample for="lua">Parameters.Listener.register(handle, "OnChanged", "handleChanged")</sample>
                        <param name="handle" type="handle" alias="Parameters.Listener" desc="The instance handle of Parameters.Listener"/>
                    </event>
                    <function name="create">
                        <desc>Creates a new listener instance. The listener stays active as long as this instance exists.</desc>
                        <sample for="lua">handle = Parameters.Listener.create()</sample>
                        <return name="handle" type="handle" alias="Parameters.Listener" desc="The new Parameters.Listener instance"/>
                    </function>
                    <function name="add">
                        <desc>Adds a parameter name to listen to</desc>
                        <sample for="lua">Parameters.Listener.add(handle, "MyParameterName")</sample>
                        <param name="handle" type="handle" alias="Parameters.Listener" desc="The instance handle of Parameters.Listener"/>
                        <param name="paramName" type="string" desc="The name of the parameter to listen to"/>
                        <return name="success" type="bool" desc="True if successfully added. False if not possible or parameter does not exist"/>
                    </function>
                    <function name="isChanged">
                        <desc>Polls the current changed state. State needs to be reset manually using the clearChanged()-function.</desc>
                        <sample for="lua">local bIsChanged = Parameters.Listener.isChanged(handle)</sample>
                        <param name="handle" type="handle" alias="Parameters.Listener" desc="The instance handle of Parameters.Listener"/>
                        <return name="changed" type="bool" desc="True if the parameters was "/>
                    </function>
                    <function name="clearChanged">
                        <desc>Clears a changed state manually.</desc>
                        <sample for="lua">Parameters.Listener.clearChanged(handle)</sample>
                        <param name="handle" type="handle" alias="Parameters.Listener" desc="The instance handle of Parameters.Listener"/>
                    </function>
                    <function name="register">
                        <desc>This function is used to register for any event of the handle.</desc>
                        <param name="handle" type="handle" alias="Parameters.Listener" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to register to"/>
                        <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                        <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                    </function>
                    <function name="deregister">
                        <desc>This function is used to deregister from any registered event of the handle.</desc>
                        <param name="handle" type="handle" alias="Parameters.Listener" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to deregister from"/>
                        <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                        <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                    </function>
                </serves>
            </crown>
            <crown name="Validator">
                <trait>released</trait>
                <desc>Provides functionality to hook in to parameter writes to decide if a write is allowed or not.
One validator could validate several parameters by using the add()-function multiple times.
The validator function can be set using the setCallback()-function. See description of the setCallback()-function for details about the callback implementation.
This functionality does NOT work with device parameters, only with app parameters.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new validator instance. The validator stays active as long as this instance exists.</desc>
                        <sample for="lua">handle = Parameters.Validator.create()
handle:add("MyParam")
function callback(paramName, paramNode)
  -- Use paramName and paramNode to decide if return true/false
  return bOk
end
handle:setCallback(handle, callback)</sample>
                        <return name="handle" type="handle" alias="Parameters.Validator" desc="The new Parameters.Validator instance"/>
                    </function>
                    <function name="add">
                        <desc>Adds a parameter name to validate</desc>
                        <sample for="lua">Parameters.Validator.add(handle, "MyParameterName")</sample>
                        <param name="handle" type="handle" alias="Parameters.Validator" desc="The instance handle of Parameters.Validator"/>
                        <param name="paramName" type="string" desc="The name of the parameter to validate"/>
                        <return name="success" type="bool" desc="True if successfully added. False if not possible or parameter does not exist"/>
                    </function>
                    <function name="setCallback">
                        <desc>Sets the validator callback function which is called upon writes to the added parameters.
There are several conditions, when and how the callback function is invoked. If the parameter is set using the Parameters CROWN the callback is called with the name of the affected parameters name and with the value that should be set. If a sub node of the parameter is accessed this way, only the name of parameter is provided. The same behavior applies if value is set directly by not using the Parameters CROWN. If the value is changed from netword, only the parameter name is provided.

In general there are two different calls: Only with the parameter name (1) and also with a node contain the value that should be set to this parameter (2). There is also a difference in the semantic of these calls. (1) is a request if the parameter can generally be written (return false in case of read-only or temporarily not writable), (2) is a request, if the new value is valid and should be used (return false if the provided value does not match necessary criteria). The provided value is const and therefore can not be changed.

The function gets called in blocking mode and the current parameter-write is blocked until the function returns.

If the function returns true, the parameter-write is done. If false, then there is an error thrown on the CoLa command interface with number 0x4 (condition wrong)</desc>
                        <sample for="lua">function callback(paramName, paramNode)
  -- get values from "paramNode" using Parameters.Node-functions
  -- if writing should be done, return true. Otherwise return false.
  return bOk
end
Parameters.Validator.setCallback(handle, callback)</sample>
                        <param name="handle" type="handle" alias="Parameters.Validator" desc="The instance handle of Parameters.Validator"/>
                        <param name="funcCallback" type="string" alias="function" desc="The function name to be called for validation. Needs to have a specific signature, read more about in the function documentation."/>
                    </function>
                </serves>
            </crown>
        </crown>
        <crown name="Command">
            <trait>released</trait>
            <desc>Command handling functionalities</desc>
            <crown name="Methods">
                <trait>released</trait>
                <desc>Provides functionality to implement CoLa command methods of the device.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new method handling instance. The methods stay implement as long as this instance exists.</desc>
                        <sample for="lua">handle = Command.Methods.create()</sample>
                        <return name="handle" type="handle" alias="Command.Methods" desc="The new Command.Methods instance"/>
                    </function>
                    <function name="add">
                        <desc>Adds a new method implementation.
Every method could only be added once in the system.
The added function callback is called if the method is executed.

The callback gets the method parameters and also a prepared return parameter objects (if defined any) as function parameters.
The callback should set the values on the return parameter object and should return it if successfully executed.
If the callback does not return the return value object, there is an error thrown on the CoLa command interface with number 0x14 (internal error)

The method parameters and return values are each in a "Parameters.Node"-object.

See the sample code for how a callback implementation looks like.</desc>
                        <sample for="lua">function callback(paramNode, resultNode)
  -- get values from "paramNode" using Parameters.Node-functions
  -- set values on "resultNode" using Parameters.Node-functions
  -- if successful return the resultNode
  return resultNode
end
local bSuccess = Command.Methods.add(handle, "MyMethodName", callback)</sample>
                        <param name="handle" type="handle" alias="Command.Methods" desc="The instance handle of Command.Methods"/>
                        <param name="commandName" type="string" desc="The command method name as served on CoLa interface"/>
                        <param name="funcCallback" type="string" alias="function" desc="The function name which implements the method. Needs to have a specific signature, read more about in the function documentation."/>
                        <return name="success" type="bool" desc="True if added successfully. False if method does not exist or is already added by someone in the system."/>
                    </function>
                </serves>
            </crown>
            <crown name="Client">
                <trait>released</trait>
                <desc>A client to connect to a command server and execute SOPAS commands.
Command servers can be other devices which speak SOPAS CoLaA, CoLaB or CoLa2.
A client can execute single commands on the device and also can store and restore parameters of it.

To be able to talk with a device, a ".sopas" file is needed to be specified with the "Command.Client.setDescription" function.
A ".sopas" file can be created using SOPAS ET and store a project.

The connection to the device must be injected using the "setConnection" function by providing a handle to a connection which is already open and configured.
Connections must be CROWNs which have a "transmit" function and an "OnReceive" event, e.g. "TCPIPClient" and "SerialCom".
The handling of disconnects can be handled by the user.

There is a default timeout for every request of 30 seconds. If the connection is lost or no response is received, the requests return with an error after that time.

There is a fix internal maximum CoLa de/serialization buffer size of 64k. Request bigger than this are not possible.</desc>
                <enum name="ProtocolType">
                    <item name="CoLa A (Default)">COLA_A</item>
                    <item name="CoLa B">COLA_B</item>
                    <item name="CoLa 2">COLA_2</item>
                </enum>
                <enum name="AccessMode">
                    <item name="By name (Default)">BY_NAME</item>
                    <item name="By index">BY_INDEX</item>
                </enum>
                <enum name="ByteOrder">
                    <item name="Big-endian (Default)">BIG_ENDIAN</item>
                    <item name="Little-endian">LITTLE_ENDIAN</item>
                </enum>
                <enum name="LoginMethod">
                    <item name="Use (unsecure) user level -&gt; SetAccessMode">USERLEVEL</item>
                    <item name="Use secure user level V1.0 -&gt; SetUserLevel">SECURE_USERLEVEL_V_1_0</item>
                    <item name="Use secure user level V2.0 (Default) -&gt; SetUserLevel">SECURE_USERLEVEL_V_2_0</item>
                </enum>
                <enum name="UserLevel">
                    <item name="Run">RUN</item>
                    <item name="Operator">OPERATOR</item>
                    <item name="Maintenance">MAINTENANCE</item>
                    <item name="AUTHORIZED_CLIENT">AUTHORIZED_CLIENT</item>
                    <item name="SERVICE">SERVICE</item>
                    <item name="SICKService">SICK_SERVICE</item>
                    <item name="Production">PRODUCTION</item>
                    <item name="Developer">DEVELOPER</item>
                </enum>
                <serves>
                    <event name="OnChanged">
                        <desc>Event which is notified if any change listener received a change of a variable.
If the event has values, they are provided as a "Parameters.Node" object.</desc>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <param name="eventName" type="string" desc="The name of the variable or event which has changed"/>
                        <param name="paramNode" type="object" multiplicity="?" alias="Parameters.Node" desc="The event value if the event has arguments"/>
                    </event>
                    <function name="create">
                        <desc>Creates a new Command.Client instance.
The client needs to be configured before using the Open()-function.</desc>
                        <sample for="lua">-- Create and configure the connection
conHandle = TCPIPClient.create()
TCPIPClient.setIPAddress(conHandle, "192.168.0.1")
TCPIPClient.connect(conHandle)
assert( TCPIPClient.isConnected(conHandle) ) -- connection handling has to be done by the user of the Command.Client

-- Create, configure and open the client
handle = Command.Client.create()
Command.Client.setDescriptionFile(handle, "resources/myDevice.sopas")
Command.Client.setProtocol(handle, "COLA_A")
Command.Client.setConnection(handle, conHandle)
assert ( Command.Client.open(handle) )
-- Now the ".sopas"-file is loaded and the client is registered at the connection and can be used

-- read a variable from the device
local paramNode = Command.Client.read(handle, "DeviceIdent")
if paramNode then
  local devName = Parameters.Node.get(paramNode, "Name")
  print("Device name is " .. devName)
end</sample>
                        <return name="handle" type="handle" alias="Command.Client" desc="The new instance"/>
                    </function>
                    <function name="setProtocol">
                        <desc>Sets the protocol to use to the device.
Default is "CoLa A".</desc>
                        <sample for="lua">Command.Client.setProtocol(handle, "COLA_A")</sample>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <param name="protocol" type="enum" ref="ProtocolType" desc="The protocol to use to the device."/>
                    </function>
                    <function name="setAccessMode">
                        <desc>Sets the access mode to use for every request.
It depends on the devices if requests by name is possible or not. Smaller devices might only support requests by index.
Default is 'by name'.
The value can also be changed on the fly when the client is open.</desc>
                        <sample for="lua">Command.Client.setAccessMode(handle, "BY_INDEX")</sample>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <param name="accessMode" type="enum" ref="AccessMode" desc="The access mode to use to the device."/>
                    </function>
                    <function name="setByteOrder">
                        <desc>Sets the CoLa byte order to use for binary cola protocols (CoLaB,CoLa2).
Defaults is 'Big-endian'.</desc>
                        <sample for="lua">Command.Client.setByteOrder(handle, "LITTLE_ENDIAN")</sample>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <param name="byteOrder" type="enum" ref="ByteOrder" desc="The cola byte order to use to the device."/>
                    </function>
                    <function name="setLoginMethod">
                        <desc>Sets the login method that should be used to login to the device. Default is "SECURE_USERLEVEL_V_2_0". Must be called before open is called to have any effect.</desc>
                        <sample for="lua">Command.Client.setLoginMethod(handle, "SECURE_USERLEVEL_V_2_0")</sample>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <param name="loginMethod" type="enum" ref="LoginMethod" desc="The method to login to the device."/>
                    </function>
                    <function name="setRequestTimeout">
                        <desc>Sets the timeout in milliseconds for every request like read, write, invokeMethod, enableChangeListener/disableChangeListener and also backup/restore requests.
Default is 30 seconds.
Maximum is 65 seconds.
The value can also be changed on the fly when the client is open. Only for backup/restore requests the timeout needs to be set before callin the open function.</desc>
                        <sample for="lua">Command.Client.setRequestTimeout(handle, 5000)</sample>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <param name="timoutMs" type="int" desc="The timeout in ms for every request. Max. 65 seconds."/>
                    </function>
                    <function name="setDescriptionFile">
                        <desc>Sets the path to the ".sopas" file to use as description for the device to communicate with.
A ".sopas" file can be created using SOPAS ET and store a project. Take care that the file needs to be created for the correct device variant.
The setDeviceSelector()-function can be used to select a device if there are multiple devices in the ".sopas"-file.</desc>
                        <sample for="lua">Command.Client.setDescriptionFile(handle, "resources/myFile.sopas")</sample>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <param name="filePath" type="string" desc="The path to the file to use as description for the device to communicate with"/>
                    </function>
                    <function name="setDeviceSelector">
                        <desc>Sets the device selector which should used to define which description to loaded from the ".sopas" description file.
Can be left empty (as per default) to load the first description in the file or if there is just one single description in the file.
The selector can be a device type name, device variant and/or the location name. Not used selectors could be set to empty string.</desc>
                        <sample for="lua">Command.Client.setDeviceSelector(handle, "Lector652 Flex")</sample>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <param name="deviceName" type="string" desc="The name of the device to load from the description file. Could be empty string."/>
                        <param name="deviceVariant" type="string" multiplicity="?" desc="The variant of the device to load from the description file. Could be empty string."/>
                        <param name="locationName" type="string" multiplicity="?" desc="The location name of the device to load from the description file. Could be empty string."/>
                    </function>
                    <function name="getDevicesFromDescriptionFile">
                        <desc>Retrieve the names of the devices, that are stored within the description file previously set with setDescriptionFile.</desc>
                        <sample for="lua">Command.Client.getDevicesFromDescriptionFile(handle)</sample>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <return name="deviceNames" type="string" multiplicity="*" desc="A vector containing all the found device names. Empty names are also valid values. Nil is returned, if the description file was not set or is not parseable. An Empty vector is empty, if the description file was loaded successfully but does not contain any devices."/>
                    </function>
                    <function name="getVariantsForDeviceFromDescriptionFile">
                        <desc>Retrieve all possible variants for a device stored in the previously set with setDescriptionFile.</desc>
                        <sample for="lua">Command.Client.getVariantsForDeviceFromDescriptionFile(handle, "DeviceName")</sample>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <param name="deviceName" type="string" desc="The name of the device to get the variants for. Should be a value which was previously returned by getDevicesFromDescriptionFile."/>
                        <return name="variantNames" type="string" multiplicity="*" desc="A vector containing all the found variant names. For a device without variants, a vector with a single, emtpy variant name is returned. Nil is returned, if the description file was not set or is not parseable."/>
                    </function>
                    <function name="setConnection">
                        <desc>Sets the connection handle to use for talking with the device.
The handle can be of any connection CROWN which serves a "transmit" function and an "OnReceive" event.
The connection has already to be opened before and can be control by the user.
Also make sure that the connection has to be set to no framing which is the default for most connections. The Client does the framing on its own, so check the setFraming function of the connection.
If the connection throws too much receive data, there is a queue of 10 packets and everything more than this is thrown away.</desc>
                        <sample for="lua"></sample>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <param name="conHandle" type="handle" desc="The connection handle to use to communicate with the device"/>
                    </function>
                    <function name="open">
                        <desc>Opens the client with the current configuration and makes usage possible.
The configuration values have to be set before calling this function.
The open()-function sends no command to device, just loads the configuration and make communication with device possible.</desc>
                        <sample for="lua">local bSuccess = Command.Client.open(handle)</sample>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <return name="success" type="bool" desc="True if successfully opened. False if configuration isn't valid (e.g. wrong description file)"/>
                        <return name="errMsg" type="string" multiplicity="?" desc="If open fails, this string contains the readable error message about why it failed"/>
                    </function>
                    <function name="close">
                        <desc>Forces a close from the server.
Can be used to shut down the communication and reconfigure the "Command.Client"</desc>
                        <sample for="lua">Command.Client.close(handle)</sample>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                    </function>
                    <function name="restore">
                        <desc>Restores the parameters from a ".sopas" file to the device.
This is useful to configure the device in a specific state.
If restoring fails the device might be in an inconsistent configuration.
The variables are only restored which match the current login level. So make sure to login to the device in the wanted userlevel before. Variables which are above the current userlevel are not written.
The opposite function is "backup" to get all parameters from a device.</desc>
                        <sample for="lua">local bSuccess = Command.Client.restore(handle, "resources/myDevice.sopas")</sample>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <param name="paramFile" type="string" desc="The path to the .sopas file to restore from"/>
                        <return name="success" type="bool" desc="True if successful restored all parameters. False if not possible or failed while restoring."/>
                        <return name="errMsg" type="string" multiplicity="?" desc="If restore fails, this string contains the readable error message about why it failed"/>
                    </function>
                    <function name="backup">
                        <desc>Stores the parameters of a device to a ".sopas" file.
This is useful to backup the parameters of a device to a file to restore it later or to open it in SOPAS ET.
If storing fails no file is created at all.
The opposite function is "restore" to put all parameters to a device.</desc>
                        <sample for="lua">local bSuccess = Command.Client.backup(handle, "private/myDevice.sopas")</sample>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <param name="paramFile" type="string" desc="The path to the .sopas file to store to"/>
                        <return name="success" type="bool" desc="True if successful stored the parameters to the file. False if not possible or failed while storing."/>
                        <return name="errMsg" type="string" multiplicity="?" desc="If backup fails, this string contains the readable error message about why it failed"/>
                    </function>
                    <function name="read">
                        <desc>Reads a parameter of the connected device and returns its value</desc>
                        <sample for="lua">local paramNode = Command.Client.read(handle, "theParameterName")</sample>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <param name="varName" type="string" desc="The name of the variable"/>
                        <return name="paramNode" type="object" multiplicity="?" alias="Parameters.Node" desc="The copy of the value. Nil if not exists or was not possible to read."/>
                    </function>
                    <function name="write">
                        <desc>Writes a value to a parameter of the connected device.
The value can retrieved by reading first or using the createNode function.</desc>
                        <sample for="lua">local bSucces = Command.Client.write(handle, "theParameterName", paramNode)</sample>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <param name="varName" type="string" desc="The name of the variable"/>
                        <param name="paramNode" type="const object" alias="Parameters.Node" desc="The node value to write"/>
                        <return name="success" type="bool" desc="True if successfully written. False if parameter was not written."/>
                    </function>
                    <function name="createNode">
                        <desc>Creates a new Parameters.Node with a defined structure for a variable or as method argument.
This can be used for write or invoke calls.</desc>
                        <sample for="lua">local newNode = Command.Client.createNode(handle, "theParameterName")</sample>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <param name="paramName" type="string" desc="The name of the variable or method."/>
                        <return name="paramNode" type="object" multiplicity="?" alias="Parameters.Node" desc="The new created not if exists"/>
                    </function>
                    <function name="login">
                        <links>setLoginMethod</links>
                        <desc>Login to the device using the specified credentials. The login method always uses the method set by setLoginMethod</desc>
                        <sample for="lua">local bSuccess = Command.Client.login(handle, "MAINTENANCE", "MaintenancesAwesomePassword")</sample>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <param name="userLevel" type="enum" ref="UserLevel" desc="The user level to login with."/>
                        <param name="password" type="string" desc="The password to use to login."/>
                        <return name="success" type="bool" desc="True if successfully executed. False if timeout or error"/>
                    </function>
                    <function name="changePassword">
                        <links>setLoginMethod</links>
                        <desc>Change the password for a user level. The changePassword method always uses the method set by setLoginMethod. Only works for SECURE_USERLEVEL_V_1_0 and SECURE_USERLEVEL_V_2_0</desc>
                        <sample for="lua">local bSuccess = Command.Client.changePassword(handle, "SERVICE", "ServicesAwesomePassword", "MAINTENANCE", "MaintenancesNewPassword")</sample>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <param name="loginUserLevel" type="enum" ref="UserLevel" desc="The user level to login with, must be higher than or equal to changeUserLevel."/>
                        <param name="loginPassword" type="string" desc="The current password of loginUserLevel."/>
                        <param name="changeUserLevel" type="enum" ref="UserLevel" desc="The user level whose password should be changed, must be lower than or equal to loginUserLevel."/>
                        <param name="changedPassword" type="string" desc="The new password for changeUserLevel."/>
                        <return name="success" type="bool" desc="True if successfully executed. False if timeout or error"/>
                    </function>
                    <function name="logout">
                        <desc>Logout from the device.</desc>
                        <sample for="lua">local bSuccess = Command.Client.logout(handle)</sample>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <return name="success" type="bool" desc="True if successfully executed. False if timeout or error"/>
                    </function>
                    <function name="invoke">
                        <desc>Invokes a method on the device and waits until it is finished.
If the method has arguments the createNode function can be used to set them and pass to this function.</desc>
                        <sample for="lua">local methodArg = Command.Client.createNode(handle, "theMethodName")
local bSuccess,methodResults = Command.Client.invoke(handle, "theMethodName", methodArg)</sample>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <param name="methodName" type="string" desc="The name of the method."/>
                        <param name="paramNode" type="const object" multiplicity="?" alias="Parameters.Node" desc="The node value as arguments if the method has arguments"/>
                        <return name="success" type="bool" desc="True if successfully executed. False if timeout or error"/>
                        <return name="paramNode" type="object" multiplicity="?" alias="Parameters.Node" desc="The method return values if the method has return values"/>
                    </function>
                    <function name="register">
                        <desc>This function is used to register for any event of the handle.</desc>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to register to"/>
                        <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                        <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                    </function>
                    <function name="deregister">
                        <desc>This function is used to deregister from any registered event of the handle.</desc>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to deregister from"/>
                        <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                        <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                    </function>
                    <function name="enableChangeListener">
                        <desc>Register for variable change of the device.
All incoming changes are directly received after this call, therefore use the "register" function to register for the "OnChanged" event before.</desc>
                        <sample for="lua">local bSuccess = Command.Client.enableChangeListener(handle, "theEventName")</sample>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <param name="eventName" type="string" desc="The name of the variable."/>
                        <return name="success" type="bool" desc="True if successfully registered. False if already registered, timed out or error"/>
                    </function>
                    <function name="disableChangeListener">
                        <desc>Removes the registration for a variable change</desc>
                        <sample for="lua">local bSuccess = Command.Client.disableChangeListener(handle, "theEventName")</sample>
                        <param name="handle" type="handle" alias="Command.Client" desc="The instance handle to use"/>
                        <param name="eventName" type="string" desc="The name of the variable."/>
                        <return name="success" type="bool" desc="True if successfully disabled. False if was not enabled before, timed out or error"/>
                    </function>
                </serves>
            </crown>
            <crown name="Scan">
                <trait>released</trait>
                <desc>API to scan for CoLa devices on Ethernet.
There is the CoLa Scan protocol used to discover devices in the Ethernet network.
The protocol sends UDP broadcast and can therefore also reach devices which are not in the same subnet.

This API can be used to find new devices in the network and configure them.
This is useful mainly for system controller purposes to e.g. implement hardware-replacement behaviour of connected devices.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new Command.Scan instance</desc>
                        <sample for="lua">local handle = Command.Scan.create()</sample>
                        <return name="handle" type="handle" alias="Command.Scan" desc="The new instance"/>
                    </function>
                    <function name="addAuxScan">
                        <trait>hidden</trait>
                        <desc>Adds an auxiliary scan function for devices that does not support CoLa protocol. This function will be called during the scan for devices.</desc>
                        <sample for="lua">Command.Scan.addAuxScan("functionname")</sample>
                        <param name="functionName" type="string" alias="function" desc="Function to be called"/>
                    </function>
                    <function name="addAuxConfig">
                        <trait>hidden</trait>
                        <desc>Adds an auxiliary config function for devices that does not support CoLa protocol. This function will be called during the configuration of devices</desc>
                        <sample for="lua">Command.Scan.addAuxConfig("functionname")</sample>
                        <param name="functionName" type="string" alias="function" desc="Function to be called."/>
                    </function>
                    <function name="setInterface">
                        <desc>Sets the Ethernet interface which should be used to scan for CoLa devices.
If no interface is set, the requests are sent on every ethernet interface after each other.</desc>
                        <sample for="lua">Command.Scan.setInterface(handle, "ETH1")</sample>
                        <param name="handle" type="handle" alias="Command.Scan" desc="The instance handle to use"/>
                        <param name="interface" type="enum" ref="EthernetInterfaces" desc="Select Ethernet interface which should be used for scanning. If none was selected network scan will be done on all available network interfaces."/>
                    </function>
                    <function name="scan">
                        <desc>Scans for CoLa devices on the specified network interface(s) and returns a list of devices.
The individual objects will provide the currently configured parameters of the corresponding device.
The function blocks until the device scan is completed.
It is possible to set a time out after which the scan should stop (default is 5 seconds).</desc>
                        <sample for="lua">local scanResultList = Command.Scan.scan(handle)</sample>
                        <param name="handle" type="handle" alias="Command.Scan" desc="The instance handle to use"/>
                        <param name="timeOutMs" type="int" multiplicity="?" desc="Optional time out after which the scan should stop (in milliseconds)."/>
                        <return name="deviceParameters" type="object" multiplicity="+" alias="Command.Scan.DeviceInfo" desc="Returns a vector with device properties for each device found on the network"/>
                    </function>
                    <function name="configure">
                        <desc>Sets new IP configuration for the selected device which is identified by the MAC address.
The configure function will wait for 5 seconds to get a response from the configured device.
If no response was received within this time the function will return false.
Use the getIPConfigDuration to get the configuration time from the device.
The function will return false if no response was received form the device within 5 seconds.</desc>
                        <sample for="lua">local success = Command.Scan.configure(handle, mac, ip, subnet, gateway, dhcpEnabled)</sample>
                        <param name="handle" type="handle" alias="Command.Scan" desc="The instance handle to use"/>
                        <param name="macAddress" type="string" desc="MAC address of device"/>
                        <param name="ipAddress" type="string" desc="New IP address of device"/>
                        <param name="subnetMask" type="string" desc="New subnet mask of device"/>
                        <param name="defaultGateway" type="string" desc="New default gateway of device"/>
                        <param name="dhcpEnabled" type="bool" desc="Set if DHCP is enabled on device"/>
                        <return name="success" type="bool" desc="Returns true if operation was successful"/>
                    </function>
                    <function name="beep">
                        <desc>Calls beep function for the selected device.
For CoLa2 devices an optional parameter can be specified which sets the time the device will signal the beep command.
Default beep time will be 5 seconds.
The function will wait for up to 3 seconds for the device to answer the beep request. If no answer was received within this time, the function will return false.</desc>
                        <sample for="lua">local success = Command.Scan.beep(handle, macAddress)</sample>
                        <param name="handle" type="handle" alias="Command.Scan" desc="The instance handle to use"/>
                        <param name="macAddress" type="string" desc="MAC address of device which should send beep signal"/>
                        <param name="beepTimeSec" type="int" multiplicity="?" desc="Time in seconds device should signal beep command - optional. Default 5 seconds."/>
                        <return name="success" type="bool" desc="Returns true if operation was successful"/>
                    </function>
                </serves>
                <crown name="DeviceInfo">
                    <trait>released</trait>
                    <desc>Contains the device info fields of one device received by the scan function.</desc>
                    <enum name="ProtocolType">
                        <item name="COLA_AB">COLA_AB</item>
                        <item name="COLA_2">COLA_2</item>
                    </enum>
                    <enum name="AccessMode">
                        <item name="Access by name">BY_NAME</item>
                        <item name="Access by index">BY_INDEX</item>
                        <item name="Access by name or index">BOTH</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <trait>hidden</trait>
                            <desc>Creates a new Command.Scan DeviceInfo instance</desc>
                            <sample for="lua">local handle = Command.Scan.DeviceInfo.create()</sample>
                            <return name="handle" type="handle" alias="Command.Scan.DeviceInfo" desc="The new instance"/>
                        </function>
                        <function name="getProtocolType">
                            <desc>Returns the transport protocol version of the device. This function can not distinguish between CoLaA/CoLaB.</desc>
                            <sample for="lua">local value = Command.Scan.DeviceInfo.getProtocolType(deviceParameters)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <return name="protocolType" type="enum" multiplicity="?" ref="ProtocolType" desc="Transport protocol of device"/>
                        </function>
                        <function name="getIPAddress">
                            <desc>Returns the IP address of the device</desc>
                            <sample for="lua">local value = Command.Scan.DeviceInfo.getIPAddress(deviceParameters)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <return name="ipAddress" type="string" multiplicity="?" desc="IP address of device"/>
                        </function>
                        <function name="getSubnetMask">
                            <desc>Returns the subnet mask of the device</desc>
                            <sample for="lua">local value = Command.Scan.DeviceInfo.getSubnetMask(deviceParameters)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <return name="subnetMaks" type="string" multiplicity="?" desc="Subnet mask of device"/>
                        </function>
                        <function name="getEthernetInterface">
                            <desc>Returns the enumeration of the ethernet interface to which the device is connected.</desc>
                            <sample for="lua">local ifName = Command.Scan.DeviceInfo.getEthernetInterface(deviceParameters)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <return name="ifName" type="enum" multiplicity="?" ref="EthernetInterfaces" desc="The ethernet interface"/>
                        </function>
                        <function name="getDefaultGateway">
                            <desc>Returns the default gateway of the device</desc>
                            <sample for="lua">local value = Command.Scan.DeviceInfo.getDefaultGateway(deviceParameters)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <return name="gateway" type="string" multiplicity="?" desc="Default gateway of device"/>
                        </function>
                        <function name="getDeviceName">
                            <desc>Returns the name of the device</desc>
                            <sample for="lua">local value = Command.Scan.DeviceInfo.getDeviceName(deviceParameters)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <return name="deviceName" type="string" multiplicity="?" desc="Name of device"/>
                        </function>
                        <function name="getFirmwareVersion">
                            <desc>Returns the firmware version of the device</desc>
                            <sample for="lua">local value = Command.Scan.DeviceInfo.getFirmwareVersion(deviceParameters)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <return name="firmwareVersion" type="string" multiplicity="?" desc="Firmware version of device"/>
                        </function>
                        <function name="getSerialNumber">
                            <desc>Returns the serial number of the device</desc>
                            <sample for="lua">local value = Command.Scan.DeviceInfo.getSerialNumber(deviceParameters)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <return name="serialNumber" type="string" multiplicity="?" desc="Serial number of device"/>
                        </function>
                        <function name="getIPConfigDuration">
                            <desc>Returns the IP config duration of the device</desc>
                            <sample for="lua">local value = Command.Scan.DeviceInfo.getIPConfigDuration(deviceParameters)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <return name="ipConfigDuration" type="int" multiplicity="?" desc="IP config duration of device"/>
                        </function>
                        <function name="getMACAddress">
                            <desc>Returns the MAC address of the device</desc>
                            <sample for="lua">local value = Command.Scan.DeviceInfo.getMACAddress(deviceParameters)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <return name="mac" type="string" multiplicity="?" desc="MAC address of device"/>
                        </function>
                        <function name="getLocationName">
                            <desc>Returns the location name of the device</desc>
                            <sample for="lua">local value = Command.Scan.DeviceInfo.getLocationName(deviceParameters)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <return name="locationName" type="string" multiplicity="?" desc="Location name of device"/>
                        </function>
                        <function name="getHasDHCPClient">
                            <desc>Does the device support DHCP?</desc>
                            <sample for="lua">local value = Command.Scan.DeviceInfo.getHasDHCPClient(deviceParameters)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <return name="hasDHCPClient" type="bool" multiplicity="?" desc="Returns true if device has a DHCP client"/>
                        </function>
                        <function name="getOrderNumber">
                            <desc>Returns the order number of the device</desc>
                            <sample for="lua">local value = Command.Scan.DeviceInfo.getOrderNumber(deviceParameters)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <return name="orderNumber" type="string" multiplicity="?" desc="Get order number of device"/>
                        </function>
                        <function name="getAuxPort">
                            <desc>Returns the port number of the auxiliary channel (UDP or TCP)</desc>
                            <sample for="lua">local value = Command.Scan.DeviceInfo.getAuxPort(deviceParameters)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <return name="auxPortNumber" type="int" multiplicity="?" desc="Port number of auxilliary channel"/>
                        </function>
                        <function name="getAccessMode">
                            <desc>Returns the CoLa access mode of the device</desc>
                            <sample for="lua">local value = Command.Scan.DeviceInfo.getAccessMode(deviceParameters)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <return name="accessMode" type="enum" multiplicity="?" ref="AccessMode" desc="Access mode of device"/>
                        </function>
                        <function name="getDHCPClientEnabled">
                            <desc>Returns if the DHCP client of the device is enabled</desc>
                            <sample for="lua">local value = Command.Scan.DeviceInfo.getDHCPClientEnabled(deviceParameters)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <return name="isDhcpEnabled" type="bool" multiplicity="?" desc="Returns true if DHCP client is enabled on device"/>
                        </function>
                        <function name="setProtocolType">
                            <trait>hidden</trait>
                            <desc>Sets transport protocol version of the device. This function can not distinguish between CoLaA/CoLaB.</desc>
                            <sample for="lua">Command.Scan.DeviceInfo.setProtocolType(deviceParameters, protocolType)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <param name="protocolType" type="enum" ref="ProtocolType" desc="Transport protocol of device"/>
                        </function>
                        <function name="setIPAddress">
                            <trait>hidden</trait>
                            <desc>Sets the IP address of the device</desc>
                            <sample for="lua">Command.Scan.DeviceInfo.setIPAddress(deviceParameters, ipAddress)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <param name="ipAddress" type="string" desc="IP address of device"/>
                        </function>
                        <function name="setSubnetMask">
                            <trait>hidden</trait>
                            <desc>Sets the subnet mask of the device</desc>
                            <sample for="lua">Command.Scan.DeviceInfo.setSubnetMask(deviceParameters, subnetMask)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <param name="subnetMask" type="string" desc="Subnet mask of device"/>
                        </function>
                        <function name="setEthernetInterface">
                            <trait>hidden</trait>
                            <desc>Sets the ethernet interface enumeration to which the device is connected</desc>
                            <sample for="lua">Command.Scan.DeviceInfo.setEthernetInterface(deviceParameters, ifName)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <param name="ifName" type="enum" multiplicity="?" ref="EthernetInterfaces" desc="The ethernet interface"/>
                        </function>
                        <function name="setDefaultGateway">
                            <trait>hidden</trait>
                            <desc>Sets the default gateway of the device</desc>
                            <sample for="lua">Command.Scan.DeviceInfo.setDefaultGateway(deviceParameters, gateway)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <param name="gateway" type="string" desc="Default gateway of device"/>
                        </function>
                        <function name="setDeviceName">
                            <trait>hidden</trait>
                            <desc>Sets the name of the device</desc>
                            <sample for="lua">Command.Scan.DeviceInfo.setDeviceName(deviceParameters, deviceName)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <param name="deviceName" type="string" desc="Name of device"/>
                        </function>
                        <function name="setFirmwareVersion">
                            <trait>hidden</trait>
                            <desc>Sets the firmware version of the device</desc>
                            <sample for="lua">Command.Scan.DeviceInfo.setFirmwareVersion(deviceParameters, firmwareVersion)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <param name="firmwareVersion" type="string" desc="Firmware version of device"/>
                        </function>
                        <function name="setSerialNumber">
                            <trait>hidden</trait>
                            <desc>Sets the serial number of the device</desc>
                            <sample for="lua">Command.Scan.DeviceInfo.setSerialNumber(deviceParameters, serialNumber)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <param name="serialNumber" type="string" desc="Serial number of device"/>
                        </function>
                        <function name="setIPConfigDuration">
                            <trait>hidden</trait>
                            <desc>Sets the IP config duration of the device</desc>
                            <sample for="lua">Command.Scan.DeviceInfo.setIPConfigDuration(deviceParameters, ipConfiguration)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <param name="ipConfigDuration" type="int" desc="IP config duration of device"/>
                        </function>
                        <function name="setMACAddress">
                            <trait>hidden</trait>
                            <desc>Sets the MAC address of the device</desc>
                            <sample for="lua">Command.Scan.DeviceInfo.setMACAddress(deviceParameters, mac)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <param name="mac" type="string" desc="MAC address of device"/>
                        </function>
                        <function name="setLocationName">
                            <trait>hidden</trait>
                            <desc>Sets the location name of the device</desc>
                            <sample for="lua">Command.Scan.DeviceInfo.setLocationName(deviceParameters, locationName)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <param name="locationName" type="string" desc="Location name of device"/>
                        </function>
                        <function name="setHasDHCPClient">
                            <trait>hidden</trait>
                            <desc>Sets if the device supports DHCP?</desc>
                            <sample for="lua">Command.Scan.DeviceInfo.setHasDHCPClient(deviceParameters, hasDHCPClient)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <param name="hasDHCPClient" type="bool" desc="True if device has a DHCP client"/>
                        </function>
                        <function name="setOrderNumber">
                            <trait>hidden</trait>
                            <desc>Sets the order number of the device</desc>
                            <sample for="lua">Command.Scan.DeviceInfo.setOrderNumber(deviceParameters, orderNumber)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <param name="orderNumber" type="string" desc="Order number of device"/>
                        </function>
                        <function name="setAuxPort">
                            <trait>hidden</trait>
                            <desc>Sets the port number of the auxiliary channel (UDP or TCP)</desc>
                            <sample for="lua">Command.Scan.DeviceInfo.setAuxPort(deviceParameters, auxPortNumber)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <param name="auxPortNumber" type="int" desc="Port number of auxilliary channel"/>
                        </function>
                        <function name="setAccessMode">
                            <trait>hidden</trait>
                            <desc>Sets the CoLa access mode of the device</desc>
                            <sample for="lua">Command.Scan.DeviceInfo.setAccessMode(deviceParameters, accessMode)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <param name="accessMode" type="enum" ref="AccessMode" desc="Access mode of device"/>
                        </function>
                        <function name="setDHCPClientEnabled">
                            <trait>hidden</trait>
                            <desc>Sets if the DHCP client of the device is enabled</desc>
                            <sample for="lua">Command.Scan.DeviceInfo.setDHCPClientEnabled(deviceParameters, isDhcpEnabled)</sample>
                            <param name="deviceParameters" type="const object" alias="Command.Scan.DeviceInfo" desc="An object that contains device parameters."/>
                            <param name="isDhcpEnabled" type="bool" desc="Must be set to true if DHCP client is enabled on device"/>
                        </function>
                    </serves>
                </crown>
            </crown>
            <crown name="SerialBus">
                <trait>released</trait>
                <desc>Provides a safe transport protocol over a serial (half duplex/ full duplex) line</desc>
                <enum name="ChecksumFormat">
                    <item name="High byte first (motorola)">HIGH_BYTE_FIRST</item>
                    <item name="Low byte first (intel)">LOW_BYTE_FIRST</item>
                </enum>
                <crown name="SimpleMaster">
                    <trait>released</trait>
                    <desc>Provides a master that is only able to exchange data with a single slave over a serial (half/ full duplex) line using the CSB (CoLa Serial Bus) transport layer protocol. Does not provide the possibility to talk with several slaves.</desc>
                    <serves>
                        <event name="OnReceive">
                            <desc>Event that is notified, if data was received</desc>
                            <param name="handle" type="handle" alias="Command.SerialBus.SimpleMaster" desc="The SimpleMaster instance"/>
                            <param name="data" type="binary" desc="The received data packet"/>
                        </event>
                        <function name="create">
                            <desc>Creates a new Command.SerialBus.SimpleMaster instance</desc>
                            <sample for="lua">local handle = Command.SerialBus.SimpleMaster.create()</sample>
                            <param name="portName" type="enum" ref="SerialPorts" desc="The (device dependent) name of the serial port which should be opened."/>
                            <return name="handle" type="handle" alias="Command.SerialBus.SimpleMaster" desc="The new instance"/>
                        </function>
                        <function name="setAddressee">
                            <desc>Set the address of the partner to communicate with</desc>
                            <sample for="lua">Command.SerialBus.SimpleMaster.setAddressee(handle, 0x01)</sample>
                            <param name="handle" type="handle" alias="Command.SerialBus.SimpleMaster" desc="The SimpleMaster instance"/>
                            <param name="addressee" type="int" desc="The address of the addressee; default: 0x04, range: 0x01 ... 0x7F, 0x81 ... 0xA9, 0xAB ... 0xBF, 0xC1 ... 0xDF, 0xE1 ... 0xEF, 0xF1 ... 0xF7, 0xF9 ... 0xFB, 0xFD"/>
                        </function>
                        <function name="setBufferedPacketCount">
                            <desc>Set how many packets can be buffered, before the implementation runs out of memory</desc>
                            <sample for="lua">Command.SerialBus.SimpleMaster.setBufferedPacketCount(handle, 5)</sample>
                            <param name="handle" type="handle" alias="Command.SerialBus.SimpleMaster" desc="The SimpleMaster instance"/>
                            <param name="bufferedPacketCount" type="int" desc="The amount of packets to be buffered; default: 4, range: 1 ... 255"/>
                        </function>
                        <function name="setPayloadSize">
                            <desc>Set the amount of payload bytes that can be transmitted with a single packet</desc>
                            <sample for="lua">Command.SerialBus.SimpleMaster.setPayloadSize(handle, 128)</sample>
                            <param name="handle" type="handle" alias="Command.SerialBus.SimpleMaster" desc="The SimpleMaster instance"/>
                            <param name="minimumPayloadSizeInBytes" type="int" desc="The amount of payload bytes per packet; default: 64, range: 64 ... 65527"/>
                        </function>
                        <function name="setMaximumPacketLoadPercentage">
                            <desc>Set the amount of packets (in percent) that can be filled before the communication partner is advised to not send any more data</desc>
                            <sample for="lua">Command.SerialBus.SimpleMaster.setMaximumPacketLoadPercentage(handle, 90)</sample>
                            <param name="handle" type="handle" alias="Command.SerialBus.SimpleMaster" desc="The SimpleMaster instance"/>
                            <param name="maximumPacketLoadPercentage" type="int" desc="The percentage at which the communication partner is advised to not send any data anymore; default: 75, range: 5 ... 95"/>
                        </function>
                        <function name="setChecksumFormat">
                            <desc>Set the checksum format to be used</desc>
                            <sample for="lua">Command.SerialBus.SimpleMaster.setChecksumFormat(handle, "HIGH_BYTE_FIRST")</sample>
                            <param name="handle" type="handle" alias="Command.SerialBus.SimpleMaster" desc="The SimpleMaster instance"/>
                            <param name="format" type="enum" ref="ChecksumFormat" desc="The checksum format to be used; default: &quot;HIGH_BYTE_FIRST&quot;, further allowed value: &quot;LOW_BYTE_FIRST&quot;"/>
                        </function>
                        <function name="setSerialType">
                            <desc>Set the type of the serial connection to be used</desc>
                            <sample for="lua">Command.SerialBus.SimpleMaster.setSerialType(handle, "RS232")</sample>
                            <param name="handle" type="handle" alias="Command.SerialBus.SimpleMaster" desc="The SimpleMaster instance"/>
                            <param name="type" type="enum" ref="SerialComTypes" desc="Interface type which is available on the device. E.g. 'RS232', 'RS422', 'RS485'; default: 'RS232'"/>
                        </function>
                        <function name="setSerialTermination">
                            <desc>Set if the connection uses termination</desc>
                            <sample for="lua">Command.SerialBus.SimpleMaster.setSerialTermination(handle, true)</sample>
                            <param name="handle" type="handle" alias="Command.SerialBus.SimpleMaster" desc="The SimpleMaster instance"/>
                            <param name="enableTermination" type="bool" desc="Flag indicating if termination is used (true) or not (false); default: false"/>
                        </function>
                        <function name="setSerialBaudRate">
                            <desc>Set the baudrate in bits per second</desc>
                            <sample for="lua">Command.SerialBus.SimpleMaster.setSerialBaudRate(handle, 115200)</sample>
                            <param name="handle" type="handle" alias="Command.SerialBus.SimpleMaster" desc="The SimpleMaster instance"/>
                            <param name="baudrate" type="int" desc="The baudrate to be used: 19200, 38400, 57600, 115200; default: 19200"/>
                        </function>
                        <function name="setSerialFlowControl">
                            <desc>Set if the connection uses flow control</desc>
                            <sample for="lua">Command.SerialBus.SimpleMaster.setSerialFlowControl(handle, true)</sample>
                            <param name="handle" type="handle" alias="Command.SerialBus.SimpleMaster" desc="The SimpleMaster instance"/>
                            <param name="enableFlowControl" type="bool" desc="Flag indicating if flow control is used (true) or not (false); default: false"/>
                        </function>
                        <function name="setSerialHandshake">
                            <desc>Set if the connection uses handshake</desc>
                            <sample for="lua">Command.SerialBus.SimpleMaster.setSerialHandshake(handle, true)</sample>
                            <param name="handle" type="handle" alias="Command.SerialBus.SimpleMaster" desc="The SimpleMaster instance"/>
                            <param name="enableHandshake" type="bool" desc="Flag indicating if handshake is used (true) or not (false); default: false"/>
                        </function>
                        <function name="setSerialReceiveTimeout">
                            <desc>Set the receive receive timeout on the underlying serial connection. This timeout directly influences the timeout of
the open function, if nothing is received on the serial line.</desc>
                            <sample for="lua">Command.SerialBus.SimpleMaster.setSerialReceiveTimeout(handle, 2000)</sample>
                            <param name="handle" type="handle" alias="Command.SerialBus.SimpleMaster" desc="The SimpleMaster instance"/>
                            <param name="ms" type="int" desc="The receive timeout for each receive operation in ms; default: 1000"/>
                        </function>
                        <function name="open">
                            <desc>Setup everything so that the communication can get started. This function tries to receive data on the underlying
serial connection using the timeout previously set by setSerialReceiveTimeout. If nothing is received, this function blocks for the
timeout time.</desc>
                            <sample for="lua">local success = Command.SerialBus.SimpleMaster.open(handle)</sample>
                            <param name="handle" type="handle" alias="Command.SerialBus.SimpleMaster" desc="The SimpleMaster instance"/>
                            <return name="success" type="bool" desc="True if setup was successful"/>
                        </function>
                        <function name="close">
                            <desc>Close the connection</desc>
                            <sample for="lua">Command.SerialBus.SimpleMaster.close(handle)</sample>
                            <param name="handle" type="handle" alias="Command.SerialBus.SimpleMaster" desc="The SimpleMaster instance"/>
                        </function>
                        <function name="isOpened">
                            <desc>Determine whether the connection is opened or not.</desc>
                            <sample for="lua">local isOpen = Command.SerialBus.SimpleMaster.isOpened(handle)</sample>
                            <param name="handle" type="handle" alias="Command.SerialBus.SimpleMaster" desc="Handle to the Serial Communication Interface that has been returned by SerialCom.create()."/>
                            <return name="isOpen" type="bool" desc="True if the simple master is open, false if not"/>
                        </function>
                        <function name="transmit">
                            <desc>Transmit some data</desc>
                            <sample for="lua">transmitted = Command.SerialBus.SimpleMaster.transmit(handle, "Hello world")</sample>
                            <param name="handle" type="handle" alias="Command.SerialBus.SimpleMaster" desc="the SimpleMaster instance"/>
                            <param name="data" type="binary" desc="The data to be transmitted"/>
                            <return name="numberOfBytesTransmitted" type="int" desc="Number of bytes transmitted; 0 if transmit failed"/>
                        </function>
                        <function name="receive">
                            <desc>Receive data</desc>
                            <param name="handle" type="handle" alias="Command.SerialBus.SimpleMaster" desc="The SimpleMaster instance"/>
                            <param name="timeout" type="int" multiplicity="?" desc="Timeout in ms to wait for received data. 0 is default and means directly return."/>
                            <return name="data" type="binary" desc="The received data"/>
                        </function>
                        <function name="register">
                            <desc>This function is used to register for any event of the handle.</desc>
                            <param name="handle" type="handle" alias="Command.SerialBus.SimpleMaster" desc="The instance handle to use"/>
                            <param name="eventname" type="string" desc="The event to register to"/>
                            <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                            <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                        </function>
                        <function name="deregister">
                            <desc>This function is used to deregister from any registered event of the handle.</desc>
                            <param name="handle" type="handle" alias="Command.SerialBus.SimpleMaster" desc="The instance handle to use"/>
                            <param name="eventname" type="string" desc="The event to deregister from"/>
                            <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                            <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                        </function>
                    </serves>
                </crown>
            </crown>
        </crown>
        <crown name="Log">
            <trait>released</trait>
            <desc>Provides logging capabilities for Apps.</desc>
            <enum name="Level">
                <item name="Log nothing">OFF</item>
                <item name="Log only severe errors">SEVERE</item>
                <item name="Log warnings and severe errors">WARNING</item>
                <item name="Log infos, warnings and severe errors">INFO</item>
                <item name="Log fine, infos, warnings and severe errors">FINE</item>
                <item name="Log finer, fine, infos, warnings and severe errors">FINER</item>
                <item name="Log finest, finer, fine, infos, warnings and severe errors">FINEST</item>
                <item name="Log all messages">ALL</item>
            </enum>
            <serves>
                <function name="severe">
                    <desc>Logs a message with level "SEVERE"</desc>
                    <sample for="lua">Log.severe("My message")</sample>
                    <param name="msg" type="string" desc="The message to print out"/>
                </function>
                <function name="warning">
                    <desc>Logs a message with level "WARNING"</desc>
                    <sample for="lua">Log.warning("My message")</sample>
                    <param name="msg" type="string" desc="The message to print out"/>
                </function>
                <function name="info">
                    <desc>Logs a message with level "INFO"</desc>
                    <sample for="lua">Log.info("My message")</sample>
                    <param name="msg" type="string" desc="The message to print out"/>
                </function>
                <function name="fine">
                    <desc>Logs a message with level "FINE"</desc>
                    <sample for="lua">Log.fine("My message")</sample>
                    <param name="msg" type="string" desc="The message to print out"/>
                </function>
                <function name="finer">
                    <desc>Logs a message with level "FINER"</desc>
                    <sample for="lua">Log.finer("My message")</sample>
                    <param name="msg" type="string" desc="The message to print out"/>
                </function>
                <function name="finest">
                    <desc>Logs a message with level "FINEST"</desc>
                    <sample for="lua">Log.finest("My message")</sample>
                    <param name="msg" type="string" desc="The message to print out"/>
                </function>
                <function name="setLevel">
                    <desc>Sets the logging level for the current App</desc>
                    <sample for="lua">Log.setLevel("INFO")</sample>
                    <param name="level" type="enum" ref="Level" desc="The level"/>
                </function>
                <function name="isLogable">
                    <desc>Returns true if the logging on the specified level is enabled.
This is useful to don't create big log outputs if the logging is disabled and log output would not be used.
Only interesting for log levels smaller than warning, because warning and severe output always is needed.</desc>
                    <param name="level" type="enum" ref="Level" desc="The level"/>
                    <return name="isLogable" type="bool" desc="True if the logging on the specified level is enabled"/>
                </function>
                <function name="setConsoleMode">
                    <desc>Sets the logging handling to console mode (=default).
This overwrites all other modes; only one mode can be assigned to the App's logger.</desc>
                    <sample for="lua">Log.setConsoleMode()</sample>
                </function>
                <function name="setFileMode">
                    <desc>Sets the logging handling to file mode.
This overwrites all other modes; only one mode can be assigned to the App's logger.

The writing of the logs to the logfile is done asynchronously in the background.
The maximum number of logs in the queue for writing to file is 128 for each app.
If the log queue is full, the new log is thrown away. The logfile will contain a "Some log messages were lost"-string if this happened. In this case the rate of log production has to be reduced by the app.

When the maximum file size is reached, the file is divided into two halves:
The first half(old entries) is discarded, the second half is shifted to the beginning of the file,
so new log entries can be appended at the end.

Note that it depends on the underlying operating system if the logged file can be accessed while it is written.
If you want to open the logged file for reading, set the logger to another file or to another mode first.
Accessing files is restricted to the public/ or private/ folder, so you may only use file paths starting with either public/ or private/.</desc>
                    <sample for="lua">Log.setFileMode("private/log.txt", 1048576)</sample>
                    <param name="fileName" type="string" desc="File name inside the public or private folder"/>
                    <param name="maxFileSize" type="int" desc="Maximum file size in range of 1024 (1 kB) to 104857600 (100 MB)"/>
                    <return name="success" type="bool" desc="true when setting was successful"/>
                </function>
            </serves>
            <crown name="Logger">
                <trait>released</trait>
                <desc>App-local logger which belongs to the app that creates it. Messages can be logged to the logger by using the functions named after the log levels (info, warning, severe, ...). To get output from the logger, a handler must be attached to it and connected to a sink. See Log.Handler for more information.

logger = Log.Logger.create("myLogger")
logger:warning("This is a warning")</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new Log.Logger instance.</desc>
                        <sample for="lua">local handle = Log.Logger.create("loggerName")</sample>
                        <param name="loggerName" type="string" desc="Name of the logger"/>
                        <return name="handle" type="handle" alias="Log.Logger" desc="The new instance"/>
                    </function>
                    <function name="severe">
                        <desc>Logs a message with level "SEVERE"</desc>
                        <sample for="lua">Log.Logger.severe(handle, "My message")</sample>
                        <param name="handle" type="handle" alias="Log.Logger" desc="The instance handle to use"/>
                        <param name="msg" type="string" desc="The message to print out"/>
                    </function>
                    <function name="warning">
                        <desc>Logs a message with level "WARNING"</desc>
                        <sample for="lua">Log.Logger.warning(handle, "My message")</sample>
                        <param name="handle" type="handle" alias="Log.Logger" desc="The instance handle to use"/>
                        <param name="msg" type="string" desc="The message to print out"/>
                    </function>
                    <function name="info">
                        <desc>Logs a message with level "INFO"</desc>
                        <sample for="lua">Log.Logger.info(handle, "My message")</sample>
                        <param name="handle" type="handle" alias="Log.Logger" desc="The instance handle to use"/>
                        <param name="msg" type="string" desc="The message to print out"/>
                    </function>
                    <function name="fine">
                        <desc>Logs a message with level "FINE"</desc>
                        <sample for="lua">Log.Logger.fine(handle, "My message")</sample>
                        <param name="handle" type="handle" alias="Log.Logger" desc="The instance handle to use"/>
                        <param name="msg" type="string" desc="The message to print out"/>
                    </function>
                    <function name="finer">
                        <desc>Logs a message with level "FINER"</desc>
                        <sample for="lua">Log.Logger.finer(handle, "My message")</sample>
                        <param name="handle" type="handle" alias="Log.Logger" desc="The instance handle to use"/>
                        <param name="msg" type="string" desc="The message to print out"/>
                    </function>
                    <function name="finest">
                        <desc>Logs a message with level "FINEST"</desc>
                        <sample for="lua">Log.Logger.finest(handle, "My message")</sample>
                        <param name="handle" type="handle" alias="Log.Logger" desc="The instance handle to use"/>
                        <param name="msg" type="string" desc="The message to print out"/>
                    </function>
                    <function name="setLevel">
                        <desc>Sets the logging level of the logger.</desc>
                        <sample for="lua">Log.Logger.setLevel(handle, "WARNING")</sample>
                        <param name="handle" type="handle" alias="Log.Logger" desc="The instance handle to use"/>
                        <param name="level" type="enum" ref="Level" desc="Log level"/>
                    </function>
                    <function name="isLoggable">
                        <desc>Check whether a message with a certain log level will be forwarded with the current level setting or not.</desc>
                        <sample for="lua">loggable = Log.Logger.isLoggable(handle, "INFO")</sample>
                        <param name="handle" type="handle" alias="Log.Logger" desc="The instance handle to use"/>
                        <param name="level" type="enum" ref="Level" desc="Log level"/>
                        <return name="loggable" type="bool" desc="True if loggable, false if not"/>
                    </function>
                </serves>
            </crown>
            <crown name="SharedLogger">
                <trait>released</trait>
                <desc>Shared logger which can be accessed from any app. The handle created does not 'own' the logger.
Messages can be logged to the logger by using the functions named after the log levels (info, warning, severe, ...).
To get output from the logger, a handler must be attached to it and connected to a sink. See Log.Handler for
more information.

logger = Log.SharedLogger.create("mySharedLogger")
logger:warning("This is a warning")</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new Log.SharedLogger instance.</desc>
                        <sample for="lua">local handle = Log.SharedLogger.create("loggerName")</sample>
                        <param name="loggerName" type="string" desc="Name of the logger"/>
                        <return name="handle" type="handle" alias="Log.SharedLogger" desc="The new instance"/>
                    </function>
                    <function name="severe">
                        <desc>Logs a message with level "SEVERE"</desc>
                        <sample for="lua">Log.SharedLogger.severe(handle, "My message")</sample>
                        <param name="handle" type="handle" alias="Log.SharedLogger" desc="The instance handle to use"/>
                        <param name="msg" type="string" desc="The message to print out"/>
                    </function>
                    <function name="warning">
                        <desc>Logs a message with level "WARNING"</desc>
                        <sample for="lua">Log.SharedLogger.warning(handle, "My message")</sample>
                        <param name="handle" type="handle" alias="Log.SharedLogger" desc="The instance handle to use"/>
                        <param name="msg" type="string" desc="The message to print out"/>
                    </function>
                    <function name="info">
                        <desc>Logs a message with level "INFO"</desc>
                        <sample for="lua">Log.SharedLogger.info(handle, "My message")</sample>
                        <param name="handle" type="handle" alias="Log.SharedLogger" desc="The instance handle to use"/>
                        <param name="msg" type="string" desc="The message to print out"/>
                    </function>
                    <function name="fine">
                        <desc>Logs a message with level "FINE"</desc>
                        <sample for="lua">Log.SharedLogger.fine(handle, "My message")</sample>
                        <param name="handle" type="handle" alias="Log.SharedLogger" desc="The instance handle to use"/>
                        <param name="msg" type="string" desc="The message to print out"/>
                    </function>
                    <function name="finer">
                        <desc>Logs a message with level "FINER"</desc>
                        <sample for="lua">Log.SharedLogger.finer(handle, "My message")</sample>
                        <param name="handle" type="handle" alias="Log.SharedLogger" desc="The instance handle to use"/>
                        <param name="msg" type="string" desc="The message to print out"/>
                    </function>
                    <function name="finest">
                        <desc>Logs a message with level "FINEST"</desc>
                        <sample for="lua">Log.SharedLogger.finest(handle, "My message")</sample>
                        <param name="handle" type="handle" alias="Log.SharedLogger" desc="The instance handle to use"/>
                        <param name="msg" type="string" desc="The message to print out"/>
                    </function>
                    <function name="setLevel">
                        <desc>Sets the logging level of the logger.</desc>
                        <sample for="lua">Log.SharedLogger.setLevel(handle, "WARNING")</sample>
                        <param name="handle" type="handle" alias="Log.SharedLogger" desc="The instance handle to use"/>
                        <param name="level" type="enum" ref="Level" desc="Log level"/>
                    </function>
                    <function name="isLoggable">
                        <desc>Check whether a message with a certain log level will be forwarded with the current level setting or not.</desc>
                        <sample for="lua">loggable = Log.SharedLogger.isLoggable(handle, "INFO")</sample>
                        <param name="handle" type="handle" alias="Log.SharedLogger" desc="The instance handle to use"/>
                        <param name="level" type="enum" ref="Level" desc="Log level"/>
                        <return name="loggable" type="bool" desc="True if loggable, false if not"/>
                    </function>
                </serves>
            </crown>
            <crown name="Handler">
                <trait>released</trait>
                <desc>Handlers are used to connect one or more loggers to one or more endpoints, the so-called 'sinks'.
A sink can be either a file, a callback function or the AppStudio console. Every handler can be attached to an arbitrary number of loggers (local, shared or the engine logger) and an arbitrary number of sinks. However, there is only one global engine logger and only one console sink because AppStudio does not offer multiple consoles. To apply the configuration on a handler, the applyConfig() function must be called.
It must also be called after making changes to an already installed handler, e.g. when changing the log level.

You can also add callback sinks which use callback functions with the following signature:

function myHandlerFunction(message, path, level, timestamp, appName, appPosition, sourceApi)
print(message)
end

The parameters appName, appPosition and sourceApi contain the name of the app, file and line position in the app source code and the name of the API the log was sent from. If this information is not available, the corresponding strings are empty.

handler = Log.Handler.create()
handler:attachToLogger("App1.myLogger")
handler:attachToSharedLogger("mySharedLogger")
handler:addFileSink("private/log.txt", 1000000)
handler:addCallbackSink("myHandlerFunction")
handler:setConsoleSinkEnabled(true)
handler:setLevel("WARNING")
handler:applyConfig()</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new Log.Handler instance.</desc>
                        <sample for="lua">local handle = Log.Handler.create()</sample>
                        <return name="handle" type="handle" alias="Log.Handler" desc="The new instance"/>
                    </function>
                    <function name="attachToLogger">
                        <desc>Attaches handler to an app-local logger.</desc>
                        <sample for="lua">Log.Handler.attachToLogger(handle, "AppName.LoggerName")</sample>
                        <param name="handle" type="handle" alias="Log.Handler" desc="The instance handle to use"/>
                        <param name="appPath" type="string" desc="Path of the app logger in the form AppName.LocalLoggerName"/>
                    </function>
                    <function name="attachToSharedLogger">
                        <desc>Attaches handler to a shared logger.</desc>
                        <sample for="lua">Log.Handler.attachToSharedLogger(handle, "LoggerName")</sample>
                        <param name="handle" type="handle" alias="Log.Handler" desc="The instance handle to use"/>
                        <param name="loggerName" type="string" desc="Name of the logger"/>
                    </function>
                    <function name="attachToEngineLogger">
                        <desc>Attaches handler to the engine logger.</desc>
                        <sample for="lua">Log.Handler.attachToEngineLogger(handle)</sample>
                        <param name="handle" type="handle" alias="Log.Handler" desc="The instance handle to use"/>
                    </function>
                    <function name="setLevel">
                        <desc>Sets the logging level of the handler.</desc>
                        <sample for="lua">Log.Handler.setLevel(handle, WARNING)</sample>
                        <param name="handle" type="handle" alias="Log.Handler" desc="The instance handle to use"/>
                        <param name="level" type="enum" ref="Level" desc="Log level"/>
                    </function>
                    <function name="addFileSink">
                        <desc>Adds a file sink to the handler.</desc>
                        <sample for="lua">Log.Handler.addFileSink(handle, "private/my.log", 1000000)</sample>
                        <param name="handle" type="handle" alias="Log.Handler" desc="The instance handle to use"/>
                        <param name="filePath" type="string" desc="Path to the log file"/>
                        <param name="fileSize" type="int" desc="Maximum size of the log file in bytes before truncating. Has to be in the range [1024,104857600] bytes."/>
                        <return name="success" type="bool" desc="True if file sink was added, false if an error occurred"/>
                    </function>
                    <function name="addCallbackSink">
                        <desc>Adds a callback sink to the handler. The signature is as follows:

function myHandlerFunction(message, path, level, timestamp, appName, appPosition, sourceApi)
print(message)
end

The parameters appName, appPosition and sourceApi contain the name of the app, file and line position in the app source code and the name of the API the log was sent from. If this information is not available, the corresponding strings are empty.</desc>
                        <sample for="lua">function myHandlerFunction(message, path, level, timestamp, appName, appPosition, sourceApi)
  print(message)
end
Log.Handler.addCallbackSink(handle, "myHandlerFunction")</sample>
                        <param name="handle" type="handle" alias="Log.Handler" desc="The instance handle to use"/>
                        <param name="callback" type="string" alias="function" desc="The callback to be triggered when a message is dispatched"/>
                    </function>
                    <function name="setConsoleSinkEnabled">
                        <desc>Enables/disables forwarding to AppStudio console.</desc>
                        <sample for="lua">Log.Handler.setConsoleSinkEnabled(handle, true)</sample>
                        <param name="handle" type="handle" alias="Log.Handler" desc="The instance handle to use"/>
                        <param name="enabled" type="bool" desc="True to enable forwarding to AppStudio console, false to disable"/>
                    </function>
                    <function name="applyConfig">
                        <desc>Applies the handle config. This must be called in order to install the low-level handlers with the configuration set on the handle.
You must also call it to update the handler after changing settings.</desc>
                        <sample for="lua">Log.Handler.applyConfig(handle)</sample>
                        <param name="handle" type="handle" alias="Log.Handler" desc="The instance handle to use"/>
                    </function>
                </serves>
            </crown>
        </crown>
        <crown name="TCPIPClient">
            <trait>released</trait>
            <keywords>Ethernet</keywords>
            <links>TCPIPServer</links>
            <desc>Provides raw TCIP/IP connections to servers.
First a new TCPIPClient needs to be created using the create function.
Afterwards the IP address and the port must be set using the set-functions.
Then a call to the connect-function starts the connection tries to the server.

If the connection gets disconnected it is tried to established it again automatically.
Connects and disconnects can be detected by a register to the OnConnect and OnDisconnect events or by polling the IsConnected function.
Failed transmits are a sign of broken connection and user could also call disconnect manually.

Data could be transmitted to the server using the "transmit" function.
Data could be received by a register to the "OnReceive" event or by calling the blocking receive()-function.

The transmitted and received data is raw data. It could get automatically framed for transmitting and receiving can be automatically parsed if setting a framing with the "setFraming" function.

If a framing is set, there is a fix buffer size of receiving and transmitting which is 10240 bytes per default and can be changed using the setFramingBufferSize()-function.
Every data packet which is larger than this will be discarded.</desc>
            <serves>
                <event name="OnReceive">
                    <desc>The on receive event which is notified for every new received data.</desc>
                    <param name="handle" type="handle" alias="TCPIPClient" desc="This is a handle event and must be registered on the handle"/>
                    <param name="data" type="binary" desc="The received data"/>
                </event>
                <event name="OnConnected">
                    <desc>The on connected event which is notified for every connect.</desc>
                    <param name="handle" type="handle" alias="TCPIPClient" desc="This is a handle event and must be registered on the handle"/>
                </event>
                <event name="OnDisconnected">
                    <desc>The on disconnected event which is notified for every disconnect.
The client automatically tries to connect again every 5 seconds, so the connect() function does not need to be called here.</desc>
                    <param name="handle" type="handle" alias="TCPIPClient" desc="This is a handle event and must be registered on the handle"/>
                </event>
                <function name="create">
                    <desc>Creates a new TCP/IP client instance. Client stays active as long as this handle exists.</desc>
                    <sample for="lua">handle = TCPIPClient.create()</sample>
                    <return name="handle" type="handle" alias="TCPIPClient" desc="The instance handle of the TCP/IP Client"/>
                </function>
                <function name="setIPAddress">
                    <desc>Sets the server ip address to connect to</desc>
                    <sample for="lua">TCPIPClient.setIPAddress(handle, "127.0.0.1")</sample>
                    <param name="handle" type="handle" alias="TCPIPClient" desc="The instance handle of the TCP/IP Client"/>
                    <param name="ipAddress" type="string" desc="The IP Address as string e.g. '192.168.0.10'"/>
                </function>
                <function name="setInterface">
                    <desc>Sets the interface to use for connecting.</desc>
                    <sample for="lua">TCPIPClient.setInterface(handle, "ETH1")</sample>
                    <param name="handle" type="handle" alias="TCPIPClient" desc="The instance handle of the TCP/IP Client"/>
                    <param name="ifName" type="enum" ref="EthernetInterfaces" desc="One of the available interfaces"/>
                </function>
                <function name="setPort">
                    <desc>Sets the server port to connect to.</desc>
                    <sample for="lua">TCPIPClient.setPort(handle, 2120)</sample>
                    <param name="handle" type="handle" alias="TCPIPClient" desc="The instance handle of the TCP/IP Client"/>
                    <param name="port" type="int" desc="The server port between 1 and 65535"/>
                </function>
                <function name="setStaticSourcePort">
                    <desc>Sets a static source port for the TCP/IP client. If this function is not used, the default behavior of the operating system is to select a free source port automatically. Do not use this function unless a custom protocol requires a static client port.</desc>
                    <sample for="lua">TCPIPClient.setStaticSourcePort(handle, 2120)</sample>
                    <param name="handle" type="handle" alias="TCPIPClient" desc="The instance handle of the TCP/IP Client"/>
                    <param name="port" type="int" desc="The client source port between 1 and 65535"/>
                </function>
                <function name="setFraming">
                    <desc>Sets the framing which is to be used.
If not set the default framing is no framing (raw byte/packet-wise connection).
Framing could be also explicitly disabled by calling this function with 2 empty binary data for rx and tx.
One framing part could be maximum size of 9 bytes.

If a framing is set, there is a fix buffer size of receiving and transmitting which is 10240 bytes per default and can be changed using the setFramingBufferSize()-function.
Every data packet which is larger than this will be discarded.</desc>
                    <sample for="lua">TCPIPClient.setFraming(handle, "\02", "\03", "", "\013\010") -- STX...ETX for receiving and ...CR/LF for transmitting</sample>
                    <param name="handle" type="handle" alias="TCPIPClient" desc="The instance handle of the TCP/IP Client"/>
                    <param name="rxStart" type="binary" desc="Start framing for receiving, could be empty string. Maximum size of 9."/>
                    <param name="rxStop" type="binary" desc="Stop framing for receiving. If empty then all raw data is received. Maximum size of 9."/>
                    <param name="txStart" type="binary" desc="Start framing for sending, could be empty string. Maximum size of 9."/>
                    <param name="txStop" type="binary" desc="Stop framing for sending, could be empty string. Maximum size of 9."/>
                </function>
                <function name="setFramingBufferSize">
                    <desc>Sets the size of the internal framing parser buffer which is used if there is a rx or tx framing set using the setFraming function.
If the rx or tx framing isn't set, its buffer size has no effect.
This size is the maximum size of a packet which can be parsed by the framing.
The size is used for start and stop framing.
Default is 10240 bytes.</desc>
                    <sample for="lua">TCPIPClient.setFramingBufferSize(handle, 21000, 21000)</sample>
                    <param name="handle" type="handle" alias="TCPIPClient" desc="The instance handle of the TCP/IP Client"/>
                    <param name="rxBufSize" type="int" desc="The new framing buffer size for framed receiving."/>
                    <param name="txBufSize" type="int" desc="The new framing buffer size for framed transmitting."/>
                </function>
                <function name="setTransmitTimeout">
                    <desc>Sets the timeout for transmits in milliseconds. When an individual transmit fails due to a timeout the connection is unaffected. The application must keep track of failed transmits itself and close the connection manually if needed. This is a network stack setting which affects only Linux and Windows devices. It is ignored on all other devices.</desc>
                    <sample for="lua">TCPIPClient.setTransmitTimeout(handle, 5000)</sample>
                    <param name="handle" type="handle" alias="TCPIPClient" desc="The instance handle of the TCP/IP Client"/>
                    <param name="timeoutMs" type="int" desc="The timeout for transmits in milliseconds."/>
                </function>
                <function name="setTransmitBufferSize">
                    <desc>Sets the size of the socket's send buffer. This is a network stack setting which affects only Linux and Windows devices. It is ignored on all other devices.</desc>
                    <sample for="lua">TCPIPClient.setTransmitBufferSize(handle, 65536)</sample>
                    <param name="handle" type="handle" alias="TCPIPClient" desc="The instance handle of the TCP/IP Client"/>
                    <param name="bufferSize" type="int" desc="The size of the buffer in bytes. Set to 0 to use the system default."/>
                </function>
                <function name="setTransmitAckTimeout">
                    <desc>Sets the maximum time interval in milliseconds that a transmitted packet may stay unacknowledged before the connection is terminated. This is a network stack setting which affects only Linux devices. It is ignored on all other devices.</desc>
                    <sample for="lua">TCPIPClient.setTransmitAckTimeout(handle, 5000)</sample>
                    <param name="handle" type="handle" alias="TCPIPClient" desc="The instance handle of the TCP/IP Client"/>
                    <param name="timeoutMs" type="int" desc="The timeout for packet ACKs in milliseconds. Set to 0 to use the system default."/>
                </function>
                <function name="setReceiveQueueSize">
                    <desc>Sets the internal queue size for the receive()-function.
Default is 10 packets and discarding the oldest item and warn if overrun occurs.
Set to 0 to disable the queue and receiving from the receive()-function, which also increases performance if only receiving over OnReceive-event.</desc>
                    <sample for="lua">TCPIPClient.setReceiveQueueSize(handle, 50)</sample>
                    <param name="handle" type="handle" alias="TCPIPClient" desc="The instance handle of the TCP/IP Client"/>
                    <param name="queueSize" type="int" desc="The new receive queue size."/>
                    <param name="bDiscardIfFull" type="bool" multiplicity="?" desc="Set to true to discard the newest item which is currently added instead of discarding the oldest element. Default is false."/>
                    <param name="warnOverruns" type="bool" multiplicity="?" desc="Set to false to disable warning on overruns when using the receive()-function. Default is true."/>
                </function>
                <function name="connect">
                    <desc>Starts trying to connect to the server.
The OnConnected and OnDisconnected events are notified every time the connection gets connected or disconnected.
If the client gets disconnected, the client automatically tries to reconnect every 5 seconds in the background. So the connect function does not need to be called in OnDisconnect.</desc>
                    <sample for="lua">TCPIPClient.connect(handle)</sample>
                    <param name="handle" type="handle" alias="TCPIPClient" desc="The instance handle to use"/>
                    <param name="timeoutMs" type="int" multiplicity="?" desc="The timeout to wait initially until the client gets connected. If not set, 500ms is the default. Check IsConnected afterwards if was successful."/>
                </function>
                <function name="disconnect">
                    <desc>Forces a disconnect from the server</desc>
                    <sample for="lua">TCPIPClient.disconnect(handle)</sample>
                    <param name="handle" type="handle" alias="TCPIPClient" desc="The instance handle of the TCP/IP Client"/>
                </function>
                <function name="isConnected">
                    <desc>Returns true if the client is connected</desc>
                    <sample for="lua">bConnected = TCPIPClient.isConnected(handle)</sample>
                    <param name="handle" type="handle" alias="TCPIPClient" desc="The instance handle of the TCP/IP Client"/>
                    <return name="isConnected" type="bool" desc="True if the client is connected"/>
                </function>
                <function name="transmit">
                    <desc>Transmits data to the server.
If framing is set using the "setFraming" function, then the framing characters are automatically prefixed and suffixed to the transmitted data.
Blocks until data has been transmitted.
If transmit fails the return number of transmitted bytes is zero.
If transmit fails the connection might be broken. The TCPIPClient would connect automatically again, but the user could also call disconnect()+connect() functions manually.</desc>
                    <sample for="lua">TCPIPClient.transmit(handle,"Hello Server")</sample>
                    <param name="handle" type="handle" alias="TCPIPClient" desc="The instance handle of the TCP/IP Client"/>
                    <param name="data" type="binary" desc="The data which is to be transmitted"/>
                    <return name="numberOfBytesTransmitted" type="int" desc="Number of bytes transmitted; 0 if transmit failed"/>
                </function>
                <function name="receive">
                    <desc>Receives data from the client with a specified timeout.
If timeout is zero then it directly returns.
The data could be framed if the "setFraming" function was called before.
Incoming data between multiple receive calls is queued per message.
There is a fix receive queue size of 10 packets per default and can be changed using the setReceiveQueueSize()-function. More data is discarded.</desc>
                    <sample for="lua">local data = TCPIPClient.receive(handle, 1000)</sample>
                    <param name="handle" type="handle" alias="TCPIPClient" desc="The instance handle of the TCP/IP Client"/>
                    <param name="timeout" type="int" multiplicity="?" desc="Timeout in ms to wait for received data. 0 is default and means directly return."/>
                    <return name="data" type="binary" desc="The data which was received"/>
                </function>
                <function name="register">
                    <desc>This function is used to register for any event of the handle.</desc>
                    <param name="handle" type="handle" alias="TCPIPClient" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to register to"/>
                    <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                    <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                </function>
                <function name="deregister">
                    <desc>This function is used to deregister from any registered event of the handle.</desc>
                    <param name="handle" type="handle" alias="TCPIPClient" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to deregister from"/>
                    <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                    <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                </function>
            </serves>
        </crown>
        <crown name="TCPIPServer">
            <trait>released</trait>
            <keywords>Ethernet</keywords>
            <links>TCPIPClient</links>
            <desc>Provides possibility to open new TCP/IP server ports at the device.
A TCP/IP Server must be created using the create-function and a port must be set using the setPort-function.
After a call to the listen-function the server waits for new incoming connections.

If new connections arrive, the "OnConnectionAccepted" event is notified. The user has to call then the accept function to accept the connection.
Every accepted connection has its one connection handle. On the connection handle the user could receive and transmit.
Currently the number of maximum parallel connections is set to 10 per default and can be changed over the setMaxConnections-function. Further connections will be automatically rejected.

If new data arrives on the connection, the "OnReceive" event of the TCP/IP server is notified with the connection handle, which received data, and the received data as parameter.

The connection can be closed by the server side by calling the "TCPIPServer.Connection.close" function.
If the connection is closed by the peer or by the server side, the "OnConnectionClosed" event is notified with the connection handle of the closed connection.

The transmitted and received data is raw data. It could get automatically framed for transmitting and receiving can be automatically parsed if setting a framing with the "setFraming" function.

If a framing is set, there is a fix buffer size of receiving and transmitting which is 10240 bytes per default and can be changed using the setFramingBufferSize()-function.
Every data packet which is larger than this will be discarded.</desc>
            <serves>
                <event name="OnConnectionAccepted">
                    <desc>This event is notified for every new connection which was accepted.
The new connection is hold until the connected peer disconnects or the connection is rejected.
To reject a connection, the function Connection.close can be called.</desc>
                    <param name="handle" type="handle" alias="TCPIPServer" desc="This is a handle event and must be registered on the handle"/>
                    <param name="conHandle" type="handle" alias="TCPIPServer.Connection" desc="The connection handle of the connection which is opened"/>
                </event>
                <event name="OnConnectionClosed">
                    <desc>This event is notified if a connection is closed by the connected peer.
The connection handle is not usable anymore.
The event is not notified if the Connection.close function was called.</desc>
                    <param name="handle" type="handle" alias="TCPIPServer" desc="This is a handle event and must be registered on the handle"/>
                    <param name="conHandle" type="handle" alias="TCPIPServer.Connection" desc="The connection handle of the connection which is closed"/>
                </event>
                <event name="OnReceive">
                    <desc>The on receive event which is notified for every new received data.</desc>
                    <param name="handle" type="handle" alias="TCPIPServer" desc="This is a handle event and must be registered on the handle"/>
                    <param name="conHandle" type="handle" alias="TCPIPServer.Connection" desc="The connection handle of the connection which is closed"/>
                    <param name="data" type="binary" desc="The received data. If a framing is set, only contains the content without the framing."/>
                </event>
                <function name="create">
                    <desc>Creates a new TCP/IP server instance. Server stays active as long as this handle exists.</desc>
                    <sample for="lua">handle = TCPIPServer.create()</sample>
                    <return name="handle" type="handle" alias="TCPIPServer" desc="The instance handle of the TCP/IP Server"/>
                </function>
                <function name="setInterface">
                    <desc>Sets the interface to use for listening.

The listen function has to be called afterwards so that the setting gets active.</desc>
                    <sample for="lua">TCPIPServer.setInterface(handle, "ETH1")</sample>
                    <param name="handle" type="handle" alias="TCPIPServer" desc="The instance handle of the TCP/IP Server"/>
                    <param name="ifName" type="enum" ref="EthernetInterfaces" desc="One of the available interfaces"/>
                </function>
                <function name="setPort">
                    <desc>Sets the server port which is to be used.

The listen function has to be called afterwards so that the setting gets active.</desc>
                    <sample for="lua">TCPIPServer.setPort(handle, 2120)</sample>
                    <param name="handle" type="handle" alias="TCPIPServer" desc="The instance handle of the TCP/IP Server"/>
                    <param name="port" type="int" desc="The server port between 1 and 65535"/>
                </function>
                <function name="setFraming">
                    <desc>Sets the framing which is to be used.
If not set the default framing is no framing (raw byte/packet-wise connection).
Framing could be also explicitly disabled by calling this function with 2 empty binary data for rx and tx.
One framing part could be maximum size of 9 bytes.

If a framing is set, there is a fix buffer size of receiving and transmitting which is 10240 bytes per default and can be changed using the setFramingBufferSize()-function.
Every data packet which is larger than this will be discarded.

The listen function has to be called afterwards so that the setting gets active.</desc>
                    <sample for="lua">TCPIPServer.setFraming(handle, "\02", "\03", "", "\013\010") -- STX...ETX for receiving and ...CR/LF for transmitting</sample>
                    <param name="handle" type="handle" alias="TCPIPServer" desc="The instance handle of the TCP/IP Server"/>
                    <param name="rxStart" type="binary" desc="Start framing for receiving, could be empty string. Maximum size of 9."/>
                    <param name="rxStop" type="binary" desc="Stop framing for receiving. If empty then all raw data is received. Maximum size of 9."/>
                    <param name="txStart" type="binary" desc="Start framing for sending, could be empty string. Maximum size of 9."/>
                    <param name="txStop" type="binary" desc="Stop framing for sending, could be empty string. Maximum size of 9."/>
                </function>
                <function name="setFramingBufferSize">
                    <desc>Sets the size of the internal framing parser buffer which is used if there is a rx or tx framing set using the setFraming function.
If the rx or tx framing isn't set, its buffer size has no effect.
This size is the maximum size of a packet which can be parsed by the framing.
The size is used for start and stop framing.
Default is 10240 bytes.

The listen function has to be called afterwards so that the setting gets active</desc>
                    <sample for="lua">TCPIPServer.setFramingBufferSize(handle, 21000, 21000)</sample>
                    <param name="handle" type="handle" alias="TCPIPServer" desc="The instance handle of the TCP/IP Server"/>
                    <param name="rxBufSize" type="int" desc="The new framing buffer size for framed receiving."/>
                    <param name="txBufSize" type="int" desc="The new framing buffer size for framed transmitting."/>
                </function>
                <function name="setMaxConnections">
                    <desc>Sets the number of maximum parallel active connections.
Further active connections are automatically discarded.
The default is set to 10 connections.

The listen function has to be called afterwards so that the setting gets active.</desc>
                    <sample for="lua">TCPIPServer.setMaxConnections(handle, 5)</sample>
                    <param name="handle" type="handle" alias="TCPIPServer" desc="The instance handle of the TCP/IP Server"/>
                    <param name="maxCons" type="int" desc="The max number of parallel active connections."/>
                </function>
                <function name="setTransmitTimeout">
                    <desc>Sets the timeout for transmits in milliseconds.</desc>
                    <sample for="lua">TCPIPServer.setTransmitTimeout(handle, 5000)</sample>
                    <param name="handle" type="handle" alias="TCPIPServer" desc="The instance handle of the TCP/IP Server"/>
                    <param name="timeoutMs" type="int" desc="The timeout for transmits in milliseconds."/>
                </function>
                <function name="listen">
                    <desc>Starts listening for new connections on the port. Remember to register for new connections before calling this function.
If port or framing is changed, this function needs to be called to apply the settings and wait for connections on the changed port.
The OnConnectionClosed function is called for existing accepted connections.</desc>
                    <sample for="lua">TCPIPServer.listen(handle)</sample>
                    <param name="handle" type="handle" alias="TCPIPServer" desc="The instance handle of the TCP/IP Server"/>
                    <return name="success" type="bool" desc="Returns true if the listening on the port was successful"/>
                </function>
                <function name="register">
                    <desc>This function is used to register for any event of the handle.</desc>
                    <param name="handle" type="handle" alias="TCPIPServer" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to register to"/>
                    <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                    <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                </function>
                <function name="deregister">
                    <desc>This function is used to deregister from any registered event of the handle.</desc>
                    <param name="handle" type="handle" alias="TCPIPServer" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to deregister from"/>
                    <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                    <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                </function>
            </serves>
            <crown name="Connection">
                <trait>released</trait>
                <desc>Controls one connection of the TCP/IP Server. To close the connection just set the handle to nil.</desc>
                <serves>
                    <function name="close">
                        <desc>Closes the connection explicitly from the server side.
The OnConnectionClosed event is not notified.</desc>
                        <sample for="lua">TCPIPServer.Connection.close(conHandle)</sample>
                        <param name="conHandle" type="handle" alias="TCPIPServer.Connection" desc="The instance handle of the TCP/IP Server connection"/>
                    </function>
                    <function name="isConnected">
                        <desc>Returns true if the client connection is still connected</desc>
                        <sample for="lua">local bConnected = TCPIPServer.Connection.isConnected(conHandle)</sample>
                        <param name="conHandle" type="handle" alias="TCPIPServer.Connection" desc="The instance handle of the TCP/IP Server connection"/>
                        <return name="isConnected" type="bool" desc="True if the client is connected"/>
                    </function>
                    <function name="getPeerAddress">
                        <desc>Returns the IP address and port of the connected peer on this connection.</desc>
                        <sample for="lua">local ip, port = TCPIPServer.Connection.getPeerAddress(conHandle)</sample>
                        <param name="conHandle" type="handle" alias="TCPIPServer.Connection" desc="The instance handle of the TCP/IP Server connection"/>
                        <return name="ipAddr" type="string" multiplicity="?" desc="The IP address of the connected peer. Nil if not available."/>
                        <return name="portNo" type="int" multiplicity="?" desc="The port number of the connected peer. Nil if not available."/>
                    </function>
                    <function name="transmit">
                        <desc>Transmits data to the clients.
If framing is set using the "setFraming" function, then the framing characters are automatically prefixed and suffixed to the transmitted data.
Blocks until data has been transmitted.</desc>
                        <sample for="lua">TCPIPServer.Connection.transmit(conHandle, "Hello Server")</sample>
                        <param name="conHandle" type="handle" alias="TCPIPServer.Connection" desc="The instance handle of the TCP/IP Server connection"/>
                        <param name="data" type="binary" desc="The data which is to be transmitted"/>
                        <return name="numberOfBytesTransmitted" type="int" desc="Number of bytes transmitted; 0 if transmit failed"/>
                    </function>
                </serves>
            </crown>
        </crown>
        <crown name="UDPSocket">
            <trait>released</trait>
            <desc>Provides functionality for sending/receiving UDP packets.
First a new UDPSocket needs to be created using the create function.
Afterwards it could be set to a specified interface using setInterface()-function.
Then a call to the bind-function binds the udp socket to a port and transmit calls and OnReceive events are possible.
If bind()-function is not called, the socket is bind implicitly to the first transmit target.

Data could be transmitted to the server using the "transmit" function.
Data could be received by a register to the "OnReceive" event or by calling the blocking receive()-function.</desc>
            <serves>
                <event name="OnReceive">
                    <desc>The event which is triggered when data is received on the socket.
The socket must be bound first either explicitly by calling bind or implicitly by a preceding transmit.
For each packet receive there is one event notified.</desc>
                    <param name="handle" type="handle" alias="UDPSocket" desc="The instance handle of the UDP socket"/>
                    <param name="data" type="binary" desc="The received data packet"/>
                    <param name="ipAddress" type="string" desc="The peer address the data was received from"/>
                    <param name="port" type="int" desc="The peer port the data was received from"/>
                </event>
                <function name="create">
                    <desc>Creates a UDP socket instance.</desc>
                    <sample for="lua">handle = UDPSocket.create()</sample>
                    <return name="handle" type="handle" alias="UDPSocket" desc="The instance handle of the UDP socket"/>
                </function>
                <function name="setInterface">
                    <desc>Sets the interface to bind the socket to.</desc>
                    <sample for="lua">UDPSocket.setInterface(handle, "ETH1")</sample>
                    <param name="handle" type="handle" alias="UDPSocket" desc="The instance handle of the UDP socket"/>
                    <param name="ifName" type="enum" ref="EthernetInterfaces" desc="One of the available interfaces"/>
                </function>
                <function name="setReceiveQueueSize">
                    <desc>Sets the internal queue size for the receive()-function.
Default is 10 packets and discarding the oldest item and warn if overrun occurs.
Set to 0 to disable the queue and receiving from the receive()-function, which also increases performance if only receiving over OnReceive-event.</desc>
                    <sample for="lua">UDPSocket.setReceiveQueueSize(handle, 50)</sample>
                    <param name="handle" type="handle" alias="UDPSocket" desc="The instance handle of the UDP socket"/>
                    <param name="queueSize" type="int" desc="The new receive queue size."/>
                    <param name="bDiscardIfFull" type="bool" multiplicity="?" desc="Set to true to discard the newest item which is currently added instead of discarding the oldest element. Default is false."/>
                    <param name="warnOverruns" type="bool" multiplicity="?" desc="Set to false to disable warning on overruns when using the receive()-function. Default is true."/>
                </function>
                <function name="bind">
                    <desc>Binds the socket to a specific local port.</desc>
                    <sample for="lua">success = UDPSocket.bind(handle, 10000)</sample>
                    <param name="handle" type="handle" alias="UDPSocket" desc="The instance handle of the UDP socket"/>
                    <param name="port" type="int" desc="The port to bind to"/>
                    <return name="success" type="bool" desc="True if socket was bound successfully, false if an error occurred."/>
                </function>
                <function name="transmit">
                    <desc>Transmit a UDP packet to the specified peer. This will trigger an implicit bind if the socket has not been bound yet.</desc>
                    <sample for="lua">transmitted = UDPSocket.transmit(handle, "192.168.0.1", 10000, "Hello world")</sample>
                    <param name="handle" type="handle" alias="UDPSocket" desc="The instance handle of the UDP socket"/>
                    <param name="ipAddress" type="string" desc="The ip address to transmit to"/>
                    <param name="port" type="int" desc="The port to transmit to"/>
                    <param name="data" type="binary" desc="The data which to be transmitted"/>
                    <return name="numberOfBytesTransmitted" type="int" desc="Number of bytes transmitted; 0 if transmit failed"/>
                </function>
                <function name="receive">
                    <desc>Receives one UDP packet with a specified timeout.
The socket must be bound first either explicitly by calling bind or implicitly by a preceding transmit.
If timeout is zero then it directly returns without any return values.
Incoming data between multiple receive calls is queued per message.
There is a fix receive queue size of 10 packets per default and can be changed using the setReceiveQueueSize()-function. More data is discarded.</desc>
                    <param name="handle" type="handle" alias="UDPSocket" desc="The instance handle of the UDP socket"/>
                    <param name="timeout" type="int" multiplicity="?" desc="Timeout in ms to wait for received data. 0 is default and means directly return."/>
                    <return name="data" type="binary" multiplicity="?" desc="The received data"/>
                    <return name="ipAddress" type="string" multiplicity="?" desc="The peer address the data was received from"/>
                    <return name="port" type="int" multiplicity="?" desc="The peer port the data was received from"/>
                </function>
                <function name="register">
                    <desc>This function is used to register for any event of the handle.</desc>
                    <param name="handle" type="handle" alias="UDPSocket" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to register to"/>
                    <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                    <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                </function>
                <function name="deregister">
                    <desc>This function is used to deregister from any registered event of the handle.</desc>
                    <param name="handle" type="handle" alias="UDPSocket" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to deregister from"/>
                    <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                    <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                </function>
            </serves>
        </crown>
        <crown name="FTPServer">
            <trait>released</trait>
            <keywords>Ethernet</keywords>
            <links>FTPClient</links>
            <desc>Provides FTP server functionality.
Create a new FTP server instance by calling the create function first.
You may set the server port and the maximum number of connections via the setServerPort and setMaxConnections functions. Default is 21 for the server port and 10000 connections.
Users may be added or removed using the addUser and removeUser functions. Login names must be unique per FTP server instance.
Please note that you must add at least one user, even if you want anonymous login. Leave the password empty in that case.
The data port range for PASV mode may be set with the setDataPortRange function.
Several other parameters can be changed using the associated set functions, but meaningful default values have been selected already.
Start the server using the start function and stop it (if needed) by calling stop.</desc>
            <serves>
                <event name="OnStore">
                    <desc>The event which is triggered after a file has been uploaded.</desc>
                    <param name="handle" type="handle" alias="FTPServer" desc="This is a handle event and must be registered on the handle"/>
                    <param name="fileName" type="string" desc="The name of the file that has been uploaded."/>
                    <param name="filePath" type="string" desc="The path where the file has been put."/>
                </event>
                <function name="create">
                    <desc>Creates a new FTP server instance.</desc>
                    <sample for="lua">handle = FTPServer.create()</sample>
                    <return name="handle" type="handle" alias="FTPServer" desc="The instance handle of the FTP server"/>
                </function>
                <function name="setServerPort">
                    <desc>Configure the port number for the FTP server's control connection.</desc>
                    <sample for="lua">success = FTPServer.setServerPort(handle, 33)</sample>
                    <param name="handle" type="handle" alias="FTPServer" desc="The instance handle of the FTP server"/>
                    <param name="port" type="int" desc="Number of the port to listen on. Default is 21."/>
                    <return name="success" type="bool" desc="Is true if server port was set successfully, false if an error occurred"/>
                </function>
                <function name="setInterface">
                    <desc>Sets the interface to use for connecting.</desc>
                    <sample for="lua">FTPServer.setInterface(handle, "ETH1")</sample>
                    <param name="handle" type="handle" alias="FTPServer" desc="The instance handle of the FTP server"/>
                    <param name="ifName" type="enum" ref="EthernetInterfaces" desc="One of the available interfaces"/>
                    <return name="success" type="bool" desc="Is true if interface was set successfully, false if an error occurred"/>
                </function>
                <function name="setMaxConnections">
                    <desc>Configures the maximum number of connections allowed on the control port.</desc>
                    <sample for="lua">success = FTPServer.setMaxConnections(handle, 100)</sample>
                    <param name="handle" type="handle" alias="FTPServer" desc="The instance handle of the FTP server"/>
                    <param name="connections" type="int" desc="Maximum number of connections that is allowed. Default is 10000."/>
                    <return name="success" type="bool" desc="Is true if max connections were set successfully, false if an error occurred"/>
                </function>
                <function name="addUser">
                    <desc>Add a user account</desc>
                    <sample for="lua">success = FTPServer.addUser(handle, "anonymous", "", "public")</sample>
                    <param name="handle" type="handle" alias="FTPServer" desc="The instance handle of the FTP server"/>
                    <param name="login" type="string" desc="Login name for the user account"/>
                    <param name="password" type="string" desc="Password for the user account. Leave empty to not check the password."/>
                    <param name="startDirectory" type="string" desc="Root directory for the user account. Only paths relative to the app home directory are allowed."/>
                    <return name="success" type="bool" desc="Is true if user was added, false if an error occurred"/>
                </function>
                <function name="removeUser">
                    <desc>Remove a user account</desc>
                    <sample for="lua">success = FTPServer.removeUser(handle, "anonymous")</sample>
                    <param name="handle" type="handle" alias="FTPServer" desc="The instance handle of the FTP server"/>
                    <param name="login" type="string" desc="Login name of the user account which is to be removed"/>
                    <return name="success" type="bool" desc="Is true if user was removed, false if an error occurred"/>
                </function>
                <function name="setTransferBufferSize">
                    <desc>Sets the size of the transfer buffer used for data connections</desc>
                    <sample for="lua">FTPServer.setTransferBufferSize(handle, 10000)</sample>
                    <param name="handle" type="handle" alias="FTPServer" desc="The instance handle of the FTP server"/>
                    <param name="bufferSize" type="int" desc="Buffer size for data connection transfers. Default is 32768."/>
                </function>
                <function name="setCheckPassDelay">
                    <desc>Configure the forced delay between subsequent login attempts in milliseconds</desc>
                    <sample for="lua">FTPServer.setCheckPassDelay(handle, 5000)</sample>
                    <param name="handle" type="handle" alias="FTPServer" desc="The instance handle of the FTP server"/>
                    <param name="delay" type="int" desc="Delay between subsequent login attempts in milliseconds. Default is 500."/>
                </function>
                <function name="setDataPortRange">
                    <desc>Set the range of data ports available for PASV mode port selection</desc>
                    <sample for="lua">FTPServer.setDataPortRange(handle, 5000, 6000)</sample>
                    <param name="handle" type="handle" alias="FTPServer" desc="The instance handle of the FTP server"/>
                    <param name="rangeBegin" type="int" desc="First port of range (inclusive)."/>
                    <param name="rangeEnd" type="int" desc="Last port of range (inclusive)."/>
                </function>
                <function name="start">
                    <desc>Start the FTP server</desc>
                    <sample for="lua">success = FTPServer.start(handle)</sample>
                    <param name="handle" type="handle" alias="FTPServer" desc="The instance handle of the FTP server"/>
                    <return name="success" type="bool" desc="Is true when the FTP server is running, false if an error occurred."/>
                </function>
                <function name="stop">
                    <desc>Stop the FTP server</desc>
                    <sample for="lua">FTPServer.stop(handle)</sample>
                    <param name="handle" type="handle" alias="FTPServer" desc="The instance handle of the FTP server"/>
                    <return name="success" type="bool" desc="Is true when the FTP server has been stopped successfully, false if an error occurred."/>
                </function>
                <function name="register">
                    <desc>This function is used to register for any event of the handle.</desc>
                    <param name="handle" type="handle" alias="FTPServer" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to register to"/>
                    <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                    <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                </function>
                <function name="deregister">
                    <desc>This function is used to deregister from any registered event of the handle.</desc>
                    <param name="handle" type="handle" alias="FTPServer" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to deregister from"/>
                    <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                    <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                </function>
            </serves>
        </crown>
        <crown name="FTPClient">
            <trait>released</trait>
            <keywords>Ethernet</keywords>
            <links>FTPServer,FTPClient.setSecurityProtocol</links>
            <desc>Provides FTP/FTPS/SFTP client functionality.

Supports plain FTP, FTPS (FTP over SSL) and SFTP (SSH File Transfer Protocol). FTPS can be configured to be used in explicit or implicit mode. The specific protocol can be selected using the function FTPClient.setSecurityProtocol.

Important note: If your application design requires FTP connections to be kept open in idle mode you must use the setKeepAliveInterval()
function to enable keep-alive. Otherwise the internal connection is closed, resulting in an unnecessary reconnect when performing the
next active operation.</desc>
            <enum name="TransferMode">
                <item name="ASCII mode">ASCII</item>
                <item name="Binary mode">BINARY</item>
            </enum>
            <enum name="SecurityProtocol">
                <item name="None" desc="Plain FTP (no transport security)">NONE</item>
                <item name="FTPS explicit mode" desc="Require explicit FTP over TLS. Explicit mode: A plain FTP connection is established first, the client then requests to switch to TLS using the FTP command AUTH. This is the usual way to run FTPS.">FTPS_EXPLICIT</item>
                <item name="FTPS implicit mode" desc="Require implicit FTP over TLS. Implicit mode: A TLS session is established directly, without a previous negotiation via plain FTP. This is a more rare way to run FTPS.">FTPS_IMPLICIT</item>
                <item name="SFTP" desc="SFTP (SSH File Transfer Protocol)">SFTP</item>
            </enum>
            <serves>
                <event name="OnDisconnected">
                    <links>FTPClient.setKeepAliveInterval</links>
                    <desc>Event that is thrown when the FTPServer disconnects the connection. This is event is only notified when the function setKeepAliveInterval is used.</desc>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                </event>
                <function name="create">
                    <desc>Creates a new FTP client instance.</desc>
                    <sample for="lua">handle = FTPClient.create()</sample>
                    <return name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                </function>
                <function name="setIpAddress">
                    <desc>Configures the ip address to connect to.</desc>
                    <sample for="lua">FTPClient.setIpAddress(handle, "192.168.0.20")</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                    <param name="ipAddress" type="string" desc="IP address of the server."/>
                </function>
                <function name="setInterface">
                    <desc>Sets the interface to use for connecting.</desc>
                    <sample for="lua">FTPClient.setInterface(handle, "ETH1")</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                    <param name="ifName" type="enum" ref="EthernetInterfaces" desc="One of the available interfaces"/>
                </function>
                <function name="setPort">
                    <links>FTPClient.setSecurityProtocol</links>
                    <desc>Configures the port to connect to.
If not specified, the default behavior is to use the correct default port depending on the selected SecurityProtocol.
The default ports are: FTP and FTPS_EXPLICIT: 21. FTPS_IMPLICIT: 990. SFTP: 22.</desc>
                    <sample for="lua">FTPClient.setPort(handle, 1234)</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                    <param name="port" type="int" desc="Port for connection."/>
                </function>
                <function name="setConnectTimeout">
                    <desc>Configures the connect/accept timeout.</desc>
                    <sample for="lua">FTPClient.setConnectTimeout(handle, 1000)</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                    <param name="timeoutMs" type="int" desc="Timeout for connect/accept in milliseconds. Default is 5000ms."/>
                </function>
                <function name="setTransmitTimeout">
                    <desc>Configures the transmit timeout.</desc>
                    <sample for="lua">FTPClient.setTransmitTimeout(handle, 5000)</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                    <param name="timeoutMs" type="int" desc="Timeout for transmits in milliseconds. If not set the value of the connect timeout is used."/>
                </function>
                <function name="setSecurityProtocol">
                    <links>FTPClient.setSecurityProtocol,FTPClient.setCABundle,FTPClient.setPeerVerification,FTPClient.setHostnameVerification,FTPClient.setSSHKnownHostsFile,FTPClient.setSSHKeyFile</links>
                    <desc>Sets the security protocol to use.</desc>
                    <sample for="lua">FTPClient.setSecurityProtocol(handle, "FTPS_EXPLICIT")</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTPClient."/>
                    <param name="protocol" type="enum" ref="SecurityProtocol" desc="Security protocol and mode to use. Default is none (plain FTP without TLS). To use FTPS, a certificate authority bundle needs to be configured. See function setCABundle. To use SFTP, it is recommended to provide a known_hosts file using the function setSSHKnownHostsFile."/>
                </function>
                <function name="setLocalPortRange">
                    <desc>Configures the local source port range to use for outgoing TCP connections.
If this function is not used, the default behavior is to select a free local source port automatically.
Do not use this function unless the network environment makes it necessary, e.g. if a firewall which has such a rule is in place.</desc>
                    <sample for="lua">FTPClient.setLocalPortRange(handle, 49150, 65535)</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                    <param name="portRangeFrom" type="int" desc="Beginning of port range for local ports."/>
                    <param name="portRangeTo" type="int" desc="End of port range for local ports."/>
                </function>
                <function name="setClientCertificate">
                    <links>FTPClient.setSecurityProtocol</links>
                    <desc>Only relevant if FTPS is selected as security protocol, otherwise ignored.
Enables client authentication. A client certificate and a private key must be provided. The passphrase for the private key is optional. Supported file formats are PEM, DER and PKCS#12 (depending on SSL engine) for the client certificate and PEM and DER for the private key. The format is selected by inspecting the extension of the provided file. If no valid extension is specified the engine defaults to PEM format.</desc>
                    <sample for="lua">FTPClient.setClientCertificate(handle, "private/cert.pem", "private/privateKey.pem", "mypassphrase")</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTPClient."/>
                    <param name="certificateFile" type="string" desc="Path to a certificate file in PEM/DER/PKCS#12 format."/>
                    <param name="keyFile" type="string" desc="Path to file containing the client's private key in PEM/DER format."/>
                    <param name="passphrase" type="string" multiplicity="?" desc="Optional passphrase for the private key."/>
                </function>
                <function name="setCABundle">
                    <links>FTPClient.setSecurityProtocol</links>
                    <desc>Only relevant if FTPS is selected as security protocol, otherwise ignored.
Configures the certificate authority bundle to be used for verifying server certificates.</desc>
                    <sample for="lua">FTPClient.setCABundle(handle, "private/CA.pem")</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTPClient."/>
                    <param name="bundleFile" type="string" desc="Path to a certificate bundle in PEM format."/>
                </function>
                <function name="setPeerVerification">
                    <links>FTPClient.setSecurityProtocol</links>
                    <desc>Only relevant if FTPS is selected as security protocol, otherwise ignored.
Enables/disables peer verification. This can be useful when connecting to a site that is not using a certificate signed by one of the certs in the CA bundle. Disabling this verification makes the connection A LOT LESS SECURE.</desc>
                    <sample for="lua">FTPClient.setPeerVerification(handle, false)</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTPClient."/>
                    <param name="enabled" type="bool" desc="True to enable peer verification, false to disable. Default is enabled."/>
                </function>
                <function name="setHostnameVerification">
                    <links>FTPClient.setSecurityProtocol</links>
                    <desc>Only relevant if FTPS is selected as security protocol, otherwise ignored.
Enables/disables hostname verification. This can be useful if the site to connect to uses a different host name than what is mentioned in the server certificate commonName (or subjectAltName) fields. Disabling this verification makes the connection less secure.</desc>
                    <sample for="lua">FTPClient.setHostnameVerification(handle, false)</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTPClient."/>
                    <param name="enabled" type="bool" desc="True to enable hostname verification, false to disable. Default is enabled."/>
                </function>
                <function name="setSSHKnownHostsFile">
                    <links>FTPClient.setSecurityProtocol</links>
                    <desc>Only relevant if SFTP is selected as security protocol, otherwise ignored.
Sets the SSH known hosts file to use for SFTP connections.
If such a file is specified, FTPClient will only allow connections to servers that are known and present in that file.
If the file is not specified, the server identity will not be checked in any way.

Important Note: The supported Hostkey Types are: ssh-rsa, ssh-dss.</desc>
                    <sample for="lua">FTPClient.setSSHKnownHostsFile(handle, "resources/known_hosts")</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTPClient."/>
                    <param name="keyFile" type="string" multiplicity="?" desc="Location of the SSH known_hosts file. The known_hosts file should use the OpenSSH file format. Supported Hostkey Types: ssh-rsa, ssh-dss."/>
                </function>
                <function name="setSSHKeyFile">
                    <links>FTPClient.setSecurityProtocol</links>
                    <desc>Only relevant if SFTP is selected as security protocol, otherwise ignored.
TODO</desc>
                    <sample for="lua">FTPClient.setSSHKeyFile(handle, "private/cert.pem", "private/privateKey.pem", "mypassphrase")</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTPClient."/>
                    <param name="privateKeyFile" type="string" desc="Path to file containing the client private key in OpenSSH private key format (PKCS#1)."/>
                    <param name="passphrase" type="string" multiplicity="?" desc="Optional passphrase for the private key."/>
                    <param name="publicKeyFile" type="string" multiplicity="?" desc="Path to to file containing the client public key in OpenSSH Public Key Format (RFC 4253)."/>
                </function>
                <function name="connect">
                    <desc>Connect to a FTP server.</desc>
                    <sample for="lua">success = FTPClient.connect(handle, "user", "password")</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                    <param name="login" type="string" desc="User name for login."/>
                    <param name="password" type="string" desc="Login password."/>
                    <return name="success" type="bool" desc="Is true if connection is established, false if an error occurred"/>
                </function>
                <function name="disconnect">
                    <desc>Disconnect an open connection to a FTP server.</desc>
                    <sample for="lua">success = FTPClient.disconnect(handle)</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                    <return name="success" type="bool" desc="Is true if connection is closed, false if an error occurred"/>
                </function>
                <function name="setMode">
                    <links>FTPClient.setSecurityProtocol</links>
                    <desc>Sets the transfer mode for following file transfers.
This setting is ignored if SFTP is selected as security protocol.</desc>
                    <sample for="lua">success = FTPClient.setMode(handle, "binary")</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                    <param name="mode" type="enum" ref="TransferMode" desc="Transfer mode that is to be set."/>
                    <return name="success" type="bool" desc="Is true if mode has been set successfully, false if an error occurred"/>
                </function>
                <function name="cd">
                    <desc>Change the current directory on the server.</desc>
                    <sample for="lua">success = FTPClient.cd(handle, "/absolute/path")</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                    <param name="directory" type="string" desc="Directory to change to. Can be a relative or absolute path in FTP path notation."/>
                    <return name="success" type="bool" desc="Is true if directory has been changed successfully, false if an error occurred"/>
                </function>
                <function name="list">
                    <desc>List the content of a directory on the server.</desc>
                    <sample for="lua">success, directoryEntries = FTPClient.list(handle, "/absolute/path")</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                    <param name="directory" type="string" desc="Directory to list. Can be a relative or absolute path in FTP path notation."/>
                    <param name="onlyNames" type="bool" multiplicity="?" desc="If true (default), the FTP command NLST is used and only the names of the directory entries are returned.  If false, the FTP command LIST is used instead. LIST returns additional information about each file, but the format is server-specific."/>
                    <return name="success" type="bool" desc="Is true if directory has been listed successfully, false if an error occurred"/>
                    <return name="directoryEntries" type="string" multiplicity="*" desc="List of directory entries."/>
                </function>
                <function name="mkdir">
                    <desc>Create a directory on the server.</desc>
                    <sample for="lua">success = FTPClient.mkdir(handle, "/absolute/path")</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                    <param name="directory" type="string" desc="Directory to create. Can be a relative or absolute path in FTP path notation."/>
                    <return name="success" type="bool" desc="Is true if directory has been created successfully, false if an error occurred"/>
                </function>
                <function name="rmdir">
                    <desc>Remove a directory on the server.</desc>
                    <sample for="lua">success = FTPClient.rmdir(handle, "/absolute/path")</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                    <param name="directory" type="string" desc="Directory to remove. Can be a relative or absolute path in FTP path notation."/>
                    <return name="success" type="bool" desc="Is true if directory has been removed successfully, false if an error occurred"/>
                </function>
                <function name="rm">
                    <desc>Remove a file on the server.</desc>
                    <sample for="lua">success = FTPClient.rm(handle, "file.txt")</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                    <param name="filename" type="string" desc="File to remove. Can be a relative or absolute path in FTP path notation."/>
                    <return name="success" type="bool" desc="Is true if the file has been removed successfully, false if an error occurred."/>
                </function>
                <function name="rename">
                    <desc>Rename a file on the server.</desc>
                    <sample for="lua">success = FTPClient.rename(handle, "fileOld.txt", "fileNew.txt")</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                    <param name="filenameFrom" type="string" desc="File to rename. Can be a relative or absolute path in FTP path notation."/>
                    <param name="filenameTo" type="string" desc="New filename."/>
                    <return name="success" type="bool" desc="Is true if the file has been renamed successfully, false if an error occurred."/>
                </function>
                <function name="put">
                    <desc>Upload a file to the server.</desc>
                    <sample for="lua">success = FTPClient.put(handle, "/path/to/file", data)</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                    <param name="filename" type="string" desc="Target name of the file to upload. Can be a relative or absolute path in FTP path notation."/>
                    <param name="data" type="binary" desc="Content of the file to upload."/>
                    <param name="appendMode" type="bool" multiplicity="?" desc="Append mode. If true, the data is appended to the file if it already exists, otherwise the file is created. Default is false."/>
                    <return name="success" type="bool" desc="Is true if the file has been uploaded successfully, false if an error occurred."/>
                </function>
                <function name="get">
                    <desc>Download a file from the server.</desc>
                    <sample for="lua">success, data = FTPClient.get(handle, "/path/to/file")</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                    <param name="filename" type="string" desc="Target name of the file to download. Can be a relative or absolute path in FTP path notation."/>
                    <return name="success" type="bool" desc="Is true if the file has been downloaded successfully, false if an error occurred."/>
                    <return name="data" type="binary" desc="Content of the file."/>
                </function>
                <function name="putFile">
                    <desc>Upload a file to the server.</desc>
                    <sample for="lua">success = FTPClient.putFile(handle, "/path/to/file", "resources/file")</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                    <param name="remoteDestination" type="string" desc="Target name of the file to upload. Can be a relative or absolute path in FTP path notation."/>
                    <param name="localSource" type="string" desc="Source path of the file to upload."/>
                    <param name="appendMode" type="bool" multiplicity="?" desc="Append mode. If true, the data is appended to the file if it already exists, otherwise the file is created. Default is false."/>
                    <return name="success" type="bool" desc="Is true if the file has been uploaded successfully, false if an error occurred."/>
                </function>
                <function name="getFile">
                    <desc>Download a file from the server.</desc>
                    <sample for="lua">success = FTPClient.getFile(handle, "/path/to/file", "private/file")</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                    <param name="remoteSource" type="string" desc="Target name of the file to download. Can be a relative or absolute path in FTP path notation."/>
                    <param name="localDestination" type="string" desc="Destination path of the file to download."/>
                    <return name="success" type="bool" desc="Is true if the file has been downloaded successfully, false if an error occurred."/>
                </function>
                <function name="setPassiveMode">
                    <links>FTPClient.setSecurityProtocol</links>
                    <desc>Enable or disable the FTP passive mode. This can be done before connecting to a FTP server. Disabled passive mode is the default setting of the FTPClient.
This setting is ignored if SFTP is selected as security protocol.</desc>
                    <sample for="lua">success = FTPClient.setPassiveMode(handle, true)</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                    <param name="state" type="bool" desc="True set passive mode. False set active mode"/>
                    <return name="success" type="bool" desc="Is true if the operation was successful. If false, use getLastError for more details on the error"/>
                </function>
                <function name="setVerbose">
                    <desc>Tell the FTPClient to print log messages during the transfer. This includes the debug output of the curl library
This method must be called before connecting to the FTP server.</desc>
                    <sample for="lua">FTPClient.setVerbose(handle, true)</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                    <param name="state" type="bool" desc="True set the FTPClient in verbose state"/>
                </function>
                <function name="setKeepAliveInterval">
                    <links>FTPClient.OnDisconnected</links>
                    <desc>Activates sending of keep-alive commands with a given time period. A time periode of 0 disables sending of keep-alive commands. Can be executed before or during a FTP connection. If the connection is found to be not working anymore, the event FTPClient.OnDisconnected is notified.

This does not enable keep-alive on TCP level. Instead, a command is sent periodically to the server to make sure the connection still works. For FTP(S), this is the NOOP command. For SFTP, the content of the directory "/" is listed.</desc>
                    <sample for="lua">FTPClient.setKeepAliveInterval(handle, 30)</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                    <param name="sec" type="int" desc="Time periode in seconds."/>
                </function>
                <function name="getLastError">
                    <desc>Get information about the last FTPClient method invocation.
Returns error code and error text.
In case communication with an FTP server has taken place, the FTP server code is delivered as code. This might be a error code or a success code. See https://en.wikipedia.org/wiki/List_of_FTP_server_return_codes.
In case a libcurl error occurs it is returned as negative value. See https://curl.haxx.se/libcurl/c/libcurl-errors.html</desc>
                    <sample for="lua">errorCode, errorText = FTPClient.getLastError(handle)</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                    <return name="errorCode" type="int" desc="Error code of the FTP server"/>
                    <return name="errorText" type="string" desc="Additional information on the error"/>
                </function>
                <function name="isConnected">
                    <desc>Returns whether the FTP client is connected to a server</desc>
                    <sample for="lua">connectStatus = FTPClient.isConnected(handle)</sample>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle of the FTP client"/>
                    <return name="connectStatus" type="bool" desc="Is true if the connection exists"/>
                </function>
                <function name="register">
                    <desc>This function is used to register for any event of the handle.</desc>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to register to"/>
                    <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                    <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                </function>
                <function name="deregister">
                    <desc>This function is used to deregister from any registered event of the handle.</desc>
                    <param name="handle" type="handle" alias="FTPClient" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to deregister from"/>
                    <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                    <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                </function>
            </serves>
        </crown>
        <crown name="Script">
            <trait>released</trait>
            <exclude>ctrl-flow</exclude>
            <exclude>data-flow</exclude>
            <exclude>java</exclude>
            <exclude>remote</exclude>
            <desc>Provides general functions to communicate with the system and other Apps.
E.g. functions to register script functions/-events to the system, in order to call them from other CROWNS.
These functions are only available from scripting!</desc>
            <enum name="Priority">
                <item name="Low priority">LOW</item>
                <item name="Medium priority">MEDIUM</item>
                <item name="High priority">HIGH</item>
            </enum>
            <serves>
                <function name="serveFunction">
                    <desc>Use to publish a lua function, so it can be called from other Apps.
The function must be specified in the app manifest over the AppStudio AppProperties Serves-tab.
All calls of the served function are executed sequentially in the context of the serving application. Execution of the caller is deferred until the function returns. There is no need for additional synchronization.</desc>
                    <sample for="lua">Script.serveFunction("MyApp.MyFunction", "MyFunction")</sample>
                    <param name="crownFunctionName" type="string" desc="The name used in the CROWN system. The app name must be prefixed to have a full qualified CROWN name (e.g. 'MyApp.MyFunc')"/>
                    <param name="localFunctionName" type="string" alias="function" desc="Name of the function inside the lua script, e.g. 'MyFunc'"/>
                    <param name="parameterTypeList" type="string" multiplicity="?" desc="DEPRECATED! Not needed to be specified if the function is declared in the manifest over AppStudio AppProperties Serves-tab! Comma separated parameter definition list, e.g.: 'bool,string,int,object'. Types match the crown types. Syntax for one type: 'qualifier typename:multiplicity:alias'"/>
                    <param name="returnTypeList" type="string" multiplicity="?" desc="DEPRECATED! Not needed to be specified if the function is declared in the manifest over AppStudio AppProperties Serves-tab! Comma separated return value definition list, e.g.: 'bool,string,int,object'. Types match the crown types. Syntax for one type: 'qualifier typename:multiplicity:alias'"/>
                    <return name="success" type="bool" desc="True if successfully served,  false otherwise"/>
                </function>
                <function name="serveFunctionInCallerContext">
                    <trait>hidden</trait>
                    <desc>Use to publish a lua function, so it can be called from other Apps.
All calls to the served function are executed within the context of caller app. There is no thread changed. The order of the calls is not guaranteed.
The function call has no app context set. Functionality which needs it e.g. file-path handling do not work.
This is useful for passive library functions which should be faster and don't need the app context.</desc>
                    <sample for="lua">Script.serveFunctionInCallerContext("MyApp.MyFunction", "MyFunction")</sample>
                    <param name="crownFunctionName" type="string" desc="The name used in the CROWN system. The app name must be prefixed to have a full qualified CROWN name (e.g. 'MyApp.MyFunc')"/>
                    <param name="localFunctionName" type="string" alias="function" desc="Name of the function inside the lua script, e.g. 'MyFunc'"/>
                    <return name="success" type="bool" desc="True if successfully served,  false otherwise"/>
                </function>
                <function name="serveCreateFunction">
                    <trait>hidden</trait>
                    <desc>Call in order to serve a create function along with a handle-based Crown.</desc>
                    <sample for="lua">
          Script.serveCreateFunction("MyCrown","onCreate", "onDestroy")
          function onCreate(handle,param)
            _G[handle] = { param = param }
          end
          function onDestroy()
            _G[handle] = nil
          end
          </sample>
                    <param name="crownName" type="string" desc="The CROWN name (e.g. 'MyApp')"/>
                    <param name="onCreateFunctionName" type="string" alias="function" desc="Name of the onCreate function callback inside the lua script (e.g. 'onCreate'). Create a global state object in here. Use the given handle as identifier."/>
                    <param name="onDestroyFunctionName" type="string" alias="function" desc="Name of the onDestroy function callback inside the lua script, e.g. 'onCreate'. Destroy the global state object in here. Use the given handle as identifier."/>
                    <return name="success" type="bool" desc="True if serve was successful,  false otherwise"/>
                </function>
                <function name="serveEvent">
                    <desc>Call to publish an event, so other apps can register on.
The event must be specified in the app manifest over the AppStudio AppProperties Serves-tab.</desc>
                    <sample for="lua">Script.serveEvent("MyApp.MyEvent", "MyEvent")</sample>
                    <param name="crownEventName" type="string" desc="The name used in the CROWN system. The app name must be prefixed to have a full qualified CROWN name (e.g. 'MyApp.MyEvent')"/>
                    <param name="localEventName" type="string" desc="Name of the event inside the lua script. Use this name for the Script.notifyEvent() function."/>
                    <param name="parameterListType" type="string" multiplicity="?" desc="DEPRECATED! Not needed to be specified if the event is declared in the manifest over AppStudio AppProperties Serves-tab! Comma separated parameter definition list, e.g.: 'bool,string,int,object'. Types match the crown types. Syntax for one type: 'qualifier typename:multiplicity:alias'"/>
                    <return name="success" type="bool" desc="True if successfully served, false otherwise"/>
                </function>
                <function name="isEventRegistered">
                    <desc>Returns true if a served event has minimum one registration active.
Only works with events which were served by this script using the Script.serveEvent-function.</desc>
                    <sample for="lua">Script.isEventRegistered("MyEvent")</sample>
                    <param name="localEventName" type="string" desc="Name of the event which is to be notified. The event needs to match the localEventName used in ServeEvent-function."/>
                    <return name="success" type="bool" desc="True if there is minimum one registration active."/>
                    <return name="registrationCount" type="int" multiplicity="?" desc="If there is a registration, this value contains the number of registrations, otherwise nil."/>
                </function>
                <function name="notifyEvent">
                    <desc>Use to notify an event which was served by the Script.serveEvent function by this app.
Add any parameter to notify along with this event to the argument list.</desc>
                    <sample for="lua">Script.notifyEvent("MyEvent", value1, value2)</sample>
                    <param name="localEventName" type="string" desc="Name of the event which is to be notified. The event needs to match the localEventName used in ServeEvent-function."/>
                    <param name="parameters" type="auto" multiplicity="*" desc="Parameters to notify."/>
                    <return name="success" type="bool" desc="True if successfully notified, false otherwise"/>
                </function>
                <function name="notifyHandleEvent">
                    <trait>hidden</trait>
                    <desc>Same as notifyEvent but with a handle as first parameter</desc>
                    <sample for="lua">Script.notifyHandleEvent(handle,"OnMyEvent",params)</sample>
                    <param name="eventName" type="string" desc="Name of the event to be notified. The event needs to match the eventname used in ServeEvent function."/>
                    <param name="parameters" type="auto" multiplicity="*" desc="Parameters to notify."/>
                    <return name="success" type="bool" desc="True if successfully notified, false otherwise"/>
                </function>
                <function name="register">
                    <desc>Registers a function to an event.
Registrations are possible only once per function and event. Further register calls for same combination return false.
Registrations are always successfully done although the event might not be served already. In future the event still could get served and fired.
If successfully registered there is a second return value added which indicates if the registered event is currently served by someone.  This is useful to verify the wiring of an application.
All calls to the registered function are executed sequentially in the context of the registering application. Execution of the event notifier is not blocked and event callback calls are queued up at the registered application.
If there is a function pointer used for registering, the execution of the function always happens in the current script context (pay attention if registering another apps functions to use register function by name).</desc>
                    <sample for="lua">Script.register("Crown.Event","MyFunction")</sample>
                    <param name="eventName" type="string" desc="The event name to register to."/>
                    <param name="consumer" type="string" alias="function" desc="Name of the function to be called if the event occurs."/>
                    <return name="success" type="bool" desc="Returns true if successfully registered. False if the function is already registered on that event."/>
                    <return name="eventServed" type="bool" multiplicity="?" desc="If registration was successful, this second parameter is added. True if the registered event is really served by someone."/>
                </function>
                <function name="deregister">
                    <desc>Deregisters a function from an event, which was registered at the event before.
Deregistration are automatically done on script destruction.</desc>
                    <sample for="lua">Script.deregister("Crown.Event","MyFunction")</sample>
                    <param name="eventName" type="string" desc="The event name to deregister from."/>
                    <param name="consumer" type="string" alias="function" desc="The function name which was used for registering."/>
                    <return name="success" type="bool" desc="Returns true if successfully deregistered."/>
                </function>
                <function name="enterDebugger">
                    <trait>hidden</trait>
                    <desc>This function must be called in the lua script so that debugging is possible after the call of this function. Call it at the top of the script if you are not sure where to put this call to.</desc>
                    <sample for="lua"></sample>
                </function>
                <function name="startScript">
                    <trait>released</trait>
                    <desc>Starts a new script with specified filename in a new interpreter, running in a new task context.

This function is used to run several script tasks and interpreters inside a single app. One example where this is useful is if there are long-running blocking function calls, but the app should still stay responsive to events while these calls are executed. One way to realize this is is to use multiple apps, but using multiple scripts within one app has advantages: There is only one app that needs to be deployed, and the scripts within one app can share common lua code via require.

The started scripts can use the CROWN framework to communicate with each other, the same way that communication between separate apps works: Via serving and using of functions and events.

The script is started synchronous, so this function blocks until the main script scope of the newly started script has ran. After the main script scope has ran, the started script keeps active in the background and can react to events and functions calls to served functions. The lifetime of the script is bound to the app within it was started.

Limitations:
- The script file to be started must be located directly in the scripts/ directory of the app, it is not possible to start scripts which are located in a subdirectory.
- It is not possible to debug a script that is started with this function in AppStudio directly. A possible workaround is to manually change the startScript() call for the specific script to be debugged to a require() to make it execute directly in the context of the main script of the app.</desc>
                    <sample for="lua">local success = Script.startScript("somescript.lua")</sample>
                    <param name="fileName" type="string" desc="The file name of the Lua file which is to be started in a new interpreter. The file extension '.lua' can be omitted. The script file to be started must be located directly in the scripts/ directory of the app, it is not possible to start scripts which are located in a subdirectory."/>
                    <param name="argument" type="auto" multiplicity="[?*]" desc="Sets the argument value which the new script can access with 'Script.getStartArgument'. For multiple values use a Container object here. The values 'LOW','MEDIUM','HIGH' are reserved and used as priority value if specified due to compatibility reasons."/>
                    <param name="priority" type="enum" multiplicity="?" ref="Priority" desc="Priority of the task running the new interpreter. The available priority levels are the same as the levels that can be selected for an app in the app properties in AppStudio. The parameter is optional. By default, the priority of the script that calls the function is used. In case of the app main script, this is the app priority."/>
                    <return name="success" type="bool" desc="Returns true if the script file could be successfully loaded and started."/>
                </function>
                <function name="getStartArgument">
                    <desc>Returns the start argument which was possibly set by 'Script.startScript'.
The argument can only be retrieved once. Further calls will return nil. This is useful so that there is no endless reference hold to the argument value.</desc>
                    <return name="argument" type="auto" multiplicity="[?*]" desc="Returns the start argument or nil if not set."/>
                </function>
                <function name="sleep">
                    <desc>Stops the execution of the interpreter at the given position and releases the processor.
This can be used to delay the script at a given position.
The usage of this function should be avoided for released applications but can be useful for testing.
The script can be stopped also if it is sleeping at this position.
During sleeping the lua script cannot handle events or other function calls. They are queued up and will be handled if the caller of this sleep returns from the script.</desc>
                    <sample for="lua">Script.sleep(50)</sample>
                    <param name="sleepTimeMs" type="int" desc="The time in milliseconds to sleep. The effective sleept time could be higher."/>
                </function>
                <function name="disableGarbageCollectionByEngine">
                    <trait>released</trait>
                    <desc>Disables the automatic collectgarbage() calls by the engine for the current Lua script interpreter which are done after each script callback.

Per default there is a full garbage collector run done on leaving the interpreter, to avoid non-deterministic behaviour due to no released CROWN objects from the interpreter.
This disableGarbageCollectionByEngine()-function can be called at the beginning of a script in global scope to disable the automatic collectgarbage()-calls.

If this function is used, the user has to know how lua garbage collection works and needs to take care by himself of the garbage collector settings of the Lua interpreter.
The user also can manually release objects and handles using the function "Script.releaseObject".

For easier usage of disabled engine garbage collection, this function also changes the garbagecollector settings to the following more aggressive settings:
- collectgarbage("setpause", 100) -- means "no pause". Lua default is 200 which is that the collection cycle starts only when the used memory is doubled.
- collectgarbage("setstepmul", 400) -- increases the work which each incremental step does. Lua default is 200.

To tune the settings even more for your application, please read more about garbage collector in lua documentation.

Basic suggestion: If the memory increases in your application and memory isn't collected fast enough, increase the "setstepmul" to larger values than 400.</desc>
                    <sample for="lua">Script.disableGarbageCollectionByEngine()</sample>
                </function>
                <function name="releaseObject">
                    <trait>released</trait>
                    <desc>Explicitly releases an object or handle from the script.
If there is no one other holding a reference to the object, it is freed.
This is useful if the user does not want to wait until the garbage collector releases it but does it at an explicit location.</desc>
                    <sample for="lua">Script.releaseObject(obj)</sample>
                    <param name="objectToRelease" type="auto" multiplicity="[1+]" desc="The object(s) or handle(s) to release"/>
                </function>
                <function name="isServedAsFunction">
                    <trait>released</trait>
                    <desc>Returns true if the specified function name is served anywhere in the CROWN framework.
This is especially useful when calling dynamic functions and checking before if the function is still served and available.</desc>
                    <param name="funcName" type="string" desc="The function name which should be checked"/>
                    <return name="isServed" type="bool" desc="True if the specified function name is currently served as CROWN function in the framework"/>
                </function>
                <function name="isServedAsEvent">
                    <trait>released</trait>
                    <desc>Returns true if the specified event name is served anywhere in the CROWN framework.
This is especially useful when registering to dynamic events and checking before if the event is still served and available.</desc>
                    <param name="eventName" type="string" desc="The event name which should be checked"/>
                    <return name="isServed" type="bool" desc="True if the specified event name is currently served as CROWN event in the framework"/>
                </function>
                <function name="callFunction">
                    <trait>released</trait>
                    <desc>Call a CROWN function generically by name from a script context.
This is useful if the function name is set dynamically and not known.
This call blocks until the function has run and returns its return-values.</desc>
                    <sample for="lua">success, ret1, ret2 = Script.callFunction("theFuncName", param1, param2)</sample>
                    <param name="funcName" type="string" desc="The function name of the function to call"/>
                    <param name="param1" type="auto" multiplicity="[?*]" desc="First parameter for the function call (optional)"/>
                    <param name="param2" type="auto" multiplicity="[?*]" desc="second parameter for the function call (optional)"/>
                    <param name="param3" type="auto" multiplicity="[?*]" desc="third parameter for the function call (optional)"/>
                    <param name="param4" type="auto" multiplicity="[?*]" desc="fourth parameter for the function call (optional)"/>
                    <param name="param5" type="auto" multiplicity="[?*]" desc="fifth parameter for the function call (optional)"/>
                    <param name="param6" type="auto" multiplicity="[?*]" desc="sixth parameter for the function call (optional)"/>
                    <param name="param7" type="auto" multiplicity="[?*]" desc="seventh parameter for the function call (optional)"/>
                    <return name="success" type="bool" desc="True if the function has been called successfully, false if function name was not a valid served function or wrong parameters passed to call the function."/>
                    <return name="result1" type="auto" multiplicity="[?*]" desc="First result of the function call (optional)"/>
                    <return name="result2" type="auto" multiplicity="[?*]" desc="second result of the function call (optional)"/>
                    <return name="result3" type="auto" multiplicity="[?*]" desc="third result of the function call (optional)"/>
                    <return name="result4" type="auto" multiplicity="[?*]" desc="fourth result of the function call (optional)"/>
                    <return name="result5" type="auto" multiplicity="[?*]" desc="fifth result of the function call (optional)"/>
                    <return name="result6" type="auto" multiplicity="[?*]" desc="sixth result of the function call (optional)"/>
                    <return name="result7" type="auto" multiplicity="[?*]" desc="seventh result of the function call (optional)"/>
                </function>
                <function name="callFunctionAsync">
                    <trait>released</trait>
                    <desc>Call a CROWN function generically by name from a script context without waiting for the return value.
This is useful if the function name is set dynamically and not known.
This call does not block if the function is implemented in another thread/script and return-values are discarded.
The call isn't guaranteed to be run async: It depends on the implementation of the calling function.</desc>
                    <sample for="lua">success = Script.callFunctionAsync("theFuncName", param1, param2)</sample>
                    <param name="funcName" type="string" desc="The function name of the function to call"/>
                    <param name="param1" type="auto" multiplicity="[?*]" desc="First parameter for the function call (optional)"/>
                    <param name="param2" type="auto" multiplicity="[?*]" desc="second parameter for the function call (optional)"/>
                    <param name="param3" type="auto" multiplicity="[?*]" desc="third parameter for the function call (optional)"/>
                    <param name="param4" type="auto" multiplicity="[?*]" desc="fourth parameter for the function call (optional)"/>
                    <param name="param5" type="auto" multiplicity="[?*]" desc="fifth parameter for the function call (optional)"/>
                    <param name="param6" type="auto" multiplicity="[?*]" desc="sixth parameter for the function call (optional)"/>
                    <param name="param7" type="auto" multiplicity="[?*]" desc="seventh parameter for the function call (optional)"/>
                    <return name="success" type="bool" desc="True if the function has been called successfully, false if function name was not a valid served function"/>
                </function>
            </serves>
            <crown name="Queue">
                <trait>released</trait>
                <exclude>ctrl-flow</exclude>
                <exclude>data-flow</exclude>
                <exclude>java</exclude>
                <exclude>remote</exclude>
                <desc>Provides functionality to create new call queue.
Per default each script has a one single default call queue to which all incoming calls are enqueued as they come in.
Separate queues are useful to e.g. increase or decrease the queue priority or limit certain incoming events.

The default queue of the script has priority 'MID'.
All queues on the same priority are scheduled fair, which means each queue can process one queued call in each cycle.

The handle to the queue needs to be held so that the queue stays active. If the handle is lost, the events are enqueued again in the default queue and currently queued events are lost.

The limitation of queue sizes and discarding if full with the setMaxQueueSize and setDiscardIfFull functions is only possible, if the call is an event callback.
For served function executions the limitation is not possible, because the functions always need to be executable and need a return value.</desc>
                <enum name="Priority">
                    <desc>The relative priority for scripts compared to other queues</desc>
                    <item name="High">HIGH</item>
                    <item name="Middle (Default)">MID</item>
                    <item name="Low">LOW</item>
                </enum>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">-- Creates a new queue for the current running script with higher priority:
function myCallback()
end
queueHandle = Script.Queue.create()
queueHandle:setPriority("HIGH")
queueHandle:setFunction(myCallback)
-- Now register the callback at an event:
SomeProvider.register(provHandle, "OnSomeEvent", myCallback)</sample>
                        <return name="handle" type="handle" alias="Script.Queue" desc="Handle to the new instance"/>
                    </function>
                    <function name="setPriority">
                        <desc>Sets the relative priority of the queue compared to other queues of the script.
Per default the priority MID is set, if this function is not called</desc>
                        <sample for="lua">Script.Queue.setPriority(handle, "LOW")</sample>
                        <param name="handle" type="handle" alias="Script.Queue" desc="The instance to use"/>
                        <param name="prio" type="enum" ref="Priority" desc="The new priority to set"/>
                    </function>
                    <function name="setMaxQueueSize">
                        <desc>Sets the maximum queue size of the call queue.
This only works for event callbacks and not for function callbacks, because function calls always need a return value.
Per default the queue is set to infinite size (=0).
If the max queue size is reached, the oldest element is discarded per default. To change that behaviour use the setDiscardIfFull-Function.</desc>
                        <sample for="lua">Script.Queue.setMaxQueueSize(handle, 10)</sample>
                        <param name="handle" type="handle" alias="Script.Queue" desc="The instance to use"/>
                        <param name="maxQueueSize" type="int" desc="The max number of events to queue. Per default 0 (=infinite)"/>
                    </function>
                    <function name="setDiscardIfFull">
                        <desc>Sets the behaviour for adding events to the queue if the queue is full.
Per default the oldest element is discarded.
To discard the newest to be added element, call this function with parameter true.</desc>
                        <sample for="lua">Script.Queue.setDiscardIfFull(handle, true)</sample>
                        <param name="handle" type="handle" alias="Script.Queue" desc="The instance to use"/>
                        <param name="bDiscardIfFull" type="bool" desc="Set to true to discard the newest item which is currently added instead of discarding the oldest element"/>
                    </function>
                    <function name="setFunction">
                        <desc>Sets the function(s) which are handled by this queue.
After this call, the specified functions are removed from the default script queue and added to this queue.
So this call should be done as last call.
This can be a lua function reference or local function name, and also be a served function name.
To prioritize calls to a function served over Script.serveFunction, the served function name has to be used, and the function needs to be served before this call.</desc>
                        <sample for="lua">Script.Queue.setFunction(handle, callbackFunc)</sample>
                        <param name="handle" type="handle" alias="Script.Queue" desc="The instance to use"/>
                        <param name="function" type="string" multiplicity="[1+]" alias="function" desc="The function or array of functions which should be handled by this queue."/>
                    </function>
                    <function name="clear">
                        <desc>Clears all currently queued calls.
This only works for event callbacks and not for function callbacks, because function calls always need a return value.
Pay attention that directly during returning from this function there might be events already added again.</desc>
                        <sample for="lua">Script.Queue.clear(handle)</sample>
                        <param name="handle" type="handle" alias="Script.Queue" desc="The instance to use"/>
                    </function>
                    <function name="getSize">
                        <desc>Returns the current number of queue calls.
Pay attention that directly during returning from this function there might be events already added again.</desc>
                        <sample for="lua">size = Script.Queue.getSize(handle)</sample>
                        <param name="handle" type="handle" alias="Script.Queue" desc="The instance to use"/>
                        <return name="size" type="int" desc="The current queue size"/>
                    </function>
                </serves>
            </crown>
        </crown>
        <crown name="Conveyor">
            <trait>released</trait>
            <desc>Provides functionality for conveyor-based applications.
Most of the functions are based on the concept of increment count.
Absolute increment count values range from 0 to 65535.
Wraparound occurs when the maximum value is exceeded or when the increment goes below the minimum value.</desc>
            <enum name="TransportMode">
                <item name="Forward direction">FORWARD</item>
                <item name="Backward direction">BACKWARD</item>
            </enum>
            <serves>
                <event name="OnConveyorStarted">
                    <desc>The event which is triggered when the conveyor belt starts from a standstill.</desc>
                </event>
                <event name="OnConveyorStopped">
                    <desc>The event which is triggered when the conveyor belt stops.</desc>
                </event>
                <event name="OnConveyorTransportModeChanged">
                    <desc>The event which is triggered when the conveyor changes it's transport mode. There are ttwo physical transport modes, running forward (default) or backward. This is the physical behavior and independend from increment counting direction!.</desc>
                    <param name="transportMode" type="enum" ref="TransportMode" desc="Current transport mode direction (forward or backward)."/>
                </event>
                <function name="getCurrentIncrement">
                    <desc>Retrieve the current increment count value.</desc>
                    <sample for="lua">local incr = Conveyor.getCurrentIncrement()</sample>
                    <return name="increment" type="int" desc="Current increment value. The increment count is always between 0 and 65535."/>
                </function>
                <function name="setCurrentIncrement">
                    <desc>Set the current absolute increment count value.
Only works if the setSource-function is set to "LOCAL" increment source (which is the default).</desc>
                    <sample for="lua">Conveyor.setCurrentIncrement(1000)</sample>
                    <param name="increment" type="int" desc="The absolute increment value which is to be set. It must be within the range 0 to 65535. Values outside of this range are not allowed."/>
                    <return name="success" type="bool" desc="Returns true if the increment has been successfully set."/>
                </function>
                <function name="increaseCurrentIncrement">
                    <desc>Increases the current absolute increment count value by 1.
Only works if the setSource-function is set to "LOCAL" increment source (which is the default).
If the value is 65535 and it is increased, there is a wraparound to 0.</desc>
                    <sample for="lua">Conveyor.increaseCurrentIncrement()</sample>
                    <return name="success" type="bool" desc="Returns true if the increment has been successfully increased."/>
                </function>
                <function name="setResolution">
                    <desc>Set the desired resolution value.</desc>
                    <sample for="lua">Conveyor.setResolution(10000)</sample>
                    <param name="resolution" type="int" desc="The resolution in micrometer/increment."/>
                </function>
                <function name="getResolution">
                    <desc>Get the current resolution value.</desc>
                    <sample for="lua">resolution = Conveyor.getResolution()</sample>
                    <return name="resolution" type="int" desc="The resolution in micrometer/increment."/>
                </function>
                <function name="getSpeed">
                    <desc>Get the current conveyor speed.</desc>
                    <sample for="lua">speed = Conveyor.getSpeed()</sample>
                    <return name="speed" type="int" desc="The conveyor speed in millimeter/second."/>
                </function>
                <function name="setSource">
                    <desc>Select the increment source to be used for updating the system increment.
Set this to value "LOCAL" so that the "setCurrentIncrement" function works. Otherwise the increment is set by the source which is set to this function.
Default is set to the "LOCAL" increment source.</desc>
                    <sample for="lua">Conveyor.setSource("ENC1")</sample>
                    <param name="source" type="enum" ref="IncrementSources" desc="The increment source"/>
                    <return name="success" type="bool" desc="Returns true if the source has been selected successfully, false if not."/>
                </function>
                <function name="setIncrementUpdateTimeout">
                    <desc>Sets the increment update inactivity timeout after which the speed is reset to 0.
This only affects the internal speed calculation and only works if the increment is still updated.</desc>
                    <sample for="lua">Conveyor.setIncrementUpdateTimeout(1000)</sample>
                    <param name="timeoutMs" type="int" desc="Timeout in milliseconds or 0 to use the internal calculation (which uses 50 * lastUpdateInterval)."/>
                </function>
                <function name="getIncrementUpdateTimeout">
                    <desc>Gets the increment update inactivity timeout after which the speed is reset to 0.</desc>
                    <sample for="lua">timeoutMs = Conveyor.getIncrementUpdateTimeout()</sample>
                    <return name="timeoutMs" type="int" desc="Timeout in milliseconds or 0 if the internal calculation is used."/>
                </function>
                <function name="distanceToIncrement">
                    <desc>Calculates the increment value from a given distance value according to current resolution. If the result is bigger than the maximum increment value, the modulo function is used.</desc>
                    <sample for="lua">Conveyor.distanceToIncrement(50)</sample>
                    <param name="distance" type="int" desc="The distance in micrometer as positive integer value."/>
                    <return name="increment" type="int" desc="The increment value. The increment count is always between 0 and 65535."/>
                </function>
                <function name="incrementToDistance">
                    <desc>Calculates the distance value from a given increment value according to current resolution.</desc>
                    <sample for="lua">Conveyor.incrementToDistance(16348)</sample>
                    <param name="increment" type="int" desc="The increment value. The increment count is always between 0 and 65535. Values outside of this range are not allowed."/>
                    <return name="distance" type="int" desc="The distance in micrometer as positive integer value."/>
                </function>
                <function name="setPrescaler">
                    <desc>Prescaler value for the increment input.
If greater than 1 all increment values are scaled with this factor.
This can be used if the incoming values need a higher resolution than the increment should have.
Default is 1.</desc>
                    <sample for="lua">Conveyor.setPrescaler(prescaler)</sample>
                    <param name="prescaler" type="int" desc="The new prescaler value. Default is 1. Needs to be greater than zero."/>
                </function>
                <function name="getPrescaler">
                    <desc>Get the prescaler value for the increment input.</desc>
                    <sample for="lua">prescaler = Conveyor.getPrescaler()</sample>
                    <return name="prescaler" type="int" desc="The current value for the prescaler"/>
                </function>
            </serves>
            <crown name="Timeout">
                <trait>released</trait>
                <desc>Allows to register a timeout based on relative increment changes, both as increment count and increment distance.</desc>
                <serves>
                    <event name="OnExpired">
                        <desc>The event which is triggered when the timeout occurs.</desc>
                        <param name="handle" type="handle" alias="Conveyor.Timeout" desc="This is a handle event and must be registered on the handle"/>
                    </event>
                    <function name="create">
                        <desc>Creates a new conveyor timeout object.</desc>
                        <sample for="lua">handle = Conveyor.Timeout.create()</sample>
                        <return name="handle" type="handle" alias="Conveyor.Timeout" desc="The instance handle of the conveyor timeout object."/>
                    </function>
                    <function name="startCount">
                        <desc>Starts an increment count timeout with the specified increment count relative to the current one.</desc>
                        <sample for="lua">Conveyor.Timeout.startCount(handle, 1000)</sample>
                        <param name="handle" type="handle" alias="Conveyor.Timeout" desc="The instance handle of the conveyor timeout object."/>
                        <param name="increment" type="int" desc="The relative increment count after which the timeout should occur. Value must be between 0 and 32767"/>
                        <return name="success" type="bool" desc="Returns true if the timeout has been successfully started. False if timeout already running or increment count is out of range."/>
                    </function>
                    <function name="startDistance">
                        <desc>Starts an increment distance timeout with the specified distance relative to the current one.</desc>
                        <sample for="lua">Conveyor.Timeout.startDistance(handle, 50)</sample>
                        <param name="handle" type="handle" alias="Conveyor.Timeout" desc="The instance handle of the conveyor timeout object."/>
                        <param name="distance" type="int" desc="The relative increment distance in millimeter after which the timeout should occur. Value must be between 0 and INT32_MAX or the from-distance-calculated increment max. of 32767."/>
                        <return name="success" type="bool" desc="Returns true if the timeout has been successfully started. False if timeout already running or distance count is out of range."/>
                    </function>
                    <function name="stop">
                        <desc>Stops a pending increment timeout.</desc>
                        <sample for="lua">Conveyor.Timeout.stop(handle)</sample>
                        <param name="handle" type="handle" alias="Conveyor.Timeout" desc="The instance handle of the conveyor timeout object."/>
                        <return name="success" type="bool" desc="Returns true if the timeout has been successfully stopped. False if it was not running before."/>
                    </function>
                    <function name="register">
                        <desc>This function is used to register for any event of the handle.</desc>
                        <param name="handle" type="handle" alias="Conveyor.Timeout" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to register to"/>
                        <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                        <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                    </function>
                    <function name="deregister">
                        <desc>This function is used to deregister from any registered event of the handle.</desc>
                        <param name="handle" type="handle" alias="Conveyor.Timeout" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to deregister from"/>
                        <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                        <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                    </function>
                </serves>
            </crown>
        </crown>
        <crown name="Hash">
            <trait>released</trait>
            <desc>Namespace for different kinds of hash algorithms.
All algorithms have two usage possibilities depending on the users needs:
- calculate()-function: For single calculation of the input data and return of the hash value
- Create a handle: For multiple incremental calculations useful if the input data is fragmented
There are two result options:
- Default is as bytes in a binary buffer
- Alternative is as hex-ASCII values in a string</desc>
            <crown name="CRC32">
                <trait>released</trait>
                <desc>CRC32 hashing algorithm.
To possibilities for usage:
- Use the calculate()-function to calculate a single hash
- Create a handle: For multiple incremental calculations useful if the input data is fragmented
There are two result options:
- Default is as bytes in a binary buffer
- Alternative is as hex-ASCII values in a string</desc>
                <serves>
                    <function name="calculate">
                        <desc>Convenience function to do a single hash calculation in one function call.
The hash result is returned directly here as byte buffer.</desc>
                        <sample for="lua">hash = Hash.CRC32.calculate(buf)</sample>
                        <param name="data" type="binary" desc="The input data to calculate the hash"/>
                        <return name="hash" type="binary" desc="The hash result as byte buffer with size of 4 bytes"/>
                    </function>
                    <function name="calculateHex">
                        <desc>Convenience function to do a single hash calculation in one function call.
The hash result is returned directly here as hex-ASCII string.</desc>
                        <sample for="lua">hash = Hash.CRC32.calculateHex(buf)</sample>
                        <param name="data" type="binary" desc="The input data to calculate the hash"/>
                        <return name="hash" type="string" desc="The hash result as hex-ASCII string with size of 8 characters"/>
                    </function>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">handle = Hash.CRC32.create()</sample>
                        <return name="handle" type="handle" alias="Hash.CRC32" desc="Handle to the new instance"/>
                    </function>
                    <function name="update">
                        <desc>Update the hash object with the specified data.
This function can be called multiple times e.g. if not all data is currently available.</desc>
                        <param name="handle" type="handle" alias="Hash.CRC32" desc="The instance to use"/>
                        <param name="data" type="binary" desc="The input data to calculate the hash"/>
                    </function>
                    <function name="getHashValue">
                        <desc>Returns the current hash value as byte buffer.
The current hash value is based on the data which was added before with calls to the update()-function.</desc>
                        <sample for="lua">Hash.CRC32.getHashValue(buf)</sample>
                        <param name="handle" type="handle" alias="Hash.CRC32" desc="The instance to use"/>
                        <return name="hash" type="binary" desc="The hash result as byte buffer with size of 4 bytes"/>
                    </function>
                    <function name="getHashValueHex">
                        <desc>Returns the current hash value as hex-ASCII string.
The current hash value is based on the data which was added before with calls to the update()-function.</desc>
                        <sample for="lua">Hash.CRC32.getHashValueHex(buf)</sample>
                        <param name="handle" type="handle" alias="Hash.CRC32" desc="The instance to use"/>
                        <return name="hashString" type="string" desc="The hash result as hex-ASCII string with size of 8 characters"/>
                    </function>
                </serves>
            </crown>
            <crown name="MD5">
                <trait>released</trait>
                <desc>MD5 hashing algorithm.
To possibilities for usage:
- Use the calculate()-function to calculate a single hash
- Create a handle: For multiple incremental calculations useful if the input data is fragmented
There are two result options:
- Default is as bytes in a binary buffer
- Alternative is as hex-ASCII values in a string</desc>
                <serves>
                    <function name="calculate">
                        <desc>Convenience function to do a single hash calculation in one function call.
The hash result is returned directly here as byte buffer.</desc>
                        <sample for="lua">hash = Hash.MD5.calculate(buf)</sample>
                        <param name="data" type="binary" desc="The input data to calculate the hash"/>
                        <return name="hash" type="binary" desc="The hash result as byte buffer with size of 16 bytes"/>
                    </function>
                    <function name="calculateHex">
                        <desc>Convenience function to do a single hash calculation in one function call.
The hash result is returned directly here as hex-ASCII string.</desc>
                        <sample for="lua">hash = Hash.MD5.calculateHex(buf)</sample>
                        <param name="data" type="binary" desc="The input data to calculate the hash"/>
                        <return name="hash" type="string" desc="The hash result as hex-ASCII string with size of 32 characters"/>
                    </function>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">handle = Hash.MD5.create()</sample>
                        <return name="handle" type="handle" alias="Hash.MD5" desc="Handle to the new instance"/>
                    </function>
                    <function name="update">
                        <desc>Update the hash object with the specified data.
This function can be called multiple times e.g. if not all data is currently available.</desc>
                        <param name="handle" type="handle" alias="Hash.MD5" desc="The instance to use"/>
                        <param name="data" type="binary" desc="The input data to calculate the hash"/>
                    </function>
                    <function name="getHashValue">
                        <desc>Returns the current hash value as byte buffer.
The current hash value is based on the data which was added before with calls to the update()-function.</desc>
                        <sample for="lua">Hash.MD5.getHashValue(buf)</sample>
                        <param name="handle" type="handle" alias="Hash.MD5" desc="The instance to use"/>
                        <return name="hash" type="binary" desc="The hash result as byte buffer with size of 16 bytes"/>
                    </function>
                    <function name="getHashValueHex">
                        <desc>Returns the current hash value as hex-ASCII string.
The current hash value is based on the data which was added before with calls to the update()-function.</desc>
                        <sample for="lua">Hash.MD5.getHashValueHex(buf)</sample>
                        <param name="handle" type="handle" alias="Hash.MD5" desc="The instance to use"/>
                        <return name="hashString" type="string" desc="The hash result as hex-ASCII string with size of 32 characters"/>
                    </function>
                </serves>
            </crown>
            <crown name="SHA256">
                <trait>released</trait>
                <desc>SHA256 hashing algorithm.
To possibilities for usage:
- Use the calculate()-function to calculate a single hash
- Create a handle: For multiple incremental calculations useful if the input data is fragmented
There are two result options:
- Default is as bytes in a binary buffer
- Alternative is as hex-ASCII values in a string</desc>
                <serves>
                    <function name="calculate">
                        <desc>Convenience function to do a single hash calculation in one function call.
The hash result is returned directly here as byte buffer.</desc>
                        <sample for="lua">hash = Hash.SHA256.calculate(buf)</sample>
                        <param name="data" type="binary" desc="The input data to calculate the hash"/>
                        <return name="hash" type="binary" desc="The hash result as byte buffer with size of 32 bytes"/>
                    </function>
                    <function name="calculateHex">
                        <desc>Convenience function to do a single hash calculation in one function call.
The hash result is returned directly here as hex-ASCII string.</desc>
                        <sample for="lua">hash = Hash.SHA256.calculateHex(buf)</sample>
                        <param name="data" type="binary" desc="The input data to calculate the hash"/>
                        <return name="hash" type="string" desc="The hash result as hex-ASCII string with size of 64 characters"/>
                    </function>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">handle = Hash.SHA256.create()</sample>
                        <return name="handle" type="handle" alias="Hash.SHA256" desc="Handle to the new instance"/>
                    </function>
                    <function name="update">
                        <desc>Update the hash object with the specified data.
This function can be called multiple times e.g. if not all data is currently available.</desc>
                        <param name="handle" type="handle" alias="Hash.SHA256" desc="The instance to use"/>
                        <param name="data" type="binary" desc="The input data to calculate the hash"/>
                    </function>
                    <function name="getHashValue">
                        <desc>Returns the current hash value as byte buffer.
The current hash value is based on the data which was added before with calls to the update()-function.</desc>
                        <sample for="lua">Hash.SHA256.getHashValue(buf)</sample>
                        <param name="handle" type="handle" alias="Hash.SHA256" desc="The instance to use"/>
                        <return name="hash" type="binary" desc="The hash result as byte buffer with size of 32 bytes"/>
                    </function>
                    <function name="getHashValueHex">
                        <desc>Returns the current hash value as hex-ASCII string.
The current hash value is based on the data which was added before with calls to the update()-function.</desc>
                        <sample for="lua">Hash.SHA256.getHashValueHex(buf)</sample>
                        <param name="handle" type="handle" alias="Hash.SHA256" desc="The instance to use"/>
                        <return name="hashString" type="string" desc="The hash result as hex-ASCII string with size of 64 characters"/>
                    </function>
                </serves>
            </crown>
        </crown>
        <crown name="Cipher">
            <trait>released</trait>
            <desc>Namespace for different kinds of en- and decryption ciphers</desc>
            <serves/>
            <uses/>
            <crown name="AES">
                <trait>released</trait>
                <desc>AES cipher support</desc>
                <serves>
                    <function name="decrypt">
                        <desc>Decrypts AES-encrypted data (OpenAES compatible)</desc>
                        <sample for="lua">decrypted = Cipher.AES.decrypt(encryptedData, key)</sample>
                        <param name="encryptedData" type="binary" desc="The AES encrypted data to be decrypted"/>
                        <param name="key" type="binary" desc="The decryption key. Has to be 16, 24, or 32 bytes long (= 128, 192 or 256 bits)"/>
                        <return name="decryptedData" type="binary" desc="The decrypted result. When any encryption stage goes wrong, or an invalid AES key is passed, an empty binary result is returned"/>
                    </function>
                    <function name="encrypt">
                        <desc>Encrypts data. The mode of operation is CBC. An IV is generated randomly and stored in a OpenAES-compatible header that is part of the ciphertext (return value).</desc>
                        <sample for="lua">encrypted = Cipher.AES.encrypt(data, key)</sample>
                        <param name="data" type="binary" desc="The data to be encrypted"/>
                        <param name="key" type="binary" desc="The encryption key. Has to be 16, 24, or 32 bytes long (= 128, 192 or 256 bits)"/>
                        <return name="encryptedData" type="binary" desc="The encrypted result. When any decryption stage goes wrong, or an invalid AES key is passed, an empty binary result is returned"/>
                    </function>
                </serves>
            </crown>
            <crown name="Key">
                <trait>released</trait>
                <desc>Represents a key to be used in public-key cryptosystem.</desc>
                <enum name="Format">
                    <item desc="PEM format. PKI X.509 PEM format for public key, PKCS#8 PEM format for private key.">PEM</item>
                </enum>
                <serves>
                    <function name="encode">
                        <desc>Encodes a key into a binary buffer.</desc>
                        <sample for="lua">local keyBuf = Cipher.Key.encode(key, "PEM", "mypassphrase")</sample>
                        <param name="key" type="object" alias="Cipher.Key" desc="The instance object to use"/>
                        <param name="format" type="enum" ref="Format" desc="Optional passphrase."/>
                        <param name="passphrase" type="string" multiplicity="?" desc="Optional passphrase. Ignored if this is not a private key."/>
                        <return name="buffer" type="binary" multiplicity="?" desc="Returns binary representation of the key, or nil on error."/>
                    </function>
                </serves>
            </crown>
            <crown name="RSA">
                <trait>released</trait>
                <desc>RSA public-key cryptosystem support.</desc>
                <serves>
                    <function name="generateKeyPair">
                        <desc>Generates a RSA key pair and stores the keys in PEM file format.</desc>
                        <sample for="lua">local publicKey, privateKey = Cipher.RSA.generateKeyPair(2048)</sample>
                        <param name="size" type="int" desc="Length of the modulus in bits. Typical sizes are 2048 or 4096."/>
                        <return name="publicKey" type="object" multiplicity="?" alias="Cipher.Key" desc="The generated public key. Nil in case of error."/>
                        <return name="privateKey" type="object" multiplicity="?" alias="Cipher.Key" desc="The generated private key. Nil in case of error."/>
                    </function>
                </serves>
            </crown>
            <crown name="Certificate">
                <trait>released</trait>
                <desc>Functionality to work with X.509 certificates.</desc>
                <crown name="SigningRequest">
                    <trait>released</trait>
                    <desc>Allows to generate certificate signing requests according to the PKCS #10 specification.</desc>
                    <enum name="Format">
                        <item desc="PKCS#10 PEM format">PEM</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <desc>Creates a new certificate signing request instance.</desc>
                            <sample for="lua">local csr = Cipher.Certificate.SigningRequest.create()</sample>
                            <return name="handle" type="handle" alias="Cipher.Certificate.SigningRequest" desc="The instance handle for the certificate signing request."/>
                        </function>
                        <function name="setKeyPair">
                            <links>Cipher.RSA.generateKeyPair</links>
                            <desc>Sets the public key that will be included in the signing request and the private key that will be used to sign the request.</desc>
                            <sample for="lua">Cipher.Certificate.SigningRequest.setKeyPair(handle, publicKey, privateKey)</sample>
                            <param name="handle" type="handle" alias="Cipher.Certificate.SigningRequest" desc="The instance handle to use"/>
                            <param name="publicKey" type="object" alias="Cipher.Key" desc="The public key to include in the certificate signing request."/>
                            <param name="privateKey" type="object" alias="Cipher.Key" desc="The private key which is used to sign the certificate signing request."/>
                            <return name="success" type="bool" desc="Returns 'true' if key pair could be loaded successfully."/>
                        </function>
                        <function name="addSubjectField">
                            <desc>Adds a field to the subject of the certificate signing request. The subject of the certificate can consist of multiple fields, each field being a key/value-pair.</desc>
                            <sample for="lua">Cipher.Certificate.SigningRequest.addSubjectField(handle, "CN", "myCommonName")</sample>
                            <param name="handle" type="handle" alias="Cipher.Certificate.SigningRequest" desc="The instance handle to use"/>
                            <param name="subjectField" type="string" desc="The subject field to add"/>
                            <param name="value" type="string" desc="The value for this subject field"/>
                            <return name="success" type="bool" desc="Returns 'true' if subjectField could be added successfully."/>
                        </function>
                        <function name="encode">
                            <desc>Encodes the signed certificate signing request into a binary buffer.</desc>
                            <sample for="lua">local success = Cipher.Certificate.SigningRequest.encode(handle)</sample>
                            <param name="handle" type="handle" alias="Cipher.Certificate.SigningRequest" desc="The instance handle to use"/>
                            <param name="format" type="enum" ref="Format" desc="Optional passphrase."/>
                            <return name="csr" type="binary" multiplicity="?" desc="Returns binary representation of the certificate signing request, or nil on error."/>
                        </function>
                    </serves>
                </crown>
            </crown>
        </crown>
        <crown name="SerialCom">
            <trait>released</trait>
            <desc>Provides raw serial communication access.
First a new SerialCom client needs to be created using the create function.
Afterwards the baudrate and the other settings need to be done.
Then a call to the open-function opens the serial port and transmit calls and OnReceive events are possible.

Data could be transmitted to the server using the "transmit" function.
Data could be received by a register to the "OnReceive" event or by calling the blocking receive()-function.

The transmitted and received data is raw data. It could get automatically framed for transmitting and receiving can be automatically parsed if setting a framing with the "setFraming" function.

If a framing is set, there is a fix buffer size of receiving and transmitting which is 10240 bytes per default and can be changed using the setFramingBufferSize()-function.
Every data packet which is larger than this will be discarded.</desc>
            <serves>
                <event name="OnReceive">
                    <desc>The on receive event which is notified for every new received data.</desc>
                    <sample for="lua"></sample>
                    <param name="handle" type="handle" alias="SerialCom" desc="This is a handle event and must be registered on the handle"/>
                    <param name="data" type="binary" desc="The received data"/>
                </event>
                <function name="create">
                    <desc>Creates a serial communication interface instance if port exists and not already in use.</desc>
                    <sample for="lua">handle = SerialCom.create("SER1")</sample>
                    <param name="portName" type="enum" ref="SerialPorts" desc="The (device dependent) name of the serial port which should be opened."/>
                    <return name="ifHandle" type="handle" multiplicity="?" alias="SerialCom" desc="Handle to the Serial Communication Interface that has been returned by SerialCom.create(). Nil if not available or already in use."/>
                </function>
                <function name="setType">
                    <desc>Selects the type of the serial interface.
Default is 'RS232'.</desc>
                    <sample for="lua">SerialCom.setType(handle, "RS232")</sample>
                    <param name="ifHandle" type="handle" alias="SerialCom" desc="Handle to the Serial Communication Interface that has been returned by SerialCom.create()."/>
                    <param name="type" type="enum" ref="SerialComTypes" desc="Interface type which is available on the device. E.g. 'RS232', 'RS422', 'RS485'"/>
                </function>
                <function name="setTermination">
                    <desc>Enables the internal termination of the serial interface.
Default is 'false'.</desc>
                    <sample for="lua">SerialCom.setTermination(handle, true)</sample>
                    <param name="ifHandle" type="handle" alias="SerialCom" desc="Handle to the Serial Communication Interface that has been returned by SerialCom.create()."/>
                    <param name="terminated" type="bool" desc="true to enable internal termination, false to disable"/>
                </function>
                <function name="setBaudRate">
                    <desc>Sets the baudrate.
Default is '57600'.</desc>
                    <sample for="lua">SerialCom.setBaudRate(handle, 9600)</sample>
                    <param name="ifHandle" type="handle" alias="SerialCom" desc="Handle to the Serial Communication Interface that has been returned by SerialCom.create()."/>
                    <param name="baudRate" type="int" desc="One of 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200"/>
                </function>
                <function name="setParity">
                    <desc>Sets the parity.
Default is 'N'.</desc>
                    <sample for="lua">SerialCom.setParity(handle, "N")</sample>
                    <param name="ifHandle" type="handle" alias="SerialCom" desc="Handle to the Serial Communication Interface that has been returned by SerialCom.create()."/>
                    <param name="parity" type="char" desc="One of &quot;N&quot;, &quot;O&quot;, &quot;E&quot;, &quot;M&quot;, &quot;S&quot; (None, Odd, Even, Mark, Space)"/>
                </function>
                <function name="setDataBits">
                    <desc>Sets the number of data bits.
Default is '8'.</desc>
                    <sample for="lua">SerialCom.setDataBits(handle, 8)</sample>
                    <param name="ifHandle" type="handle" alias="SerialCom" desc="Handle to the Serial Communication Interface that has been returned by SerialCom.create()."/>
                    <param name="dataBits" type="int" desc="8 or 7"/>
                </function>
                <function name="setStopBits">
                    <desc>Sets the number of stop bits.
Default is '1'.</desc>
                    <sample for="lua">SerialCom.setStopBits(handle, 1)</sample>
                    <param name="ifHandle" type="handle" alias="SerialCom" desc="Handle to the Serial Communication Interface that has been returned by SerialCom.create()."/>
                    <param name="stopBits" type="int" desc="1 or 2"/>
                </function>
                <function name="setFlowControl">
                    <desc>Enables or disables hardware flow control.
Default is 'false'.</desc>
                    <sample for="lua">SerialCom.setFlowControl(handle, false)</sample>
                    <param name="ifHandle" type="handle" alias="SerialCom" desc="Handle to the Serial Communication Interface that has been returned by SerialCom.create()."/>
                    <param name="enabled" type="bool" desc="true to enable flow control, false to disable"/>
                </function>
                <function name="setHandshake">
                    <desc>Enables or disables handshake.
Default is 'false'.</desc>
                    <sample for="lua">SerialCom.setHandshake(handle, true)</sample>
                    <param name="ifHandle" type="handle" alias="SerialCom" desc="Handle to the Serial Communication Interface that has been returned by SerialCom.create()."/>
                    <param name="enabled" type="bool" desc="true to enable Xon/Xoff handshake, false to disable"/>
                </function>
                <function name="setReceiveQueueSize">
                    <desc>Sets the internal queue size for the receive()-function.
Default is 10 packets and discarding the oldest item and warn if overrun occurs.
Set to 0 to disable the queue and receiving from the receive()-function, which also increases performance if only receiving over OnReceive-event.</desc>
                    <sample for="lua">SerialCom.setReceiveQueueSize(handle, 50)</sample>
                    <param name="handle" type="handle" alias="SerialCom" desc="The instance handle of the UDP socket"/>
                    <param name="queueSize" type="int" desc="The new receive queue size."/>
                    <param name="bDiscardIfFull" type="bool" multiplicity="?" desc="Set to true to discard the newest item which is currently added instead of discarding the oldest element. Default is false."/>
                    <param name="warnOverruns" type="bool" multiplicity="?" desc="Set to false to disable warning on overruns when using the receive()-function. Default is true."/>
                </function>
                <function name="open">
                    <desc>Opens the serial connection that has been configured with the set* functions.</desc>
                    <sample for="lua">success = SerialCom.open(handle)</sample>
                    <param name="ifHandle" type="handle" alias="SerialCom" desc="Handle to the Serial Communication Interface that has been returned by SerialCom.create()."/>
                    <return name="isOpen" type="bool" desc="Returns true if interface could be opened. If false, the port might be in use already."/>
                </function>
                <function name="close">
                    <desc>Closes the serial handle.</desc>
                    <sample for="lua">SerialCom.close(handle)</sample>
                    <param name="ifHandle" type="handle" alias="SerialCom" desc="Handle to the Serial Communication Interface that has been returned by SerialCom.create()."/>
                </function>
                <function name="isOpened">
                    <desc>Determine whether the serial port is open or not.</desc>
                    <sample for="lua">isOpen = SerialCom.isOpened(handle)</sample>
                    <param name="ifHandle" type="handle" alias="SerialCom" desc="Handle to the Serial Communication Interface that has been returned by SerialCom.create()."/>
                    <return name="isOpen" type="bool" desc="true if the COM port is open, false if not"/>
                </function>
                <function name="transmit">
                    <desc>Transmits the data on the serial handle.
If framing is set using the "setFraming" function, then the framing characters are automatically prefixed and suffixed to the transmitted data.
Blocks until data has been transmitted.</desc>
                    <sample for="lua">SerialCom.transmit(handle, "data to transmit")</sample>
                    <param name="ifHandle" type="handle" alias="SerialCom" desc="Handle to the Serial Communication Interface that has been returned by SerialCom.create()."/>
                    <param name="data" type="binary" desc="The data which should be sent"/>
                    <return name="numberOfBytesTransmitted" type="int" desc="Number of bytes transmitted; 0 if transmit failed"/>
                </function>
                <function name="receive">
                    <desc>Receives data from the client with a specified timeout.
If timeout is zero then it directly returns.
The data could be framed if the "setFraming" function was called before.
Incoming data between multiple receive calls is queued per message.
There is a fix receive queue size of 10 packets per default and can be changed using the setReceiveQueueSize()-function. More data is discarded.</desc>
                    <sample for="lua">data = SerialCom.receive(handle, 5000)</sample>
                    <param name="ifHandle" type="handle" alias="SerialCom" desc="Handle to the Serial Communication Interface that has been returned by SerialCom.create()."/>
                    <param name="timeout" type="int" multiplicity="?" desc="Timeout in ms to wait for received data. 0 is default and means directly return."/>
                    <return name="data" type="binary" desc="The data which was received"/>
                </function>
                <function name="setFraming">
                    <desc>Sets the framing which is to be used.
If not set the default framing is no framing (raw byte/packet-wise connection).
Framing could be also explicitly disabled by calling this function with 2 empty binary data for rx and tx.
One framing part could be maximum size of 9 bytes.

If a framing is set, there is a fix buffer size of receiving and transmitting which is 10240 bytes per default and can be changed using the setFramingBufferSize()-function.
Every data packet which is larger than this will be discarded.

The close and open functions has to be called afterwards so that the setting gets active.</desc>
                    <sample for="lua">SerialCom.setFraming(handle, "", "", "", "")</sample>
                    <param name="handle" type="handle" alias="SerialCom" desc="Handle to the Serial Communication Interface that has been returned by SerialCom.create()."/>
                    <param name="rxStart" type="binary" desc="Start framing for receiving, could be empty string. Maximum size of 9."/>
                    <param name="rxStop" type="binary" desc="Stop framing for receiving. If empty then all raw data is received. Maximum size of 9."/>
                    <param name="txStart" type="binary" desc="Start framing for sending, could be empty string. Maximum size of 9."/>
                    <param name="txStop" type="binary" desc="Stop framing for sending, could be empty string. Maximum size of 9."/>
                </function>
                <function name="setFramingBufferSize">
                    <desc>Sets the size of the internal framing parser buffer which is used if there is a rx or tx framing set using the setFraming function.
If the rx or tx framing isn't set, its buffer size has no effect.
This size is the maximum size of a packet which can be parsed by the framing.
The size is used for start and stop framing.
Default is 10240 bytes.

The close and open functions have to be called afterwards for activating the setting.</desc>
                    <sample for="lua">SerialCom.setFramingBufferSize(handle, 21000, 21000)</sample>
                    <param name="handle" type="handle" alias="SerialCom" desc="Handle to the Serial Communication Interface that has been returned by SerialCom.create()."/>
                    <param name="rxBufSize" type="int" desc="The new framing buffer size for framed receiving."/>
                    <param name="txBufSize" type="int" desc="The new framing buffer size for framed transmitting."/>
                </function>
                <function name="register">
                    <desc>This function is used to register for any event of the handle.</desc>
                    <param name="handle" type="handle" alias="SerialCom" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to register to"/>
                    <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                    <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                </function>
                <function name="deregister">
                    <desc>This function is used to deregister from any registered event of the handle.</desc>
                    <param name="handle" type="handle" alias="SerialCom" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to deregister from"/>
                    <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                    <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                </function>
            </serves>
        </crown>
        <crown name="DigitalLogic">
            <trait>released</trait>
            <desc>Contains DigitalLogic elements to be used in Control Flows.</desc>
            <crown name="Delay">
                <trait>released</trait>
                <exclude>java</exclude>
                <exclude>script</exclude>
                <exclude>remote</exclude>
                <desc>Delays incoming signals for a given delay.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">handle = DigitalLogic.Delay.create()</sample>
                        <return name="handle" type="handle" alias="DigitalLogic.Delay" desc="Handle to the new instance"/>
                    </function>
                    <function name="setDelayTime">
                        <desc>Time in milliseconds or microseconds for the delay.
Resolution depends on the used delay function delay or highAccuracyDelay.</desc>
                        <sample for="lua">DigitalLogic.Delay.setDelayTime(handle, 10)</sample>
                        <param name="handle" type="handle" alias="DigitalLogic.Delay" desc="The instance handle to use"/>
                        <param name="delayTime" type="int" desc="Time in milliseconds or microseconds. Resolution depends on the used function (delay or highAccuracyDelay)."/>
                    </function>
                    <function name="setDelayDistance">
                        <desc>Distance in mm or increment ticks.
Resolution depends on the used function (delay or highAccuracyDelay).</desc>
                        <sample for="lua">DigitalLogic.Delay.setDelayDistance(handle, 100)</sample>
                        <param name="handle" type="handle" alias="DigitalLogic.Delay" desc="The instance handle to use"/>
                        <param name="delayDistance" type="int" desc="Distance in mm or increment ticks. Resolution depends on the used function (delay or highAccuracyDelay)."/>
                    </function>
                    <function name="setMaxQueueSize">
                        <desc>Maximum number of queued signals (0: unlimited). Affects only delay, not highAccuracyDelay.</desc>
                        <sample for="lua">DigitalLogic.Delay.setMaxQueueSize(handle, 100)</sample>
                        <param name="handle" type="handle" alias="DigitalLogic.Delay" desc="The instance handle to use"/>
                        <param name="maxQueueSize" type="int" desc="Maximum number of queued signals (0: unlimited)"/>
                    </function>
                    <function name="delay">
                        <include>ctrl-flow</include>
                        <include>data-flow</include>
                        <desc>Starts a delay with a millisecond or mm resolution.</desc>
                        <sample for="lua">delayedSignal=DigitalLogic.Delay.delay(handle, signal)</sample>
                        <param name="handle" type="handle" alias="DigitalLogic.Delay" desc="The instance handle to use"/>
                        <param name="signal" type="bool" desc="The state of the level/Dirac signal to delay"/>
                        <return name="delayedSignal" type="bool" desc="The state of the delayed level/Dirac signal"/>
                    </function>
                    <function name="highAccuracyDelay">
                        <include>ctrl-flow</include>
                        <exclude>data-flow</exclude>
                        <desc>Starts a delay with a microsecond or increment tick resolution.</desc>
                        <sample for="lua">delayedSignal=DigitalLogic.Delay.highAccuracyDelay(handle, signal)</sample>
                        <param name="handle" type="handle" alias="DigitalLogic.Delay" desc="The instance handle to use"/>
                        <param name="signal" type="bool" desc="The state of the level signal to delay"/>
                        <return name="delayedSignal" type="bool" desc="The state of the delayed level signal"/>
                    </function>
                </serves>
            </crown>
            <crown name="EdgeDetector">
                <trait>released</trait>
                <desc>Detects edges in a level signal and generates Dirac signals for the falling and rising edge.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">handle = DigitalLogic.EdgeDetector.create()</sample>
                        <return name="handle" type="handle" alias="DigitalLogic.EdgeDetector" desc="Handle to the new instance"/>
                    </function>
                    <function name="detect">
                        <include>ctrl-flow</include>
                        <include>data-flow</include>
                        <desc>Detects edges in a level based signal and generates Dirac signals.</desc>
                        <sample for="lua">risingEdge, fallingEdge = DigitalLogic.EdgeDetector.detect(handle, level)</sample>
                        <param name="handle" type="handle" alias="DigitalLogic.EdgeDetector" desc="The instance handle to use"/>
                        <param name="level" type="bool" desc="The state of the level signal"/>
                        <return name="risingEdge" type="bool" multiplicity="?" desc="Creates a Dirac signal if a rising edge is detected in the level signal."/>
                        <return name="fallingEdge" type="bool" multiplicity="?" desc="Creates a Dirac signal if a falling edge is detected in the level signal."/>
                    </function>
                </serves>
            </crown>
            <crown name="TFlipFlop">
                <trait>released</trait>
                <desc>Toggle a level signal from high to low or vice versa on each incoming Dirac signal.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">handle = DigitalLogic.TFlipFlop.create()</sample>
                        <return name="handle" type="handle" alias="DigitalLogic.TFlipFlop" desc="Handle to the new instance"/>
                    </function>
                    <function name="toggle">
                        <include>ctrl-flow</include>
                        <include>data-flow</include>
                        <desc>Toggle a level signal from high to low or vice versa on each incoming Dirac signal. The default state is low.</desc>
                        <sample for="lua">level = DigitalLogic.TFlipFlop.toggle(handle, signal)</sample>
                        <param name="handle" type="handle" alias="DigitalLogic.TFlipFlop" desc="The instance handle to use"/>
                        <param name="signal" type="bool" desc="The incoming Dirac signal"/>
                        <return name="level" type="bool" desc="The resulting level signal"/>
                    </function>
                </serves>
            </crown>
            <crown name="Gate">
                <trait>released</trait>
                <desc>Logical gate functions implemented in hardware or software.</desc>
                <enum name="Affinity">
                    <item name="Bound to software">SW</item>
                    <item name="Bound to hardware">HW</item>
                </enum>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">handle = DigitalLogic.Gate.create()</sample>
                        <return name="handle" type="handle" alias="DigitalLogic.Gate" desc="Handle to the new instance"/>
                    </function>
                    <function name="setAffinity">
                        <exclude>data-flow</exclude>
                        <exclude>java</exclude>
                        <exclude>script</exclude>
                        <exclude>remote</exclude>
                        <desc>Changes the affinity of the control flow block</desc>
                        <sample for="lua">DigitalLogic.Gate.setAffinity(handle, newAffinity)</sample>
                        <param name="handle" type="handle" alias="DigitalLogic.Gate" desc="The instance handle to use"/>
                        <param name="value" type="enum" ref="Affinity" desc="Affinity of the gate block."/>
                    </function>
                    <function name="not">
                        <include>ctrl-flow</include>
                        <include>data-flow</include>
                        <desc>Invert the input signal with a logical NOT.</desc>
                        <sample for="lua">level = DigitalLogic.Gate.not(handle, levelA)</sample>
                        <param name="handle" type="handle" alias="DigitalLogic.Gate" desc="The instance handle to use"/>
                        <param name="levelA" type="bool" desc="The state of the input signal"/>
                        <return name="level" type="bool" desc="Resulting output signal of the logical NOT, only if state changed."/>
                    </function>
                    <function name="and">
                        <include>ctrl-flow</include>
                        <include>data-flow</include>
                        <desc>Combine the input signals with a logical AND.</desc>
                        <sample for="lua">level = DigitalLogic.Gate.and(handle, levelA, levelB, levelC, levelD)</sample>
                        <param name="handle" type="handle" alias="DigitalLogic.Gate" desc="The instance handle to use"/>
                        <param name="levelA" type="bool" multiplicity="?" desc="The state of the first signal"/>
                        <param name="levelB" type="bool" multiplicity="?" desc="The state of the second signal"/>
                        <param name="levelC" type="bool" multiplicity="?" desc="The state of the third optional signal"/>
                        <param name="levelD" type="bool" multiplicity="?" desc="The state of the fourth optional signal"/>
                        <return name="level" type="bool" desc="Resulting output signal of the logical AND, only if state changed."/>
                    </function>
                    <function name="or">
                        <include>ctrl-flow</include>
                        <include>data-flow</include>
                        <desc>Combine the input signals with a logical OR.</desc>
                        <sample for="lua">level = DigitalLogic.Gate.or(handle, levelA, levelB, levelC, levelD)</sample>
                        <param name="handle" type="handle" alias="DigitalLogic.Gate" desc="The instance handle to use"/>
                        <param name="levelA" type="bool" multiplicity="?" desc="The state of the first signal"/>
                        <param name="levelB" type="bool" multiplicity="?" desc="The state of the second signal"/>
                        <param name="levelC" type="bool" multiplicity="?" desc="The state of the third optional signal"/>
                        <param name="levelD" type="bool" multiplicity="?" desc="The state of the fourth optional signal"/>
                        <return name="level" type="bool" desc="Resulting output signal of the logical OR, only if state changed."/>
                    </function>
                    <function name="xor">
                        <include>ctrl-flow</include>
                        <include>data-flow</include>
                        <desc>Combine the input signals with a logical XOR.
If only one of the input signals is high, the output is high.
Attention: Also if three of the input signals are high, the output is still low (this is different than the 3-way xor definition).</desc>
                        <sample for="lua">level = DigitalLogic.Gate.xor(handle, levelA, levelB, levelC, levelD)</sample>
                        <param name="handle" type="handle" alias="DigitalLogic.Gate" desc="The instance handle to use"/>
                        <param name="levelA" type="bool" multiplicity="?" desc="The state of the first signal"/>
                        <param name="levelB" type="bool" multiplicity="?" desc="The state of the second signal"/>
                        <param name="levelC" type="bool" multiplicity="?" desc="The state of the third optional signal"/>
                        <param name="levelD" type="bool" multiplicity="?" desc="The state of the fourth optional signal"/>
                        <return name="level" type="bool" desc="Resulting output signal of the logical XOR, only if state changed."/>
                    </function>
                    <function name="nand">
                        <include>ctrl-flow</include>
                        <include>data-flow</include>
                        <desc>Combine the input signals with a logical NAND.</desc>
                        <sample for="lua">level = DigitalLogic.Gate.nand(handle, levelA, levelB, levelC, levelD)</sample>
                        <param name="handle" type="handle" alias="DigitalLogic.Gate" desc="The instance handle to use"/>
                        <param name="levelA" type="bool" multiplicity="?" desc="The state of the first signal"/>
                        <param name="levelB" type="bool" multiplicity="?" desc="The state of the second signal"/>
                        <param name="levelC" type="bool" multiplicity="?" desc="The state of the third optional signal"/>
                        <param name="levelD" type="bool" multiplicity="?" desc="The state of the fourth optional signal"/>
                        <return name="level" type="bool" desc="Resulting output signal of the logical NAND, only if state changed."/>
                    </function>
                    <function name="nor">
                        <include>ctrl-flow</include>
                        <include>data-flow</include>
                        <desc>Combine the input signals with a logical NOR.</desc>
                        <sample for="lua">level = DigitalLogic.Gate.nor(handle, levelA, levelB, levelC, levelD)</sample>
                        <param name="handle" type="handle" alias="DigitalLogic.Gate" desc="The instance handle to use"/>
                        <param name="levelA" type="bool" multiplicity="?" desc="The state of the first signal"/>
                        <param name="levelB" type="bool" multiplicity="?" desc="The state of the second signal"/>
                        <param name="levelC" type="bool" multiplicity="?" desc="The state of the third optional signal"/>
                        <param name="levelD" type="bool" multiplicity="?" desc="The state of the fourth optional signal"/>
                        <return name="level" type="bool" desc="Resulting output signal of the logical NOR, only if state changed."/>
                    </function>
                    <function name="xnor">
                        <include>ctrl-flow</include>
                        <include>data-flow</include>
                        <desc>Combine the input signals with a logical XNOR.
If only one of the input signals is high, the output is low.
Attention: Also if three of the input signals are high, the output is still high (this is different than the 3-way xnor definition).</desc>
                        <sample for="lua">level = DigitalLogic.Gate.xnor(handle, levelA, levelB, levelC, levelD)</sample>
                        <param name="handle" type="handle" alias="DigitalLogic.Gate" desc="The instance handle to use"/>
                        <param name="levelA" type="bool" multiplicity="?" desc="The state of the first signal"/>
                        <param name="levelB" type="bool" multiplicity="?" desc="The state of the second signal"/>
                        <param name="levelC" type="bool" multiplicity="?" desc="The state of the third optional signal"/>
                        <param name="levelD" type="bool" multiplicity="?" desc="The state of the fourth optional signal"/>
                        <return name="level" type="bool" desc="Resulting output signal of the logical XNOR, only if state changed."/>
                    </function>
                </serves>
            </crown>
        </crown>
        <crown name="Encoder">
            <trait>released</trait>
            <enum name="Direction">
                <item name="Forward Direction">FORWARD</item>
                <item name="Backward Direction">BACKWARD</item>
            </enum>
            <enum name="DecoderCountMode">
                <item name="Bidirectional" desc="Counts up in Encoder forward / backward direction">BIDIRECTIONAL</item>
                <item name="Positive Movement" desc="Counts up in Encoder forward direction / counts down in Encoder backward direction">POSITIVE_MOVEMENT</item>
                <item name="Negative Movement" desc="Counts down in Encoder forward direction / counts up in Encoder backward direction">NEGATIVE_MOVEMENT</item>
                <item name="Forward Movement" desc="Counts up in Encoder forward direction / no count in Encoder backward direction">FORWARD_MOVEMENT</item>
                <item name="Backward Movement" desc="No count in Encoder forward direction / counts up in Encoder backward direction">BACKWARD_MOVEMENT</item>
            </enum>
            <enum name="DecoderPhases">
                <item name="Single Phase">SINGLE_PHASE</item>
                <item name="Dual Phase">DUAL_PHASE</item>
            </enum>
            <serves>
                <function name="create">
                    <desc>Creates an encoder with the given name if exists and not already in use.</desc>
                    <sample for="lua">handle = Encoder.create("ENC1")</sample>
                    <param name="encSrc" type="enum" ref="EncoderIncrementSources" desc="The devices identifier of the encoder (e.g. ENC1)"/>
                    <return name="handle" type="handle" multiplicity="?" alias="Encoder" desc="Unique handle for the encoder. Nil if not available or already in use."/>
                </function>
                <function name="getCurrentIncrement">
                    <desc>Retrieve the current increment count value and corresponding timestamp.</desc>
                    <sample for="lua">local incr, timestamp = Encoder.getCurrentIncrement()</sample>
                    <param name="handle" type="handle" alias="Encoder" desc="The instance handle of the encoder object."/>
                    <return name="increment" type="int" desc="Current increment value."/>
                    <return name="timestamp" type="int" desc="Current timestamp in microseconds."/>
                </function>
                <function name="getTicksPerSecond">
                    <desc>Retrieve the current speed value (increment/sec).</desc>
                    <sample for="lua">local ticksPerSecond = Encoder.getTicksPerSecond()</sample>
                    <param name="handle" type="handle" alias="Encoder" desc="The instance handle of the encoder object."/>
                    <return name="ticksPerSecond" type="int" desc="Current ticks per second value."/>
                </function>
                <function name="getDirection">
                    <desc>Retrieve the current direction (forward/backward).</desc>
                    <sample for="lua">local direction = Encoder.getDirection()</sample>
                    <param name="handle" type="handle" alias="Encoder" desc="The instance handle of the encoder object."/>
                    <return name="direction" type="enum" ref="Direction" desc="Current direction (forward/backward)."/>
                </function>
                <function name="setCountMode">
                    <desc>Select how increments will be counted</desc>
                    <sample for="lua">Encoder.setCountMode(handle, mode)</sample>
                    <param name="handle" type="handle" alias="Encoder" desc="The instance handle to use"/>
                    <param name="mode" type="enum" ref="DecoderCountMode" desc="The decoder count mode to set"/>
                </function>
                <function name="setNumberOfPhases">
                    <desc>Select single phase (using A_in) or dual phase (using A_in and B_in)</desc>
                    <sample for="lua">Encoder.setNumberOfPhases(handle, singlePhase)</sample>
                    <param name="handle" type="handle" alias="Encoder" desc="The instance handle to use"/>
                    <param name="singlePhase" type="enum" ref="DecoderPhases" desc="Single/Dual Phase"/>
                </function>
                <function name="setSource">
                    <desc>Sets source for the increment decoder input. Could be either an increment connector (external) or an encoder generator (internal) which could be used for fixed speed.</desc>
                    <sample for="lua">Encoder.setSource(handle, sourceHandle)</sample>
                    <param name="handle" type="handle" alias="Encoder" desc="The instance handle to use"/>
                    <param name="sourceHandle" type="handle" desc="Handle of the connected input source."/>
                </function>
            </serves>
            <crown name="Timeout">
                <trait>hidden</trait>
                <desc>Allows to register a timeout based on relative increment changes, both as increment count and increment distance.</desc>
                <serves>
                    <event name="OnExpired">
                        <desc>The event which is triggered when the timeout occurs.</desc>
                        <param name="handle" type="handle" alias="Encoder.Timeout" desc="This is a handle event and must be registered on the handle"/>
                    </event>
                    <function name="create">
                        <desc>Creates a new encoder timeout object.</desc>
                        <sample for="lua">handle = Encoder.Timeout.create()</sample>
                        <return name="handle" type="handle" alias="Encoder.Timeout" desc="The instance handle of the encoder timeout object."/>
                    </function>
                    <function name="startCount">
                        <desc>Starts an increment count timeout.</desc>
                        <sample for="lua">Encoder.Timeout.startCount(handle, 1000)</sample>
                        <param name="handle" type="handle" alias="Encoder.Timeout" desc="The instance handle of the encoder timeout object."/>
                        <param name="increment" type="int" desc="The relative increment count after which the timeout should occur."/>
                        <return name="success" type="bool" desc="Returns true if the timeout has been successfully started."/>
                    </function>
                    <function name="stop">
                        <desc>Stops a pending increment timeout.</desc>
                        <sample for="lua">Encoder.Timeout.stop(handle)</sample>
                        <param name="handle" type="handle" alias="Encoder.Timeout" desc="The instance handle of the encoder timeout object."/>
                        <return name="success" type="bool" desc="Returns true if the timeout has been successfully stopped."/>
                    </function>
                    <function name="register">
                        <desc>This function is used to register for any event of the handle.</desc>
                        <param name="handle" type="handle" alias="Encoder.Timeout" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to register to"/>
                        <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                        <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                    </function>
                    <function name="deregister">
                        <desc>This function is used to deregister from any registered event of the handle.</desc>
                        <param name="handle" type="handle" alias="Encoder.Timeout" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to deregister from"/>
                        <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                        <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                    </function>
                </serves>
            </crown>
            <crown name="Decoder">
                <trait>released</trait>
                <exclude>script</exclude>
                <desc>Consumer block for the increment decoder.</desc>
                <enum name="DecoderCountMode">
                    <item name="Bidirectional" desc="Counts up in Encoder forward / backward direction">BIDIRECTIONAL</item>
                    <item name="Positive Movement" desc="Counts up in Encoder forward direction / counts down in Encoder backward direction">POSITIVE_MOVEMENT</item>
                    <item name="Negative Movement" desc="Counts down in Encoder forward direction / counts up in Encoder backward direction">NEGATIVE_MOVEMENT</item>
                    <item name="Forward Movement" desc="Counts up in Encoder forward direction / no count in Encoder backward direction">FORWARD_MOVEMENT</item>
                    <item name="Backward Movement" desc="No count in Encoder forward direction / counts up in Encoder backward direction">BACKWARD_MOVEMENT</item>
                </enum>
                <enum name="DecoderPhases">
                    <item name="Single Phase">SINGLE_PHASE</item>
                    <item name="Dual Phase">DUAL_PHASE</item>
                </enum>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">handle = Encoder.Decoder.create()</sample>
                        <param name="instance" type="enum" ref="EncoderDecoderInstance" desc="The instance of the decoder module"/>
                        <return name="handle" type="handle" alias="Encoder.Decoder" desc="Handle to the new instance"/>
                    </function>
                    <function name="setHighResolution">
                        <desc>true=high resolution, false=robust mode</desc>
                        <sample for="lua">Encoder.Decoder.setHighResolution(handle, highRes)</sample>
                        <param name="handle" type="handle" alias="Encoder.Decoder" desc="The instance handle to use"/>
                        <param name="highRes" type="bool" desc=""/>
                    </function>
                    <function name="setCountMode">
                        <desc>Select how increments will be counted</desc>
                        <sample for="lua">Encoder.Decoder.setCountMode(handle, mode)</sample>
                        <param name="handle" type="handle" alias="Encoder.Decoder" desc="The instance handle to use"/>
                        <param name="mode" type="enum" ref="DecoderCountMode" desc=""/>
                    </function>
                    <function name="setPrescaler">
                        <desc>Prescaler value for the increment input.</desc>
                        <sample for="lua">Encoder.Decoder.setPrescaler(handle, prescaler)</sample>
                        <param name="handle" type="handle" alias="Encoder.Decoder" desc="The instance handle to use"/>
                        <param name="prescaler" type="int" desc="The new prescaler value. Default is 1. Needs to be greater than zero."/>
                    </function>
                    <function name="setNumberOfPhases">
                        <desc>Select single phase (using A_in) or dual phase (using A_in and B_in)</desc>
                        <sample for="lua">Encoder.Decoder.setNumberOfPhases(handle, singlePhase)</sample>
                        <param name="handle" type="handle" alias="Encoder.Decoder" desc="The instance handle to use"/>
                        <param name="singlePhase" type="enum" ref="DecoderPhases" desc="Single/Dual Phase"/>
                    </function>
                    <function name="decodeIncrement">
                        <include>ctrl-flow</include>
                        <desc>Link the pins.</desc>
                        <sample for="lua">Encoder.Decoder.decodeIncrement(handle, A_in, B_in)</sample>
                        <param name="handle" type="handle" alias="Encoder.Decoder" desc="The instance handle to use"/>
                        <param name="A_in" type="bool" desc="The new state for pin pair A+/A- of the increment decoder."/>
                        <param name="B_in" type="bool" desc="The new state for pin pair B+/B- of the increment decoder."/>
                    </function>
                </serves>
            </crown>
            <crown name="Generator">
                <trait>released</trait>
                <desc>Provider block for increment generator.</desc>
                <serves>
                    <event name="OnIncrement">
                        <include>ctrl-flow</include>
                        <exclude>script</exclude>
                        <desc>Link the pins in the FPGA's IO-multiplexer.</desc>
                        <sample for="lua">Encoder.Generator.OnIncrement(handle, A_out, B_out)</sample>
                        <param name="handle" type="handle" alias="Encoder.Generator" desc="The instance handle to use"/>
                        <param name="A_out" type="bool" desc="Signal from pin pair A+/A- of the increment generator."/>
                        <param name="B_out" type="bool" desc="Signal from pin pair B+/B- of the increment generator."/>
                    </event>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">handle = Encoder.Generator.create("ENC1")</sample>
                        <param name="instance" type="enum" ref="EncoderGeneratorInstance" desc="The instance of the generator module"/>
                        <return name="handle" type="handle" alias="Encoder.Generator" desc="Handle to the new instance"/>
                    </function>
                    <function name="setSource">
                        <exclude>script</exclude>
                        <desc>Select the increment source</desc>
                        <sample for="lua">Encoder.Generator.setSource(handle, source)</sample>
                        <param name="handle" type="handle" alias="Encoder.Generator" desc="The instance handle to use"/>
                        <param name="source" type="enum" ref="EncoderGeneratorSources" desc="The device dependent name of the increment source"/>
                    </function>
                    <function name="setPrescaler">
                        <desc>Prescaler value for external trigger</desc>
                        <sample for="lua">Encoder.Generator.setPrescaler(handle, prescale)</sample>
                        <param name="handle" type="handle" alias="Encoder.Generator" desc="The instance handle to use"/>
                        <param name="prescaler" type="int" desc="The new prescaler value. Default is 1. Needs to be greater than zero."/>
                    </function>
                    <function name="setSpeed">
                        <desc>Speed of the generator in Hz</desc>
                        <sample for="lua">Encoder.Generator.setSpeed(handle, speed)</sample>
                        <param name="handle" type="handle" alias="Encoder.Generator" desc="The instance handle to use"/>
                        <param name="speed" type="int" desc=""/>
                    </function>
                    <function name="setDirection">
                        <desc>Forward or backward increment</desc>
                        <sample for="lua">Encoder.Generator.setDirection(handle, direction)</sample>
                        <param name="handle" type="handle" alias="Encoder.Generator" desc="The instance handle to use"/>
                        <param name="direction" type="enum" ref="Direction" desc="Forward/Backward"/>
                    </function>
                    <function name="getName">
                        <trait>hidden</trait>
                        <desc>Get generator name.</desc>
                        <sample for="lua">name = Encoder.Generator.getName(handle)</sample>
                        <param name="handle" type="handle" alias="Encoder.Generator" desc="The instance handle to use"/>
                        <return name="name" type="string" desc="Encoder.Generator name."/>
                    </function>
                </serves>
            </crown>
        </crown>
        <crown name="NTPClient">
            <trait>released</trait>
            <desc>Offers access to control the NPTClient of the device.
There can be only one NPTClient running on one defined ethernet interface.
Also there can be only one controlling the NTPClient, therefore the handle can only be instantiated once.

If the handle is destructed, the last NTP configuration keeps active and NTPClient stays running if activated.</desc>
            <enum name="TimeSource">
                <item name="Manual" desc="Don't update the time over NTP">MANUAL</item>
                <item name="NTP" desc="Update the time over NTP">NTP</item>
            </enum>
            <serves>
                <function name="create">
                    <desc>Creates a handle to the NTPClient. Only one instance can be acquired.</desc>
                    <sample for="lua">handle = NTPClient.create()</sample>
                    <return name="handle" type="handle" multiplicity="?" alias="NTPClient" desc="Unique handle for the NTPClient. nil if there is already another instance or if the device has no NTP functionality."/>
                </function>
                <function name="startManualRequest">
                    <desc>Trigger a NTP request manually now.
TimeSource needs to be set to 'NTP' so that this function works, otherwise returns false.
This function does not block until the request is over, it just triggers an asynchronous start of a request.</desc>
                    <sample for="lua">success = NTPClient.startManualRequest(handle)</sample>
                    <param name="handle" type="handle" alias="NTPClient" desc="The instance handle of the NTPClient object."/>
                    <return name="success" type="bool" desc="True if request was successfully triggered, false if not possible because not configured to NTP or internal error."/>
                </function>
                <function name="setTimeSource">
                    <desc>Configures the source of the system time.</desc>
                    <sample for="lua">success = NTPClient.setTimeSource(handle, "MANUAL")</sample>
                    <param name="handle" type="handle" alias="NTPClient" desc="The instance handle of the NTPClient object."/>
                    <param name="source" type="enum" ref="TimeSource" desc="System time source."/>
                    <return name="success" type="bool" desc="True if successfully set, false if not."/>
                </function>
                <function name="setInterface">
                    <desc>Sets the interface to use for connecting.</desc>
                    <sample for="lua">NTPClient.setInterface(handle, "ETH1")</sample>
                    <param name="handle" type="handle" alias="NTPClient" desc="The instance handle of the NTPClient object."/>
                    <param name="ifName" type="enum" ref="EthernetInterfaces" desc="One of the available interfaces"/>
                </function>
                <function name="setServerAddress">
                    <desc>Sets the NTP server address.</desc>
                    <sample for="lua">NTPClient.setServerAddress(handle, "192.168.0.1")</sample>
                    <param name="handle" type="handle" alias="NTPClient" desc="The instance handle of the NTPClient object."/>
                    <param name="address" type="string" desc="Address of the NTP server."/>
                </function>
                <function name="setServerPort">
                    <desc>Sets the NTP server port.</desc>
                    <sample for="lua">NTPClient.setServerPort(handle, 12345)</sample>
                    <param name="handle" type="handle" alias="NTPClient" desc="The instance handle of the NTPClient object."/>
                    <param name="port" type="int" desc="Port of the NTP server."/>
                </function>
                <function name="setTimeout">
                    <desc>Sets the timeout for NTP requests in milliseconds.</desc>
                    <sample for="lua">NTPClient.setTimeout(handle, 5000)</sample>
                    <param name="handle" type="handle" alias="NTPClient" desc="The instance handle of the NTPClient object."/>
                    <param name="timeout" type="int" desc="Timeout in milliseconds."/>
                </function>
                <function name="setApplyEnabled">
                    <desc>Enables or disables the application of the timestamp received by NTP to the system time.</desc>
                    <sample for="lua">NTPClient.setApplyEnabled(handle, false)</sample>
                    <param name="handle" type="handle" alias="NTPClient" desc="The instance handle of the NTPClient object."/>
                    <param name="state" type="bool" desc="Set to true to apply NTP time to system time. If set to false the NTP time is just printed to the log."/>
                </function>
                <function name="setPeriodicUpdateEnabled">
                    <desc>Enables or disables periodic NTP requests.
Per default, the periodic update is enabled if time source is set to 'NTP'.</desc>
                    <sample for="lua">NTPClient.setPeriodicUpdateEnabled(handle, true)</sample>
                    <param name="handle" type="handle" alias="NTPClient" desc="The instance handle of the NTPClient object."/>
                    <param name="state" type="bool" desc="Set to true to request time updates from NTP in 10 minute intervals. If set to false you must trigger requests manually by using startManualRequest()."/>
                </function>
            </serves>
        </crown>
        <crown name="LUA">
            <trait>hidden</trait>
            <exclude>ctrl-flow</exclude>
            <exclude>data-flow</exclude>
            <exclude>script</exclude>
            <exclude>remote</exclude>
            <exclude>java</exclude>
            <desc>Dummy CROWN which contains all LUA interpreter internal functions and standard library functions.
This should be part of the device manifests so that this is version-ed with the LUA interpreter version.
All functions and libraries below this node are interpreted by AppStudio and automatically put to the root node of the programming input helper.</desc>
            <serves>
                <function name="require">
                    <desc>Opens and calls a lua module. A module is a lua-file. The global scope of the lua-file is executed and imported into calling file.
The module path is without the ".lua" extension. Subpaths are separated by "." and are an absolute path based on the project root.</desc>
                    <param name="modulePath" type="string" desc="Module path separated by '.'"/>
                </function>
                <function name="assert">
                    <desc>Calls error if the value of its argument v is false (i.e., nil or false); otherwise, returns all its arguments. In case of error, message is the error object; when absent, it defaults to "assertion failed!"</desc>
                    <param name="v" type="bool" desc=""/>
                    <param name="message" type="string" desc=""/>
                </function>
                <function name="collectgarbage">
                    <desc>This function is a generic interface to the garbage collector. It performs different functions according to its first argument, opt:

"collect": performs a full garbage-collection cycle. This is the default option.
"stop": stops automatic execution of the garbage collector. The collector will run only when explicitly invoked, until a call to restart it.
"restart": restarts automatic execution of the garbage collector.
"count": returns the total memory in use by Lua in Kbytes. The value has a fractional part, so that it multiplied by 1024 gives the exact number of bytes in use by Lua (except for overflows).
"step": performs a garbage-collection step. The step "size" is controlled by arg. With a zero value, the collector will perform one basic (indivisible) step. For non-zero values, the collector will perform as if that amount of memory (in KBytes) had been allocated by Lua. Returns true if the step finished a collection cycle.
"setpause": sets arg as the new value for the pause of the collector (see 2.5). Returns the previous value for pause.
"setstepmul": sets arg as the new value for the step multiplier of the collector (see 2.5). Returns the previous value for step.
"isrunning": returns a boolean that tells whether the collector is running (i.e., not stopped).</desc>
                    <param name="opt" type="string" multiplicity="?" desc="Default is 'collect'"/>
                    <param name="arg" type="int" multiplicity="?" desc="value is dependent on the opt"/>
                </function>
                <function name="error">
                    <desc>Terminates the last protected function called and returns message as the error object. Function error never returns.

Usually, error adds some information about the error position at the beginning of the message, if the message is a string. The level argument specifies how to get the error position. With level 1 (the default), the error position is where the error function was called. Level 2 points the error to where the function that called error was called; and so on. Passing a level 0 avoids the addition of error position information to the message.</desc>
                </function>
                <function name="getmetatable">
                    <desc>If object does not have a metatable, returns nil. Otherwise, if the object's metatable has a "__metatable" field, returns the associated value. Otherwise, returns the metatable of the given object.</desc>
                    <param name="object" type="auto" desc=""/>
                    <return name="table" type="auto" multiplicity="?" desc="table"/>
                </function>
                <function name="ipairs">
                    <desc>Returns three values (an iterator function, the table t, and 0) so that the construction

for i,v in ipairs(t) do body end

will iterate over the key-value pairs (1,t[1]), (2,t[2]), ..., up to the first nil value.</desc>
                    <param name="t" type="auto" desc="table"/>
                    <return name="iterator" type="auto" desc="function"/>
                    <return name="t" type="auto" desc="table"/>
                    <return name="0" type="int" desc="constant 0"/>
                </function>
                <function name="load">
                    <desc>Loads a chunk.

If chunk is a string, the chunk is this string. If chunk is a function, load calls it repeatedly to get the chunk pieces. Each call to chunk must return a string that concatenates with previous results. A return of an empty string, nil, or no value signals the end of the chunk.

If there are no syntactic errors, returns the compiled chunk as a function; otherwise, returns nil plus the error message.

If the resulting function has upvalues, the first upvalue is set to the value of env, if that parameter is given, or to the value of the global environment. Other upvalues are initialized with nil. (When you load a main chunk, the resulting function will always have exactly one upvalue, the _ENV variable (see 2.2). However, when you load a binary chunk created from a function (see string.dump), the resulting function can have an arbitrary number of upvalues.) All upvalues are fresh, that is, they are not shared with any other function.

chunkname is used as the name of the chunk for error messages and debug information (see 4.9). When absent, it defaults to chunk, if chunk is a string, or to "=(load)" otherwise.

The string mode controls whether the chunk can be text or binary (that is, a precompiled chunk). It may be the string "b" (only binary chunks), "t" (only text chunks), or "bt" (both binary and text). The default is "bt".

Lua does not check the consistency of binary chunks. Maliciously crafted binary chunks can crash the interpreter.</desc>
                    <param name="chunk" type="auto" desc=""/>
                    <param name="chunkname" type="string" multiplicity="?" desc=""/>
                    <param name="mode" type="string" multiplicity="?" desc=""/>
                    <param name="env" type="auto" multiplicity="?" desc=""/>
                </function>
                <function name="loadfile">
                    <trait>hidden</trait>
                    <desc></desc>
                </function>
                <function name="loadstring">
                    <trait>deprecated</trait>
                    <desc>DEPRECATED</desc>
                </function>
                <function name="next">
                    <desc>Allows a program to traverse all fields of a table. Its first argument is a table and its second argument is an index in this table. next returns the next index of the table and its associated value. When called with nil as its second argument, next returns an initial index and its associated value. When called with the last index, or with nil in an empty table, next returns nil. If the second argument is absent, then it is interpreted as nil. In particular, you can use next(t) to check whether a table is empty.

The order in which the indices are enumerated is not specified, even for numeric indices. (To traverse a table in numerical order, use a numerical for.)

The behavior of next is undefined if, during the traversal, you assign any value to a non-existent field in the table. You may however modify existing fields. In particular, you may clear existing fields.</desc>
                    <param name="table" type="auto" desc="table"/>
                    <param name="index" type="int" desc=""/>
                    <return name="index" type="int" desc=""/>
                    <return name="value" type="auto" desc=""/>
                </function>
                <function name="pairs">
                    <desc>If t has a metamethod __pairs, calls it with t as argument and returns the first three results from the call.

Otherwise, returns three values: the next function, the table t, and nil, so that the construction

for k,v in pairs(t) do body end

will iterate over all key-value pairs of table t.

See function next for the caveats of modifying the table during its traversal.</desc>
                    <param name="t" type="auto" desc="table"/>
                    <return name="iterator" type="auto" desc="function"/>
                    <return name="t" type="auto" desc="table"/>
                </function>
                <function name="pcall">
                    <desc>Calls function f with the given arguments in protected mode. This means that any error inside f is not propagated; instead, pcall catches the error and returns a status code. Its first result is the status code (a boolean), which is true if the call succeeds without errors. In such case, pcall also returns all results from the call, after this first result. In case of any error, pcall returns false plus the error message.</desc>
                    <param name="f" type="auto" desc="function"/>
                    <param name="arg1" type="auto" desc=""/>
                    <param name="argN" type="auto" multiplicity="*" desc=""/>
                </function>
                <function name="print">
                    <desc>Receives any number of arguments and prints their values to stdout, using the tostring function to convert each argument to a string. print is not intended for formatted output, but only as a quick way to show a value, for instance for debugging. For complete control over the output, use string.format.</desc>
                    <param name="x1" type="auto" desc=""/>
                    <param name="xN" type="auto" multiplicity="*" desc=""/>
                </function>
                <function name="rawequal">
                    <desc>Checks whether v1 is equal to v2, without invoking any metamethod. Returns a boolean.</desc>
                    <param name="v1" type="auto" desc=""/>
                    <param name="v2" type="auto" desc=""/>
                    <return name="equal" type="bool" desc=""/>
                </function>
                <function name="rawget">
                    <desc>Gets the real value of table[index], without invoking any metamethod. table must be a table; index may be any value.</desc>
                    <param name="table" type="auto" desc=""/>
                    <param name="index" type="int" desc=""/>
                    <return name="value" type="auto" desc=""/>
                </function>
                <function name="rawlen">
                    <desc>Returns the length of the object v, which must be a table or a string, without invoking any metamethod. Returns an integer number.</desc>
                    <param name="v" type="auto" desc=""/>
                    <return name="len" type="int" desc=""/>
                </function>
                <function name="rawset">
                    <desc>Sets the real value of table[index] to value, without invoking any metamethod. table must be a table, index any value different from nil and NaN, and value any Lua value.

This function returns table.</desc>
                    <param name="table" type="auto" desc=""/>
                    <param name="index" type="int" desc=""/>
                    <param name="value" type="auto" desc=""/>
                </function>
                <function name="select">
                    <desc>If index is a number, returns all arguments after argument number index; a negative number indexes from the end (-1 is the last argument). Otherwise, index must be the string "##", and select returns the total number of extra arguments it received.</desc>
                    <param name="index" type="int" desc=""/>
                    <param name="a1" type="auto" desc=""/>
                    <param name="aN" type="auto" desc=""/>
                    <return name="x1" type="auto" desc=""/>
                    <return name="xN" type="auto" multiplicity="*" desc=""/>
                </function>
                <function name="setmetatable">
                    <desc>Sets the metatable for the given table. (You cannot change the metatable of other types from Lua, only from C.) If metatable is nil, removes the metatable of the given table. If the original metatable has a "__metatable" field, raises an error.

This function returns table.</desc>
                    <param name="table" type="auto" desc=""/>
                    <param name="metatable" type="auto" desc=""/>
                    <return name="table" type="auto" desc=""/>
                </function>
                <function name="tonumber">
                    <desc>When called with no base, tonumber tries to convert its argument to a number. If the argument is already a number or a string convertible to a number (see lua reference 3.4.2), then tonumber returns this number; otherwise, it returns nil.

When called with base, then e should be a string to be interpreted as an integer numeral in that base. The base may be any integer between 2 and 36, inclusive. In bases above 10, the letter 'A' (in either upper or lower case) represents 10, 'B' represents 11, and so forth, with 'Z' representing 35. If the string e is not a valid numeral in the given base, the function returns nil.</desc>
                    <param name="e" type="auto" desc=""/>
                    <param name="base" type="int" multiplicity="?" desc=""/>
                    <return name="number" type="auto" multiplicity="?" desc=""/>
                </function>
                <function name="tostring">
                    <desc>Receives a value of any type and converts it to a string in a reasonable format. (For complete control of how numbers are converted, use string.format.)

If the metatable of v has a "__tostring" field, then tostring calls the corresponding value with v as argument, and uses the result of the call as its result.</desc>
                    <param name="v" type="auto" desc=""/>
                    <return name="string" type="string" desc=""/>
                </function>
                <function name="type">
                    <desc>Returns the type of its only argument, coded as a string. The possible results of this function are "nil" (a string, not the value nil), "number", "string", "boolean", "table", "function", "thread", and "userdata".</desc>
                    <param name="v" type="auto" desc=""/>
                    <return name="string" type="string" desc=""/>
                </function>
                <function name="unpack">
                    <trait>deprecated</trait>
                    <desc>DEPRECATED</desc>
                </function>
                <function name="xpcall">
                    <desc>This function is similar to pcall, except that it sets a new message handler msgh</desc>
                    <param name="f" type="auto" desc="function"/>
                    <param name="msgh" type="auto" desc="message handler"/>
                    <param name="arg1" type="auto" desc=""/>
                    <param name="argN" type="auto" multiplicity="*" desc=""/>
                </function>
            </serves>
            <crown name="bit32">
                <trait>deprecated</trait>
                <desc>DEPRECATED: Lua 5.3 has native integer and bitwise support.
This library provides bitwise operations. It provides all its functions inside the table bit32.
Unless otherwise stated, all functions accept numeric arguments in the range (-2^51,+2^51); each argument is normalized to the remainder of its division by 232 and truncated to an integer (in some unspecified way), so that its final value falls in the range [0,232 - 1]. Similarly, all results are in the range [0,2^32 - 1]. Note that bit32.bnot(0) is 0xFFFFFFFF, which is different from -1.</desc>
                <serves>
                    <function name="arshift">
                        <trait>deprecated</trait>
                        <desc>Returns the number x shifted disp bits to the right. The number disp may be any representable integer. Negative displacements shift to the left.
This shift operation is what is called arithmetic shift. Vacant bits on the left are filled with copies of the higher bit of x; vacant bits on the right are filled with zeros. In particular, displacements with absolute values higher than 31 result in zero or 0xFFFFFFFF (all original bits are shifted out).</desc>
                        <param name="x" type="int" desc=""/>
                        <param name="disp" type="int" desc=""/>
                        <return name="arshift" type="int" desc=""/>
                    </function>
                    <function name="band">
                        <trait>deprecated</trait>
                        <desc>Returns the bitwise and of its operands.</desc>
                        <param name="x1" type="auto" desc=""/>
                        <param name="x2" type="auto" desc=""/>
                        <param name="xN" type="auto" multiplicity="*" desc=""/>
                        <return name="band" type="auto" desc=""/>
                    </function>
                    <function name="bnot">
                        <trait>deprecated</trait>
                        <desc>Returns the bitwise negation of x. For any integer x, the following identity holds:
assert(bit32.bnot(x) == (-1 - x) % 2^32)</desc>
                        <param name="x" type="auto" desc=""/>
                        <return name="bnot" type="auto" desc=""/>
                    </function>
                    <function name="bor">
                        <trait>deprecated</trait>
                        <desc>Returns the bitwise or of its operands.</desc>
                        <param name="x1" type="auto" desc=""/>
                        <param name="x2" type="auto" desc=""/>
                        <param name="xN" type="auto" multiplicity="*" desc=""/>
                        <return name="bor" type="auto" desc=""/>
                    </function>
                    <function name="btest">
                        <trait>deprecated</trait>
                        <desc>Returns a boolean signaling whether the bitwise and of its operands is different from zero.</desc>
                        <param name="x1" type="auto" desc=""/>
                        <param name="x2" type="auto" desc=""/>
                        <param name="xN" type="auto" multiplicity="*" desc=""/>
                        <return name="btest" type="auto" desc="bool"/>
                    </function>
                    <function name="bxor">
                        <trait>deprecated</trait>
                        <desc>Returns the bitwise exclusive or of its operands.</desc>
                        <param name="x1" type="auto" desc=""/>
                        <param name="x2" type="auto" desc=""/>
                        <param name="xN" type="auto" multiplicity="*" desc=""/>
                        <return name="bxor" type="auto" desc=""/>
                    </function>
                    <function name="extract">
                        <trait>deprecated</trait>
                        <desc>Returns the unsigned number formed by the bits field to field + width - 1 from n. Bits are numbered from 0 (least significant) to 31 (most significant). All accessed bits must be in the range [0, 31].
The default for width is 1.</desc>
                        <param name="n" type="auto" desc=""/>
                        <param name="field" type="auto" desc=""/>
                        <param name="width" type="auto" multiplicity="?" desc=""/>
                        <return name="extractedX" type="auto" desc=""/>
                    </function>
                    <function name="replace">
                        <trait>deprecated</trait>
                        <desc>Returns a copy of n with the bits field to field + width - 1 replaced by the value v. See bit32.extract for details about field and width.</desc>
                        <param name="n" type="auto" desc=""/>
                        <param name="v" type="auto" desc=""/>
                        <param name="field" type="auto" desc=""/>
                        <param name="width" type="auto" multiplicity="?" desc=""/>
                        <return name="replacedN" type="auto" desc=""/>
                    </function>
                    <function name="lrotate">
                        <trait>deprecated</trait>
                        <desc>Returns the number x rotated disp bits to the left. The number disp may be any representable integer.
For any valid displacement, the following identity holds:
assert(bit32.lrotate(x, disp) == bit32.lrotate(x, disp % 32))
In particular, negative displacements rotate to the right.</desc>
                        <param name="x" type="auto" desc=""/>
                        <param name="disp" type="auto" desc=""/>
                        <return name="rotatedX" type="auto" desc=""/>
                    </function>
                    <function name="lshift">
                        <trait>deprecated</trait>
                        <desc>Returns the number x shifted disp bits to the left. The number disp may be any representable integer. Negative displacements shift to the right. In any direction, vacant bits are filled with zeros. In particular, displacements with absolute values higher than 31 result in zero (all bits are shifted out).
For positive displacements, the following equality holds:
assert(bit32.lshift(b, disp) == (b * 2^disp) % 2^32)</desc>
                        <param name="x" type="auto" desc=""/>
                        <param name="disp" type="auto" desc=""/>
                        <return name="shiftedX" type="auto" desc=""/>
                    </function>
                    <function name="rrotate">
                        <trait>deprecated</trait>
                        <desc>Returns the number x rotated disp bits to the right. The number disp may be any representable integer.
For any valid displacement, the following identity holds:
assert(bit32.rrotate(x, disp) == bit32.rrotate(x, disp % 32))
In particular, negative displacements rotate to the left.</desc>
                        <param name="x" type="auto" desc=""/>
                        <param name="disp" type="auto" desc=""/>
                        <return name="rotatedX" type="auto" desc=""/>
                    </function>
                    <function name="rshift">
                        <trait>deprecated</trait>
                        <desc>Returns the number x shifted disp bits to the right. The number disp may be any representable integer. Negative displacements shift to the left. In any direction, vacant bits are filled with zeros. In particular, displacements with absolute values higher than 31 result in zero (all bits are shifted out).
For positive displacements, the following equality holds:
assert(bit32.rshift(b, disp) == math.floor(b % 2^32 / 2^disp))
This shift operation is what is called logical shift.</desc>
                        <param name="x" type="auto" desc=""/>
                        <param name="disp" type="auto" desc=""/>
                        <return name="shiftedX" type="auto" desc=""/>
                    </function>
                </serves>
            </crown>
            <crown name="coroutine">
                <trait>hidden</trait>
                <desc>The operations related to coroutines comprise a sub-library of the basic library and come inside the table coroutine. See lua reference 2.6 for a general description of coroutines.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new coroutine, with body f. f must be a Lua function. Returns this new coroutine, an object with type "thread".</desc>
                        <param name="f" type="auto" desc="function"/>
                        <return name="coroutine" type="auto" desc="coroutine"/>
                    </function>
                    <function name="isyieldable">
                        <desc>Returns true when the running coroutine can yield.

A running coroutine is yieldable if it is not the main thread and it is not inside a non-yieldable C function.</desc>
                        <return name="isYieldable" type="bool" desc=""/>
                    </function>
                    <function name="resume">
                        <desc>Starts or continues the execution of coroutine co. The first time you resume a coroutine, it starts running its body. The values val1, ... are passed as the arguments to the body function. If the coroutine has yielded, resume restarts it; the values val1, ... are passed as the results from the yield.

If the coroutine runs without any errors, resume returns true plus any values passed to yield (when the coroutine yields) or any values returned by the body function (when the coroutine terminates). If there is any error, resume returns false plus the error message.</desc>
                        <param name="co" type="auto" desc="coroutine"/>
                        <param name="val1" type="auto" multiplicity="?" desc=""/>
                        <param name="val2" type="auto" multiplicity="?" desc=""/>
                        <param name="valN" type="auto" multiplicity="*" desc=""/>
                        <return name="success" type="bool" desc=""/>
                        <return name="val1" type="auto" multiplicity="?" desc=""/>
                        <return name="val2" type="auto" multiplicity="?" desc=""/>
                        <return name="valN" type="auto" multiplicity="*" desc=""/>
                    </function>
                    <function name="running">
                        <desc>Returns the running coroutine plus a boolean, true when the running coroutine is the main one.</desc>
                        <return name="coroutine" type="auto" desc="coroutine"/>
                        <return name="isMain" type="bool" desc=""/>
                    </function>
                    <function name="status">
                        <desc>Returns the status of coroutine co, as a string: "running", if the coroutine is running (that is, it called status); "suspended", if the coroutine is suspended in a call to yield, or if it has not started running yet; "normal" if the coroutine is active but not running (that is, it has resumed another coroutine); and "dead" if the coroutine has finished its body function, or if it has stopped with an error.</desc>
                        <param name="co" type="auto" desc="coroutine"/>
                        <return name="status" type="string" desc=""/>
                    </function>
                    <function name="wrap">
                        <desc>Creates a new coroutine, with body f. f must be a Lua function. Returns a function that resumes the coroutine each time it is called. Any arguments passed to the function behave as the extra arguments to resume. Returns the same values returned by resume, except the first boolean. In case of error, propagates the error.</desc>
                        <param name="f" type="auto" desc="function"/>
                        <return name="coroutine" type="auto" desc="coroutine"/>
                    </function>
                    <function name="yield">
                        <desc>Suspends the execution of the calling coroutine. Any arguments to yield are passed as extra results to resume.</desc>
                        <param name="val1" type="auto" multiplicity="?" desc=""/>
                        <param name="val2" type="auto" multiplicity="?" desc=""/>
                        <param name="valN" type="auto" multiplicity="*" desc=""/>
                    </function>
                </serves>
            </crown>
            <crown name="debug">
                <trait>released</trait>
                <desc>This library provides the functionality of the debug interface (4.9) to Lua programs. You should exert care when using this library. Several of its functions violate basic assumptions about Lua code (e.g., that variables local to a function cannot be accessed from outside; that userdata metatables cannot be changed by Lua code; that Lua programs do not crash) and therefore can compromise otherwise secure code. Moreover, some functions in this library may be slow.

All functions in this library are provided inside the debug table. All functions that operate over a thread have an optional first argument which is the thread to operate over. The default is always the current thread.</desc>
                <serves>
                    <function name="debug">
                        <trait>hidden</trait>
                        <desc></desc>
                    </function>
                    <function name="gethook">
                        <trait>hidden</trait>
                        <desc></desc>
                    </function>
                    <function name="getinfo">
                        <desc>Returns a table with information about a function. You can give the function directly or you can give a number as the value of f, which means the function running at level f of the call stack of the given thread: level 0 is the current function (getinfo itself); level 1 is the function that called getinfo (except for tail calls, which do not count on the stack); and so on. If f is a number larger than the number of active functions, then getinfo returns nil.

The returned table can contain all the fields returned by lua_getinfo, with the string what describing which fields to fill in. The default for what is to get all information available, except the table of valid lines. If present, the option 'f' adds a field named func with the function itself. If present, the option 'L' adds a field named activelines with the table of valid lines.

For instance, the expression debug.getinfo(1,"n").name returns a name for the current function, if a reasonable name can be found, and the expression debug.getinfo(print) returns a table with all available information about the print function.</desc>
                        <param name="thread" type="auto" multiplicity="?" desc="thread"/>
                        <param name="f" type="auto" desc=""/>
                        <param name="what" type="string" multiplicity="?" desc=""/>
                        <return name="table" type="auto" desc="table"/>
                    </function>
                    <function name="getlocal">
                        <desc>This function returns the name and the value of the local variable with index local of the function at level f of the stack. This function accesses not only explicit local variables, but also parameters, temporaries, etc.

The first parameter or local variable has index 1, and so on, following the order that they are declared in the code, counting only the variables that are active in the current scope of the function. Negative indices refer to vararg parameters; -1 is the first vararg parameter. The function returns nil if there is no variable with the given index, and raises an error when called with a level out of range. (You can call debug.getinfo to check whether the level is valid.)

Variable names starting with '(' (open parenthesis) represent variables with no known names (internal variables such as loop control variables, and variables from chunks saved without debug information).

The parameter f may also be a function. In that case, getlocal returns only the name of function parameters.</desc>
                        <param name="thread" type="auto" multiplicity="?" desc="thread"/>
                        <param name="f" type="auto" desc=""/>
                        <param name="local" type="int" desc=""/>
                        <return name="name" type="string" desc=""/>
                        <return name="value" type="auto" multiplicity="?" desc=""/>
                    </function>
                    <function name="getmetatable">
                        <desc>Returns the metatable of the given value or nil if it does not have a metatable.</desc>
                        <param name="value" type="auto" desc=""/>
                        <return name="table" type="auto" desc="table"/>
                    </function>
                    <function name="getregistry">
                        <desc>Returns the registry table (see lua reference 4.5).</desc>
                        <return name="table" type="auto" desc="table"/>
                    </function>
                    <function name="getupvalue">
                        <trait>hidden</trait>
                        <desc></desc>
                    </function>
                    <function name="getuservalue">
                        <trait>hidden</trait>
                        <desc></desc>
                    </function>
                    <function name="sethook">
                        <trait>hidden</trait>
                        <desc></desc>
                    </function>
                    <function name="setlocal">
                        <trait>hidden</trait>
                        <desc></desc>
                    </function>
                    <function name="setmetatable">
                        <trait>hidden</trait>
                        <desc></desc>
                    </function>
                    <function name="setupvalue">
                        <trait>hidden</trait>
                        <desc></desc>
                    </function>
                    <function name="setuservalue">
                        <trait>hidden</trait>
                        <desc></desc>
                    </function>
                    <function name="traceback">
                        <desc>If message is present but is neither a string nor nil, this function returns message without further processing. Otherwise, it returns a string with a traceback of the call stack. The optional message string is appended at the beginning of the traceback. An optional level number tells at which level to start the traceback (default is 1, the function calling traceback).</desc>
                        <param name="thread" type="auto" multiplicity="?" desc="thread"/>
                        <param name="message" type="string" multiplicity="?" desc=""/>
                        <param name="level" type="int" multiplicity="?" desc=""/>
                        <return name="message" type="string" desc=""/>
                    </function>
                    <function name="upvalueid">
                        <trait>hidden</trait>
                        <desc></desc>
                    </function>
                    <function name="upvaluejoin">
                        <trait>hidden</trait>
                        <desc></desc>
                    </function>
                </serves>
            </crown>
            <crown name="math">
                <trait>released</trait>
                <desc>This library provides basic mathematical functions. It provides all its functions and constants inside the table math. Functions with the annotation "integer/float" give integer results for integer arguments and float results for float (or mixed) arguments. Rounding functions (math.ceil, math.floor, and math.modf) return an integer when the result fits in the range of an integer, or a float otherwise.</desc>
                <enum name="Constants" type="object">
                    <item name="huge" desc="The value HUGE_VAL, a value larger than or equal to any other numerical value.">math.huge</item>
                    <item name="pi" desc="The value of Pi (3.1415....).">math.pi</item>
                </enum>
                <serves>
                    <function name="abs">
                        <desc>Returns the absolute value of x. (integer/float)</desc>
                        <param name="x" type="float" desc="number"/>
                        <return name="abs" type="float" desc="number"/>
                    </function>
                    <function name="acos">
                        <desc>Returns the arc cosine of x (in radians).</desc>
                        <param name="x" type="float" desc="number"/>
                        <return name="acos" type="float" desc="number"/>
                    </function>
                    <function name="asin">
                        <desc>Returns the arc sine of x (in radians).</desc>
                        <param name="x" type="float" desc="number"/>
                        <return name="asin" type="float" desc="number"/>
                    </function>
                    <function name="atan">
                        <desc>Returns the arc tangent of y/x (in radians), but uses the signs of both parameters to find the quadrant of the result. (It also handles correctly the case of x being zero.)

The default value for x is 1, so that the call math.atan(y) returns the arc tangent of y.</desc>
                        <param name="x" type="float" desc="number"/>
                        <return name="atan" type="float" desc="number"/>
                    </function>
                    <function name="atan2">
                        <trait>deprecated</trait>
                        <desc>DEPRECATED: Use "atan" instead with additional argument.
Returns the arc tangent of y/x (in radians), but uses the signs of both parameters to find the quadrant of the result. (It also handles correctly the case of x being zero.)</desc>
                        <param name="y" type="float" desc="number"/>
                        <param name="x" type="float" multiplicity="?" desc="number"/>
                        <return name="atan2" type="float" desc="number"/>
                    </function>
                    <function name="ceil">
                        <desc>Returns the smallest integral value larger than or equal to x.</desc>
                        <param name="x" type="float" desc="number"/>
                        <return name="ceil" type="float" desc="number"/>
                    </function>
                    <function name="cos">
                        <desc>Returns the cosine of x (assumed to be in radians).</desc>
                        <param name="x" type="float" desc="number"/>
                        <return name="cos" type="float" desc="number"/>
                    </function>
                    <function name="cosh">
                        <trait>deprecated</trait>
                        <desc>DEPRECATED: Use an external library or implement it in Lua.
Returns the hyperbolic cosine of x.</desc>
                        <param name="x" type="float" desc="number"/>
                        <return name="cosh" type="float" desc="number"/>
                    </function>
                    <function name="deg">
                        <desc>Returns the angle x (given in radians) in degrees.</desc>
                        <param name="x" type="float" desc="number"/>
                        <return name="deg" type="float" desc="number"/>
                    </function>
                    <function name="exp">
                        <desc>Returns the value e^x (where e is the base of natural logarithms).</desc>
                        <param name="x" type="float" desc="number"/>
                        <return name="exp" type="float" desc="number"/>
                    </function>
                    <function name="floor">
                        <desc>Returns the largest integral value smaller than or equal to x.</desc>
                        <param name="x" type="float" desc="number"/>
                        <return name="floor" type="float" desc="number"/>
                    </function>
                    <function name="fmod">
                        <desc>Returns the remainder of the division of x by y that rounds the quotient towards zero. (integer/float)</desc>
                        <param name="x" type="float" desc="number"/>
                        <param name="y" type="float" desc="number"/>
                        <return name="fmod" type="float" desc="number"/>
                    </function>
                    <function name="frexp">
                        <trait>deprecated</trait>
                        <desc>DEPRECATED: Use an external library or implement it in Lua.
Returns m and e such that x = m2^e, e is an integer and the absolute value of m is in the range [0.5, 1) (or zero when x is zero).</desc>
                        <param name="x" type="float" desc="number"/>
                        <return name="m" type="float" desc="number"/>
                        <return name="e" type="float" desc="number"/>
                    </function>
                    <function name="ldexp">
                        <trait>deprecated</trait>
                        <desc>DEPRECATED: Replace with "x*2.0^e".
Returns m2^e (e should be an integer).</desc>
                        <param name="m" type="float" desc="number"/>
                        <param name="e" type="float" desc="number"/>
                        <return name="ldexp" type="float" desc="number"/>
                    </function>
                    <function name="log">
                        <desc>Returns the logarithm of x in the given base. The default for base is e (so that the function returns the natural logarithm of x).</desc>
                        <param name="x" type="float" desc="number"/>
                        <param name="base" type="float" multiplicity="*" desc="number"/>
                        <return name="log" type="float" desc="number"/>
                    </function>
                    <function name="log10">
                        <trait>deprecated</trait>
                        <desc>DEPRECATED: Use "log" instead with additional argument.
Returns the logarithm of x in base 10.</desc>
                        <param name="x" type="float" desc="number"/>
                        <return name="log10" type="float" desc="number"/>
                    </function>
                    <function name="max">
                        <desc>Returns the argument with the maximum value, according to the Lua operator &lt; (integer/float)</desc>
                        <param name="x1" type="float" desc="number"/>
                        <param name="x2" type="float" desc="number"/>
                        <param name="xN" type="float" multiplicity="*" desc="number"/>
                        <return name="max" type="float" desc="number"/>
                    </function>
                    <function name="min">
                        <desc>Returns the argument with the minimum value, according to the Lua operator &gt;. (integer/float)</desc>
                        <param name="x1" type="float" desc="number"/>
                        <param name="x2" type="float" desc="number"/>
                        <param name="xN" type="float" multiplicity="*" desc="number"/>
                        <return name="min" type="float" desc="number"/>
                    </function>
                    <function name="modf">
                        <desc>Returns the integral part of x and the fractional part of x. Its second result is always a float.</desc>
                        <param name="x" type="float" desc="number"/>
                        <return name="integral" type="float" desc="number"/>
                        <return name="fractional" type="float" desc="number"/>
                    </function>
                    <function name="pow">
                        <trait>deprecated</trait>
                        <desc>DEPRECATED: Replace with "x^y".
Returns x^y. (You can also use the expression x^y to compute this value.)</desc>
                        <param name="x" type="float" desc="number"/>
                        <param name="y" type="float" desc="number"/>
                        <return name="pow" type="float" desc="number"/>
                    </function>
                    <function name="rad">
                        <desc>Returns the angle x (given in degrees) in radians.</desc>
                        <param name="x" type="float" desc="number"/>
                        <return name="rad" type="float" desc="number"/>
                    </function>
                    <function name="random">
                        <desc>When called without arguments, returns a pseudo-random float with uniform distribution in the range [0,1). When called with two integers m and n, math.random returns a pseudo-random integer with uniform distribution in the range [m, n]. (The value n-m cannot be negative and must fit in a Lua integer.) The call math.random(n) is equivalent to math.random(1,n).

This function is an interface to the underling pseudo-random generator function provided by C.</desc>
                        <param name="m" type="float" multiplicity="?" desc="number"/>
                        <param name="n" type="float" multiplicity="?" desc="number"/>
                        <return name="random" type="float" desc="number"/>
                    </function>
                    <function name="randomseed">
                        <desc>Sets x as the "seed" for the pseudo-random generator: equal seeds produce equal sequences of numbers.</desc>
                        <param name="x" type="float" desc="number"/>
                    </function>
                    <function name="sin">
                        <desc>Returns the sine of x (assumed to be in radians).</desc>
                        <param name="x" type="float" desc="number"/>
                        <return name="sin" type="float" desc="number"/>
                    </function>
                    <function name="sinh">
                        <trait>deprecated</trait>
                        <desc>DEPRECATED: Use an external library or implement it in Lua.
Returns the hyperbolic sine of x.</desc>
                        <param name="x" type="float" desc="number"/>
                        <return name="sinh" type="float" desc="number"/>
                    </function>
                    <function name="sqrt">
                        <desc>Returns the square root of x. (You can also use the expression x^0.5 to compute this value.)</desc>
                        <param name="x" type="float" desc="number"/>
                        <return name="sqrt" type="float" desc="number"/>
                    </function>
                    <function name="tan">
                        <desc>Returns the tangent of x (assumed to be in radians).</desc>
                        <param name="x" type="float" desc="number"/>
                        <return name="tan" type="float" desc="number"/>
                    </function>
                    <function name="tanh">
                        <trait>deprecated</trait>
                        <desc>DEPRECATED: Use an external library or implement it in Lua.
Returns the hyperbolic tangent of x.</desc>
                        <param name="x" type="float" desc="number"/>
                        <return name="tanh" type="float" desc="number"/>
                    </function>
                    <function name="tointeger">
                        <desc>If the value x is convertible to an integer, returns that integer. Otherwise, returns nil.</desc>
                        <param name="x" type="float" desc="number"/>
                        <return name="integer" type="int" desc=""/>
                    </function>
                    <function name="type">
                        <desc>Returns "integer" if x is an integer, "float" if it is a float, or nil if x is not a number.</desc>
                        <param name="x" type="float" desc="number"/>
                        <return name="type" type="string" desc=""/>
                    </function>
                    <function name="ult">
                        <desc>Returns a boolean, true if integer m is below integer n when they are compared as unsigned integers.</desc>
                        <param name="m" type="int" desc=""/>
                        <param name="n" type="int" desc=""/>
                        <return name="ult" type="bool" desc=""/>
                    </function>
                </serves>
            </crown>
            <crown name="string">
                <trait>released</trait>
                <desc>This library provides generic functions for string manipulation, such as finding and extracting substrings, and pattern matching. When indexing a string in Lua, the first character is at position 1 (not at 0, as in C). Indices are allowed to be negative and are interpreted as indexing backwards, from the end of the string. Thus, the last character is at position -1, and so on.

The string library provides all its functions inside the table string. It also sets a metatable for strings where the __index field points to the string table. Therefore, you can use the string functions in object-oriented style. For instance, string.byte(s,i) can be written as s:byte(i).

The string library assumes one-byte character encodings.

6.4.1 - Patterns

Patterns in Lua are described by regular strings, which are interpreted as patterns by the pattern-matching functions string.find, string.gmatch, string.gsub, and string.match. This section describes the syntax and the meaning (that is, what they match) of these strings.
Character Class:

A character class is used to represent a set of characters. The following combinations are allowed in describing a character class:

x: (where x is not one of the magic characters ^$()%.[]*+-?) represents the character x itself.
.: (a dot) represents all characters.
%a: represents all letters.
%c: represents all control characters.
%d: represents all digits.
%g: represents all printable characters except space.
%l: represents all lowercase letters.
%p: represents all punctuation characters.
%s: represents all space characters.
%u: represents all uppercase letters.
%w: represents all alphanumeric characters.
%x: represents all hexadecimal digits.
%x: (where x is any non-alphanumeric character) represents the character x. This is the standard way to escape the magic characters. Any non-alphanumeric character (including all punctuation characters, even the non-magical) can be preceded by a '%' when used to represent itself in a pattern.
[set]: represents the class which is the union of all characters in set. A range of characters can be specified by separating the end characters of the range, in ascending order, with a '-'. All classes %x described above can also be used as components in set. All other characters in set represent themselves. For example, [%w_] (or [_%w]) represents all alphanumeric characters plus the underscore, [0-7] represents the octal digits, and [0-7%l%-] represents the octal digits plus the lowercase letters plus the '-' character.

The interaction between ranges and classes is not defined. Therefore, patterns like [%a-z] or [a-%%] have no meaning.
[^set]: represents the complement of set, where set is interpreted as above.

For all classes represented by single letters (%a, %c, etc.), the corresponding uppercase letter represents the complement of the class. For instance, %S represents all non-space characters.

The definitions of letter, space, and other character groups depend on the current locale. In particular, the class [a-z] may not be equivalent to %l.
Pattern Item:

A pattern item can be

a single character class, which matches any single character in the class;
a single character class followed by '*', which matches zero or more repetitions of characters in the class. These repetition items will always match the longest possible sequence;
a single character class followed by '+', which matches one or more repetitions of characters in the class. These repetition items will always match the longest possible sequence;
a single character class followed by '-', which also matches zero or more repetitions of characters in the class. Unlike '*', these repetition items will always match the shortest possible sequence;
a single character class followed by '?', which matches zero or one occurrence of a character in the class. It always matches one occurrence if possible;
%n, for n between 1 and 9; such item matches a substring equal to the n-th captured string (see below);
%bxy, where x and y are two distinct characters; such item matches strings that start with x, end with y, and where the x and y are balanced. This means that, if one reads the string from left to right, counting +1 for an x and -1 for a y, the ending y is the first y where the count reaches 0. For instance, the item %b() matches expressions with balanced parentheses.
%f[set], a frontier pattern; such item matches an empty string at any position such that the next character belongs to set and the previous character does not belong to set. The set set is interpreted as previously described. The beginning and the end of the subject are handled as if they were the character '\0'.

Pattern:

A pattern is a sequence of pattern items. A caret '^' at the beginning of a pattern anchors the match at the beginning of the subject string. A '$' at the end of a pattern anchors the match at the end of the subject string. At other positions, '^' and '$' have no special meaning and represent themselves.
Captures:

A pattern can contain sub-patterns enclosed in parentheses; they describe captures. When a match succeeds, the substrings of the subject string that match captures are stored (captured) for future use. Captures are numbered according to their left parentheses. For instance, in the pattern "(a*(.)%w(%s*))", the part of the string matching "a*(.)%w(%s*)" is stored as the first capture (and therefore has number 1); the character matching "." is captured with number 2, and the part matching "%s*" has number 3.

As a special case, the empty capture () captures the current string position (a number). For instance, if we apply the pattern "()aa()" on the string "flaaap", there will be two captures: 3 and 5.

6.4.2 - Format Strings for Pack and Unpack

The first argument to string.pack, string.packsize, and string.unpack is a format string, which describes the layout of the structure being created or read.

A format string is a sequence of conversion options. The conversion options are as follows:

&lt;: sets little endian
&gt;: sets big endian
=: sets native endian
![n]: sets maximum alignment to n (default is native alignment)
b: a signed byte (char)
B: an unsigned byte (char)
h: a signed short (native size)
H: an unsigned short (native size)
l: a signed long (native size)
L: an unsigned long (native size)
j: a lua_Integer
J: a lua_Unsigned
T: a size_t (native size)
i[n]: a signed int with n bytes (default is native size)
I[n]: an unsigned int with n bytes (default is native size)
f: a float (native size)
d: a double (native size)
n: a lua_Number
cn: a fixed-sized string with n bytes
z: a zero-terminated string
s[n]: a string preceded by its length coded as an unsigned integer with n bytes (default is a size_t)
x: one byte of padding
Xop: an empty item that aligns according to option op (which is otherwise ignored)
' ': (empty space) ignored

(A "[n]" means an optional integral numeral.) Except for padding, spaces, and configurations (options "xX &lt;=&gt;!"), each option corresponds to an argument (in string.pack) or a result (in string.unpack).

For options "!n", "sn", "in", and "In", n can be any integer between 1 and 16. All integral options check overflows; string.pack checks whether the given value fits in the given size; string.unpack checks whether the read value fits in a Lua integer.

Any format string starts as if prefixed by "!1=", that is, with maximum alignment of 1 (no alignment) and native endianness.

Alignment works as follows: For each option, the format gets extra padding until the data starts at an offset that is a multiple of the minimum between the option size and the maximum alignment; this minimum must be a power of 2. Options "c" and "z" are not aligned; option "s" follows the alignment of its starting integer.

All padding is filled with zeros by string.pack (and ignored by string.unpack).</desc>
                <serves>
                    <function name="byte">
                        <desc>Returns the internal numeric codes of the characters s[i], s[i+1], ..., s[j]. The default value for i is 1; the default value for j is i. These indices are corrected following the same rules of function string.sub.

Numeric codes are not necessarily portable across platforms.</desc>
                        <param name="s" type="string" desc=""/>
                        <param name="i" type="int" multiplicity="?" desc=""/>
                        <param name="j" type="int" multiplicity="?" desc=""/>
                        <return name="byte" type="int" multiplicity="*" desc=""/>
                    </function>
                    <function name="char">
                        <desc>Receives zero or more integers. Returns a string with length equal to the number of arguments, in which each character has the internal numeric code equal to its corresponding argument.

Numeric codes are not necessarily portable across platforms.</desc>
                        <param name="x1" type="int" desc=""/>
                        <param name="xN" type="int" multiplicity="*" desc=""/>
                        <return name="string" type="string" desc=""/>
                    </function>
                    <function name="dump">
                        <desc>Returns a string containing a binary representation (a binary chunk) of the given function, so that a later load on this string returns a copy of the function (but with new upvalues). If strip is a true value, the binary representation may not include all debug information about the function, to save space.

Functions with upvalues have only their number of upvalues saved. When (re)loaded, those upvalues receive fresh instances containing nil. (You can use the debug library to serialize and reload the upvalues of a function in a way adequate to your needs.)</desc>
                        <param name="function" type="auto" desc="function"/>
                        <return name="binary" type="binary" desc=""/>
                    </function>
                    <function name="find">
                        <desc>Looks for the first match of pattern (see 6.4.1) in the string s. If it finds a match, then find returns the indices of s where this occurrence starts and ends; otherwise, it returns nil. A third, optional numeric argument init specifies where to start the search; its default value is 1 and can be negative. A value of true as a fourth, optional argument plain turns off the pattern matching facilities, so the function does a plain "find substring" operation, with no characters in pattern being considered magic. Note that if plain is given, then init must be given as well.

If the pattern has captures, then in a successful match the captured values are also returned, after the two indices.</desc>
                        <param name="s" type="string" desc=""/>
                        <param name="pattern" type="string" desc=""/>
                        <param name="init" type="int" multiplicity="?" desc=""/>
                        <param name="plain" type="bool" multiplicity="?" desc=""/>
                        <return name="x1" type="string" desc=""/>
                        <return name="xN" type="string" multiplicity="*" desc=""/>
                    </function>
                    <function name="format">
                        <desc>Returns a formatted version of its variable number of arguments following the description given in its first argument (which must be a string). The format string follows the same rules as the ISO C function sprintf. The only differences are that the options/modifiers *, h, L, l, n, and p are not supported and that there is an extra option, q. The q option formats a string between double quotes, using escape sequences when necessary to ensure that it can safely be read back by the Lua interpreter. For instance, the call

string.format('%q', 'a string with "quotes" and \n new line')

may produce the string:

"a string with \"quotes\" and \
new line"

Options A, a, E, e, f, G, and g all expect a number as argument. Options c, d, i, o, u, X, and x expect an integer. Option q expects a string. Option s expects a string; if its argument is not a string, it is converted to one following the same rules of tostring. If the option has any modifier (flags, width, length), the string argument should not contain embedded zeros.

When Lua is compiled with a non-C99 compiler, options A and a (hexadecimal floats) do not support any modifier (flags, width, length).</desc>
                        <param name="formatstring" type="string" desc=""/>
                        <param name="x1" type="auto" desc=""/>
                        <param name="xN" type="auto" multiplicity="*" desc=""/>
                    </function>
                    <function name="gmatch">
                        <desc>Returns an iterator function that, each time it is called, returns the next captures from pattern (see 6.4.1) over the string s. If pattern specifies no captures, then the whole match is produced in each call.

As an example, the following loop will iterate over all the words from string s, printing one per line:

s = "hello world from Lua"
for w in string.gmatch(s, "%a+") do
print(w)
end

The next example collects all pairs key=value from the given string into a table:

t = {}
s = "from=world, to=Lua"
for k, v in string.gmatch(s, "(%w+)=(%w+)") do
t[k] = v
end

For this function, a caret '^' at the start of a pattern does not work as an anchor, as this would prevent the iteration.</desc>
                        <param name="s" type="string" desc=""/>
                        <param name="pattern" type="string" desc=""/>
                        <return name="function" type="auto" desc="function"/>
                    </function>
                    <function name="gsub">
                        <desc>Returns a copy of s in which all (or the first n, if given) occurrences of the pattern (see 6.4.1) have been replaced by a replacement string specified by repl, which can be a string, a table, or a function. gsub also returns, as its second value, the total number of matches that occurred. The name gsub comes from Global SUBstitution.

If repl is a string, then its value is used for replacement. The character % works as an escape character: any sequence in repl of the form %d, with d between 1 and 9, stands for the value of the d-th captured substring. The sequence %0 stands for the whole match. The sequence %% stands for a single %.

If repl is a table, then the table is queried for every match, using the first capture as the key.

If repl is a function, then this function is called every time a match occurs, with all captured substrings passed as arguments, in order.

In any case, if the pattern specifies no captures, then it behaves as if the whole pattern was inside a capture.

If the value returned by the table query or by the function call is a string or a number, then it is used as the replacement string; otherwise, if it is false or nil, then there is no replacement (that is, the original match is kept in the string).

Here are some examples:

x = string.gsub("hello world", "(%w+)", "%1 %1")
--&gt; x="hello hello world world"

x = string.gsub("hello world", "%w+", "%0 %0", 1)
--&gt; x="hello hello world"

x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
--&gt; x="world hello Lua from"

x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)
--&gt; x="home = /home/roberto, user = roberto"

x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
return load(s)()
end)
--&gt; x="4+5 = 9"

local t = {name="lua", version="5.3"}
x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)
--&gt; x="lua-5.3.tar.gz"</desc>
                        <param name="s" type="string" desc=""/>
                        <param name="pattern" type="string" desc=""/>
                        <param name="repl" type="auto" desc=""/>
                        <param name="n" type="auto" multiplicity="?" desc="number"/>
                        <return name="copyS" type="string" desc=""/>
                        <return name="numberOfMatches" type="int" desc=""/>
                    </function>
                    <function name="len">
                        <desc>Receives a string and returns its length. The empty string "" has length 0. Embedded zeros are counted, so "a\000bc\000" has length 5.</desc>
                        <param name="s" type="string" desc=""/>
                        <return name="len" type="int" desc=""/>
                    </function>
                    <function name="lower">
                        <desc>Receives a string and returns a copy of this string with all uppercase letters changed to lowercase. All other characters are left unchanged. The definition of what an uppercase letter is depends on the current locale.</desc>
                        <param name="s" type="string" desc=""/>
                        <return name="string" type="string" desc=""/>
                    </function>
                    <function name="match">
                        <desc>Looks for the first match of pattern in the string s. If it finds one, then match returns the captures from the pattern; otherwise it returns nil. If pattern specifies no captures, then the whole match is returned. A third, optional numerical argument init specifies where to start the search; its default value is 1 and can be negative.</desc>
                        <param name="s" type="string" desc=""/>
                        <param name="pattern" type="string" desc=""/>
                        <param name="init" type="int" multiplicity="?" desc=""/>
                        <return name="string" type="string" desc=""/>
                    </function>
                    <function name="pack">
                        <desc>Returns a binary string containing the values v1, v2, etc. packed (that is, serialized in binary form) according to the format string fmt (see string description).</desc>
                        <param name="fmt" type="string" desc=""/>
                        <param name="v1" type="auto" desc=""/>
                        <param name="vN" type="auto" multiplicity="*" desc=""/>
                        <return name="binaryString" type="string" desc=""/>
                    </function>
                    <function name="packsize">
                        <desc>Returns the size of a string resulting from string.pack with the given format. The format string cannot have the variable-length options 's' or 'z' (see 6.4.2).</desc>
                        <param name="fmt" type="string" desc=""/>
                        <return name="packsize" type="int" desc=""/>
                    </function>
                    <function name="rep">
                        <desc>Returns a string that is the concatenation of n copies of the string s separated by the string sep. The default value for sep is the empty string (that is, no separator). Returns the empty string if n is not positive.

(Note that it is very easy to exhaust the memory of your machine with a single call to this function.)</desc>
                        <param name="s" type="string" desc=""/>
                        <param name="n" type="int" desc=""/>
                        <param name="sep" type="string" multiplicity="?" desc=""/>
                        <return name="string" type="string" desc=""/>
                    </function>
                    <function name="reverse">
                        <desc>Returns a string that is the string s reversed.</desc>
                        <param name="s" type="string" desc=""/>
                        <return name="string" type="string" desc=""/>
                    </function>
                    <function name="sub">
                        <desc>Returns the substring of s that starts at i and continues until j; i and j can be negative. If j is absent, then it is assumed to be equal to -1 (which is the same as the string length). In particular, the call string.sub(s,1,j) returns a prefix of s with length j, and string.sub(s, -i) returns a suffix of s with length i.

If, after the translation of negative indices, i is less than 1, it is corrected to 1. If j is greater than the string length, it is corrected to that length. If, after these corrections, i is greater than j, the function returns the empty string.</desc>
                        <param name="s" type="string" desc=""/>
                        <param name="i" type="int" desc=""/>
                        <param name="j" type="int" multiplicity="?" desc=""/>
                        <return name="substring" type="string" desc=""/>
                    </function>
                    <function name="unpack">
                        <desc>Returns the values packed in string s (see string.pack) according to the format string fmt (see 6.4.2). An optional pos marks where to start reading in s (default is 1). After the read values, this function also returns the index of the first unread byte in s.</desc>
                        <param name="fmt" type="string" desc=""/>
                        <param name="s" type="string" desc=""/>
                        <param name="pos" type="int" multiplicity="?" desc=""/>
                        <param name="v1" type="auto" desc=""/>
                        <param name="v2" type="auto" desc=""/>
                        <param name="vN" type="auto" multiplicity="*" desc=""/>
                        <param name="firstUnreadByte" type="int" desc=""/>
                    </function>
                    <function name="upper">
                        <desc>Receives a string and returns a copy of this string with all lowercase letters changed to uppercase. All other characters are left unchanged. The definition of what a lowercase letter is depends on the current locale.</desc>
                        <param name="s" type="string" desc=""/>
                        <return name="string" type="string" desc=""/>
                    </function>
                </serves>
            </crown>
            <crown name="table">
                <trait>released</trait>
                <desc>This library provides generic functions for table manipulation. It provides all its functions inside the table table.

Remember that, whenever an operation needs the length of a table, the table must be a proper sequence or have a __len metamethod (see 3.4.7). All functions ignore non-numeric keys in the tables given as arguments.</desc>
                <serves>
                    <function name="concat">
                        <desc>Given a list where all elements are strings or numbers, returns the string list[i]..sep..list[i+1] ... sep..list[j]. The default value for sep is the empty string, the default for i is 1, and the default for j is ##list. If i is greater than j, returns the empty string.</desc>
                        <param name="list" type="auto" desc="table"/>
                        <param name="sep" type="string" multiplicity="?" desc=""/>
                        <param name="i" type="int" multiplicity="?" desc=""/>
                        <param name="j" type="int" multiplicity="?" desc=""/>
                        <return name="concat" type="string" desc=""/>
                    </function>
                    <function name="insert">
                        <desc>Inserts element value at position pos in list, shifting up the elements list[pos], list[pos+1], ..., list[##list]. The default value for pos is ##list+1, so that a call table.insert(t,x) inserts x at the end of list t.</desc>
                        <param name="list" type="auto" desc="table"/>
                        <param name="pos" type="int" multiplicity="?" desc=""/>
                        <param name="value" type="auto" desc=""/>
                    </function>
                    <function name="move">
                        <desc>Moves elements from table a1 to table a2. This function performs the equivalent to the following multiple assignment: a2[t],... = a1[f],...,a1[e]. The default for a2 is a1. The destination range can overlap with the source range. The number of elements to be moved must fit in a Lua integer.</desc>
                        <param name="a1" type="auto" desc="table"/>
                        <param name="f" type="int" desc=""/>
                        <param name="e" type="int" desc=""/>
                        <param name="t" type="int" desc=""/>
                        <param name="a2" type="auto" multiplicity="?" desc="table"/>
                    </function>
                    <function name="pack">
                        <desc>Returns a new table with all parameters stored into keys 1, 2, etc. and with a field "n" with the total number of parameters. Note that the resulting table may not be a sequence.</desc>
                        <param name="x1" type="auto" desc=""/>
                        <param name="xN" type="auto" multiplicity="*" desc=""/>
                        <return name="table" type="auto" desc="table"/>
                    </function>
                    <function name="remove">
                        <desc>Removes from list the element at position pos, returning the value of the removed element. When pos is an integer between 1 and ##list, it shifts down the elements list[pos+1], list[pos+2], ..., list[##list] and erases element list[##list]; The index pos can also be 0 when ##list is 0, or ##list + 1; in those cases, the function erases the element list[pos].

The default value for pos is ##list, so that a call table.remove(l) removes the last element of list l.</desc>
                        <param name="list" type="auto" desc="table"/>
                        <param name="pos" type="int" multiplicity="?" desc=""/>
                    </function>
                    <function name="sort">
                        <desc>Sorts list elements in a given order, in-place, from list[1] to list[##list]. If comp is given, then it must be a function that receives two list elements and returns true when the first element must come before the second in the final order (so that, after the sort, i &lt; j implies not comp(list[j],list[i])). If comp is not given, then the standard Lua operator &gt; is used instead.

Note that the comp function must define a strict partial order over the elements in the list; that is, it must be asymmetric and transitive. Otherwise, no valid sort may be possible.

The sort algorithm is not stable; that is, elements not comparable by the given order (e.g., equal elements) may have their relative positions changed by the sort.</desc>
                        <param name="list" type="auto" desc="table"/>
                        <param name="comp" type="auto" multiplicity="?" desc="function"/>
                    </function>
                    <function name="unpack">
                        <desc>Returns the elements from the given list. This function is equivalent to

return list[i], list[i+1], ..., list[j]

By default, i is 1 and j is ##list.</desc>
                        <param name="list" type="auto" desc="table"/>
                        <return name="x1" type="auto" desc=""/>
                        <return name="xN" type="auto" multiplicity="*" desc=""/>
                    </function>
                </serves>
            </crown>
            <crown name="utf8">
                <trait>released</trait>
                <desc>This library provides basic support for UTF-8 encoding. It provides all its functions inside the table utf8. This library does not provide any support for Unicode other than the handling of the encoding. Any operation that needs the meaning of a character, such as character classification, is outside its scope.

Unless stated otherwise, all functions that expect a byte position as a parameter assume that the given position is either the start of a byte sequence or one plus the length of the subject string. As in the string library, negative indices count from the end of the string.</desc>
                <enum name="Constants" type="object">
                    <item name="UTF8 Pattern" desc="The pattern (a string, not a function) '[\0-\x7F\xC2-\xF4][\x80-\xBF]*' (see 6.4.1), which matches exactly one UTF-8 byte sequence, assuming that the subject is a valid UTF-8 string.">utf8.charpattern</item>
                </enum>
                <serves>
                    <function name="char">
                        <desc>Receives zero or more integers, converts each one to its corresponding UTF-8 byte sequence and returns a string with the concatenation of all these sequences.</desc>
                        <param name="x1" type="int" desc=""/>
                        <param name="xN" type="int" multiplicity="*" desc=""/>
                        <return name="string" type="string" desc=""/>
                    </function>
                    <function name="codes">
                        <desc>Returns values so that the construction

for p, c in utf8.codes(s) do body end

will iterate over all characters in string s, with p being the position (in bytes) and c the code point of each character. It raises an error if it meets any invalid byte sequence.</desc>
                        <param name="s" type="string" desc=""/>
                        <return name="p" type="int" desc=""/>
                        <return name="c" type="int" desc=""/>
                    </function>
                    <function name="codepoint">
                        <desc>Returns the codepoints (as integers) from all characters in s that start between byte position i and j (both included). The default for i is 1 and for j is i. It raises an error if it meets any invalid byte sequence.</desc>
                        <param name="s" type="string" desc=""/>
                        <param name="i" type="int" multiplicity="*" desc=""/>
                        <param name="j" type="int" multiplicity="*" desc=""/>
                        <return name="c" type="int" desc=""/>
                    </function>
                    <function name="len">
                        <desc>Returns the number of UTF-8 characters in string s that start between positions i and j (both inclusive). The default for i is 1 and for j is -1. If it finds any invalid byte sequence, returns a false value plus the position of the first invalid byte.</desc>
                        <param name="s" type="string" desc=""/>
                        <param name="i" type="int" multiplicity="*" desc=""/>
                        <param name="j" type="int" multiplicity="*" desc=""/>
                        <return name="len" type="int" desc=""/>
                    </function>
                    <function name="offset">
                        <desc>Returns the position (in bytes) where the encoding of the n-th character of s (counting from position i) starts. A negative n gets characters before position i. The default for i is 1 when n is non-negative and ##s + 1 otherwise, so that utf8.offset(s, -n) gets the offset of the n-th character from the end of the string. If the specified character is neither in the subject nor right after its end, the function returns nil.

As a special case, when n is 0 the function returns the start of the encoding of the character that contains the i-th byte of s.

This function assumes that s is a valid UTF-8 string.</desc>
                        <param name="s" type="string" desc=""/>
                        <param name="n" type="int" desc=""/>
                        <param name="i" type="int" multiplicity="*" desc=""/>
                        <return name="offset" type="int" desc=""/>
                    </function>
                </serves>
            </crown>
        </crown>
        <crown name="Monitor">
            <trait>released</trait>
            <desc>Provides monitoring functionality</desc>
            <serves/>
            <uses/>
            <crown name="Temperature">
                <trait>released</trait>
                <desc>Provides monitoring access to the device internal temperature values.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance if exists and not already in use.</desc>
                        <sample for="lua">handle = Monitor.Temperature.create("DIGITAL_BOARD_1")</sample>
                        <param name="name" type="enum" ref="TemperatureSensors" desc="The name of the temperature sensor"/>
                        <return name="handle" type="handle" multiplicity="?" alias="Monitor.Temperature" desc="Handle to the new instance. Nil if not available or already in use."/>
                    </function>
                    <function name="get">
                        <desc>Get data from a temperature sensor.</desc>
                        <sample for="lua">temperature = Monitor.Temperature.get(handle)</sample>
                        <param name="sensorHandle" type="handle" alias="Monitor.Temperature" desc="Handle to the temperature sensor."/>
                        <return name="temperature" type="float" desc="Temperature in degrees Celsius. Precision depends on the underlying temperature sensor."/>
                        <return name="timeStamp" type="int" desc="Timestamp of the temperature data in milliseconds. This time is synchronized to the sensor time, i.e. it has the same time base as DateTime.getTimestamp"/>
                    </function>
                </serves>
            </crown>
            <crown name="CPU">
                <trait>released</trait>
                <desc>Provides monitoring access to CPU load in sum and for each core.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance. Can be instantiated multiple times.</desc>
                        <sample for="lua">handle = Monitor.CPU.create()</sample>
                        <return name="handle" type="handle" alias="Monitor.CPU" desc="handle to the CPU-monitor."/>
                    </function>
                    <function name="getLoad">
                        <desc>Get the current load of the CPU.</desc>
                        <sample for="lua">Monitor.CPU.getLoad(handle)</sample>
                        <param name="monitorHandle" type="handle" alias="Monitor.CPU" desc="Handle to the CPU-monitor."/>
                        <return name="overallLoad" type="float" desc="The overall CPU load in percent."/>
                        <return name="detailedLoad" type="float" multiplicity="+" desc="The load of each CPU core in percent."/>
                    </function>
                </serves>
            </crown>
            <crown name="Memory">
                <trait>released</trait>
                <desc>Provides monitoring access to the RAM memory usage of the device.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">handle = Monitor.Memory.create()</sample>
                        <return name="handle" type="handle" alias="Monitor.Memory" desc="handle to the Memory-monitor."/>
                    </function>
                    <function name="getUsage">
                        <desc>Get the current memory usage.</desc>
                        <sample for="lua">Monitor.Memory.getUsage(handle)</sample>
                        <param name="monitorHandle" type="handle" alias="Monitor.Memory" desc="Handle to the Memory-monitor."/>
                        <return name="usedBytes" type="int" desc="Currently used bytes."/>
                        <return name="capacityBytes" type="int" desc="Memory capacity in bytes."/>
                        <return name="memUsage" type="float" desc="The memory used in percent of the whole capacity."/>
                    </function>
                </serves>
            </crown>
            <crown name="App">
                <trait>released</trait>
                <desc>Provides monitoring access to the status info of an app like app status and memory usage.</desc>
                <enum name="AppStatus">
                    <desc>The different possible status of an app.</desc>
                    <item name="UNKNOWN">UNKNOWN</item>
                    <item name="RUNNING">RUNNING</item>
                    <item name="STOPPED">STOPPED</item>
                    <item name="CRASHED">CRASHED</item>
                </enum>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">handle = Monitor.App.create("HelloWorld")</sample>
                        <param name="appName" type="string" desc="The name of the app to monitor."/>
                        <return name="handle" type="handle" multiplicity="?" alias="Monitor.App" desc="handle to the App-monitor."/>
                    </function>
                    <function name="getStatusInfo">
                        <desc>Get the status of the app.</desc>
                        <sample for="lua">Monitor.App.getStatusInfo(handle)</sample>
                        <param name="monitorHandle" type="handle" alias="Monitor.App" desc="Handle to the App-monitor."/>
                        <return name="state" type="enum" ref="AppStatus" desc="Status of the app."/>
                        <return name="additionalInfo" type="string" desc="Additional info to the status of the App. This can be the crash reason in case of a crash."/>
                    </function>
                    <function name="getMemoryUsage">
                        <desc>Get the script interpreter memory usage of the app.</desc>
                        <sample for="lua">Monitor.App.getMemoryUsage(handle)</sample>
                        <param name="monitorHandle" type="handle" alias="Monitor.App" desc="Handle to the App-monitor."/>
                        <return name="usedBytes" type="int" desc="Memory-bytes used by the script interpreter of this app."/>
                    </function>
                    <function name="getPrivateDataUsage">
                        <desc>Get the AppData usage of the app.</desc>
                        <sample for="lua">Monitor.App.getPrivateDataUsage(handle)</sample>
                        <param name="monitorHandle" type="handle" alias="Monitor.App" desc="Handle to the App-monitor."/>
                        <return name="usedBytes" type="int" desc="Bytes in the AppData folder used by this app."/>
                        <return name="capacityBytes" type="int" multiplicity="?" desc="Total capacity of the AppData folder for all apps in bytes."/>
                        <return name="appDataUsage" type="float" multiplicity="?" desc="The used bytes of the app in percent of the whole capactiy of the AppData folder."/>
                    </function>
                </serves>
            </crown>
            <crown name="Network">
                <trait>released</trait>
                <desc>Provides monitoring access to the network interface load of each interface or all interfaces together.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">Monitor.Network.create("ETH1")</sample>
                        <param name="interface" type="enum" ref="EthernetInterfaces" desc="The interface to monitor. Use 'ALL' to monitor all interfaces."/>
                        <return name="handle" type="handle" multiplicity="?" alias="Monitor.Network" desc="Handle to the Network-monitor. Will return nil if the interface is not valid, or if no statistics can be loaded."/>
                    </function>
                    <function name="getLoad">
                        <desc>Get the current network load.</desc>
                        <sample for="lua">Monitor.Network.getLoad(handle)</sample>
                        <param name="monitorHandle" type="handle" alias="Monitor.Network" desc="Handle to the Network-monitor."/>
                        <return name="sentBytesPerSec" type="int" desc="Current bytes sent per second."/>
                        <return name="receivedBytesPerSec" type="int" desc="Current bytes received per second."/>
                    </function>
                </serves>
            </crown>
        </crown>
        <crown name="Switch">
            <trait>released</trait>
            <desc>Provides functionality for rotary- and other multi-state switches</desc>
            <serves>
                <function name="create">
                    <desc>Creates a new Switch handle if switch exists and not already in use.</desc>
                    <sample for="lua">handle = Switch.create("YOUR_SWITCH")</sample>
                    <param name="switchName" type="enum" ref="Switches" desc="A unique identifier of the switch."/>
                    <return name="handle" type="handle" multiplicity="?" alias="Switch" desc="Handle to the switch. Nil if not available or already in use."/>
                </function>
                <function name="getState">
                    <desc>Get current switch position.</desc>
                    <sample for="lua">state, success = Switch.getState(handle)</sample>
                    <param name="handle" type="handle" alias="Switch" desc="Unique handle to the Switch"/>
                    <return name="state" type="int" desc="Current switch state. Only valid when second return value is true."/>
                    <return name="success" type="bool" desc="True if state was read successful."/>
                </function>
            </serves>
        </crown>
        <crown name="Object">
            <trait>released</trait>
            <desc>Provides functionality to work on object datatypes.
Persistence is one of the main features. Currently supported data format: JSON (file extension ".json") and MessagePack (file extension .msgpack)</desc>
            <enum name="DataFormat">
                <desc>In what kind of format data should be read/written</desc>
                <item name="JSON">JSON</item>
                <item name="MessagePack">MSGPACK</item>
            </enum>
            <serves>
                <function name="save">
                    <desc>Saves an object content to a file. If the data type enumeration is not passed as argument, the file extension is used to guess the data format.</desc>
                    <sample for="lua">success = Object.save(data, "private/FileContent.json")</sample>
                    <param name="obj" type="const auto" multiplicity="[1+]" desc="The object/handle(s) to be saved. Only objects/handle types are supported. Saving of handles is reserved for future use."/>
                    <param name="fileName" type="string" desc="The file where the data should be written to"/>
                    <param name="dataFormat" type="enum" multiplicity="?" ref="DataFormat" desc="Optional data format specification. If omitted, it is guessed from the file name extension"/>
                    <return name="success" type="bool" desc="true when saving succeeded, false when there was an error. In case of errors, please look at the console for error information"/>
                </function>
                <function name="load">
                    <desc>Loads an object/handle content from a file. When the type parameter is not passed, the data format is guessed from the file extension.</desc>
                    <sample for="lua">object = Object.load("private/FileContent.json")</sample>
                    <param name="fileName" type="string" desc="The file where the data should read from"/>
                    <param name="dataFormat" type="enum" multiplicity="?" ref="DataFormat" desc="Optional data format specification. If omitted, it is guessed from the file name extension"/>
                    <return name="obj" type="auto" multiplicity="[?*]" desc="A valid object/handle (or multiple of them) in case of success, no value in case of error"/>
                </function>
                <function name="serialize">
                    <desc>Serializes an object to a byte array</desc>
                    <sample for="json">buf = Object.serialize(data, "JSON")</sample>
                    <param name="obj" type="const auto" multiplicity="[1+]" desc="The object/handle(s) to be serialized. Only objects/handle types are supported. In case of handles, the configuration data is saved which was passed at the creation of the handle (if supported by the handle)"/>
                    <param name="dataFormat" type="enum" ref="DataFormat" desc="Data format specification"/>
                    <return name="serializedData" type="binary" multiplicity="?" desc="The serialized data in case of success, no data otherwise"/>
                </function>
                <function name="deserialize">
                    <desc>De-Serializes an object from a byte array</desc>
                    <sample for="json">obj = Object.deserialize(data, "JSON")</sample>
                    <param name="serializedData" type="binary" desc="The serialized data"/>
                    <param name="dataFormat" type="enum" ref="DataFormat" desc="Data format specification"/>
                    <return name="obj" type="auto" multiplicity="[?*]" desc="A valid object/handle (or multiple of them) in case of success, no value in case of error"/>
                </function>
                <function name="getType">
                    <desc>Returns the type name of an object/handle which is the CROWN name assigned to the object</desc>
                    <param name="obj" type="const auto" desc="The object/handle to get the type from"/>
                    <return name="crownName" type="string" multiplicity="?" desc="The name of the CROWN the object is assigned to"/>
                </function>
                <function name="clone">
                    <desc>Creates a full deep copy clone of the provided object/handle.
Can fail if the object/handle does not support cloning.</desc>
                    <param name="obj" type="const auto" desc="The object/handle to clone"/>
                    <return name="cloneObj" type="auto" multiplicity="?" desc="The cloned object/handle. Nil if clone was not possible or not successful."/>
                </function>
                <function name="toConst">
                    <desc>Return the provided object explicitly as const object.
This is useful to guarantee further const usage of the object.
The input object is not touched and stays non-const.</desc>
                    <param name="obj" type="const object" desc="The object to return as const"/>
                    <return name="constObj" type="const object" desc="The same object but as const"/>
                </function>
            </serves>
            <crown name="Binary">
                <trait>released</trait>
                <desc>The binary data type as object for better performance and shared object use cases.
Instead of using the binary data type of the CROWN framework, this object can be used to improve performance by reducing binary memory copies.
There are also algorithm functions operating on the binary content like encode/decode Base64.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new binary object.</desc>
                        <param name="value" type="binary" multiplicity="[?*]" desc="The initial binary value to set, or multiple values which are concatenated."/>
                        <return name="binaryObject" type="object" alias="Object.Binary" desc="The new binary object."/>
                    </function>
                    <function name="set">
                        <desc>Sets a new binary value to the object.</desc>
                        <param name="binaryObject" type="object" alias="Object.Binary" desc="Binary object instance."/>
                        <param name="value" type="binary" multiplicity="[1+]" desc="The new binary value to set, or multiple values which are concatenated."/>
                    </function>
                    <function name="get">
                        <desc>Gets the current binary value from the object.</desc>
                        <param name="binaryObject" type="const object" alias="Object.Binary" desc="Binary object instance."/>
                        <return name="value" type="binary" desc="Returns the current binary value of the object."/>
                    </function>
                    <function name="append">
                        <desc>Appends the specified binary value or Object.Binary instance to the binary object.</desc>
                        <param name="binaryObject" type="object" alias="Object.Binary" desc="Binary object instance."/>
                        <param name="value" type="const auto" multiplicity="[1+]" desc="The binary value or Object.Binary instance to append. Multiple values are possible to be append together."/>
                    </function>
                    <function name="toString">
                        <desc>Returns a string description of the content of the binary object.</desc>
                        <param name="binaryObject" type="const object" alias="Object.Binary" desc="Binary object instance."/>
                        <return name="description" type="string" desc="User-friendly description of the binary object. Non-string characters are escaped. Format is 'Size = x, Value 'yz'. Value longer than 30 bytes is ignored."/>
                    </function>
                    <function name="getSize">
                        <desc>Returns the size of the contained binary value.</desc>
                        <param name="binaryObject" type="const object" alias="Object.Binary" desc="Binary object instance."/>
                        <return name="size" type="int" desc="Size in bytes of the contained binary value."/>
                    </function>
                    <function name="encodeBase64">
                        <desc>Encodes the binary value to Base64 and returns a new binary value or Object.Binary instance with the encoded data.
Works with binary datatype as well as Object.Binary instance.</desc>
                        <param name="binaryObject" type="const auto" desc="Binary value or Object.Binary instance."/>
                        <return name="encodedObject" type="auto" desc="The new created binary value or Object.Binary instance with the encoded base64 data. The return type is the same than the input type."/>
                    </function>
                    <function name="decodeBase64">
                        <desc>Decodes the binary value from Base64 and returns a new binary value or Object.Binary instance with the decoded data.
The function parses for possible whitespace characters first and ignores them during decoding.
Works with binary datatype as well as Object.Binary instance.</desc>
                        <param name="binaryObject" type="const auto" desc="Binary value or Object.Binary instance."/>
                        <return name="decodedObject" type="auto" desc="The new created binary value or Object.Binary instance with the decoded base64 data. The return type is the same than the input type."/>
                    </function>
                </serves>
            </crown>
        </crown>
        <crown name="Recording">
            <trait>released</trait>
            <desc>Provides Recording/Playback functionality</desc>
            <crown name="Provider" builtin="true">
                <trait>released</trait>
                <desc>Contains meta-info about data providers. Is (de)serializable, so also suitable for Web-Control use. See also: Recording.Recorder.getProviders() function.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new, empty instance of the type</desc>
                        <return name="instance" type="object" alias="Recording.Provider" desc="The instance"/>
                    </function>
                    <function name="getEngineName">
                        <desc>Returns the name of the Engine which has created the provider. When the device is a single-engine device (the default case), this will be an empty string</desc>
                        <param name="instance" type="object" alias="Recording.Provider" desc="The instance"/>
                        <return name="engineName" type="string" desc="The engine name"/>
                    </function>
                    <function name="setEngineName">
                        <desc>Returns the name of the Engine which has created the provider. When the device is a single-engine device (the default case), this will be an empty string</desc>
                        <param name="instance" type="object" alias="Recording.Provider" desc="The instance"/>
                        <param name="engineName" type="string" desc="The engine name"/>
                    </function>
                    <function name="getAppName">
                        <desc>Returns the name of the App which has created the provider</desc>
                        <param name="instance" type="object" alias="Recording.Provider" desc="The instance"/>
                        <return name="appName" type="string" desc="The app name"/>
                    </function>
                    <function name="setAppName">
                        <desc>Sets the name of the App which has created the provider</desc>
                        <param name="instance" type="object" alias="Recording.Provider" desc="The instance"/>
                        <param name="appName" type="string" desc="The app name"/>
                    </function>
                    <function name="getCrownName">
                        <desc>Returns the name of the CROWN of the data provider</desc>
                        <param name="instance" type="object" alias="Recording.Provider" desc="The instance"/>
                        <return name="crownName" type="string" desc="The CROWN name"/>
                    </function>
                    <function name="setCrownName">
                        <desc>Returns the name of the CROWN of the data provider</desc>
                        <param name="instance" type="object" alias="Recording.Provider" desc="The instance"/>
                        <param name="crownName" type="string" desc="The CROWN name"/>
                    </function>
                    <function name="getEventName">
                        <desc>Returns the name of the CROWN event which delivers data</desc>
                        <param name="instance" type="object" alias="Recording.Provider" desc="The instance"/>
                        <return name="eventName" type="string" desc="The Event name"/>
                    </function>
                    <function name="setEventName">
                        <desc>Sets the name of the CROWN event which delivers data</desc>
                        <param name="instance" type="object" alias="Recording.Provider" desc="The instance"/>
                        <param name="eventName" type="string" desc="The Event name"/>
                    </function>
                    <function name="getConfigData">
                        <desc>Returns the configuration string of the data provider handle (if it is handle based)</desc>
                        <param name="instance" type="object" alias="Recording.Provider" desc="The instance"/>
                        <return name="configData" type="string" desc="The config data"/>
                    </function>
                    <function name="setConfigData">
                        <desc>Sets the configuration string of the data provider handle (if it is handle based)</desc>
                        <param name="instance" type="object" alias="Recording.Provider" desc="The instance"/>
                        <param name="configData" type="string" desc="The config data"/>
                    </function>
                    <function name="getInstanceCount">
                        <desc>Returns the instance counter of the data provider (0 based, from starting of all apps on)</desc>
                        <param name="instance" type="object" alias="Recording.Provider" desc="The instance"/>
                        <return name="instanceCount" type="int" desc="The instance count"/>
                    </function>
                    <function name="setInstanceCount">
                        <desc>Sets the instance counter of the data provider (0 based, from starting of all apps on)</desc>
                        <param name="instance" type="object" alias="Recording.Provider" desc="The instance"/>
                        <param name="instanceCount" type="int" desc="The instance count"/>
                    </function>
                    <function name="getTopic">
                        <desc>Returns the user defined topic string</desc>
                        <param name="instance" type="object" alias="Recording.Provider" desc="The instance"/>
                        <return name="topic" type="string" desc="The topic string"/>
                    </function>
                    <function name="setTopic">
                        <desc>Sets the user defined topic string (default empty)</desc>
                        <param name="instance" type="object" alias="Recording.Provider" desc="The instance"/>
                        <param name="topic" type="string" desc="The topic string"/>
                    </function>
                    <function name="getSelected">
                        <desc>Returns true when the provider is selected for data recording</desc>
                        <param name="instance" type="object" alias="Recording.Provider" desc="The instance"/>
                        <return name="selected" type="bool" desc="The selection"/>
                    </function>
                    <function name="setSelected">
                        <desc>Sets the provider as selected</desc>
                        <param name="instance" type="object" alias="Recording.Provider" desc="The instance"/>
                        <param name="selected" type="bool" desc="The selection"/>
                    </function>
                </serves>
            </crown>
            <crown name="StampInfo" builtin="true">
                <trait>released</trait>
                <desc>Contains information about stamps. Stamps are points in time and can be timestamps, increments, or anything else. Currently implemented are only timestamps.
This data type is meant to be used as communication structure for the client, to show play-back progress.
See also event "Recording.Player.OnProgressChange"</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new, empty instance of the type</desc>
                        <return name="instance" type="object" alias="Recording.StampInfo" desc="The instance"/>
                    </function>
                    <function name="getName">
                        <desc>Returns the name of the stamp. The default name for timestamps are 'TimeUs', which is microseconds since recording start</desc>
                        <param name="instance" type="object" alias="Recording.StampInfo" desc="The instance"/>
                        <return name="name" type="string" desc="The stamp name"/>
                    </function>
                    <function name="setName">
                        <desc>Sets the name of the stamp</desc>
                        <param name="instance" type="object" alias="Recording.StampInfo" desc="The instance"/>
                        <param name="name" type="string" desc="The stamp name"/>
                    </function>
                    <function name="getMinValue">
                        <desc>Returns the minimum valid value of the stamp. For 'TimeUs' stamps, this is usually the start stamp of the recording, which is zero</desc>
                        <param name="instance" type="object" alias="Recording.StampInfo" desc="The instance"/>
                        <return name="minValue" type="auto" desc="The minimum valid stamp value"/>
                    </function>
                    <function name="setMinValue">
                        <desc>Sets the minimum valid value of the stamp</desc>
                        <param name="instance" type="object" alias="Recording.StampInfo" desc="The instance"/>
                        <param name="minValue" type="auto" desc="The minimum valid stamp value"/>
                    </function>
                    <function name="getCurrentValue">
                        <desc>Returns the current value of the stamp</desc>
                        <param name="instance" type="object" alias="Recording.StampInfo" desc="The instance"/>
                        <return name="currentValue" type="auto" desc="The current stamp value"/>
                    </function>
                    <function name="setCurrentValue">
                        <desc>Sets the current value of the stamp</desc>
                        <param name="instance" type="object" alias="Recording.StampInfo" desc="The instance"/>
                        <param name="currentValue" type="auto" desc="The current stamp value"/>
                    </function>
                    <function name="getMaxValue">
                        <desc>Returns the maximum valid value of the stamp. For 'TimeUs' stamps, this is the most recent event which has occurred, at the end of the recording</desc>
                        <param name="instance" type="object" alias="Recording.StampInfo" desc="The instance"/>
                        <return name="maxValue" type="auto" desc="The minimum valid stamp value"/>
                    </function>
                    <function name="setMaxValue">
                        <desc>Sets the maximum valid value of the stamp</desc>
                        <param name="instance" type="object" alias="Recording.StampInfo" desc="The instance"/>
                        <param name="maxValue" type="auto" desc="The maximum valid stamp value"/>
                    </function>
                </serves>
            </crown>
            <crown name="Recorder">
                <trait>released</trait>
                <desc>Recording functionality. Recording is implemented as a separate, decoupled thread/task, to write recorded data to a destination.
Decoupling is done by using a queue/buffer in which the events that should be recorded are temporarily stored, until the recording thread/task gets processing time to write them to the destination. Each Handle-based event, with payload that correlates to a manifested data format, is recordable and will be shown in the "Providers" list returned by "getProviders()". The minimum calls needed to have recording working is: create(), setProviders(), add...Target(), start().
Without defined targets or data providers, recording won't be possible.
The Recorder instances can be made persistent by using the Object.save()/serialize() API and can also be re-loaded. The recording mode, selected providers and meta-info is made persistent;
the other features, such as targets, have to be re-added in case the instance is loaded again.</desc>
                <enum name="RecordingMode">
                    <desc>In which way to record data</desc>
                    <item name="CONTINUOUS" desc="The default mode, where each event is recorded to the target as soon as possible, in a low priority thread. The optional integer parameter is the event queue size, which is 128 by default when not specified">CONTINUOUS</item>
                    <item name="STOP_BASED_TIME" desc="Fetch data in a queue, but do not write to the target continuously. When recording is stopped, the last N milliseconds (N is specified via parameter) are written to the target. An additional parameter, which specifies the number of milliseconds, needs to be passed">STOP_BASED_TIME</item>
                    <item name="STOP_BASED_ITEMS" desc="Fetch data in a queue, but do not write to the target continuously. When recording is stopped, the last N fetched items/occurred events are written to the target. An additional parameter, which specifies the number of items/events, needs to be passed">STOP_BASED_ITEMS</item>
                </enum>
                <serves>
                    <event name="OnRecordingStopped">
                        <desc>Notified when recording stopped automatically due to target overrun or target errors, or manually by API 'stop()' call</desc>
                        <sample for="lua">instance:register(handle, "OnRecordingStopped", function() print("Recording has stopped.") end)</sample>
                        <param name="handle" type="handle" alias="Recording.Recorder" desc="The recorder instance"/>
                    </event>
                    <event name="OnDataLost">
                        <desc>Notified when the recording queue was too small and was overrun due to high data load. Can be used to signal in a GUI that recording has data loss</desc>
                        <sample for="lua">instance:register(handle, "OnDataLost", function() print("Data lost during recording; please increase queue size or reduce data load.") end)</sample>
                        <param name="handle" type="handle" alias="Recording.Recorder" desc="The recorder instance"/>
                    </event>
                    <function name="create">
                        <desc>Creates a new recorder instance. The number of creatable recorders is not limited; it is multi-instantiatable</desc>
                        <sample for="lua">instance = Recording.Recorder.create()</sample>
                        <return name="instance" type="handle" alias="Recording.Recorder" desc="The instance"/>
                    </function>
                    <function name="setMode">
                        <desc>Sets the mode of recording. When not called, the default mode is like if setMode("CONTINUOUS", 128) would have been called.</desc>
                        <sample for="lua">
              handle:setMode("CONTINUOUS") -- Default mode with queue size=128 items
              handle:setMode("CONTINUOUS", 1000) -- Record continuously with a maximum item queue size of 1000 elements
              handle:setMode("STOP_BASED_TIME", 2000) -- Record the last 2 seconds before recording stop (=2000 milliseconds)
              handle:setMode("STOP_BASED_ITEMS", 10) -- Record the last 10 events before recording stop
            </sample>
                        <param name="instance" type="handle" alias="Recording.Recorder" desc="The instance"/>
                        <param name="mode" type="enum" ref="RecordingMode" desc="Recording mode, see enumeration"/>
                        <param name="modeParam0" type="int" multiplicity="?" desc="Optional parameter to the recording mode, depends on the selected mode (See enumeration documentation)"/>
                    </function>
                    <function name="setDataFormat">
                        <desc>Sets the data format that should be used for recording. The default is 'JSON' when not called. This function must be called before recording starts to have an effect. When the passed data format is not supported, an error is logged.</desc>
                        <sample for="lua">instance:setDataFormat("MSGPACK")</sample>
                        <param name="instance" type="handle" alias="Recording.Recorder" desc="The instance"/>
                        <param name="format" type="enum" ref="Object.DataFormat" desc="the format"/>
                    </function>
                    <function name="getProviders">
                        <desc>Returns a list of description objects of the currently available data providers that can be recorded.
That list is a snapshot of the current state; the returned providers may get invalid at run-time. The returned list can be serialized to a GUI.
By default, the 'Selected' property on each provider is set to 'false'. A GUI or script may set that to 'true' to enable recording on that provider.</desc>
                        <sample for="lua">provs = instance:getProviders()</sample>
                        <param name="instance" type="handle" alias="Recording.Recorder" desc="The instance"/>
                        <return name="providers" type="object" multiplicity="*" alias="Recording.Provider" desc="Data providers description"/>
                    </function>
                    <function name="setProviders">
                        <desc>Sets the data providers which are used for data recording. This should be a sub-set of the list returned by the getProviders() call, or the whole list.
The object can be de-serialized from a GUI/Device Page.
Only data providers which have the 'Selected' member set to 'true' are considered for data recording; the rest is simply ignored</desc>
                        <sample for="lua">instance:setProviders(provs)</sample>
                        <param name="instance" type="handle" alias="Recording.Recorder" desc="The instance"/>
                        <param name="providers" type="object" multiplicity="*" alias="Recording.Provider" desc="The providers list"/>
                    </function>
                    <function name="removeAllTargets">
                        <desc>Clears the list of recording targets. Can be called before and add...Target() call to make sure that there is only one target active, if needed.
A newly created 'Recorder' instance has no pre-defined targets.</desc>
                        <sample for="lua">instance:removeAllTargets()</sample>
                        <param name="instance" type="handle" alias="Recording.Recorder" desc="The instance"/>
                    </function>
                    <function name="addFileTarget">
                        <desc>Adds a file target, to put the recorded data into. When a maximum file size is specified an reached during recording, recording is stopped automatically when the parameter 'split' isn't set or is false. When 'split' is true however,
the current file will be closed and a new file will be started with a different file name. The file name for split files is created by replacing a dollar sign ($) in the file name with an index that starts from zero and counts up. See second lua sample
to this function.
The file name part 'sdr' means Sensor Data Recording, 'sdri' means Sensor Data Recording Index.
The file extension for JSON should be '.sdr.json' or '.sdri.json', for MessagePack '.sdr.msgpack' or '.sdri.msgpack'.
Having the correct file extension, the player is able to auto-detect the file format.</desc>
                        <sample for="lua">instance:addFileTarget("private/MyRecording.sdr.json", "private/MyRecording.sdri.json") -- no split recording
instance:addFileTarget("private/MyRecording$.sdr.json", "private/MyRecording$.sdri.json", 104857600, true) -- Create new file every 10 megabytes of data
            </sample>
                        <param name="instance" type="handle" alias="Recording.Recorder" desc="The instance"/>
                        <param name="fileName" type="string" desc="target file name for recorded data"/>
                        <param name="indexFileName" type="string" multiplicity="?" desc="Optional file for index data (better stream navigation possible"/>
                        <param name="maxFileSize" type="int" multiplicity="?" desc="Maximum size of the recorded stream, in bytes"/>
                        <param name="split" type="bool" multiplicity="?" desc="When true, the recording is split over several files when the maxFileSize is exceeded (each file may be a little bigger than the specified maxFileSize). The file name(s) needs to have an embedded dollar ($) sign which is replaced by a counter that starts counting from 0 (zero) on"/>
                    </function>
                    <function name="addTCPIPTarget">
                        <desc>Adds a TCP/IP connection as target.
The target must be a TCP/IP server which listens on a specific port and receives data.
Linux' NetCat (nc) command, also available under Windows, can be used for that, or any other TCP/IP server that can listen on some port and record data.
When index data should be recorded, two open ports are needed and the index arguments of this functions need to be filled.
When the connection is closed from server side, the recording automatically stops.
Netcat usage example: "nc -l -p 3333 &gt; myRecording.sdr.msgpack" will start a TCP/IP server that listens on port 3333 and dump the received data into a server-local file "myRecording.sdr.msgpack"
Recording of index data is, as with file targets, optional and only needed when the user wants to seek during play-back afterwards.
In play-back though, seeking can only be done in forward direction because of the stream-like behavior of TCP/IP (there is no random access).
However, the recorded files may also be put to the device's file system, if small enough, for random access seeking.</desc>
                        <sample for="lua">instance:addTCPIPTarget("127.0.0.1", 4711)</sample>
                        <param name="instance" type="handle" alias="Recording.Recorder" desc="The instance"/>
                        <param name="ipAddr" type="string" desc="Server IP address"/>
                        <param name="ipPort" type="int" desc="Server IP port number"/>
                        <param name="interface" type="enum" multiplicity="?" ref="EthernetInterfaces" desc="Interface name; omitted argument or the string 'ALL' means all interfaces"/>
                        <param name="idxIpAddr" type="string" multiplicity="?" desc="Server IP address for index data"/>
                        <param name="idxIpPort" type="int" multiplicity="?" desc="Server IP port number for index data"/>
                        <param name="idxInterface" type="enum" multiplicity="?" ref="EthernetInterfaces" desc="Interface name for index data. Omitted argument or the string 'ALL' means all interfaces"/>
                    </function>
                    <function name="removeMetaInfo">
                        <desc>Removes a single meta-info or all meta info</desc>
                        <sample for="lua">instance:removeMetaInfo("Info1") -- Removes only one info
instance:removeMetaInfo() -- Removes all meta info
            </sample>
                        <param name="instance" type="handle" alias="Recording.Recorder" desc="The instance"/>
                        <param name="name" type="string" multiplicity="?" desc="Name of the meta-information to be removed. When omitted, all meta info is removed"/>
                        <return name="success" type="bool" desc="true when the info was successfully removed, false in case the passed meta-info name does not exist"/>
                    </function>
                    <function name="setMetaInfo">
                        <desc>Adds user-defined meta-information to the recording file, when started. That meta-info is meant just for the user, to understand the recording scenario, for example how the sensors were arranged during the recording. You can use whatever MIME type you want. When the MIME type is 'text/plain', the information is stored as a string in the file, else, as a binary segment.</desc>
                        <sample for="lua">instance:setMetaInfo("DeviceSetUp", "image/png", pngData, "How the devices were arranged in the room during recording")</sample>
                        <param name="instance" type="handle" alias="Recording.Recorder" desc="The instance"/>
                        <param name="name" type="string" desc="Name of the meta-information, can be chosen freely; supported characters are [A-Z][a-z][0-9]_ (no space allowed). It should not clash with other meta-info"/>
                        <param name="mimeType" type="string" desc="MIME-type of the meta information. For plain text, please use 'text/plain'. If there is no known MIME type, please pass 'application/octet-stream' which means 'undefined'"/>
                        <param name="data" type="binary" desc="The meta-information in the specified MIME type format"/>
                        <param name="comment" type="string" multiplicity="?" desc="Comment on the meta-info, is optional. When an empty string is passed, this is equivalent to omitting the argument"/>
                    </function>
                    <function name="getMetaInfoNames">
                        <desc>Returns the names of all set meta infos</desc>
                        <param name="instance" type="handle" alias="Recording.Recorder" desc="The instance"/>
                        <return name="names" type="string" multiplicity="*" desc="Names of the meta-informations"/>
                    </function>
                    <function name="getMetaInfoByName">
                        <desc>Returns meta info by name, which was set by the API setMetaInfo(). When the meta info does not exist, empty strings/binaries will be returned.</desc>
                        <param name="instance" type="handle" alias="Recording.Recorder" desc="The instance"/>
                        <param name="name" type="string" desc="Name of the meta-information"/>
                        <return name="mimeType" type="string" desc="MIME-type of the meta information"/>
                        <return name="data" type="binary" desc="The meta-information in the specified MIME type format"/>
                        <return name="comment" type="string" desc="Comment on the meta-info. When no comment was set, this is an empty string"/>
                    </function>
                    <function name="setQueueSize">
                        <trait>deprecated</trait>
                        <desc>Deprecated. Please use the function setMode() instead. This function behaves the same as setMode("CONTINUOUS", x).
Sets the internal buffer size of the queue of events which is used to decouple the recording from the rest of the system.
Recording is done asynchronous in a separate thread, using a queue to buffer elements until they can be written to the destination.
The default value is 128. Please choose a different value when there is too much system load and the queue ran over at some point, printing out errors.
Note that with very big queues, there might be a risk to run out of memory at high loads, because a lot of memory is needed to buffer a lot of events.</desc>
                        <sample for="lua">instance:setQueueSize(1000)</sample>
                        <param name="instance" type="handle" alias="Recording.Recorder" desc="The instance"/>
                        <param name="size" type="int" desc="Queue size in number of event entries. Allowed values: 1 - 4294967295"/>
                    </function>
                    <function name="start">
                        <desc>Starts recording. Errors will be printed to the console. Recording stops when the target is disconnected or file is full.</desc>
                        <sample for="lua">success = instance:start()</sample>
                        <param name="instance" type="handle" alias="Recording.Recorder" desc="The instance"/>
                        <return name="success" type="bool" desc="When true, recording is started; when false, it means that recording already is running"/>
                    </function>
                    <function name="stop">
                        <desc>Stops recording. Closes the data source.</desc>
                        <sample for="lua">success = instance:stop()</sample>
                        <param name="instance" type="handle" alias="Recording.Recorder" desc="The instance"/>
                        <return name="success" type="bool" desc="When true, recording is stopped; when false, it means that recording wasn't running"/>
                    </function>
                    <function name="register">
                        <desc>This function is used to register for any event of the handle.</desc>
                        <param name="handle" type="handle" alias="Recording.Recorder" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to register to"/>
                        <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                        <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                    </function>
                    <function name="deregister">
                        <desc>This function is used to deregister from any registered event of the handle.</desc>
                        <param name="handle" type="handle" alias="Recording.Recorder" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to deregister from"/>
                        <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                        <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                    </function>
                </serves>
            </crown>
            <crown name="Player">
                <trait>released</trait>
                <desc>Play-back functionality of recorded data. Like "Recorder" instances, there can also be multiple players in the system; the number is not limited.
Playback is done by "injecting" the recorded events back into the system. This can be done in a merge-like way, to inject that data additionally (DataSourceMode MIX) or by replacing the live events by the recorded events (DataSourceMode MUTE, which is the default). To be able to play-back, the recording mechanisms search in the system for data providers matching the name and description of the data providers used in the recording. The App names and the data source names should match to avoid play-back problems and conflicts. See also DataSourceLookupMode enumeration. The minimum calls to enable play-back are: create(), set...Source(), start().</desc>
                <enum name="DataSourceMode">
                    <desc>The way data sources are handled during play-back</desc>
                    <item name="MUTE" desc="Shut down/mute data source and only play recorded data back into the system">MUTE</item>
                    <item name="MIX" desc="Don't mute data source but mix recorded data with live data">MIX</item>
                </enum>
                <enum name="DataSourceLookupMode">
                    <desc>The way existing data sources are looked-up for playing-back data into them</desc>
                    <item name="PERFECT_MATCH" desc="The default setting: Only allow perfect matching data sources. When not found, the data track is ignored during play-back">PERFECT_MATCH</item>
                    <item name="BEST_MATCH" desc="First try to find the perfect matching data source (crown name, event name, app name, instance counter and config match exactly). When not found, first ignore the instance counter and re-try, then ignore the config data and re-try, and then ignore the app name and re-try, and then some combinations of all three. When the data source is still not found, the data track is left-out at playback and a warning is printed at the console. Note that this mode can lead to sending recorded data to wrong data sources when not used carefully. Please look at the console for warnings.">BEST_MATCH</item>
                    <item name="CALLBACK" desc="Don't play-back into the system but use callback functions registered with the registerCallback() function. This mode is mandatory for 'UNTIMED' play-back mode">CALLBACK</item>
                </enum>
                <enum name="PlayBackMode">
                    <desc>How to do play-back control (time based vs. increment based)</desc>
                    <item name="TIME_BASED" desc="Play-back controlling based on timestamp">TIME_BASED</item>
                    <item name="INCREMENT_BASED" desc="Play-back controlling based on increment. Pre-condition is the availability of increment stamps in the recording (See Conveyor API).">INCREMENT_BASED</item>
                    <item name="UNTIMED" desc="Play without wait states, which means as fast as possible. This mode requires the 'CALLBACK' data source look-up mode to not overload the system with too many events at once">UNTIMED</item>
                </enum>
                <serves>
                    <event name="OnPlaybackStopped">
                        <desc>Notified when either the the whole data was played back or the pause/stop functions have been called.
When this event is notified, one can use the getCurrent...() function to report the current position in the data</desc>
                        <param name="instance" type="handle" alias="Recording.Player" desc="The instance"/>
                    </event>
                    <event name="OnPlaybackFailed">
                        <desc>Notified when playback has been stopped unexpectedly due to an error.
The details can be looked up at the console.
This event is fired additionally after a OnPlaybackStopped event</desc>
                        <param name="instance" type="handle" alias="Recording.Player" desc="The instance"/>
                    </event>
                    <event name="OnProgressChange">
                        <desc>Notifies the current progress of play-back. For each stamp object fired, there is a MinValue/MaxValue/CurrentValue member from which the progress can be calculated depending on the application needs.
The stamp 'TimeUs' is mandatory and always present, so this can be reliably used for that purpose. Other stamps are application specific.
When the length of play-back data is unknown (no index available), this event is never fired after 'play()' has been called.</desc>
                        <param name="instance" type="handle" alias="Recording.Player" desc="The instance"/>
                        <param name="stamps" type="object" multiplicity="+" alias="Recording.StampInfo" desc="The stamps"/>
                    </event>
                    <function name="create">
                        <desc>Creates a new Player instance</desc>
                        <return name="instance" type="handle" alias="Recording.Player" desc="The instance"/>
                    </function>
                    <function name="setPlayBackMode">
                        <desc>Defines according to which stamp information in the recording the play-back should be done. Default, when not called, is 'TIME_BASED'</desc>
                        <sample for="lua">instance:setPlayBackMode("INCREMENT_BASED")</sample>
                        <param name="instance" type="handle" alias="Recording.Player" desc="The instance"/>
                        <param name="mode" type="enum" ref="PlayBackMode" desc="The mode"/>
                        <return name="success" type="bool" desc="true if the mode could be set, false when either the device doesn't support the mode"/>
                    </function>
                    <function name="setSpeedUpFactor">
                        <desc>Changes the play-back speed</desc>
                        <sample for="lua">instance:setSpeedUpFactor(1.25)</sample>
                        <param name="instance" type="handle" alias="Recording.Player" desc="The instance"/>
                        <param name="factor" type="float" desc="The speed-up factor. Depending on the play-back mode, the value (usually between 0.1 and 10.0) is accepted"/>
                        <return name="success" type="bool" desc="true when the factor could be set, false when either the device and play-back mode doesn't support that factor"/>
                    </function>
                    <function name="setDataSourceMode">
                        <desc>Sets the data source mocking mode. The default, when not called, is MUTE. In case of MUTE, the original data sources are muted and only the recorded data is played back into the system, to not interfere with live data. In case of MIX, the recorded data is played-back into the system, mixed with the live data that is coming in</desc>
                        <sample for="lua">instance:setDataSourceMode("MIX")</sample>
                        <param name="instance" type="handle" alias="Recording.Player" desc="The instance"/>
                        <param name="mode" type="enum" ref="DataSourceMode" desc="The mode (see enum)"/>
                    </function>
                    <function name="setDataSourceLookupMode">
                        <desc>How data sources are found by examining the info stored in the recorded file. The default, when not called, is 'BEST_MATCH'. You only need to call this function when that behavior does not meet the play-back requirements.
When 'PERFECT_MATCH' is used, only perfect matching sources are used. When 'BEST_MATCH' is used, th player first tries to find the perfect matching data source
(crown name, event name, app name, instance counter and config match exactly). When not found, it first ignores the instance counter and re-tries,
then ignores the config data and re-ties, and then ignores the app name and re-tries, and then some combinations of all three.
When the data source is still not found, the data track is left-out at playback and a warning is printed at the console.
Note that this mode can lead to sending recorded data to wrong data sources when not used carefully.
Please look at the console for warnings.</desc>
                        <param name="instance" type="handle" alias="Recording.Player" desc="The instance"/>
                        <param name="mode" type="enum" ref="DataSourceLookupMode" desc="The look-up mode"/>
                    </function>
                    <function name="setFileSource">
                        <desc>Sets the source to file type. The file name part 'sdr' means Sensor Data Recording, 'sdri' means Sensor Data Recording Index. When no second file for index data is provided, the seek...() functions may not work due to missing index information. With file sources, random access seeking (absolute, relative in forward- and backward direction) is possible.</desc>
                        <sample for="lua">instance:setFileSource("private/MyRecording.sdr.json", "private/MyRecording.sdri.json")</sample>
                        <param name="instance" type="handle" alias="Recording.Player" desc="The instance"/>
                        <param name="fileName" type="string" desc="Source file name for recorded data"/>
                        <param name="indexFileName" type="string" multiplicity="?" desc="Optional file for index data (Makes stream navigation/seeking better)"/>
                    </function>
                    <function name="setTCPIPSource">
                        <desc>Sets a TCP/IP connection as source.
The connection must point to a TCP/IP server that serves the data. Linux's NetCat (nc) command, also available under Windows, can be used for that.
In case index data should be used as well, two distinct open server ports are needed.
When the server does not deliver data within one second, the player considers this as an end-of-data/file indicator and stops play-back. This is so due to the fact that
there is no end-of-recording marker in the recorded data.
Important note: Seeking using the seek...() functions is only possible in forward direction and only if the number of already received bytes is smaller or equal to the seeking position due to the
stream-like (not random access) characteristic of TCP. Also, when too many bytes were received and buffered before the actual play-back, seeking may fail.
This can be partially worked around by starting the play-back in "stopped" mode (see function start()), then seeking to the wanted position, then resuming play-back, but also for that
there is no guarantee for success, especially for low seeking offsets.
Example for netcat: "nc -l -p 3333 &lt; myRecording.sdr.msgpack"</desc>
                        <sample for="lua">instance:setTCPIPSource("127.0.0.1", 4711)</sample>
                        <param name="instance" type="handle" alias="Recording.Player" desc="The instance"/>
                        <param name="ipAddr" type="string" desc="Server IP address"/>
                        <param name="ipPort" type="int" desc="Server IP port number"/>
                        <param name="interface" type="enum" multiplicity="?" ref="EthernetInterfaces" desc="Interface name; omitted argument or the string 'ALL' means all interfaces"/>
                        <param name="idxIpAddr" type="string" multiplicity="?" desc="Server IP address for index data"/>
                        <param name="idxIpPort" type="int" multiplicity="?" desc="Server IP port number for index data"/>
                        <param name="idxInterface" type="enum" multiplicity="?" ref="EthernetInterfaces" desc="Interface name for index data. Omitted argument or the string 'ALL' means all interfaces"/>
                    </function>
                    <function name="registerCallback">
                        <desc>Registers a call back function for specific tracks of data, which is needed when the data source look-up mode is set to 'CALLBACK'. Multiple call-backs can be registered to one player object to allow distribution of data to multiple handlers.
The registered call-back function needs to call the acknowledge() function when processing is done because the internal player task blocks until acknowledge() is called to not block the CPU of the device. This is for importance for the 'UNTIMED' replay mode.
But even when another mode is chose, acknowledge() should anyway be called. It won't do anything in other modes, but that way, he call-back functions don't need to be altered when the play-back mode changes.
The user is free to also slow down reading by adding code that calls acknowledge() in an delayed way (useful only in 'UNTIMED' play-back mode)
The call-back function is called with the following arguments:
- Player instance reference, which is needed to call acknowledge()
- Current fragment ID, which is an increasing integer stored in the recorded data
- Stamps of the fragment (array of Recording.StampInfo objects), which contains at least one element ('TimeUs' stamp)
- First payload item
- Second payload item
- ... (up to 5 different payloads items)</desc>
                        <sample for="lua">local prov = Recording.Provider.create()
prov:setCrownName("TheCrownName")
prov:setEventName("TheEventName")
prov:setInstanceCount(-1) -- Important: Negative integers or empty strings serve as 'don't care'
prov:setSelected(true) -- Only then, the prov will be evaluated

function cb(player, fragmentNr, stamps, trackData1, trackData2, ...)
  print("Fragment: " .. fragmentNr)
  for i,stamp in pairs(stamps) do
    print("Stamp '" .. stamp:getName() .. "': " .. stamp:getCurrentValue())
  end
  -- Proces trackData...
  player:acknowledge() -- This call is mandatory!
end

instance:registerCallback(cb, "Image*;int", { 1, 0 }, prov) -- Everything except the 'callback' parameter is optional. Just use 'cb' alone if that should handle all kinds of data.
instance:start() -- Reads data and calls cb function
</sample>
                        <param name="instance" type="handle" alias="Recording.Player" desc="The instance"/>
                        <param name="callback" type="string" alias="function" desc="The call-back function to call for a specific data track"/>
                        <param name="datatypes" type="string" multiplicity="?" desc="At which data types to call the call-back. When one of the passed values matches on any event payload, the call-back is called. When an empty string is passed or the argument is not passed (optional), this means any kind of data. Multiple types can be passed, separated by semicolon. A '*' or '?' can be passed as wildcard (DOS-style). Also basic types, such as 'int', are allowed."/>
                        <param name="indexes" type="int" multiplicity="*" desc="What indexes of the event payload to pass to the call-back function in which order. An empty array means 'every value in order of occurence'"/>
                        <param name="tracks" type="const object" multiplicity="[?*]" alias="Recording.Provider" desc="Zero or more provider objects that describe the tracks to select. When no object is passed, this means selection of all tracks. Empty/unset strings or negative integers in the objects serve as 'don't care'. Only providers that have the 'Selected' property set to 'true' are evaluated."/>
                        <return name="success" type="bool" desc="true when the call-back function is properly served and when all other parameters are also valid. false otherwise. When false, no registration has been done."/>
                    </function>
                    <function name="acknowledge">
                        <desc>Acknowledges the current call-back. See also registerCallback() function. Please call that function in each registered callback function at the end</desc>
                        <param name="instance" type="handle" alias="Recording.Player" desc="The instance"/>
                    </function>
                    <function name="start">
                        <desc>Starts play-back. Data source is closed when the whole stream was played back. At start, the index (if available) is parsed and after that playing starts immediately unless the parameter 'paused' is set to true</desc>
                        <sample for="lua">success = instance:start()</sample>
                        <param name="instance" type="handle" alias="Recording.Player" desc="The instance"/>
                        <param name="paused" type="bool" multiplicity="?" desc="Optional parameter. When true, only the index (if available) is parsed and the player will be in a state as if 'pause()' would have been called directly after 'start()'. This enables calling the 'seek...()' functions directly after starting play-back"/>
                        <return name="success" type="bool" desc="When true, play-back is started; when false, it means that play-back already is running"/>
                    </function>
                    <function name="pause">
                        <desc>Pauses play-back. To continue, call pause or start again. Data source is not closed and may not be accessible during pausing state. During pausing, the seek...() functions can be used to jump to another position in the data, but only when index data is available</desc>
                        <sample for="lua">success = instance:pause()</sample>
                        <param name="instance" type="handle" alias="Recording.Player" desc="The instance"/>
                        <return name="success" type="bool" desc="When true, pause/resume succeeded, when false, play-back is currently not running, so the pause() call is meaningless"/>
                    </function>
                    <function name="stop">
                        <desc>Stops and cancels play-back. Closes the data source.</desc>
                        <sample for="lua">success = instance:stop()</sample>
                        <param name="instance" type="handle" alias="Recording.Player" desc="The instance"/>
                        <return name="success" type="bool" desc="When true, recording is stopped; when false, recording isn't running, so the stop() call was meaningless"/>
                    </function>
                    <function name="getMetaInfoNames">
                        <desc>Returns the names of all set meta infos. This function can be called after start() has returned successfulls. It is recommended to start in 'paused' mode (calling start(true)), then reading out the meta-info, then resuming with either pause() or start() or cancelling with stop()</desc>
                        <param name="instance" type="handle" alias="Recording.Player" desc="The instance"/>
                        <return name="names" type="string" multiplicity="*" desc="Names of the meta-informations"/>
                    </function>
                    <function name="getMetaInfoByName">
                        <desc>Returns meta info by name. When the meta info does not exist, empty strings/binaries will be returned. This function can be called after start() has returned successfulls. It is recommended to start in 'paused' mode (calling start(true)), then reading out the meta-info, then resuming with either pause() or start() or cancelling with stop()</desc>
                        <param name="instance" type="handle" alias="Recording.Player" desc="The instance"/>
                        <param name="name" type="string" desc="Name of the meta-information"/>
                        <return name="mimeType" type="string" desc="MIME-type of the meta information"/>
                        <return name="data" type="binary" desc="The meta-information in the specified MIME type format"/>
                        <return name="comment" type="string" desc="Comment on the meta-info. When no comment was set, this is an empty string"/>
                    </function>
                    <function name="getLastFragmentId">
                        <desc>Returns the number of the last fragment (a number starting with zero) that has been played back. It is meaningful but not necessary that the player is in paused state when calling this function. When the player hasn't been started yet, this function returns -1</desc>
                        <sample for="lua">lastFragmentNr = instance:getLastFragmentId()</sample>
                        <param name="instance" type="handle" alias="Recording.Player" desc="The instance"/>
                        <return name="success" type="int" desc="The last played-back fragment number or -1 in case the player has been stopped or hasn't been started yet"/>
                    </function>
                    <function name="getLastStamp">
                        <desc>Returns a stamp value of the last played-back fragment. The 'TimeUs' stamp always exists and returns the number of microseconds since recording begin; all other stamps are application defined. When the player hasn't been started yet or the stamp isn't found, no value/nil is returned</desc>
                        <sample for="lua">lastTimeUs = instance:getLastStamp("TimeUs")</sample>
                        <param name="instance" type="handle" alias="Recording.Player" desc="The instance"/>
                        <param name="stampName" type="string" desc="The stamp name"/>
                        <return name="stampValue" type="auto" multiplicity="?" desc="The stamp value"/>
                    </function>
                    <function name="seekFragment">
                        <desc>Navigates in the stream to a defined fragment number (Fragments are usually points in time where data has been recorded, counted from zero upwards).
Precondition for successful seeking is availability of index data and a source that supports random access seeking, such as file sources. For TCP/IP, seeking is only possible in forward direction and only when the position is after the already read offset in bytes.</desc>
                        <sample for="lua">instance:seekFragment(3) -- Jump to fragment nr. 3</sample>
                        <param name="instance" type="handle" alias="Recording.Player" desc="The instance"/>
                        <param name="fragmentNr" type="int" desc="Number of the data fragment. Usually, one data fragment covers one point in time (stamp) where data has been recorded."/>
                        <return name="success" type="bool" desc="true when successful, false when the frame number is unknown or seeking direction is not supported on the data source or no index data is available"/>
                    </function>
                    <function name="seekStamp">
                        <desc>Navigates in the stream to a specific point in time.
Play-back will start again after calling 'pause()' or 'start()' at the first fragment found that is equal or later in time to the defined stamp.
The default stamp is "TimeUs" which is the number of microseconds since the recording has started.
Precondition for successful seeking is availability of index data and a source that supports random access seeking, such as file sources. For TCP/IP, seeking is only possible in forward direction and only when the position is after the already read offset in bytes.
When the passed stamp value is outside of the range of the available index data, it is adjusted to the nearest neighbor.</desc>
                        <sample for="lua">instance:seekStamp("TimeUs", 3000) -- Jumps to 3000 micro-seconds from beginning of recording</sample>
                        <param name="instance" type="handle" alias="Recording.Player" desc="The instance"/>
                        <param name="stampName" type="string" desc="Name of the stamp, 'TimeUs' always works with integer value"/>
                        <param name="value" type="auto" desc="Stamp value. For the default 'TimeUs' stamp, this has to be a integer"/>
                        <return name="success" type="bool" desc="true when successful, false when the frame number is unknown or seeking direction is not supported on the data source"/>
                    </function>
                    <function name="register">
                        <desc>This function is used to register for any event of the handle.</desc>
                        <param name="handle" type="handle" alias="Recording.Player" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to register to"/>
                        <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                        <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                    </function>
                    <function name="deregister">
                        <desc>This function is used to deregister from any registered event of the handle.</desc>
                        <param name="handle" type="handle" alias="Recording.Player" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to deregister from"/>
                        <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                        <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                    </function>
                </serves>
            </crown>
        </crown>
        <crown name="Ethernet">
            <trait>released</trait>
            <desc>Encapsulates functionality related to Ethernet interface configuration and manipulation.</desc>
            <serves>
                <function name="ping">
                    <links>Ethernet.Diagnosis</links>
                    <desc>Send and receive single ping packet to network ip addresses to check if the address is reachable.
The function blocks until the answer is received or timeout is reached.</desc>
                    <sample for="lua">local bReachable = Ethernet.ping("192.168.0.1")</sample>
                    <param name="ipAddress" type="string" desc="The IP address as string e.g. '192.168.0.10'"/>
                    <param name="timeoutMs" type="int" multiplicity="?" desc="Timeout to try to ping in milliseconds. Default 1000ms. Maximum of 5000ms is allowed. Bigger number is cropped."/>
                    <param name="ifName" type="enum" multiplicity="?" ref="EthernetInterfaces" desc="One of the available interfaces. Empty for all interfaces using routing table (Default)."/>
                    <param name="payloadSizeBytes" type="int" multiplicity="?" desc="Size of the ping packet payload. Default 32 bytes."/>
                    <return name="success" type="bool" desc="True if target response received within timeout"/>
                    <return name="responseTimeMs" type="int" multiplicity="?" desc="The time in milliseconds until the response was received. Only returned if there was a response."/>
                </function>
                <function name="getInterfaceConfig">
                    <trait>hidden</trait>
                    <desc>Returns the current configuration of the specified ethernet interface.</desc>
                    <param name="ifName" type="enum" ref="EthernetInterfaces" desc="The interface to get the config from"/>
                    <return name="ipAddress" type="string" multiplicity="?" desc="The IP address of the specified interface or nil if interface does not exist"/>
                    <return name="subnetMask" type="string" multiplicity="?" desc="The subnet mask of the specified interface or nil if interface does not exist"/>
                    <return name="gateway" type="string" multiplicity="?" desc="The gateway of the specified interface or nil if interface does not exist"/>
                    <return name="macAddress" type="string" multiplicity="?" desc="The MAC address of the specified interface or nil if interface does not exist"/>
                    <return name="dhcpEnabled" type="bool" multiplicity="?" desc="True if dhcp is enabled or nil if interface does not exist"/>
                    <return name="linkActive" type="bool" multiplicity="?" desc="True if there is currently a link active or nil if interface does not exist"/>
                    <return name="speed" type="string" multiplicity="?" desc="The current speed (1000FD,100FD/HD,10FD/HD) of the specified interface or nil if interface does not exist"/>
                </function>
                <function name="resolveHostName">
                    <links>Ethernet.DNS,Ethernet.Diagnosis</links>
                    <desc>Resolves a DNS-name to an IP-address and returns the IP-address.</desc>
                    <sample for="lua">local ip = Ethernet.resolveHostName("sick.com")</sample>
                    <param name="hostName" type="string" desc="The DNS-name to resolve."/>
                    <return name="ip" type="string" desc="The IP-address represented by the DNS-name."/>
                </function>
                <function name="resolveIPAddress">
                    <links>Ethernet.DNS,Ethernet.Diagnosis</links>
                    <desc>Resolves an IP-address to a DNS-name and returns the hostname and serice name.</desc>
                    <sample for="lua">local hostname = Ethernet.resolveIPAddress("8.8.8.8")</sample>
                    <param name="ipaddress" type="string" desc="The IP address to resolve."/>
                    <return name="hostname" type="string" desc="The hostname represented by the DNS-name."/>
                </function>
            </serves>
            <uses/>
            <crown name="Bridge">
                <trait>released</trait>
                <links>Ethernet.Interface.isBridge,Ethernet.Interface.isBridged,Ethernet.Diagnosis.getBridgeStatus</links>
                <desc>Multiple Ethernet interfaces can be bridged to form a single aggregate network.
To create a bridge you must first obtain a handle to a Ethernet.Bridge instance by calling create() with the desired bridge name.
The bridge name must be unique, so that there is no more than one bridge with the same name registered in the system at a given time.

local bridge = Ethernet.Bridge.create("myBridge")

To specify the hardware Ethernet interfaces that should be bridged, you must call setInterfaces() on the handle with a list of interface names. Interfaces already bridged by another bridge instance cannot be bridged again.

bridge:setInterfaces({"ETH4", "ETH5"})

The bridge can then be enabled/disabled at runtime by calling the enable()/disable() functions on the handle. By default the bridge has no IP address configured, so the device cannot communicate via the bridged interfaces. If you want a local address to be setup, you can either call setStaticAddress() to configure a static address

bridge:setStaticAddress(handle, "192.168.0.1", "255.255.255.0", "0.0.0.0")

or you can call setDynamicAddress() to make the device obtain a local IP address via DHCP

bridge:setDynamicAddress()

If you need to disable the local IP address again afterwards, you can use setNoAddress() on the bridge handle.

Note that the bridge is automatically disabled if the handle goes out of scope.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new Ethernet bridge instance.</desc>
                        <sample for="lua">local handle = Ethernet.Bridge.create("myBridge")</sample>
                        <param name="name" type="string" desc="Name of the Ethernet bridge to create. Must be unique in the system and different from any Ethernet interface names."/>
                        <return name="handle" type="handle" alias="Ethernet.Bridge" desc="The instance handle for the Ethernet bridge."/>
                    </function>
                    <function name="setInterfaces">
                        <desc>Sets the list of Ethernet interfaces that should be bridged. If the list was already configured previously it is overwritten.</desc>
                        <sample for="lua">success = Ethernet.Bridge.setInterfaces(handle, {"ETH4", "ETH5"})</sample>
                        <param name="handle" type="handle" alias="Ethernet.Bridge" desc="The instance handle for the Ethernet bridge."/>
                        <param name="interfaceList" type="enum" multiplicity="+" ref="EthernetInterfaces" desc="List of Ethernet interface names to bridge."/>
                        <return name="success" type="bool" desc="True if interfaces were set successfully, false if not (e.g. if one of the interfaces was already used in another bridge)."/>
                    </function>
                    <function name="setNoAddress">
                        <desc>Configure the bridge so that it does not setup a local address for its interface.</desc>
                        <sample for="lua">Ethernet.Bridge.setNoAddress(handle)</sample>
                        <param name="handle" type="handle" alias="Ethernet.Bridge" desc="The instance handle for the Ethernet bridge."/>
                    </function>
                    <function name="setStaticAddress">
                        <desc>Configure the bridge so that it sets up a static address for its interface.</desc>
                        <sample for="lua">Ethernet.Bridge.setStaticAddress(handle, "192.168.0.1", "255.255.255.0", "0.0.0.0")</sample>
                        <param name="handle" type="handle" alias="Ethernet.Bridge" desc="The instance handle for the Ethernet bridge."/>
                        <param name="ip" type="string" desc="IPv4 address to configure on the bridge interface."/>
                        <param name="netmask" type="string" desc="IPv4 netmask to configure on the bridge interface."/>
                        <param name="gateway" type="string" desc="IPv4 gateway address to configure on the bridge interface."/>
                    </function>
                    <function name="setDynamicAddress">
                        <desc>Configure the bridge so that it uses DHCP to retrieve a lease for its interface.</desc>
                        <sample for="lua">Ethernet.Bridge.setDynamicAddress(handle)</sample>
                        <param name="handle" type="handle" alias="Ethernet.Bridge" desc="The instance handle for the Ethernet bridge."/>
                    </function>
                    <function name="enable">
                        <desc>Enables the bridge. The bridged interfaces are disabled.</desc>
                        <sample for="lua">success = Ethernet.Bridge.enable(handle)</sample>
                        <param name="handle" type="handle" alias="Ethernet.Bridge" desc="The instance handle for the Ethernet bridge."/>
                        <return name="success" type="bool" desc="True if bridge was enabled successfully, false if not."/>
                    </function>
                    <function name="disable">
                        <desc>Disables the bridge. The bridged interfaces are enabled again and brought back to the state they had before enabling the bridge.</desc>
                        <sample for="lua">success = Ethernet.Bridge.disable(handle)</sample>
                        <param name="handle" type="handle" alias="Ethernet.Bridge" desc="The instance handle for the Ethernet bridge."/>
                        <return name="success" type="bool" desc="True if bridge was disabled successfully, false if not."/>
                    </function>
                </serves>
            </crown>
            <crown name="Diagnosis">
                <trait>released</trait>
                <links>Ethernet.ping,Ethernet.resolveHostName,Monitor.Network</links>
                <desc>Provides functionality to get low-level diagnostic information related to Ethernet interfaces and the TCP/IP-stack of the device.</desc>
                <serves>
                    <function name="getBridgeStatus">
                        <links>Ethernet.Bridge</links>
                        <desc>Get a human-readable list showing the status of all configured Ethernet bridge interfaces on the device.</desc>
                        <return name="bridgeStatus" type="string" desc="The Ethernet bridge status of the device."/>
                    </function>
                    <function name="getInterfaceStatus">
                        <links>Ethernet.Interface</links>
                        <desc>Gets a human-readable list of all network interfaces of the device and their associated properties.</desc>
                        <return name="interfaceStatus" type="string" desc="List of all network interfaces."/>
                    </function>
                    <function name="getRoutingTable">
                        <desc>Gets a human-readable string containing the current routing table of the device.</desc>
                        <return name="routingTable" type="string" desc="The routing table of the device."/>
                    </function>
                    <function name="getSocketStatus">
                        <desc>Gets a human-readable list containing the status of all TCP and UDP sockets on the device.</desc>
                        <return name="socketStatus" type="string" desc="List of TCP and UDP sockets."/>
                    </function>
                    <function name="getDnsConfig">
                        <links>Ethernet.DNS</links>
                        <desc>Gets a human-readable version of the current DNS configuration of the device.</desc>
                        <return name="content" type="string" desc="The DNS configuration of the device."/>
                    </function>
                </serves>
            </crown>
            <crown name="DNS">
                <trait>released</trait>
                <links>Ethernet.Diagnosis.getDnsConfig,Ethernet.resolveHostName</links>
                <desc>Provides functionality to configure DNS and hostname resolving settings.</desc>
                <serves>
                    <function name="getNameservers">
                        <links>Ethernet.DNS.setNameservers</links>
                        <desc>Gets the list of nameservers that are used to resolve hostnames to IP addresses on the system.</desc>
                        <return name="nameservers" type="string" multiplicity="*" desc="List of IP addresses of nameservers."/>
                    </function>
                    <function name="setNameservers">
                        <links>Ethernet.DNS.getNameservers</links>
                        <desc>Sets the list of nameservers that are used to resolve hostnames to IP addresses on the system.</desc>
                        <param name="nameservers" type="string" multiplicity="[?*]" desc="List of IP addresses of nameservers."/>
                    </function>
                    <function name="getSearchList">
                        <links>Ethernet.DNS.setSearchList</links>
                        <desc>Gets the search list that contains local domain suffixes that are used to resolve local hostnames (without any dots in the hostname).</desc>
                        <return name="searchList" type="string" multiplicity="*" desc="List of domain suffixes to add to local hostnames."/>
                    </function>
                    <function name="setSearchList">
                        <links>Ethernet.DNS.getSearchList</links>
                        <desc>Gets the search list that contains local domain suffixes that are used to resolve local hostnames (without any dots in the hostname).</desc>
                        <param name="searchList" type="string" multiplicity="[?*]" desc="List of domain suffixes to add to local hostnames."/>
                    </function>
                    <function name="getResolveTimeout">
                        <links>Ethernet.DNS.setResolveTimeout</links>
                        <desc>Gets the amount of time to wait for a response from a single nameserver before switching to a different nameserver.</desc>
                        <return name="timeout" type="int" desc="Timeout in seconds."/>
                    </function>
                    <function name="setResolveTimeout">
                        <links>Ethernet.DNS.getResolveTimeout</links>
                        <desc>Sets the amount of time to wait for a response from a single nameserver before switching to a different nameserver.</desc>
                        <param name="timeout" type="int" multiplicity="?" desc="Timeout in seconds. Initial: 5; Min: 1; Max: 30."/>
                    </function>
                    <function name="getResolveAttempts">
                        <links>Ethernet.DNS.setResolveAttempts</links>
                        <desc>Gets the number of overall attempts to reach the nameservers per request.</desc>
                        <return name="attempts" type="int" desc="Number of attempts."/>
                    </function>
                    <function name="setResolveAttempts">
                        <links>Ethernet.DNS.getResolveAttempts</links>
                        <desc>Sets the number of overall attempts to reach the nameservers per request.</desc>
                        <param name="attempts" type="int" multiplicity="?" desc="Number of attempts. Initial: 2; Min: 1; Max: 5"/>
                    </function>
                    <function name="getHostsEntries">
                        <links>Ethernet.DNS.addHostsEntry,Ethernet.DNS.removeHostsEntry</links>
                        <desc>Gets the list of IP address to hostname mappings that is used to resolve hostnames before issuing a resolve request to the nameservers.</desc>
                        <return name="ipAddresses" type="string" multiplicity="*" desc="IP address of the host."/>
                        <return name="hostnames" type="string" multiplicity="*" desc="Hostname to associate with the given IP address. This string may contain multiple hostnames (aliases), separated by tab character."/>
                    </function>
                    <function name="addHostsEntry">
                        <links>Ethernet.DNS.getHostsEntries,Ethernet.DNS.removeHostsEntry</links>
                        <desc>Adds a mapping of IP address to hostname.</desc>
                        <param name="ipAddress" type="string" desc="IP address of the host."/>
                        <param name="canonicalHostname" type="string" desc="Fully-qualified hostname (including domain name) to associate with the given IP address."/>
                        <param name="aliases" type="string" multiplicity="[?*]" desc="Further, possibly shorter hostnames to associate with the given IP address"/>
                    </function>
                    <function name="removeHostsEntry">
                        <links>Ethernet.DNS.getHostsEntries,Ethernet.DNS.addHostsEntry</links>
                        <desc>Removes a mapping of IP address to hostname.</desc>
                        <param name="ipAddress" type="string" desc="IP address of the host."/>
                    </function>
                </serves>
            </crown>
            <crown name="Interface">
                <trait>released</trait>
                <links>Ethernet.Diagnosis.getInterfaceStatus</links>
                <desc>Provides functionality to configure Ethernet interfaces and monitor their status.</desc>
                <serves>
                    <event name="OnAddressConfigChanged">
                        <desc>This event is notified every time the address configuration of an Ethernet interface changes.</desc>
                        <param name="ifName" type="enum" ref="EthernetInterfaces" desc="The interface of which the address changed."/>
                        <param name="dhcpEnabled" type="bool" desc="True if DHCP is enabled."/>
                        <param name="ipAddress" type="string" desc="The IP address of the interface."/>
                        <param name="subnetMask" type="string" desc="The subnet mask of the interface."/>
                        <param name="gateway" type="string" desc="The IP address of the gateway of the specified interface."/>
                    </event>
                    <event name="OnLinkActiveChanged">
                        <desc>This event is notified every time a link is established or lost on a Ethernet interface.</desc>
                        <param name="ifName" type="enum" ref="EthernetInterfaces" desc="The interface of which the link active state changed."/>
                        <param name="linkActive" type="bool" desc="True if there is currently a link up, false if the link is down."/>
                    </event>
                    <event name="OnInterfaceAdded">
                        <links>Ethernet.Bridge</links>
                        <desc>This event is notified every time an Ethernet interface is added to the device.</desc>
                        <param name="ifName" type="enum" ref="EthernetInterfaces" desc="The interface that was added."/>
                    </event>
                    <event name="OnInterfaceRemoved">
                        <links>Ethernet.Bridge</links>
                        <desc>This event is notified every time an Ethernet interface is removed from the device</desc>
                        <param name="ifName" type="enum" ref="EthernetInterfaces" desc="The interface that was removed."/>
                    </event>
                    <function name="getAddressConfig">
                        <desc>Returns the current address configuration of the specified ethernet interface.</desc>
                        <param name="ifName" type="enum" ref="EthernetInterfaces" desc="The interface to get the config from"/>
                        <return name="dhcpEnabled" type="bool" multiplicity="?" desc="True if DHCP is enabled. Nil if interface is currently a bridged interface or if the interface does not exist."/>
                        <return name="ipAddress" type="string" multiplicity="?" desc="The IP address of the specified interface. Nil if interface is currently a bridged interface or if the interface does not exist."/>
                        <return name="subnetMask" type="string" multiplicity="?" desc="The subnet mask of the specified interface. Nil if interface is currently a bridged interface or if the interface does not exist."/>
                        <return name="gateway" type="string" multiplicity="?" desc="The IP address of the gateway of the specified interface. Nil if interface is currently a bridged interface or if the interface does not exist."/>
                    </function>
                    <function name="setAddressConfig">
                        <links>Ethernet.Interface.applyAddressConfig,Parameters.savePermanent</links>
                        <desc>Sets the address configuration of the specified Ethernet interface.</desc>
                        <param name="ifName" type="enum" ref="EthernetInterfaces" desc="The interface to get the config from"/>
                        <param name="dhcpEnabled" type="bool" desc="True if address configuration should be retrieved from a DHCP server for this interface, other parameters must be omitted in this case."/>
                        <param name="ipAddress" type="string" multiplicity="?" desc="The IP address of the specified interface. Must be nil if parameter dhcpEnabled is true."/>
                        <param name="subnetMask" type="string" multiplicity="?" desc="The subnet mask of the specified interface.  Must be nil if parameter dhcpEnabled is true."/>
                        <param name="gateway" type="string" multiplicity="?" desc="The IP address of the gateway of the specified interface. Optional. Must be nil if parameter dhcpEnabled is true."/>
                    </function>
                    <function name="applyAddressConfig">
                        <links>Ethernet.Interface.setAddressConfig</links>
                        <desc>Applies any changes to the Ethernet interface address configuration previously done using the function Ethernet.Interface.setAddressConfig.</desc>
                        <param name="ifName" type="enum" ref="EthernetInterfaces" desc="The interface to apply the address config on, or ALL to apply on all interfaces at once."/>
                    </function>
                    <function name="getInterfaces">
                        <desc>Gets a list of all available Ethernet interfaces of the device.</desc>
                        <return name="ifName" type="enum" multiplicity="*" ref="EthernetInterfaces" desc="List of all available Ethernet interfaces."/>
                    </function>
                    <function name="getLinkSpeed">
                        <desc>Gets the current speed of the Ethernet link.</desc>
                        <param name="ifName" type="enum" ref="EthernetInterfaces" desc="The interface to get the speed from"/>
                        <return name="linkSpeed" type="string" multiplicity="?" desc="The current speed (1000FD,100FD/HD,10FD/HD) of the specified interface. Nil if interface is currently a bridged interface or if the interface does not exist."/>
                    </function>
                    <function name="getMACAddress">
                        <desc>Returns the MAC address of the of the specified Ethernet interface.</desc>
                        <param name="ifName" type="enum" ref="EthernetInterfaces" desc="The interface to get the MAC address from"/>
                        <return name="macAddress" type="string" multiplicity="?" desc="The MAC address of the specified interface. Notation is six groups of two hexadecimal digits separated by hyphens, e.g. '01-23-45-67-89-AB'. Nil if interface is currently a bridged interface or if the interface does not exist."/>
                    </function>
                    <function name="isBridge">
                        <links>Ethernet.Bridge,Ethernet.Interface.isBridged</links>
                        <desc>Checks whether the specified Ethernet interface is a bridge interface.</desc>
                        <param name="ifName" type="enum" ref="EthernetInterfaces" desc="The interface to get the link state from"/>
                        <return name="isBridge" type="bool" multiplicity="?" desc="True if the interface is a bridge interface which was created via Ethernet.Bridge. Nil if interface does not exist"/>
                    </function>
                    <function name="isBridged">
                        <links>Ethernet.Bridge,Ethernet.Interface.isBridge</links>
                        <desc>Checks whether the specified Ethernet interface is a currently bridged (part of a bridge interface).</desc>
                        <param name="ifName" type="enum" ref="EthernetInterfaces" desc="The interface to get the link state from"/>
                        <return name="isBridged" type="bool" multiplicity="?" desc="True if the interface is a bridged interface which was added to a bridge interface created via Ethernet.Bridge. Nil if interface does not exist"/>
                    </function>
                    <function name="isLinkActive">
                        <desc>Returns the current link state of the specified Ethernet interface.</desc>
                        <param name="ifName" type="enum" ref="EthernetInterfaces" desc="The interface to get the link state from"/>
                        <return name="linkActive" type="bool" multiplicity="?" desc="True if there is currently a link up, false if the link is down. Nil if interface is currently a bridged interface or if the interface does not exist."/>
                    </function>
                </serves>
            </crown>
            <crown name="SSHTunnel">
                <trait>released</trait>
                <desc>Creates an encrypted tunnel created through an SSH protocol connection. This can be used e.g. to transfer data through this connection and forward it to a sensor behind the device. The tunnel supports local and remote port forwarding of the SSH connection.
Usage:

local handle = Ethernet.SSHTunnel.create()
Ethernet.SSHTunnel.setUserCredentials(handle, "sick", "")
Ethernet.SSHTunnel.setIPAddress(handle, "202.123.222.4")
Ethernet.SSHTunnel.setPort(handle, 4444)
Ethernet.SSHTunnel.addForwardRemotePort(handle, 5000, "192.0.0.1", 6000)
Ethernet.SSHTunnel.setKeyFile(handle, "resources/key.txt")
Ethernet.SSHTunnel.open(handle)
...
Ethernet.SSHTunnel.close(handle)

Note that the tunnel is automatically closed if the handle goes out of scope, e.g. if the application is stopped.
In case of an unexpected connection loss the SSHTunnel is not automatically re-established.
The status of the connection can be checked at any time via Ethernet.SSHTunnel.isOpen(handle).</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new SSH tunnel instance.</desc>
                        <sample for="lua">local handle = Ethernet.SSHTunnel.create()</sample>
                        <return name="handle" type="handle" alias="Ethernet.SSHTunnel" desc="The instance handle for the SSH tunnel."/>
                    </function>
                    <function name="setIPAddress">
                        <desc>Sets the remote server IP to connect to.</desc>
                        <sample for="lua">Ethernet.SSHTunnel.setIPAddress(handle, "202.123.222.4")</sample>
                        <param name="handle" type="handle" alias="Ethernet.SSHTunnel" desc="The instance handle for the SSH tunnel."/>
                        <param name="ip" type="string" desc="Remote IP address of the SSH connection."/>
                    </function>
                    <function name="setPort">
                        <desc>Sets the remote server port to connect to.</desc>
                        <sample for="lua">Ethernet.SSHTunnel.setPort(handle, 4444)</sample>
                        <param name="handle" type="handle" alias="Ethernet.SSHTunnel" desc="The instance handle for the SSH tunnel."/>
                        <param name="port" type="int" desc="Remote port of the SSH connection."/>
                    </function>
                    <function name="setKeyFile">
                        <desc>Sets the ssh key file.</desc>
                        <sample for="lua">Ethernet.SSHTunnel.setKeyFile(handle, "resources/key.txt")</sample>
                        <param name="handle" type="handle" alias="Ethernet.SSHTunnel" desc="The instance handle for the SSH tunnel."/>
                        <param name="keyFile" type="string" desc="Location of the SSH key file."/>
                    </function>
                    <function name="setKnownHostsFile">
                        <desc>Sets the ssh known hosts file.</desc>
                        <sample for="lua">Ethernet.SSHTunnel.setKnownHostsFile(handle, "resources/knownHosts.txt")</sample>
                        <param name="handle" type="handle" alias="Ethernet.SSHTunnel" desc="The instance handle for the SSH tunnel."/>
                        <param name="keyFile" type="string" desc="Location of the SSH known hosts file."/>
                    </function>
                    <function name="setUserCredentials">
                        <desc>Set the user name and password used to connect to the server. Note: The password is currently ignored, SSH connections can only be established using certificates.</desc>
                        <sample for="lua">Ethernet.SSHTunnel.setUserCredentials(handle, "user", "")</sample>
                        <param name="handle" type="handle" alias="Ethernet.SSHTunnel" desc="The instance handle for the SSH tunnel."/>
                        <param name="user" type="string" desc="User name for the remote server connection."/>
                        <param name="password" type="string" desc="Password for the user. Note: This parameter is currently ignored."/>
                    </function>
                    <function name="open">
                        <desc>Opens the SSH tunnel and connects to the server.</desc>
                        <sample for="lua">Ethernet.SSHTunnel.open(handle)</sample>
                        <param name="handle" type="handle" alias="Ethernet.SSHTunnel" desc="The instance handle for the SSH tunnel."/>
                        <return name="success" type="bool" desc="Returns 'true' if the tunnel was opened successfully."/>
                    </function>
                    <function name="close">
                        <desc>Closes the SSH tunnel.</desc>
                        <sample for="lua">Ethernet.SSHTunnel.close(handle)</sample>
                        <param name="handle" type="handle" alias="Ethernet.SSHTunnel" desc="The instance handle for the SSH tunnel."/>
                        <return name="success" type="bool" desc="Returns 'true' if the tunnel was closed successfully."/>
                    </function>
                    <function name="addForwardLocalPort">
                        <desc>Sets the local port forwarding configuration ("ssh -L LocalPort:RemoteIP:RemotePort").</desc>
                        <sample for="lua">Ethernet.SSHTunnel.addForwardLocalPort(handle, LocalPort, RemoteIP, RemotePort)</sample>
                        <param name="handle" type="handle" alias="Ethernet.SSHTunnel" desc="The instance handle for the SSH tunnel."/>
                        <param name="localPort" type="int" desc="Local port for the SSH tunnel."/>
                        <param name="remoteIP" type="string" desc="Remote IP address for the SSH tunnel."/>
                        <param name="remotePort" type="int" desc="Remote port of the SSH tunnel."/>
                    </function>
                    <function name="addForwardRemotePort">
                        <desc>Sets the remote port forwarding configuration ("ssh -R LocalPort:RemoteIP:RemotePort").</desc>
                        <sample for="lua">Ethernet.SSHTunnel.addForwardRemotePort(handle, LocalPort, RemoteIP, RemotePort)</sample>
                        <param name="handle" type="handle" alias="Ethernet.SSHTunnel" desc="The instance handle for the SSH tunnel."/>
                        <param name="localPort" type="int" desc="Local port for the SSH tunnel."/>
                        <param name="remoteIP" type="string" desc="Remote IP address for the SSH tunnel."/>
                        <param name="remotePort" type="int" desc="Remote port of the SSH tunnel."/>
                    </function>
                    <function name="isOpen">
                        <desc>Returns true, if the tunnel is still active.</desc>
                        <sample for="lua">local tunnelactive = Ethernet.SSHTunnel.isOpen()</sample>
                        <param name="handle" type="handle" alias="Ethernet.SSHTunnel" desc="The instance handle for the SSH tunnel."/>
                        <return name="success" type="bool" desc="Returns 'true' if the tunnel is still active."/>
                    </function>
                    <function name="setEnableHostKeyCheck">
                        <desc>If enabled new host keys are never automatically added to the list of known hosts and connections to hosts whose host key has changed are refused.</desc>
                        <sample for="lua">Ethernet.SSHTunnel.setEnableHostKeyCheck(handle, true)</sample>
                        <param name="handle" type="handle" alias="Ethernet.SSHTunnel" desc="The instance handle for the SSH tunnel."/>
                        <param name="enable" type="bool" desc="Host key check flag. Default: false."/>
                    </function>
                    <function name="setEnableRemoteCommands">
                        <desc>Do not execute a remote commands on the remote server.</desc>
                        <sample for="lua">Ethernet.SSHTunnel.setEnableRemoteCommands(handle, true)</sample>
                        <param name="handle" type="handle" alias="Ethernet.SSHTunnel" desc="The instance handle for the SSH tunnel."/>
                        <param name="enable" type="bool" desc="Enable remote command flag. Default: false."/>
                    </function>
                    <function name="setIgnoreHostKeyChanges">
                        <desc>If set to false the connection to a host with a key differing from the known key for this host are refused. The function setKnownHostsFile overrides this setting: If setKnownHostsFile is used, this function setIgnoreHostKeyChanges does not have an effect.</desc>
                        <sample for="lua">Ethernet.SSHTunnel.setIgnoreHostKeyChanges(handle, true)</sample>
                        <param name="handle" type="handle" alias="Ethernet.SSHTunnel" desc="The instance handle for the SSH tunnel."/>
                        <param name="enable" type="bool" desc="Ignore Host key changes flag. Default: true."/>
                    </function>
                    <function name="setExitOnForwardFailure">
                        <desc>Specifies whether the connection is terminated if any of the requested forwardings fails, (e.g. if either end is unable to bind and listen on a specified port).</desc>
                        <sample for="lua">Ethernet.SSHTunnel.setExitOnForwardFailure(handle, true)</sample>
                        <param name="handle" type="handle" alias="Ethernet.SSHTunnel" desc="The instance handle for the SSH tunnel."/>
                        <param name="enable" type="bool" desc="Exit on forward failure flag. Default: true."/>
                    </function>
                    <function name="removeHostKey">
                        <desc>Removes the servers host key from the list of known hosts. This API requires only the server ip address that is set via Ethernet.SSHTunnel.setIPAddress, no active SSHTunnel connection is required.</desc>
                        <sample for="lua">Ethernet.SSHTunnel.removeHostKey(handle)</sample>
                        <param name="handle" type="handle" alias="Ethernet.SSHTunnel" desc="The instance handle for the SSH tunnel."/>
                    </function>
                </serves>
            </crown>
            <crown name="Firewall">
                <trait>released</trait>
                <desc>Provides firewall-functionality similar to iptables.
One firewall instance only operates and affects one single ethernet interface. The interface it operates on is specified in the create() function.
When the firewall is enabled, an ordered chain of rules is evaluated for every IP packet that enters or leaves the system over the ethernet interface.
If a rule matches a packet, the corresponding action to the rule is executed: The packet is either accepted or dropped and rule processing for this packet stops.
There are separate chains "INPUT" and "OUTPUT" for the different directions of IP packets.
To create rules, create instances of Firewall.Rule and specify the rule using the Firewall.Rule functions.
The rules can than be added using the addRule function of the Firewall API.

The firewall has a set of default rules: All outgoing packets are allowed, incoming packets are only allowed when they belong to an existing outgoing connection that was established by the device.

The default rules are appended to the chains after all user defined rules and are only relevant when no user specified rule matches a packet.
The default behavior can be overridden by adding a user-defined rule that matches all packets.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new Firewall instance for the specified interface. Only one instance per interface can exist.</desc>
                        <sample for="lua">local firewall = Ethernet.Firewall.create("ETH1")</sample>
                        <param name="interface" type="enum" ref="EthernetInterfaces" desc="The interface to configure the firewall for."/>
                        <return name="handle" type="handle" multiplicity="?" alias="Ethernet.Firewall" desc="The instance handle for the firewall."/>
                    </function>
                    <function name="enable">
                        <desc>Enables the firewall.
If the firewall is already enabled or enabling fails, the function will return false.
If this function fails for any reason, it is guaranteed that none of the rules are activated.</desc>
                        <sample for="lua">local success = Ethernet.Firewall.enable(handle)</sample>
                        <param name="handle" type="handle" alias="Ethernet.Firewall" desc="The instance handle for the firewall."/>
                        <return name="success" type="bool" desc="True, if enabling the firewall was successful."/>
                    </function>
                    <function name="disable">
                        <desc>Disables the firewall.
If the firewall is not enabled or disabeling fails, the function will return false.</desc>
                        <sample for="lua">local success = Ethernet.Firewall.disable(handle)</sample>
                        <param name="handle" type="handle" alias="Ethernet.Firewall" desc="The instance handle for the firewall."/>
                        <return name="success" type="bool" desc="True, if disabling the firewall was successful."/>
                    </function>
                    <function name="isEnabled">
                        <desc>Returns if the firewall is enabled.</desc>
                        <sample for="lua">local enabled = Ethernet.Firewall.isEnabled(handle)</sample>
                        <param name="handle" type="handle" alias="Ethernet.Firewall" desc="The instance handle for the firewall."/>
                        <return name="enalbed" type="bool" desc="True, if the firewall is enabled."/>
                    </function>
                    <function name="addRule">
                        <desc>Adds one or more rules to the firewall.
When the firewall is enabled, the rules are evaluated per IP packet in the order in which they were added via this function.
The Firewall.Rule objects that are passed into this function are copied, so future changes to the Firewall.Rule objects that were added do not have an effect.</desc>
                        <sample for="lua">Ethernet.Firewall.addRule(handle, rule)</sample>
                        <param name="handle" type="handle" alias="Ethernet.Firewall" desc="The instance handle for the firewall."/>
                        <param name="rule" type="object" multiplicity="[1+]" alias="Ethernet.Firewall.Rule" desc="The instance object for the rule(s) to add to the firewall."/>
                        <return name="success" type="bool" desc="True, if all rules could be added. False if firewall is already enabled or if any rule was invalid. When false, no rules were added."/>
                    </function>
                    <function name="getActiveRules">
                        <trait>hidden</trait>
                        <desc>Get a human-readable list of all rules that are currently active in the system.</desc>
                        <sample for="lua">Ethernet.Firewall.getActiveRules(handle)</sample>
                        <param name="handle" type="handle" alias="Ethernet.Firewall" desc="The instance handle for the firewall."/>
                        <return name="success" type="string" desc="List of currently active rules."/>
                    </function>
                </serves>
                <crown name="Rule">
                    <trait>released</trait>
                    <desc>Provides functionality to create Firewall rules.
The settings for Chain and Action are mandatory. If no further settings are done, the packet matches all packets by default.
The other setters are used to restrict the class of packets that this rule matches.</desc>
                    <enum name="Action">
                        <desc>The action performed by the rule.</desc>
                        <item name="Accept packet">ACCEPT</item>
                        <item name="Drop packet">DROP</item>
                    </enum>
                    <enum name="Chain">
                        <desc>The chain to add the rule to.</desc>
                        <item name="Input chain">INPUT</item>
                        <item name="Output chain">OUTPUT</item>
                    </enum>
                    <enum name="State">
                        <desc>Possible connection states that can be used in function addStateFilter()</desc>
                        <item name="INVALID" desc="The packet is associated with no known connection.">INVALID</item>
                        <item name="ESTABLISHED" desc="The packet is associated with a connection which has seen packets in both directions.">ESTABLISHED</item>
                        <item name="NEW" desc="The packet has started a new connection, or otherwise associated with a connection which has not seen packets in both directions.">NEW</item>
                        <item name="RELATED" desc="The packet is starting a new connection, but is associated with an existing connection, like an ICMP error.">RELATED</item>
                    </enum>
                    <enum name="Protocol">
                        <desc>Possible protocols that can be used in function setProtocolFilter()</desc>
                        <item name="ALL" desc="Rule matches all protocols">ALL</item>
                        <item name="ICMP" desc="Rule only matches ICMP packets">ICMP</item>
                        <item name="TCP" desc="Rule only matches TCP packets">TCP</item>
                        <item name="UDP" desc="Rule only matches UDP packets">UDP</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <desc>Creates a new iptables rule instance.</desc>
                            <sample for="lua">local rule = Ethernet.Firewall.Rule.create()</sample>
                            <return name="rule" type="object" alias="Ethernet.Firewall.Rule" desc="The instance object for the rule."/>
                        </function>
                        <function name="setChain">
                            <desc>Set the chain for the rule.</desc>
                            <sample for="lua">Ethernet.Firewall.Rule.setChain(rule,"INPUT")</sample>
                            <param name="rule" type="object" alias="Ethernet.Firewall.Rule" desc="The instance object for the rule."/>
                            <param name="chain" type="enum" ref="Chain" desc="The chain to add the rule to."/>
                        </function>
                        <function name="setAction">
                            <desc>Sets the action to be performed by the rule.</desc>
                            <sample for="lua">Ethernet.Firewall.Rule.setAction(rule,"DROP")</sample>
                            <param name="rule" type="object" alias="Ethernet.Firewall.Rule" desc="The instance object for the rule."/>
                            <param name="action" type="enum" ref="Action" desc="The action performed by the rule."/>
                        </function>
                        <function name="setSourcePort">
                            <desc>Sets a source port filter to the rule. Only works with the protocols TCP and UDP (see function setProtocol)</desc>
                            <sample for="lua">Ethernet.Firewall.Rule.setSourcePort(rule,80,100)</sample>
                            <param name="rule" type="object" alias="Ethernet.Firewall.Rule" desc="The instance object for the rule."/>
                            <param name="port" type="int" desc="Port number or lower range limit to apply the rule to."/>
                            <param name="rangeLimit" type="int" multiplicity="?" desc="The upper range limit to apply the rule to."/>
                        </function>
                        <function name="setDestinationPort">
                            <desc>Sets a destination port filter to the rule. Only works with the protocols TCP and UDP (see function setProtocol)</desc>
                            <sample for="lua">Ethernet.Firewall.Rule.setDestinationPort(rule,80,100)</sample>
                            <param name="rule" type="object" alias="Ethernet.Firewall.Rule" desc="The instance object for the rule."/>
                            <param name="port" type="int" desc="Port number or lower range limit to apply the rule to."/>
                            <param name="rangeLimit" type="int" multiplicity="?" desc="The upper range limit to apply the rule to."/>
                        </function>
                        <function name="setConnectionLimit">
                            <desc>Sets a connection limit to the rule. Only works with TCP protocol (see function setProtocol)</desc>
                            <sample for="lua">Ethernet.Firewall.Rule.setConnectionLimit(rule,5)</sample>
                            <param name="rule" type="object" alias="Ethernet.Firewall.Rule" desc="The instance object for the rule."/>
                            <param name="limit" type="int" desc="The maximum number of connections allowed."/>
                        </function>
                        <function name="setSourceIP">
                            <desc>Sets a source IP address filter to the rule.</desc>
                            <sample for="lua">Ethernet.Firewall.Rule.setSourceIP(rule,"192.168.0.1")</sample>
                            <param name="rule" type="object" alias="Ethernet.Firewall.Rule" desc="The instance object for the rule."/>
                            <param name="ip" type="string" desc="IPv4-Address to apply the rule to. Can be a single address or a network address in CIDR notation, e.g. '192.168.0.0/16'."/>
                        </function>
                        <function name="setDestinationIP">
                            <desc>Sets a destination IP filter to the rule.</desc>
                            <sample for="lua">Ethernet.Firewall.Rule.setDestinationIP(rule,"192.168.0.1")</sample>
                            <param name="rule" type="object" alias="Ethernet.Firewall.Rule" desc="The instance object for the rule."/>
                            <param name="ip" type="string" desc="IPv4-Address to apply the rule to. Can be a single address or a network address in CIDR notation, e.g. '192.168.0.0/16'."/>
                        </function>
                        <function name="setSourceMAC">
                            <desc>Sets a source MAC address to the rule. Filtering for destination MAC is not possible.</desc>
                            <sample for="lua">Ethernet.Firewall.Rule.setSourceMAC(rule,"01-23-45-67-89-AB")</sample>
                            <param name="rule" type="object" alias="Ethernet.Firewall.Rule" desc="The instance object for the rule."/>
                            <param name="mac" type="string" desc="MAC-Address to apply the rule to. Notation is six groups of two hexadecimal digits separated by hyphens, e.g. '01-23-45-67-89-AB'. It is not possible to use wildcards."/>
                        </function>
                        <function name="setProtocol">
                            <desc>Sets a protocol to the rule. The default when this function is not called is 'ALL'.</desc>
                            <sample for="lua">Ethernet.Firewall.Rule.setProtocol(rule, "TCP")</sample>
                            <param name="rule" type="object" alias="Ethernet.Firewall.Rule" desc="The instance object for the rule."/>
                            <param name="protocol" type="enum" ref="Protocol" desc="The protocol to apply the rule to."/>
                        </function>
                        <function name="setState">
                            <desc>Sets a connection tracking state to the rule. The rule only matches packets that belong to connections of a certain state.</desc>
                            <sample for="lua">Ethernet.Firewall.Rule.setState(rule, {"ESTABLISHED", "RELATED"})</sample>
                            <param name="rule" type="object" alias="Ethernet.Firewall.Rule" desc="The instance object for the rule."/>
                            <param name="state" type="enum" multiplicity="[1+]" ref="State" desc="The connection states to apply the rule to."/>
                        </function>
                    </serves>
                </crown>
            </crown>
        </crown>
        <crown name="Database">
            <trait>released</trait>
            <desc>Database access functionality.
Currently, only device internal SQLite DB access is possible, but the API is designed in a way so it can be extended to access external DBs in future.
For SQL type Database access, see API 'Database.SQL'.</desc>
            <crown name="SQL">
                <trait>released</trait>
                <desc>General SQL database access (Relational Databases). Specific functions for specific databases can be found in sub-crowns, such as Database.SQL.SQLite</desc>
                <crown name="SQLite">
                    <trait>released</trait>
                    <desc>Bindings to built-in SQLite database.
A SQLite-3 database (for exact version info, please call Database.SQL.SQLite.getVersion()) is integrated in the firmware and can be used via this API, together with the more generic Database.SQL.* API.
SQLite is either statically or dynamically linked to the firmware and does not need external binaries installed in the device.
Also, access to SQLite is direct (task context-wise), meaning that the overhead is minimal.
The SQLite API highly corresponds to the C API of SQLite, which can be found here: https://www.sqlite.org/docs.html
The database is transaction safe when used with a Windows/Linux file system in case the fsync() and other synchonization primitives works correctly on that OS.
The basic guarantees can be found on the page https://www.sqlite.org/atomiccommit.html
Please take indexing of important table columns into consideration. See tutorial http://www.sqlitetutorial.net/sqlite-index/

The most important changes using the CROWN API are:

- Every array or placeholder indexing is zero based, not one-based, to correspond to the CROWN guidelines.
That means when a placeholder (?) is bound to a value, the first placeholder has index zero, the next one index one and so on
- A reset() call on a prepared statement also invokes the underlying clearBindings()-function
- There is additional support for storing CROWN object types in the DB.

So, when using a particular CROWN function, please also look-up the corresponding documentation in the internet (for example sqlite-doc-3170000.zip). A hint to which function is used below the API is attached to each function/event documentation.

An important extension is the binding of CROWN objects. Binding can be done in two different modes:

- SERIALIZED: The object is transformed into a stream of bytes or characters and then stored as a BLOB or TEXT field in the data base. JSON and MessagePack are supported as formats. The object in memory is not referenced to any more when put into the DB
- MAP_TO_ID: A reference to the object is held in a local cache (in this documentation, it is called the 'object cache') and is mapped to an integer ID which is stored in the database instead of the object. This mode only makes sense for in-memory database with fast object look-up.

For the mode MAP_TO_ID, the creation of the IDs that are stored in the DB is done automatically and it is ensured that IDs are unique.
IDs in the positive range of a 64 bit integer are used.
When an object is bound twice (or more) to a DB field, two (or more) distinct IDs are created for the same object, and the object is also held as long all of the IDs referring to it exist.
To also remove an object from the cache when getting it, use the 'MAP_FROM_ID_AND_REMOVE' mode.
Further supplied functions to manipulate the cache are getObjectIds(), getObject(), setObject() and removeObject().
When you fear or encounter that the object cache grows unpredictably, you can optionally use the 'garbage collection' feature which is a manually triggered mark-and-sweep kind of collection.
It works by querying the DB for all object IDs that are stored in the DB.
Then, it walks over the object cache to find objects that have IDs that are not existent in the DB any more.
Those objects are then removed from the cache.
To use garbage collection, use the addGarbageCollectionStatement() and collectGarbage() APIs.
Please make sure that every DB field referring to object IDs is added with addGarbageCollectionStatement(), else, the GC will leave unused objects in the cache (leaks).
It is up to the responsibility of the API user to take care of that.
See also the sample of the 'addGarbageCollectionStatement()' API.
Also, the 'collectGarbage()' function is not automatically triggered, so there is the need to manually call that. However, when the DB is closed, the object cache is cleared out entirely.</desc>
                    <enum name="FileOpenMode">
                        <item name="READ">READ</item>
                        <item name="READ_WRITE">READ_WRITE</item>
                        <item name="READ_WRITE_CREATE">READ_WRITE_CREATE</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <desc>Creates a new device internal SQLite database instance.
The database is not open yet, so a call to one of the various open...() functions is needed to be able to work with a database.</desc>
                            <sample for="lua">handle = Database.SQL.SQLite.create()</sample>
                            <return name="handle" type="handle" alias="Database.SQL.SQLite" desc="The handle of the Database instance"/>
                        </function>
                        <function name="getVersion">
                            <desc>Returns the version number of the SQLite implementation in the firmware as string.
Calls the underlying 'sqlite3_libversion()' C API</desc>
                            <sample for="lua">print(handle:getVersion())</sample>
                            <param name="handle" type="handle" alias="Database.SQL.SQLite" desc="The handle of the Database instance"/>
                            <return name="versionString" type="string" desc="The version string, for example '3.17.0'"/>
                        </function>
                        <function name="openMemory">
                            <desc>Opens an fast in-memory database for read/write access.
Calls the underlying C APIs 'sqlite3_open()' and 'sqlite3_exec()' to pass 'PRAGMA page_size' and 'PRAGMA max_page_count' to limit the RAM usage to the passed 'size' parameter.
In case of error, the database is closed immediately and may be re-opened.</desc>
                            <sample for="lua">success = handle:openMemory(1048576)</sample>
                            <param name="handle" type="handle" alias="Database.SQL.SQLite" desc="The handle of the Database instance"/>
                            <param name="size" type="int" desc="Size of the in-memory DB in number of bytes. A size smaller than 512 bytes is not possible, and the size is enlarged to be a multiple of 512 bytes."/>
                            <return name="success" type="bool" desc="True if database was opened successfully, false if not. When false is returned, the database is closed and ready to be opened again."/>
                        </function>
                        <function name="openFile">
                            <desc>Opens a database to work on a device file.
Calls the underlying C API 'sqlite3_open_v2()'.
In case of error, 'false' is returned, the database is closed immediately and may be re-opened again.</desc>
                            <sample for="lua">success = handle:openFile("public/sample.db", "READ")</sample>
                            <param name="handle" type="handle" alias="Database.SQL.SQLite" desc="The handle of the Database instance"/>
                            <param name="filename" type="string" desc="Path to the database file to open."/>
                            <param name="openmode" type="enum" ref="FileOpenMode" desc="How to open the database"/>
                            <return name="success" type="bool" desc="True if database was opened successfully, false if not. When false is returned, the database is closed and ready to be opened again."/>
                        </function>
                        <function name="close">
                            <desc>Closes an open database.
This is an optional operation since expiring an open Database.SQL.SQLite handle closes the underlying database automatically.
Calls the C API 'sqlite3_close()'</desc>
                            <sample for="lua">success = handle:close()</sample>
                            <param name="handle" type="handle" alias="Database.SQL.SQLite" desc="The handle of the Database instance"/>
                        </function>
                        <function name="prepare">
                            <desc>Creates a prepared SQL statement.
Prepared statements get pre-compiled inside the DB and can be execute faster when used multiple times, so this one should be prefered over the 'exec()' API for repeated calls on a huge amount of data.
Calls the C APIs 'sqlite3_prepare_v2()' and for destruction 'sqlite3_finalize()'.</desc>
                            <sample for="lua">statement = handle:prepare("select * from MyTable where name = ?")</sample>
                            <param name="handle" type="handle" alias="Database.SQL.SQLite" desc="The handle of the Database instance"/>
                            <param name="query" type="string" desc="The SQL query to execute. Placeholders can be freely inserted according to the SQLite language (see bind...() and getColumn...() API"/>
                            <return name="statement" type="handle" multiplicity="?" alias="Database.SQL.Statement" desc="The prepared statement object. When the query has errors, no statement is created. getErrorMessage() can be called to get extended error information in case no statement has been returned."/>
                        </function>
                        <function name="execute">
                            <desc>Executes one or more SQL statements/queries without retrieving results. This is particularly useful to set-up the database after creating it.
Multiple statements/queries can be passed by inserting semicolon (';') separators.
Calls the C API 'sqlite3_exec()'</desc>
                            <sample for="lua">success = handle:execute("create table MyTable(Id int primary key not null)")</sample>
                            <param name="handle" type="handle" alias="Database.SQL.SQLite" desc="The handle of the Database instance"/>
                            <param name="query" type="string" desc="The SQL query to execute. You can use placeholders. Multiple queries may be specified by finishing each of them with a semicolon."/>
                            <return name="success" type="bool" desc="Whether the operation was successful. In case of error, the getErrorMessage() function can be called to get extended error information"/>
                        </function>
                        <function name="addGarbageCollectionStatement">
                            <desc>Optionally needed when Database.SQL.Statement.bindObject() should be called in future with bindingMode=MAP_TO_ID and when there is need for cleaning-up the object cache periodically.
It adds a SQL statement to retrieve object IDs from the DB for objects that are still considered to be in use by the client (which should NOT be removed by the collector).
The function can be called multiple times to add multiple statements to the collector. See also collectGarbage() function.
The statements are all discarded when a 'close()' call is done on the DB, so, when re-opening a DB, the calls to this function may need to be repeated.
Has no direct mapping to an SQLite API, but uses the API 'prepare()' call and holds the created statement objects internally.</desc>
                            <sample for="lua">
handle:addGarbageCollectionStatement("select ObjId from Images")
handle:addGarbageCollectionStatement("select ObjId from PointClounds")
handle:addGarbageCollectionStatement("select ObjId from Scans")
-- See also sample of collectGarbage() for a more complete scenario
              </sample>
                            <param name="handle" type="handle" alias="Database.SQL.SQLite" desc="The handle of the Database instance"/>
                            <param name="sql" type="string" desc="The SQL statement which returns a single column of type 'int'"/>
                            <return name="success" type="bool" desc="Whether the collection statement could be added"/>
                        </function>
                        <function name="collectGarbage">
                            <desc>Can be used in conjunction with prior 'addGarbageCollectionStatement()' calls to remove objects from the object cache which have an ID that does not exist in the DB any more.
Only needed if the MAP_TO_ID mapping is used somewhere and if it is not clear if all the objects are removed with 'MAP_FROM_ID_AND_REMOVE'.
This function needs to be manually triggered to do the clean-up, probably when there is enough time for doing that, since it might be an expensive operation depending on the size of the DB.
It executes all SQL statements added by addGarbageCollectionStatement() to get all object IDs which should be retained.
Then, it walks through the object cache to remove all objects that have IDs that are not part of the 'retain' list (IDs that are not part of the sql results).
Note that when no statement has been added with 'addGarbageCollectionStatement', the function won't clean up and report an error instead.
This operation uses the 'Statement' API internally and thus has no direct SQLite equivalent</desc>
                            <sample for="lua">
handle:addGarbageCollectionStatement("select ObjId from Images")        -- To clean-up images in cache
handle:addGarbageCollectionStatement("select ObjId from PointClounds")  -- To clean-up point clouds in cache
handle:addGarbageCollectionStatement("select ObjId from Scans")         -- To clean-up scans in cache
local query = handle:prepare("insert into Images values(?)")
local img = Image.create(...)
query:bindObject(0, "MAP_TO_ID", img) -- Fill the 'ObjId' field
query:step() -- Inserts the image to the cache and stores an ID into the DB
handle:exec("delete from Images") -- Removes all Image IDs from the database, but the cache still contains the actual Image objects
handle:collectGarbage() -- Retains PointClouds and Scans, but removes the temporary image stored in the cache
              </sample>
                            <param name="handle" type="handle" alias="Database.SQL.SQLite" desc="The handle of the Database instance"/>
                            <return name="numOfObjectsRemoved" type="int" desc="Number of objects collected"/>
                            <return name="numOfObjectsTotal" type="int" desc="Number of objects that existed in the cache before collection"/>
                        </function>
                        <function name="getObjectIds">
                            <desc>Returns the IDs of all objects in the object cache (see collectGarbage() or bindObject()).</desc>
                            <sample for="Lua">ids = handle:getObjectIds()</sample>
                            <param name="handle" type="handle" alias="Database.SQL.SQLite" desc="The handle of the Database instance"/>
                            <return name="ids" type="int" multiplicity="*" desc="The object ids"/>
                        </function>
                        <function name="getObject">
                            <desc>Returns an object in the cache by its ID. When the ID is not a valid ID, a 'nil' value is returned instead.</desc>
                            <sample for="Lua">obj = handle:getObject(id)</sample>
                            <param name="handle" type="handle" alias="Database.SQL.SQLite" desc="The handle of the Database instance"/>
                            <param name="id" type="int" desc="The object ID that should be used for look-up"/>
                            <return name="obj" type="object" multiplicity="?" desc="The returned object "/>
                        </function>
                        <function name="setObject">
                            <desc>Replaces an object in the cache. When the ID is not a valid ID or the passed object is a 'nil' value, an error is message is printed out.</desc>
                            <sample for="Lua">handle:setObject(id, obj)</sample>
                            <param name="handle" type="handle" alias="Database.SQL.SQLite" desc="The handle of the Database instance"/>
                            <param name="id" type="int" desc="The object ID that should be used for look-up"/>
                            <param name="obj" type="object" desc="The object to set"/>
                            <return name="success" type="bool" desc="True if object could be set, false when ID is invalid"/>
                        </function>
                        <function name="removeObject">
                            <desc>Removes an object plus its ID from the object cache. Please make sure that the particular ID is not used inside the DB.</desc>
                            <sample for="Lua">handle:removeObject(id)</sample>
                            <param name="handle" type="handle" alias="Database.SQL.SQLite" desc="The handle of the Database instance"/>
                            <param name="id" type="int" desc="The object ID that should be removed"/>
                            <return name="success" type="bool" desc="True if object could be removed, false when ID is invalid"/>
                        </function>
                        <function name="getErrorMessage">
                            <desc>Returns error message for the last error.
Calling this function when no error occured results in a random string, so only call it in error cases.
The error strings usually come from SQL API 'sqlite3_errmsg()' calls, but these calls are done at the point where errors occur and the error string is cached until this API is called.</desc>
                            <sample for="lua">errorMessage = handle:getErrorMessage()</sample>
                            <param name="handle" type="handle" alias="Database.SQL.SQLite" desc="The handle of the Database instance"/>
                            <return name="errorMessage" type="string" desc="Error message or an empty string if there was no error."/>
                        </function>
                    </serves>
                </crown>
                <crown name="Statement">
                    <trait>released</trait>
                    <desc>Pre-compiled prepared statements generated by a SQL-like DB.
This CROWN is designed to work with any kind of SQL database, as long as the device supports it.
The Statement data type has no constructor but it needs to be created by a factory, for example 'Database.SQL.SQLite.prepare()'.
Since the Statements can be created by any SQL DB, the underlying API calls may differ.
For SQLite binding, the used SQLite API is annotated, so the equivalent SQLite documentation can be looked up.</desc>
                    <enum name="StepResult">
                        <item name="ERROR" desc="An error occurred">ERROR</item>
                        <item name="DONE" desc="Statement has finished successfully or no more rows of data can be obtained">DONE</item>
                        <item name="ROW" desc="A new row of data has been evaluated and can be retrieved using the get...() and is...() functions">ROW</item>
                    </enum>
                    <enum name="ObjectBindingMode">
                        <item name="SERIALIZE" desc="Serializes the object to a BLOB or STRING">SERIALIZE</item>
                        <item name="MAP_TO_ID" desc="Maps the object to an integer ID, stores the ID in the DB and caches the object. Needs later clean-up by using 'MAP_FROM_ID_AND_REMOVE' or using the 'collectGarbage()' feature of the DB API">MAP_TO_ID</item>
                    </enum>
                    <enum name="ObjectGettingMode">
                        <item name="DESERIALIZE" desc="De-serializes the object from a BLOB or STRING">DESERIALIZE</item>
                        <item name="MAP_FROM_ID" desc="Maps the object from an integer ID and retrieves it from the cache, without removing it there. May need later garbage collection (or a later get call with 'MAP_FROM_ID_AND_REMOVE') to avoid unpredictable growing of the object cache">MAP_FROM_ID</item>
                        <item name="MAP_FROM_ID_AND_REMOVE" desc="Same as MAP_FROM_ID, but removes the object from the cache">MAP_FROM_ID_AND_REMOVE</item>
                    </enum>
                    <serves>
                        <function name="reset">
                            <desc>Resets the statement to its original state and clears all placeholder bindings. Must be called after usage of the statement ('step()' calls) and before re-using the statement.
In case SQLite is used, the SQLite API 'sqlite3_reset()' together with 'sqlite3_clear_bindings()' is used.</desc>
                            <sample for="lua">statement:bindInt(...) -- bind placeholders (optionally)
statement:step() -- make use of the statement
statement:reset() -- make statement ready for another usage</sample>
                            <param name="handle" type="handle" alias="Database.SQL.Statement" desc="The handle of the Statement instance"/>
                            <return name="success" type="bool" desc="True if statement was reset and is ready for new execution, false if not."/>
                        </function>
                        <function name="bindInt">
                            <desc>Binds an integer value to a placeholder. When using integer indexes they start with zero (not one, like in SQLite!)
Binding using indexes is more performant than using string-based placeholders, which need additional look-up.
Conversion takes place according to the rules of the particular DB.
In case SQLite is used, the SQLite API 'sqlite3_bind_int64()' and optionally (for named placeholders) 'sqlite3_bind_parameter_index()' is called.</desc>
                            <sample for="lua">-- index based:
statement:bindInt(0, 4711)
-- string based:
statement:bindInt("MyNamedPlaceholder", 4711)</sample>
                            <param name="handle" type="handle" alias="Database.SQL.Statement" desc="The handle of the Statement instance"/>
                            <param name="indexOrKey" type="auto" desc="Index of the placeholder to bind, or name of the placeholder to bind (int or string)"/>
                            <param name="value" type="int" desc="Value to bind to the placeholder."/>
                            <return name="success" type="bool" desc="True if value was bound, false if not."/>
                        </function>
                        <function name="bindDouble">
                            <desc>Binds a floating point value to a placeholder. When using integer indexes they start with zero (not one, like in SQLite!)
Binding using indexes is more performant than using string-based placeholders, which need additional look-up.
Conversion takes place according to the rules of the particular DB.
In case SQLite is used, the SQLite API 'sqlite3_bind_double()' and optionally (for named placeholders) 'sqlite3_bind_parameter_index()' is called.</desc>
                            <sample for="lua">-- index based:
statement:bindDouble(0, 3.14)
-- string based:
statement:bindDouble("MyNamedPlaceholder", 3.14)</sample>
                            <param name="handle" type="handle" alias="Database.SQL.Statement" desc="The handle of the Statement instance"/>
                            <param name="indexOrKey" type="auto" desc="Index of the placeholder to bind, or name of the placeholder to bind (int or string)"/>
                            <param name="value" type="float" desc="Value to bind to the placeholder."/>
                            <return name="success" type="bool" desc="True if value was bound, false if not."/>
                        </function>
                        <function name="bindText">
                            <desc>Binds a string value to a placeholder. When using integer indexes they start with zero (not one, like in SQLite!)
Binding using indexes is more performant than using string-based placeholders, which need additional look-up.
Conversion takes place according to the rules of the particular DB.
In case SQLite is used, the SQLite API 'sqlite3_bind_text()' and optionally (for named placeholders) 'sqlite3_bind_parameter_index()' is called.</desc>
                            <sample for="lua">-- index based:
statement:bindText(0, "Hi, there!")
-- string based:
statement:bindText("MyNamedPlaceholder", "Hi, there!")</sample>
                            <param name="handle" type="handle" alias="Database.SQL.Statement" desc="The handle of the Statement instance"/>
                            <param name="indexOrKey" type="auto" desc="Index of the placeholder to bind, or name of the placeholder to bind (int or string)"/>
                            <param name="value" type="string" desc="Value to bind to the placeholder."/>
                            <return name="success" type="bool" desc="True if value was bound, false if not."/>
                        </function>
                        <function name="bindBlob">
                            <desc>Binds a binary (array of bytes, binary large object [BLOB]) value to a placeholder. When using integer indexes they start with zero (not one, like in SQLite!)
Binding using indexes is more performant than using string-based placeholders, which need additional look-up.
Conversion takes place according to the rules of the particular DB.
In case SQLite is used, the SQLite API 'sqlite3_bind_blob()' and optionally (for named placeholders) 'sqlite3_bind_parameter_index()' is called.</desc>
                            <sample for="lua">-- index based:
blob = "Some binary-interpreted data"
statement:bindBlob(0, blob)
-- string based:
statement:bindBlob("MyNamedPlaceholder", blob)</sample>
                            <param name="handle" type="handle" alias="Database.SQL.Statement" desc="The handle of the Statement instance"/>
                            <param name="indexOrKey" type="auto" desc="Index of the placeholder to bind, or name of the placeholder to bind (int or string)"/>
                            <param name="value" type="binary" desc="Value to bind to the placeholder."/>
                            <return name="success" type="bool" desc="True if value was bound, false if not."/>
                        </function>
                        <function name="bindNull">
                            <desc>Binds a null value to a placeholder. This does only work for SQL columns which aren't 'not null'. When using integer indexes they start with zero (not one, like in SQLite!)
Binding using indexes is more performant than using string-based placeholders, which need additional look-up.
Conversion takes place according to the rules of the particular DB.
In case SQLite is used, the SQLite API 'sqlite3_bind_null()' and optionally (for named placeholders) 'sqlite3_bind_parameter_index()' is called.</desc>
                            <sample for="lua">-- index based:
statement:bindNull(0)
-- string based:
statement:bindNull("MyNamedPlaceholder")</sample>
                            <param name="handle" type="handle" alias="Database.SQL.Statement" desc="The handle of the Statement instance"/>
                            <param name="indexOrKey" type="auto" desc="Index of the placeholder to bind, or name of the placeholder to bind (int or string)"/>
                            <return name="success" type="bool" desc="True if value was bound, false if not."/>
                        </function>
                        <function name="bindObject">
                            <desc>Binds a CROWN object.
There are two modes available: 1. Serialization to BLOB/TEXT or 2. Mapping to an integer ID and storing that ID together with the reference in a cache instead.
For the first mode, choose either SQL TEXT data type in case a text-based format, such as JSON, is chosen, or SQL BLOB in case a binary format, such as MessagePack, is used.
The second mode needs an SQL INT data type. It may require periodic garbage collection by calling the Database.SQL.collectGarbage() function (see description of the Database.SQL.SQLite API)
and is only useful for fast object access without serialization involved, together with in-memory databases.
So, the SERIALIZED option should be preferred since it does not require manual clean-up.
Also, the 2nd option does not make the actual objects persistent; it just caches them in RAM temporarily.
In case SQLite is used, the API functions 'sqlite3_bind_text()' is used for text-based serialization, the function 'sqlite3_bind_blob()' for binary serialization and 'sqlite3_bind_int64()' in case of ID mapping</desc>
                            <sample for="lua">-- index based:
obj = Image.create(...)
statement:bindObject(0, "SERIALIZE", obj, "JSON")
-- string based:
statement:bindObject("MyNamedPlaceholder", "SERIALIZE", obj, "JSON")</sample>
                            <param name="handle" type="handle" alias="Database.SQL.Statement" desc="The handle of the Statement instance"/>
                            <param name="indexOrKey" type="auto" desc="Index of the placeholder to bind, or name of the placeholder to bind (int or string)"/>
                            <param name="bindingMode" type="enum" ref="ObjectBindingMode" desc="Binding mode"/>
                            <param name="value" type="object" desc="Value to bind to the placeholder."/>
                            <param name="dataFormat" type="enum" multiplicity="?" ref="Object.DataFormat" desc="Serialization format of object in case bindingMode is set to SERIALIZE. When not specified, JSON is used as default, like in Object.save()"/>
                            <return name="success" type="bool" desc="True if value was bound, false if not."/>
                        </function>
                        <function name="bind">
                            <desc>Binds multiple values to multiple placeholders at once. Only index-based, not named, placeholders are possible.
Each bound value can either be a single value or an array of values. They are bound in order of occurrence and when an array is used, the values are extracted from the array and bound one after another with increasing index.
That enables binding of an unlimited number of values and reduces call overhead.
A pre-requisite for convenient usage of this function is a DB design where the columns are sorted by type,
for instance 'create table Tab(int, int, real, real, string)'.
Because of binding of Lua to CROWN subsystem, there is an ambiguity between data of type 'string' and 'binary' when using interfaces with type 'auto'. When lua strings are passed through this function, such as { "Hello", "World!" }, they are by default converted to string by this function and bound as 'TEXT' values, and there is an error when the strings aren't valid UTF-8 data.
If that behavior should be changed to 'BLOB' binary binding, one can pass the string '$blob' as the first element of the array.
It will be used as a kind of 'pragma' switch to bind all following values of the array as 'BLOB' data. For example, a call

local offset = 0
statement:bind(offset, {"$blob", "\x01\x02", "\x03"})

binds 2 values: At index 0, a BLOB with content [0x01,0x02] is bound, and at index 1, one BLOB with content [0x03] is bound. The string '$blob' will not be inserted into the DB at all because it is used as indicator only.
Accordingly, the magic string '$text' will leave the content to be interpreted as string values and bound to a DB 'TEXT' field. The '$text' pragma is redundant but can document the intention of the user.
For numeric values, the same problem with int/float ambiguity arises, but in that case, it is determined at runtime if all values in the array are integers,
and then the values are bound like 'bindInt' when this is the case.
That will also work when the target is a REAL column, because the DB will do the INT-to-REAL conversion as needed.
Full usage example for a DB table with design 'create table Tab(int, int, real, string, string, blob), which are 6 values of 4 different types:

local offset = 0
bind(offset, {4711, 42}, 3.14, {"$text", "Hello", "World!"}, {"$blob", "\x01\x02\x03" })</desc>
                            <sample for="lua">statement:bind(offset, {4711, 42}, 3.14, {"$text", "Hello", "World!"}, {"$blob", "\x01\x02\x03" })</sample>
                            <param name="handle" type="handle" alias="Database.SQL.Statement" desc="The handle of the Statement instance"/>
                            <param name="offset" type="int" desc="Binding offset. A value of 0 means binding from index 0 upwards. Only when multiple bind() calls are necessary, this must be the offset of the previous bind() call"/>
                            <param name="values0" type="auto" multiplicity="[?*]" desc="Value(s) to bind, see description of the function"/>
                            <param name="values1" type="auto" multiplicity="[?*]" desc="Value(s) to bind, see description of the function"/>
                            <param name="values2" type="auto" multiplicity="[?*]" desc="Value(s) to bind, see description of the function"/>
                            <param name="values3" type="auto" multiplicity="[?*]" desc="Value(s) to bind, see description of the function"/>
                            <param name="values4" type="auto" multiplicity="[?*]" desc="Value(s) to bind, see description of the function"/>
                            <param name="values5" type="auto" multiplicity="[?*]" desc="Value(s) to bind, see description of the function"/>
                            <return name="success" type="bool" desc="True if value was bound, false if not. false is also return in case of string binding with invalid UTF-8 data"/>
                        </function>
                        <function name="step">
                            <desc>Executes the statement, which means applying the place-holder bindings and retrieving a cursor to the first of the result rows.
This call is meant to be executed in a while- or repeat-until loop to catch all rows of the result data set. For SQLite, multiple, implementation-defined API functions are called.</desc>
                            <sample for="lua">-- without error handling (simple while loop)
while (statement:step() == "ROW") do
  local result1 = statement:getColumnInt(0)
  -- retrieve other results...
end
-- with error handling (more complicated but catches more subtle cases):
local stepResult = nil
repeat
  stepResult = checkDB:step()
  if stepResult == "ROW" then
    local result1 = statement:getColumnInt(0)
  end  
until (stepResult ~= "ROW")
if (stepResult == "ERROR") then
  local errorString = statement:getErrorMessage()
  print("An error has occurred while retrieving results: " .. errorString)
end</sample>
                            <param name="handle" type="handle" alias="Database.SQL.Statement" desc="The handle of the Statement instance"/>
                            <return name="ret" type="enum" ref="Database.SQL.Statement.StepResult" desc="Result of executing the statement"/>
                        </function>
                        <function name="getColumnsAsString">
                            <desc>Retrieves all result colums, converts them to string and concatenates them with vertical bars.
This is very convenient for debugging or logging to catch all results regardless of type and order.</desc>
                            <sample for="lua">while (statement:step() == "ROW") do
  local allColumns = statement:getColumnsAsString()
  print("The result columns are: " .. allColumns)
end</sample>
                            <param name="handle" type="handle" alias="Database.SQL.Statement" desc="The handle of the Statement instance"/>
                            <return name="ret" type="string" desc="All columns, formatted as string, separated by vertical bars"/>
                        </function>
                        <function name="getColumsForLuaTable">
                            <desc>Retrieves all result columns, converts them to lua table string. This string can be converted to a lua table"</desc>
                            <sample for="lua">while (statement:step() == "ROW") do
  local tableString = statement:getColumsForLuaTable()
  print("The result columns are: " .. tableString)
end</sample>
                            <param name="handle" type="handle" alias="Database.SQL.Statement" desc="The handle of the Statement instance"/>
                            <return name="ret" type="string" desc="All columns are formatted to a table string"/>
                        </function>
                        <function name="getColumnInt">
                            <desc>Returns a result column as integer value. In case of SQLite, 'sqlite3_column_int64()' is called</desc>
                            <sample for="lua">while (statement:step() == "ROW") do
  local myInt = statement:getColumnInt(0)
end</sample>
                            <param name="handle" type="handle" alias="Database.SQL.Statement" desc="The handle of the Statement instance"/>
                            <param name="index" type="int" desc="Index of the column"/>
                            <return name="ret" type="int" desc="The value"/>
                        </function>
                        <function name="getColumnDouble">
                            <desc>Returns a result column as floating point value. In case of SQLite, 'sqlite3_column_double()' is called</desc>
                            <sample for="lua">while (statement:step() == "ROW") do
  local myFloat = statement:getColumnDouble(0)
end</sample>
                            <param name="handle" type="handle" alias="Database.SQL.Statement" desc="The handle of the Statement instance"/>
                            <param name="index" type="int" desc="Index of the column"/>
                            <return name="ret" type="float" desc="The value"/>
                        </function>
                        <function name="getColumnText">
                            <desc>Returns a result column as string value. In case of SQLite, 'sqlite3_column_text()' is called</desc>
                            <sample for="lua">while (statement:step() == "ROW") do
  local myString = statement:getColumnText(0)
end</sample>
                            <param name="handle" type="handle" alias="Database.SQL.Statement" desc="The handle of the Statement instance"/>
                            <param name="index" type="int" desc="Index of the column"/>
                            <return name="ret" type="string" desc="The value"/>
                        </function>
                        <function name="getColumnBlob">
                            <desc>Returns a result column byte-array/BLOB value. In case of SQLite, 'sqlite3_column_bytes()' and 'sqlite3_column_blob()' is called</desc>
                            <sample for="lua">while (statement:step() == "ROW") do
  local myBinary = statement:getColumnBlob(0)
end</sample>
                            <param name="handle" type="handle" alias="Database.SQL.Statement" desc="The handle of the Statement instance"/>
                            <param name="index" type="int" desc="Index of the column"/>
                            <return name="ret" type="binary" desc="The value"/>
                        </function>
                        <function name="getColumnObject">
                            <desc>Retrieves a CROWN object by either de-serialization of the stored BLOB or retrieving the ID and mapping from the object cache.
For information on which SQL data type to choose in which scenario, please look-up the documentation of 'bindObject()'.
In case SQLite is used, the SQLite API function 'sqlite3_column_type()' is used to dis-ambiguate the types, followed by either 'sqlite3_column_bytes()'/'sqlite3_column_blob()', 'sqlite3_column_text()' or 'sqlite3_column_int64()' depending on the row type</desc>
                            <sample for="lua">while (statement:step() == "ROW") do
  local myObj = statement:getColumnObject(0, "DESERIALIZE", "JSON")
end</sample>
                            <param name="handle" type="handle" alias="Database.SQL.Statement" desc="The handle of the Statement instance"/>
                            <param name="index" type="int" desc="Index of the column"/>
                            <param name="gettingMode" type="enum" ref="ObjectGettingMode" desc="Getting mode. See enum description"/>
                            <param name="dataFormat" type="enum" multiplicity="?" ref="Object.DataFormat" desc="Serialization format of object in case bindingMode is set to SERIALIZE. When not specified, JSON is used as default, like in Object.load()"/>
                            <return name="ret" type="object" multiplicity="?" desc="The object, when it could be de-serialized or mapped, or no value if there was an error with the mapping or de-serialization"/>
                        </function>
                        <function name="getColumns">
                            <desc>Retrieves multiple columns at once, equivalent to the multi-value 'bind()' function.
The function needs a description string that denotes which columns should be retrieved by which way and into which target data type, and if they should be retrieved as single value or as an array of values.
The syntax of that string is

'crownType:singleIntegerIndex'

or

'crownType:[array of integer indexes separated by comma]'

or

'crownType:[beginRange-endRange]'


More than one of those statements can be passed, using a semicolon ';' as separator.

The first variant fetches a single value from a single column, the second one fetches multiple values from multiple columns and returns them packed as one array value. The third one fetches 0..n values, where the begin and the
end of the range (inclusive) is specified with a dash. So, the expresssion [1,2,3,4] and [1-4] are equal, but the second form might be slightly faster due to less parsing overhead and should be prefered for getting a lot of values at once.

crownType can be one of: 'int', 'float', 'string', 'binary', 'bool'.
Treatement of 'bool' is special: The value is extracted as SQL INT value and then converted to bool (0=false, all other values=true)
Otherwise, 'int' refers to INTEGER columns, 'float' to REAL columns, 'string' to TEXT columns and 'binary' to BLOB.
Other types are not possible because there is no direct SQL mapping,
so to extract other types, such as 'object', please use a separate 'getColumnObject' call.

Example to get column 0 as int and column 1 and 2 as string array:

myInt, myStrings = statement:getColumns("int:0;string:[1,2]")

Note that the returned 'myStrings' is an array of length 2.

Both forms can be combined by separating them with semicolons ';', as shown in the example.
A maximum of 7 distinct values can be returned. But when packing multiple values into an array (as with 'type:[index,...]'), this restriction can be circumvented.

When the function fails for whatever reason, no values are returned, resulting in 'nil' values for the script programmer.</desc>
                            <sample for="lua">myInt, myStrings = statement:getColumns("int:0;string:[1,2]")</sample>
                            <param name="handle" type="handle" alias="Database.SQL.Statement" desc="The handle of the Statement instance"/>
                            <param name="getMode" type="string" desc="Information on how to retrieve the values. For syntax, see description of the function."/>
                            <return name="results0" type="auto" multiplicity="[?*]" desc="Either a single value or an array of values as mentioned in the 'getMode' parameter. No value/'nil' in case of error"/>
                            <return name="results1" type="auto" multiplicity="[?*]" desc="Either a single value or an array of values as mentioned in the 'getMode' parameter. No value/'nil' in case of error"/>
                            <return name="results2" type="auto" multiplicity="[?*]" desc="Either a single value or an array of values as mentioned in the 'getMode' parameter. No value/'nil' in case of error"/>
                            <return name="results3" type="auto" multiplicity="[?*]" desc="Either a single value or an array of values as mentioned in the 'getMode' parameter. No value/'nil' in case of error"/>
                            <return name="results4" type="auto" multiplicity="[?*]" desc="Either a single value or an array of values as mentioned in the 'getMode' parameter. No value/'nil' in case of error"/>
                            <return name="results5" type="auto" multiplicity="[?*]" desc="Either a single value or an array of values as mentioned in the 'getMode' parameter. No value/'nil' in case of error"/>
                            <return name="results6" type="auto" multiplicity="[?*]" desc="Either a single value or an array of values as mentioned in the 'getMode' parameter. No value/'nil' in case of error"/>
                        </function>
                        <function name="isColumnNull">
                            <desc>Checks if a column contains the SQL 'null' value. In case of SQLite, 'sqlite3_column_type()' is called and compared against 'SQLITE_NULL'</desc>
                            <sample for="lua">while (statement:step() == "ROW") do
  local isNull = statement:isColumnNull(0)
end</sample>
                            <param name="handle" type="handle" alias="Database.SQL.Statement" desc="The handle of the Statement instance"/>
                            <param name="index" type="int" desc="Index of the column"/>
                            <return name="success" type="bool" desc="True if column value is NULL, false if not."/>
                        </function>
                        <function name="getErrorMessage">
                            <desc>Retrieves error message for the last error of the statement.
Calling this function without having an actual error results in a random string.
Only meaningful to be called when the last 'bind...()', 'get...()', 'step()' or 'reset()' functions returned either an error code or the boolean 'false'
In case of SQLite, the SQLite API 'sqlite3_errstr()' is called or the error string is formatted by the abstraction code in case it is no general SQL error</desc>
                            <sample for="lua">errorMessage = statement:getErrorMessage()</sample>
                            <param name="handle" type="handle" alias="Database.SQL.Statement" desc="The handle of the Statement instance"/>
                            <return name="errorMessage" type="string" desc="The last error message"/>
                        </function>
                    </serves>
                </crown>
            </crown>
            <crown name="Expressions">
                <trait>released</trait>
                <desc>Expression evaluation on top of SQL data bases.
'Expressions' are a small domain-specific language (DSL) based on XML. Goal is fast string, numeric or boolean value formatting by combining several data base values, together with some formatting options,
to a single- or array result (formerly known as 'EvalConditions' or 'StringFormatting', but more powerful).
The DSL is easy enough to be passed to some GUI, so it is suitable for operator use (not just programmer!). The API is rather coarse because most of the work is done below the API.
For detailed information about the XML formats used, please look up the provided .dtd files. They contain the XML format, suitable for an XML editor, as well as sample snippets.
Expressions are manually triggered and work on the data set of a data base at the point of evaluation. The data base may be locked from concurrent access until the evaluation has finished.

Expression evaluation imposes some limits on the underlying data base, which must be followed, to make it work:
- Each DB table used together with expressions must have a primary key of type 'INT' which is never 'null' and has the name 'Id' (upper case 'I', lower case 'd')
- The supported data types are 'INT', 'REAL', 'TEXT' only.
- Boolean values can be emulated by prefixing them with 'bool'. Database columns starting with 'bool' are interpreted as booleans (0=false, all other values=true) and must be of type 'INT'
- Parent-child relationship from tables to other tables must be done with foreign keys in the child referring to the 'Id' of the parent table. The naming of these foreign keys must be 'ForeignTableName' concatenated with 'Id', for example 'ObjectId'
- 1:1 as well as n:1 child-parent relationships are possible

A valid database scheme might look like this (Example in SQLite SQL dialect):

PRAGMA foreign_keys = ON;
create table Object(Id int primary key not null,
Duration int,
Triggerlength int);
create table Code(Id int primary key not null,
Content text,
Position int,
Codetype text,
Dimension int,
boolValidity int,
ObjectId int references Object on delete cascade);
create index CodeIndex on Code(ObjectId)
create table Code1D(Id int primary key not null,
Expenditureunknown int,
Expenditurestd int,
Expendituresmartfwd int,
Expendituresmartbwd int,
CodeId int references Code on delete cascade);
create index Code1DIndex on Code1D(CodeId)
create table Code2D(Id int primary key not null,
Xsize int,
Ysize int,
CodeId int references Code on delete cascade);
create index Code2DIndex on Code2D(CodeId)

The 'on delete cascade' and the 'PRAGMA foreign_keys' are optional and useful for the programmer to provide a more consistent database which also cleans-up itself (children are removed when the parent table entry dies).
The 'create index' statements help speeding-up SQL queries done by the internal implementation for parent-child relationships. In the shown example, the Object table relates to n Code-tables, so querying Code items for ObjectId
will occur often. Thus, the index is created on that foreign key. For more information on SQLite index creation, see tutorial: http://www.sqlitetutorial.net/sqlite-index/

The order in which the API functions have to be called is:

- create()           -- to be called once
- bind()             -- to assign the expression to a DB instance
- registerFunction() -- optionally
- parse()            -- To generate the expression out of the DSL XML description
- evaluate()         -- To evaluate the expression on the data base
- getResult()        -- To retrieve the results of the evaluation

Note that evaluate() and getResult() are trimmed for speed and repeated calling. All other functions should be called at configuration time, not at normal operation mode.</desc>
                <enum name="Type">
                    <item name="INVALID" desc="Expression has not been parsed yet or can not be set up">INVALID</item>
                    <item name="BOOLEAN" desc="Expression has boolean result(s)">BOOLEAN</item>
                    <item name="NUMERIC" desc="Expression has numeric result(s)">NUMERIC</item>
                    <item name="STRING" desc="Expression has string/binary result(s)">STRING</item>
                </enum>
                <enum name="Format">
                    <item name="XML" desc="XML format of Expressions">XML</item>
                </enum>
                <enum name="MetaInfo">
                    <item name="EXPRESSIONS" desc="Available expressions">EXPRESSIONS</item>
                    <item name="RELATIONS" desc="Available data base relations">RELATIONS</item>
                    <item name="ATTRIBUTES" desc="Available data base attributes/fields">ATTRIBUTES</item>
                    <item name="FUNCTIONS" desc="Available formatting functions">FUNCTIONS</item>
                </enum>
                <serves>
                    <function name="create">
                        <desc>Creates a new Expressions object.
Multiple expression objects may be parsed into that "pool" object, to be evaluated together at one point in time.</desc>
                        <sample for="lua">handle = Database.Expressions.create()</sample>
                        <return name="handle" type="handle" alias="Database.Expressions" desc="The newly created object"/>
                    </function>
                    <function name="bind">
                        <desc>Binds the expressions object to a data base instance.</desc>
                        <sample for="lua">success = expr:bind(myDB, "Root")</sample>
                        <param name="handle" type="handle" alias="Database.Expressions" desc="The expression instance"/>
                        <param name="db" type="handle" desc="The data base handle"/>
                        <param name="rootRelation" type="string" desc="The primary SQL table/relation from where to start evaluation. This is the uppermost table of a parent-child relationship (in the example shown in description of the Database.Expressions API, this is the 'Object' table"/>
                        <return name="success" type="bool" desc="true if the binding was successful, false otherwise"/>
                    </function>
                    <function name="registerFunction">
                        <desc>Registers a custom user-defined function that can afterwards be used in the expression XML as if it was a pre-defined function.
That function will then also be present in the GUI for operator use.
When that function needs a context, such as an OOP this-pointer/reference,
a constructor function may be passed as well.
The returned values of that constructor call are then held as long as the expression exists and passed as first parameter(s) to each function invocation at point of the 'evaluate()' call.
This way, a context can be passed to the function.
The constructor function, if existent, is called each time a parse() call is triggered and the results of that call are held internally.</desc>
                        <sample for="lua">function f() return {1,2,3} end
expression:registerFunction("NUMERIC", "func", "Some very useful function delivering 3 values", f)
-- or a more complicated function involving OOP and constructor:
function g(self, param) return self:returnValues(param) end -- 'self' is a kind of this-pointer created by the constructor function
function constructorForG(databaseHandle) --[[ create some handle type, assign database and return it: ]] return instance; end
expression:registerFunction("moreComplexFunc", "Function calling the data base and returning some values out of it", g, constructorForG, dbHandle) -- 'dbHandle' is the parameter to the constructor function 'constructorForG'
            </sample>
                        <param name="handle" type="handle" alias="Database.Expressions" desc="The expression instance"/>
                        <param name="retTypes" type="enum" ref="Database.Expressions.Type" desc="What kind of value(s) that function returns. This can be a single value or multiple values"/>
                        <param name="name" type="string" desc="Name of the function as it should appear in the GUI. That name may be different from the actual function name passed by the 'func' parameter. The name needs to have the form [a-z][A-Z][0-9]_+, so upper-, lower case characters, numbers and underscore are allowed (no spaces). The first character should not be a number"/>
                        <param name="description" type="string" desc="Description (and usage) string shown in the GUI when that function is shown to the operator"/>
                        <param name="func" type="string" alias="function" desc="The function which is executed under that name. That function needs to return either a single value or an array of values, according to the 'retTypes' parameter, and gets a values passed as parameters (see examples). The first parameters passed are the values returned by the 'constructor' function, if passed."/>
                        <param name="constructor" type="string" multiplicity="?" alias="function" desc="Optional constructor function that is used to set-up an environment or context, for example a prepared DB statement, at the point where the expression is parsed, prior to evaluation. This function can return values, and all these returned values are stored internally and later passed to the function 'func' as first parameters. For example, a 'this' object may be returned, which is later passed as first parameter, to support OOP."/>
                        <param name="ctorParam0" type="auto" multiplicity="[?*]" desc="Optional parameter passed to the 'constructor' function"/>
                        <param name="ctorParam1" type="auto" multiplicity="[?*]" desc="Optional secondary parameter passed to the 'constructor' function"/>
                        <return name="success" type="bool" desc="true when the function has been registered successfully, false otherwise (for example, when a function with that name already exists)"/>
                    </function>
                    <function name="clear">
                        <desc>Removes all parsed expressions from the pool, to make it ready for another 'parse()' call.
Does not affect registered functions or DB binding.</desc>
                        <param name="handle" type="handle" alias="Database.Expressions" desc="The expression instance"/>
                    </function>
                    <function name="parse">
                        <desc>Parses an XML description that contains one or more expressions.
Overwrites already parsed expressions having the same 'exprName' (see return values)</desc>
                        <param name="handle" type="handle" alias="Database.Expressions" desc="The expression instance"/>
                        <param name="content" type="string" desc="The XML string which is parsed into the expression. Must be valid UTF-8 based XML conforming to the 'exprs.dtd'"/>
                        <return name="success" type="bool" desc="true when the parsing succeeded, false in case of errors (please look at the logging console for more info)"/>
                    </function>
                    <function name="getNames">
                        <desc>Returns the names of all expressions currently existing in the pool</desc>
                        <param name="handle" type="handle" alias="Database.Expressions" desc="The expression instance"/>
                        <return name="names" type="string" multiplicity="*" desc="Names of the expressions"/>
                    </function>
                    <function name="getTypeByName">
                        <desc>Returns the type of one expression in the pool</desc>
                        <param name="handle" type="handle" alias="Database.Expressions" desc="The expression instance"/>
                        <param name="exprName" type="string" desc="Name of the expression to get the type from"/>
                        <return name="type" type="enum" ref="Database.Expressions.Type" desc="Returns the type. When the expression does not exist, 'INVALID' is returned"/>
                    </function>
                    <function name="evaluate">
                        <desc>Evaluates expressions on the current data set(s) stored in the DB</desc>
                        <param name="handle" type="handle" alias="Database.Expressions" desc="The expression instance"/>
                        <param name="key" type="auto" desc="Primary key of the outermost relation to be evaluated"/>
                        <param name="exprNames" type="string" multiplicity="[?*]" desc="Optional: Name(s) of the expressions to be evaluated. When not specified, all expressions will be evaluated"/>
                        <return name="success" type="bool" desc="'true' when the evaluation was successful, 'false' otherwise"/>
                    </function>
                    <function name="getPossibleEvaluationContexts">
                        <desc>Returns an array of data base relation names on which the passed expression can be evaluated on.
This can be the 'root' relation set with the bind() call or any other relation which relates
directly or indirectly to the root in a parent-child manner. When the 'root' relation is not one of the results,
this means that the expression can't be evaluated on its own but only by iteration inside of another expression.</desc>
                        <param name="handle" type="handle" alias="Database.Expressions" desc="The expression instance"/>
                        <param name="exprName" type="string" desc="Name of the expression to get the type from"/>
                        <return name="relationNames" type="string" multiplicity="*" desc="An array of relation names. When the expression doesn't exist, an empty array will be returned"/>
                    </function>
                    <function name="getResults">
                        <desc>Returns the last evaluation result(s) by expression name</desc>
                        <param name="handle" type="handle" alias="Database.Expressions" desc="The expression instance"/>
                        <param name="exprName" type="string" desc="Name of the expression to retrieve the results from"/>
                        <return name="results" type="auto" multiplicity="[?*]" desc="An array of results. May be empty, one result or multiple ones, depending on the expression. When an expression with the name 'exprName' does not exist, no value is returned, which will result in a 'nil' value for the caller."/>
                    </function>
                    <function name="clearResults">
                        <desc>Clears the results of a specified- or of all expressions, so that evaluation result of a future evaluation can not depend on any previous one.
After calling, the getResults() call will return nil or an empty list for the specified condition.</desc>
                        <param name="handle" type="handle" alias="Database.Expressions" desc="The expression instance"/>
                        <param name="exprName" type="string" multiplicity="?" desc="Name of the expression to clear results. When empty or omitted, all results are cleared."/>
                    </function>
                    <function name="getMetaInfo">
                        <desc>Returns meta-information about the expressions set-up so a GUI can use it for displaying the correct items.</desc>
                        <param name="handle" type="handle" alias="Database.Expressions" desc="The expression instance"/>
                        <param name="format" type="enum" ref="Database.Expressions.Format" desc="In what format the meta-info should be delivered"/>
                        <param name="metaInfo" type="enum" ref="Database.Expressions.MetaInfo" desc="What meta-info to obtain"/>
                        <return name="success" type="bool" desc="'true' in case the meta-info could be obtained, 'false' otherwise (for example, when the expressions object was not correctly bound to the database instance"/>
                        <return name="metaInfo" type="string" multiplicity="?" desc="The meta-info string if success is true"/>
                        <return name="metaInfoDtd" type="string" multiplicity="?" desc="The corresponding DTD in case XML has been used"/>
                    </function>
                </serves>
            </crown>
        </crown>
        <crown name="View">
            <trait>released</trait>
            <desc>Provides view function for iconics like Text, Scan, Image and PointCloud.</desc>
            <enum name="PointerType">
                <item name="PRIMARY" desc="">PRIMARY</item>
                <item name="SECONDARY" desc="">SECONDARY</item>
                <item name="MIDDLE" desc="">MIDDLE</item>
            </enum>
            <enum name="PointerActionType">
                <item name="CLICKED" desc="">CLICKED</item>
                <item name="DOWN" desc="">DOWN</item>
                <item name="UP" desc="">UP</item>
            </enum>
            <enum name="Channel">
                <item name="LIVE" desc="In case of queues on the channel, only the latest presented iconics will be delivered. This is the default value for View.present().">LIVE</item>
                <item name="ASSURED" desc="None of the presented iconics will be discarded.">ASSURED</item>
            </enum>
            <serves>
                <event name="OnView">
                    <trait>hidden</trait>
                    <desc>This static event is published when iconics are to be viewed (View.view is called). Viewers can register to show this iconic. Currently there are only internal viewers.</desc>
                    <param name="iconic" type="const object" multiplicity="+" desc="The iconic object which is to be viewed."/>
                    <param name="id" type="string" desc="identifier of the view"/>
                </event>
                <event name="OnPresent">
                    <trait>hidden</trait>
                    <desc>This static event is published when View.present is called. Viewers register to this event to display iconics previously added to the View.</desc>
                    <param name="id" type="string" desc="ID of the Viewer to which present objects should be sent"/>
                    <param name="viewObjects" type="const object" multiplicity="+" desc="The objects to view. An object could be any of View.Present sub-objects such as View.Present.Add, View.Present.Clear, View.Present.Editor or View.Present.Remove."/>
                </event>
                <event name="OnPresentAssured">
                    <trait>hidden</trait>
                    <desc>This static event is published when View.present is called. Viewers register to this event to display iconics previously added to the View.</desc>
                    <param name="id" type="string" desc="ID of the Viewer to which present objects should be sent"/>
                    <param name="viewObjects" type="const object" multiplicity="+" desc="The objects to view. An object could be any of View.Present sub-objects such as View.Present.Add, View.Present.Clear, View.Present.Editor or View.Present.Remove."/>
                </event>
                <event name="OnPresentLive">
                    <trait>hidden</trait>
                    <desc>This static event is published when View.present is called. Viewers register to this event to display iconics previously added to the View.</desc>
                    <param name="id" type="string" desc="ID of the Viewer to which present objects should be sent"/>
                    <param name="viewObjects" type="const object" multiplicity="+" desc="The objects to view. An object could be any of View.Present sub-objects such as View.Present.Add, View.Present.Clear, View.Present.Editor or View.Present.Remove."/>
                </event>
                <event name="OnConnect">
                    <desc>This event is published when a Viewer has connected to the View.
Apps can register to this event to perform actions in response to the connection.</desc>
                    <param name="handle" type="handle" alias="View" desc="Instance handle of this view"/>
                </event>
                <event name="OnChange">
                    <desc>This event is published when an Iconic is modified using an editor in the Viewer.

Apps can register to this event to react to the changes, for example to update their representation of the object with the changes from the viewer.</desc>
                    <param name="handle" type="handle" alias="View" desc="Instance handle of this view"/>
                    <param name="iconicId" type="string" desc="ID of the modified iconic"/>
                    <param name="iconic" type="object" desc="The modified iconic"/>
                </event>
                <event name="OnPointer">
                    <desc>This event is published when a user has interacted with a Viewer using the select tool.

Apps can register to this event to receive the id of the iconic under the pointer (if any) and the type of action.</desc>
                    <param name="handle" type="handle" alias="View" desc="Instance handle of this view"/>
                    <param name="iconicId" type="string" desc="The ID of the iconic under the pointer or an empty string if no iconic was hit."/>
                    <param name="pointerActionType" type="enum" ref="PointerActionType" desc="Pointer action type"/>
                    <param name="pointerType" type="enum" ref="PointerType" desc="Pointer type"/>
                </event>
                <function name="create">
                    <desc>Creates a new View.</desc>
                    <sample for="lua">viewer = View.create()</sample>
                    <param name="id" type="string" multiplicity="?" desc="Optional viewer identifier which is used to select dedicated viewers."/>
                    <return name="handle" type="handle" alias="View" desc="The new View"/>
                </function>
                <function name="register">
                    <desc>This function is used to register for any event of the handle.</desc>
                    <param name="handle" type="handle" alias="View" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to register to"/>
                    <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                    <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                </function>
                <function name="deregister">
                    <desc>This function is used to deregister from any registered event of the handle.</desc>
                    <param name="handle" type="handle" alias="View" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to deregister from"/>
                    <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                    <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                </function>
                <function name="view">
                    <trait>deprecated</trait>
                    <include>data-flow</include>
                    <desc>Shows the given iconics (e.g. images, results, etc.) in the available viewers. If the decoration is omitted a default decoration is used.
This function is deprecated. Use View.addXYZ and View.present instead.
Reasons for deprecation: performance issues, type-safety, missing parent-id leads to usage of wrong coordinate-systems.</desc>
                    <sample for="lua">View.view(handle, iconics, decoration)</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="iconics" type="const auto" multiplicity="[1+]" desc="The iconic or list of iconics to be viewed."/>
                    <param name="decoration" type="const object" multiplicity="?" desc="Optional decoration for the iconics."/>
                </function>
                <function name="add">
                    <trait>deprecated</trait>
                    <desc>Adds the iconics, with an optional decoration, to be shown in viewers when View.present is called. If the decoration is omitted a default decoration is used.

Iconics are stored by reference, if they are modified between View.add and View.present, only their latest state will be presented.

This function is deprecated. Use View.addXYZ instead.
Reasons for deprecation: type-safety, missing parent-id leads to usage of wrong coordinate-systems.</desc>
                    <sample for="lua">View.add(handle, iconics, decoration)</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="iconics" type="const auto" multiplicity="[1+]" desc="The iconic or list of iconics to be viewed."/>
                    <param name="decoration" type="const object" multiplicity="?" desc="Optional decoration for the iconics."/>
                </function>
                <function name="addHeightmap">
                    <desc>Adds an Image that is shown as a heightmap in viewers when View.present is called.

If a list of images is used, the first image will be presented as the heightmap. Consecutive images are used as selectable view-components (textures) for the heightmap using the labels from the labels list argument.</desc>
                    <sample for="lua">iconicId = View.addHeightmap(handle, {heightmap, reflectance}, {reflectanceDecoration}, {"Reflectance"}, "heightmap1")</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="images" type="const object" multiplicity="[1+]" alias="Image" desc="The heightmap to be viewed. Additional images will be used as selectable view components."/>
                    <param name="decorations" type="const object" multiplicity="[?*]" alias="View.ImageDecoration" desc="Optional decorations for the image(s)."/>
                    <param name="labels" type="string" multiplicity="[?*]" desc="Optional labels for the additional images"/>
                    <param name="iconicId" type="string" multiplicity="?" desc="Optional iconic id."/>
                    <param name="parentId" type="string" multiplicity="?" desc="Optional parent id. The same parent id is used for all added images."/>
                    <return name="iconicId" type="string" multiplicity="?" desc="Iconic id. An id is generated if not provided."/>
                </function>
                <function name="addImage">
                    <desc>Adds one or more Image to be shown in viewers when View.present is called.</desc>
                    <sample for="lua">iconicId = View.addImage(handle, image, imageDecoration, "image1")</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="image" type="const object" multiplicity="[1+]" alias="Image" desc="The image(s) to be viewed."/>
                    <param name="decoration" type="const object" multiplicity="?" alias="View.ImageDecoration" desc="Optional decoration for the image(s)."/>
                    <param name="iconicId" type="string" multiplicity="[?*]" desc="Optional iconic id(s). One iconic id per image must be supplied if this parameter is used."/>
                    <param name="parentId" type="string" multiplicity="?" desc="Optional parent id. The same parent id is used for all added images."/>
                    <return name="iconicId" type="string" multiplicity="[?*]" desc="A (vector of) iconic id(s). Id(s) are generated if not provided."/>
                </function>
                <function name="addPixelRegion">
                    <links>Image.drawPixelRegion</links>
                    <desc>Adds one or more Image.PixelRegion to be shown as an overlay for an iconic or separately when View.present is called.

If a parentId is given, the PixelRegion is displayed as a clipped overlay for the given parent, otherwise it is drawn separately in world-coordinates.</desc>
                    <sample for="lua">iconicId = View.addPixelRegion(handle, pixelRegion, pixelRegionDecoration, "pixelRegion1", "image1")</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="pixelRegion" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="The pixel region(s) to be viewed."/>
                    <param name="decoration" type="const object" multiplicity="?" alias="View.PixelRegionDecoration" desc="Optional decoration for the pixel region(s). The same decoration is used for all added pixel regions."/>
                    <param name="iconicId" type="string" multiplicity="[?*]" desc="Optional iconic id(s). One iconic id per pixel region must be supplied if this parameter is used."/>
                    <param name="parentId" type="string" multiplicity="?" desc="Optional parent id. The same parent id is used for all added pixel regions."/>
                    <return name="iconicId" type="string" multiplicity="[?*]" desc="A (vector of) iconic id(s). Id(s) are generated if not provided."/>
                </function>
                <function name="addPointCloud">
                    <desc>Adds one or more PointClouds to be shown in viewers when View.present is called.</desc>
                    <sample for="lua">iconicId = View.addPointCloud(handle, pointCloud, pointCloudDecoration, "pointcloud1")</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="pointCloud" type="const object" multiplicity="[1+]" alias="PointCloud" desc="The point cloud(s) to be viewed."/>
                    <param name="decoration" type="const object" multiplicity="?" alias="View.PointCloudDecoration" desc="Optional decoration for the point cloud(s)."/>
                    <param name="iconicId" type="string" multiplicity="[?*]" desc="Optional iconic id(s). One iconic id per point cloud must be supplied if this parameter is used."/>
                    <param name="parentId" type="string" multiplicity="?" desc="Optional parent id. The same parent id is used for all added pointClouds."/>
                    <return name="iconicId" type="string" multiplicity="[?*]" desc="A (vector of) iconic id(s). Id(s) are generated if not provided."/>
                </function>
                <function name="addMesh">
                    <desc>Adds one or more Meshes to be shown in viewers when View.present is called.</desc>
                    <sample for="lua">iconicId = View.addMesh(handle, mesh, decoration, "mesh1")</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="mesh" type="object" multiplicity="[1+]" alias="Mesh" desc="The mesh(es) to be viewed."/>
                    <param name="decoration" type="const object" multiplicity="?" alias="View.MeshDecoration" desc="Optional decoration for the mesh(es)."/>
                    <param name="iconicId" type="string" multiplicity="[?*]" desc="Optional iconic id(s). One iconic id per mesh must be supplied if this parameter is used."/>
                    <param name="parentId" type="string" multiplicity="?" desc="Optional parent id. The same parent id is used for all added meshes."/>
                    <return name="iconicId" type="string" multiplicity="[?*]" desc="A (vector of) iconic id(s). Id(s) are generated if not provided."/>
                </function>
                <function name="addProfile">
                    <desc>Adds one or more profiles to be shown in viewers when View.present is called. The visualization properties are specified using a GraphDecoration object.

If the parentId refers to an Image, the profile will be drawn relative to its coordinate system. If no parent is given, it is drawn relative to the world coordinate system.</desc>
                    <sample for="lua">iconicId = View.addProfile(handle, profile, decoration, iconicId)</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="profile" type="object" multiplicity="[1+]" alias="Profile" desc="The profile(s) to be viewed."/>
                    <param name="decoration" type="const object" multiplicity="?" alias="View.GraphDecoration" desc="Optional decoration for the profile."/>
                    <param name="iconicId" type="string" multiplicity="[?*]" desc="Optional iconic id(s). One iconic id per profile must be supplied if this parameter is used."/>
                    <param name="parentId" type="string" multiplicity="?" desc="Optional parent id. The same parent id is used for all added profiles."/>
                    <return name="iconicId" type="string" multiplicity="[?*]" desc="A (vector of) iconic id(s). Id(s) are generated if not provided."/>
                </function>
                <function name="addGraph">
                    <desc>Adds a graph to be shown in viewers when View.present is called. The graph type, e.g., xy-plot or histogram, is set by the GraphDecoration object.

If the parentId refers to an Image, the graph will be drawn relative to its coordinate system. If no parent is given, it is drawn relative to the world coordinate system.</desc>
                    <sample for="lua">iconicId = View.addGraph(handle, values, coordinates, decoration, iconicId)</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="values" type="float" multiplicity="+" desc="A vector of float values to be plotted on the y-axis of the graph."/>
                    <param name="coordinates" type="float" multiplicity="[?*]" desc="Optional vector of float values for the x-axis, e.g., time, position etc. The default value is an empty vector, in which case the integer indexes of the value vector are used."/>
                    <param name="decoration" type="const object" multiplicity="?" alias="View.GraphDecoration" desc="Optional decoration for the graph."/>
                    <param name="iconicId" type="string" multiplicity="?" desc="Optional iconic id."/>
                    <param name="parentId" type="string" multiplicity="?" desc="Optional parent id."/>
                    <return name="iconicId" type="string" multiplicity="?" desc="Iconic id. An id is generated if not provided."/>
                </function>
                <function name="addScan">
                    <desc>Adds one or more Scan objects to be shown in viewers when View.present is called.</desc>
                    <sample for="lua">iconicId = View.addScan(handle, scan, scanDecoration, "scan1")</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="scan" type="const object" multiplicity="[1+]" alias="Scan" desc="The scan which is to be viewed."/>
                    <param name="decoration" type="const object" multiplicity="?" alias="View.ScanDecoration" desc="Optional decoration for the point cloud."/>
                    <param name="iconicId" type="string" multiplicity="[?*]" desc="Optional iconic id(s). One iconic id per scan must be supplied if this parameter is used."/>
                    <param name="parentId" type="string" multiplicity="?" desc="Optional parent id. The same parent id is used for all added scans."/>
                    <return name="iconicId" type="string" multiplicity="[?*]" desc="A (vector of) iconic id(s). Id(s) are generated if not provided."/>
                </function>
                <function name="addShape">
                    <links>Image.drawShape</links>
                    <desc>Adds either one or more Shape/Shape3D objects to be shown in viewers when View.present is called.

If the parentId refers to an Image, the shape will be drawn relative to its coordinate system.
If no parent is given, it is drawn relative to the world coordinate system.</desc>
                    <sample for="lua">iconicId = View.addShape(handle, shape, shapeDecoration, "shape1", "image1")</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="shape" type="const object" multiplicity="[1+]" desc="The shape(s)/point(s) which is to be viewed."/>
                    <param name="decoration" type="const object" multiplicity="?" alias="View.ShapeDecoration" desc="Optional decoration for the shape. The same decoration is used for all added shapes."/>
                    <param name="iconicId" type="string" multiplicity="[?*]" desc="Optional iconic id(s). One iconic id per shape must be supplied if this parameter is used."/>
                    <param name="parentId" type="string" multiplicity="?" desc="Optional parent id. The same parent id is used for all added shapes."/>
                    <return name="iconicId" type="string" multiplicity="[?*]" desc="A (vector of) iconic id(s). Id(s) are generated if not provided."/>
                </function>
                <function name="addPoint">
                    <links>Image.drawPoint</links>
                    <desc>Adds one or more Point objects to be shown in viewers when View.present is called.

If the parentId refers to an Image, the point will be drawn relative to its coordinate system.
If no parent is given, it is drawn relative to the world coordinate system.</desc>
                    <sample for="lua">iconicId = View.addPoint(handle, point, shapeDecoration, "point1", "image1")</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="point" type="const object" multiplicity="[1+]" desc="The point(s) which is to be viewed."/>
                    <param name="decoration" type="const object" multiplicity="?" alias="View.ShapeDecoration" desc="Optional decoration for the point. The same decoration is used for all added points. N.B: A ShapeDecoration shall be used, there is no dedicated decoration only for Points."/>
                    <param name="iconicId" type="string" multiplicity="[?*]" desc="Optional iconic id(s). One iconic id per point must be supplied if this parameter is used."/>
                    <param name="parentId" type="string" multiplicity="?" desc="Optional parent id. The same parent id is used for all added points."/>
                    <return name="iconicId" type="string" multiplicity="[?*]" desc="A (vector of) iconic id(s). Id(s) are generated if not provided."/>
                </function>
                <function name="addText">
                    <links>Image.drawText</links>
                    <desc>Adds a string to be drawn when View.present is called.

If the parentId refers to an Image, the text will be drawn relative to its coordinate system. If no parent is given, it is drawn relative to the world coordinate system.</desc>
                    <sample for="lua">iconicId = View.addText(handle, "Hello world", textDecoration, "text1", "image1")</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="text" type="string" desc="The text which is to be viewed."/>
                    <param name="decoration" type="const object" multiplicity="?" alias="View.TextDecoration" desc="Optional decoration for the text."/>
                    <param name="iconicId" type="string" multiplicity="?" desc="Optional iconic id."/>
                    <param name="parentId" type="string" multiplicity="?" desc="Optional parent id."/>
                    <return name="iconicId" type="string" desc="Iconic id. An id is generated if not provided."/>
                </function>
                <function name="clear">
                    <desc>Deletes all iconics added with any View.add-function. Removes all previously added iconics from viewers when View.present is called.</desc>
                    <sample for="lua">View.clear(handle)</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                </function>
                <function name="installEditor">
                    <desc>Installs an editor for the specified iconic so that it can be edited in viewers. The editor is available after calling View.present.

When an iconic is changed by an editor the View.OnChange event is published.</desc>
                    <sample for="lua">View.installEditor(handle, "shape1")</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="iconicId" type="string" desc="ID of the iconic for which to install an editor."/>
                </function>
                <function name="uninstallEditor">
                    <desc>Removes the editor from the specified iconic. The editor is removed from viewers after View.present after calling View.present.</desc>
                    <sample for="lua">View.uninstallEditor(handle, "shape1")</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="iconicId" type="string" desc="ID of the iconic for which to uninstall an editor."/>
                </function>
                <function name="present">
                    <desc>Updates registered viewers with changes to the View.

This lets viewers
- show iconics added with any of the View.add-functions
- make editors (added with View.installEditor) available
- remove (View.remove) or clear (View.clear) iconics.

The Channel parameter is optional and defaults to LIVE.
In overload situations, ASSURED means that present calls will be queued and LIVE means that older present calls will be discarded.</desc>
                    <sample for="lua">View.present(handle, "LIVE")</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="channel" type="enum" multiplicity="?" ref="Channel" desc="The channel on which to transmit the presented iconics. Default value is LIVE."/>
                </function>
                <function name="remove">
                    <desc>Removes the iconic with the given id from viewers when View.present is called.</desc>
                    <sample for="lua">View.remove(handle, iconicId)</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="iconicId" type="string" desc="Id of the iconic to remove."/>
                </function>
                <function name="setID">
                    <desc>Set the viewer identifier in order to select dedicated viewers.</desc>
                    <sample for="lua">View.setID(handle, "Viewer1")</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="id" type="string" desc="The identifier."/>
                </function>
                <function name="updateDecoration">
                    <links>View.ShapeDecoration, View.ImageDecoration, View.TextDecoration, View.PixelRegionDecoration, View.PointCloudDecoration, View.MeshDecoration, View.GraphDecoration, View.ScanDecoration, View.present</links>
                    <desc>Updates the decoration of an already existing iconic when View.present is called. The type of the decoration must match the iconic.</desc>
                    <sample for="lua">View.updateDecoration(handle, "shape1", decoration)</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="id" type="string" desc="The identifier of the iconic."/>
                    <param name="decoration" type="object" desc="Decoration object that will be used for the update."/>
                </function>
                <function name="updateTransform">
                    <links>Transform, View.present</links>
                    <desc>Updates the pose (position, orientation, scaling) with the given transform of an already existing iconic when View.present is called. It is up to the viewer what kind of transformations are valid.</desc>
                    <sample for="lua">View.updateTransform(handle, "shape1", transform)</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="id" type="string" desc="The identifier."/>
                    <param name="transform" type="object" alias="Transform" desc="Transformation applied to the given object."/>
                </function>
                <function name="updateCamera">
                    <links>View.Camera, View.present</links>
                    <desc>Updates the camera settings for the scene when View.present is called.</desc>
                    <sample for="lua">View.updateCamera(handle, cam)</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="camera" type="object" alias="View.Camera" desc="The camera to set."/>
                </function>
                <function name="countConnections">
                    <desc>Returns the number of connected viewers at this viewer's identifier.
If no identifier is set, it counts all connected viewers on all identifiers.</desc>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <return name="connectedCount" type="int" desc="The number of connected viewers or 0 if none is connected."/>
                </function>
                <function name="setDefaultDecoration">
                    <desc>Sets a default decoration, e.g., ShapeDecoration or ImageDecoration, that will be used in successive calls to view() and add() if the optional decoration argument is omitted.</desc>
                    <sample for="lua">View.setDefaultDecoration(handle, decoration)</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="decoration" type="object" desc="Decoration object that will be set as default."/>
                </function>
                <function name="setLineColor">
                    <trait>deprecated</trait>
                    <desc>Sets the line color of the default ShapeDecoration.
This function is deprecated, please use View.ShapeDecoration.setLineColor instead.</desc>
                    <sample for="lua">View.setLineColor(handle, 255, 0, 0)</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="red" type="int" desc="Red"/>
                    <param name="green" type="int" desc="Green"/>
                    <param name="blue" type="int" desc="Blue"/>
                </function>
                <function name="setFillColor">
                    <trait>deprecated</trait>
                    <desc>Sets the fill color of the default ShapeDecoration.
This function is deprecated, please use View.ShapeDecoration.setFillColor instead.</desc>
                    <sample for="lua">View.setFillColor(handle, 255, 0, 0, 255)</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="red" type="int" desc="Red"/>
                    <param name="green" type="int" desc="Green"/>
                    <param name="blue" type="int" desc="Blue"/>
                    <param name="alpha" type="int" multiplicity="?" desc="Alpha"/>
                </function>
                <function name="setLineWidth">
                    <trait>deprecated</trait>
                    <desc>Set the line width of the default ShapeDecoration.
This function is deprecated, please use View.ShapeDecoration.setLineWidth instead.</desc>
                    <sample for="lua">View.setLineWidth(handle, 1)</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="width" type="int" desc="The line thickness."/>
                </function>
                <function name="addDepthmap">
                    <desc>Adds an Image that is shown as a depthmap in viewers when View.present is called.

If a list of images is used, the first image will be presented as the depthmap. Consecutive images are used as selectable view-components (textures) for the depthmap using the labels from the labels list argument.</desc>
                    <sample for="lua">iconicId = View.addDepthmap(handle, {depthmap, reflectance}, model, {reflectanceDecoration}, {"Reflectance"}, "depthmap1")</sample>
                    <param name="handle" type="handle" alias="View" desc="The instance to be used."/>
                    <param name="images" type="const object" multiplicity="[1+]" alias="Image" desc="The depthmap to be viewed. Additional images will be used as selectable view components."/>
                    <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="Camera model for the images."/>
                    <param name="decorations" type="const object" multiplicity="[?*]" alias="View.ImageDecoration" desc="Optional decorations for the images."/>
                    <param name="labels" type="string" multiplicity="[?*]" desc="Optional labels for the additional images"/>
                    <param name="iconicId" type="string" multiplicity="?" desc="Optional iconic id."/>
                    <param name="parentId" type="string" multiplicity="?" desc="Optional parent id. The same parent id is used for all added depthmaps."/>
                    <return name="iconicId" type="string" desc="Iconic id. An id is generated if not provided."/>
                </function>
                <function name="rasterize">
                    <trait>released</trait>
                    <keywords>draw, render, color, png, jpg, jpeg</keywords>
                    <links>View.addImage, View.addHeightMap, View.addShape, View.addPoint, View.addPixelRegion, View.addPointCloud, View.addText, Image.save, Object.save</links>
                    <desc>Generates a 2D color image by rasterizing Shapes, Points, PixelRegions and Text as overlays into the pixels of a previously added image. The base image to rasterize into is taken to be the last added image using View.addImage or View.addHeightmap. Any subsequent calls to View.addShape, View.addPoint, View.addPixelRegion, View.addText, View.addPointCloud are used to add overlay graphics into the base image by modifying the pixel values in this image. This results in an image similar to what is shown in the viewer. Note however that this function does not have the full capacity as the external viewer typically has, so there will be differences.

The main limitations are as follows:
* 3D scenes cannot be reproduced, e.g., 3D pointcloud or mesh visualizations cannot be generated.
* The resolution of the generated graphics is limited by the image rasterized into.
* For text rendering there is a more limited set of ASCII characters supported compared to the external viewer. Moreover, rotated text is not currently supported.

View.rasterize must be called prior to View.present as this latter function clears the internal list of objects inside the viewer instance.

For each overlay iconic type there are also restrictions in terms of capacity compared to an external viewer. The support and limitations are as described below.

Base image:
The base image to draw on is defined to the last call by either by View.addImage or View.addHeightMap. Any pixel type is supported, e.g., UINT8, UINT16, FLOAT32. Grayscale images will be converted to RGB using a colormap. If the image is UINT8 without missing data a grayscale RGB image is generated. Otherwise the colormap 'JET' is used for conversion to RGB. To select a custom color map use the colormap ID in the View.ImageDecoration object when adding the image to the viewer. See details further down.
The View.addHeightmap takes both a range image and an intensity image as input. To select which of these images to use there is a channelIndex input parameter to View.rasterize.

Overlay support and restrictions:
* PixelRegion - Fully supported using the provided decoration object. Full decoration support.
* Shape - Supported as rasterized versions without any anti-aliasing. Full decoration support.
* Point - Supported as rasterized versions without any anti-aliasing. Full decoration support.
* Text - Supported with approximate mapping to the text rendered in the viewer. A limited ASCII-set is supported, i.e., not all characters will be rendered. Not all properties in the TextDecoration object are supported.
* PointCloud - Partial support. Points are rendered over their x,y-coordinates in the image. The same colormaps are available as for the Image type.

The following iconics are not supported: Mesh, Profile, Graph, Scan

The colors for the rasterized image or pointcloud can be selected by the colormap ID in the View.ImageDecoration.setColormap or conversely in the View.PointCloudDecoration.setZColormap functions. This ID is mapped to the View.ColorMap.fromMap enums in the following order:
'AUTUMN', 'BLUE_WHITE_RED', 'COOL', 'GRAY', 'HOT', 'HSV', 'JET', 'RAINBOW', 'SPRING', 'SUMMER', 'THERMAL', 'TRAFFIC_LIGHT', 'WINTER', 'RGB'.
Default is zero which attempts to mimic the default viewer behavior. Set 1 to get 'AUTUMN' and -1 to get an inverted 'AUTUMN' colorization.</desc>
                    <sample for="lua">local image = View.rasterize(viewer)</sample>
                    <param name="viewer" type="handle" alias="View" desc="The viewer instance to rasterize."/>
                    <param name="channelIndex" type="int" multiplicity="?" desc="Only relevant when View.addHeightMap was used to add the base image. Default is 0, which means that the heightmap/range image is used as base image. Set 1 to use the reflectance/intensity image instead."/>
                    <return name="image" type="object" multiplicity="?" alias="Image" desc="Rasterized color RGB image. Nil on failure."/>
                </function>
            </serves>
            <uses/>
            <crown name="Present">
                <trait>hidden</trait>
                <desc>Internal Crown which viewers connect to. Maps to the View crown by ID.</desc>
                <enum name="LogLevel">
                    <item name="INFO" desc="Log level for info">INFO</item>
                    <item name="WARNING" desc="Log level for warnings">WARNING</item>
                    <item name="ERROR" desc="Log level for errors">ERROR</item>
                </enum>
                <serves>
                    <event name="OnConnect">
                        <desc>This static event is published when a Viewer connects. Is forwarded as a View.OnConnect-event to the View with matching ID.</desc>
                        <param name="id" type="string" desc="ID of the View handle to which OnConnect will be forwarded."/>
                    </event>
                    <event name="OnPresent">
                        <desc>Event for transmitting iconics to viewers.</desc>
                        <param name="handle" type="handle" alias="View.Present" desc="Handle returned by create"/>
                        <param name="viewObject" type="const object" multiplicity="+" desc="The objects to view. An object could be any of View.Present sub-objects such as View.Present.Add, View.Present.Clear, View.Present.Editor, View.Present.Remove, View.Camera, View.Present.UpdateDecoration, View.Present.UpdateTransform"/>
                    </event>
                    <event name="OnPresentAssured">
                        <desc>Event for transmitting iconics to viewers.</desc>
                        <param name="handle" type="handle" alias="View.Present" desc="Handle returned by create"/>
                        <param name="viewObject" type="const object" multiplicity="+" desc="The objects to view. An object could be any of View.Present sub-objects such as View.Present.Add, View.Present.Clear, View.Present.Editor or View.Present.Remove."/>
                    </event>
                    <event name="OnPresentLive">
                        <desc>Event for transmitting iconics to viewers.</desc>
                        <param name="handle" type="handle" alias="View.Present" desc="Handle returned by create"/>
                        <param name="viewObject" type="const object" multiplicity="+" desc="The objects to view. An object could be any of View.Present sub-objects such as View.Present.Add, View.Present.Clear, View.Present.Editor or View.Present.Remove."/>
                    </event>
                    <event name="OnChange">
                        <desc>This static event is published when an iconic is changed in a Viewer. Is forwarded as a View.OnChange-event to the View with matching ID.</desc>
                        <param name="id" type="string" desc="ID of the View handle to which OnChange will be forwarded."/>
                        <param name="iconicId" type="string" desc="ID of the iconic for the changed iconic object"/>
                        <param name="iconic" type="object" desc="Changed iconic object"/>
                    </event>
                    <event name="OnPointer">
                        <desc>This static event is published when a user has interacted with a Viewer using the select tool. Is forwarded as a View.OnPointer-event to the View with matching ID.</desc>
                        <param name="id" type="string" desc="ID of the View handle to which OnPointer will be forwarded."/>
                        <param name="iconicId" type="string" desc="The ID of the iconic under the pointer or an empty string if no iconic was hit."/>
                        <param name="pointerActionType" type="enum" ref="PointerActionType" desc="Pointer action type"/>
                        <param name="pointerType" type="enum" ref="PointerType" desc="Pointer type"/>
                    </event>
                    <function name="create">
                        <desc>Creates a new View.Present</desc>
                        <sample for="lua">viewPresent = View.Present.create()</sample>
                        <return name="handle" type="handle" alias="View.Present" desc="The new view present"/>
                    </function>
                    <function name="notifyIconicChangedEvent">
                        <desc>Triggers a notification of the View.OnChange event.</desc>
                        <sample for="lua">View.Present.notifyIconicChangedEvent(handle, id, iconic)</sample>
                        <param name="handle" type="handle" alias="View.Present" desc="The instance to be used"/>
                        <param name="iconicId" type="string" desc="ID of the iconic for the changed iconic object"/>
                        <param name="iconic" type="object" desc="Changed iconic object"/>
                    </function>
                    <function name="notifyPointerEvent">
                        <desc>Triggers a notification of the View.OnPointer event.</desc>
                        <sample for="lua">View.Present.notifyPointerEvent(handle, id, "CLICKED", "PRIMARY")</sample>
                        <param name="handle" type="handle" alias="View.Present" desc="The instance to be used"/>
                        <param name="iconicId" type="string" desc="ID of the targeted iconic object. Empty string if an action did not target any iconic."/>
                        <param name="pointerActionType" type="enum" ref="PointerActionType" desc="Pointer action type"/>
                        <param name="pointerType" type="enum" ref="PointerType" desc="Pointer type"/>
                    </function>
                    <function name="logMessage">
                        <desc>Logs a message with specified severity level</desc>
                        <sample for="lua">View.Present.logMessage(handle, "WARNING", "Warning message")</sample>
                        <param name="handle" type="handle" alias="View.Present" desc="The instance to be used"/>
                        <param name="level" type="enum" ref="LogLevel" desc="Log level"/>
                        <param name="message" type="string" desc="Message to log"/>
                    </function>
                    <function name="register">
                        <desc>This function is used to register for any event of the handle.</desc>
                        <param name="handle" type="handle" alias="View.Present" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to register to"/>
                        <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                        <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                    </function>
                    <function name="deregister">
                        <desc>This function is used to deregister from any registered event of the handle.</desc>
                        <param name="handle" type="handle" alias="View.Present" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to deregister from"/>
                        <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                        <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                    </function>
                    <function name="setID">
                        <desc>Set the viewer identifier in order to connect with dedicated view.</desc>
                        <sample for="lua">View.Present.setID(handle, "Viewer1")</sample>
                        <param name="handle" type="handle" alias="View.Present" desc="The instance to be used."/>
                        <param name="id" type="string" desc="The identifier."/>
                    </function>
                </serves>
                <crown name="Add">
                    <trait>hidden</trait>
                    <desc>Internal CROWN sent to the viewer in View.Present.OnPresent event to add iconic objects.</desc>
                    <enum name="IconicType">
                        <item name="HEIGHTMAP" desc="Add heightmap type">HEIGHTMAP</item>
                        <item name="IMAGE" desc="Add image type">IMAGE</item>
                        <item name="PIXEL_REGION" desc="Add pixel region type">PIXEL_REGION</item>
                        <item name="POINT_CLOUD" desc="Add point cloud type">POINT_CLOUD</item>
                        <item name="SHAPE" desc="Add shape type">SHAPE</item>
                        <item name="TEXT" desc="Add text type">TEXT</item>
                        <item name="PROFILE" desc="Add profile type">PROFILE</item>
                        <item name="POLAR_SCAN" desc="Add polar scan type">POLAR_SCAN</item>
                        <item name="MESH" desc="Add mesh type">MESH</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <desc>Creates a new View.Present.Add</desc>
                            <sample for="lua">viewPresentAdd = View.Present.Add.create()</sample>
                            <return name="handle" type="handle" alias="View.Present.Add" desc="The new view present add object"/>
                        </function>
                        <function name="getType">
                            <desc>Gets the type of the iconics.</desc>
                            <sample for="lua">type = View.Present.Add.getType(handle)</sample>
                            <param name="handle" type="handle" alias="View.Present.Add" desc="The instance to be used."/>
                            <return name="type" type="enum" ref="IconicType" desc="Type of iconics"/>
                        </function>
                        <function name="getIconics">
                            <desc>Gets iconic objects.</desc>
                            <sample for="lua">iconics = View.Present.Add.getIconics(handle)</sample>
                            <param name="handle" type="handle" alias="View.Present.Add" desc="The instance to be used."/>
                            <return name="iconics" type="auto" multiplicity="[1+]" desc="Iconic objects which are to be viewed"/>
                        </function>
                        <function name="getIconicID">
                            <desc>Gets the ID of the iconics.</desc>
                            <sample for="lua">iconicId = View.Present.Add.getIconicID(handle)</sample>
                            <param name="handle" type="handle" alias="View.Present.Add" desc="The instance to be used."/>
                            <return name="iconicId" type="string" desc="ID of the iconics"/>
                        </function>
                        <function name="getParentID">
                            <desc>Gets the ID of the parent iconic.</desc>
                            <sample for="lua">parentId = View.Present.Add.getParentID(handle)</sample>
                            <param name="handle" type="handle" alias="View.Present.Add" desc="The instance to be used."/>
                            <return name="parentId" type="string" multiplicity="?" desc="ID of the parent iconic."/>
                        </function>
                        <function name="getDecorations">
                            <desc>Gets the iconic decorations.</desc>
                            <sample for="lua">decorations = View.Present.Add.getDecorations(handle)</sample>
                            <param name="handle" type="handle" alias="View.Present.Add" desc="The instance to be used."/>
                            <return name="decorations" type="object" multiplicity="[?*]" desc="Decorations for the iconics."/>
                        </function>
                        <function name="getLabels">
                            <desc>Gets the labels for the additional iconics. (currently only used for View.addHeightmap())</desc>
                            <sample for="lua">labels = View.Present.Add.getLabels(handle)</sample>
                            <param name="handle" type="handle" alias="View.Present.Add" desc="The instance to be used."/>
                            <return name="labels" type="string" multiplicity="[?*]" desc="Labels for additional iconics."/>
                        </function>
                    </serves>
                </crown>
                <crown name="Clear">
                    <trait>hidden</trait>
                    <desc>Internal CROWN sent to the viewer in View.Present.OnPresent event to clear the scene.</desc>
                    <serves>
                        <function name="create">
                            <desc>Creates a new View.Present.Clear</desc>
                            <sample for="lua">viewPresentClear = View.Present.Clear.create()</sample>
                            <return name="handle" type="handle" alias="View.Present.Clear" desc="The new view present clear object"/>
                        </function>
                    </serves>
                </crown>
                <crown name="Editor">
                    <trait>hidden</trait>
                    <desc>Internal CROWN sent to the viewer View.Present.OnPresent event to install or uninstall an editor.</desc>
                    <enum name="EditorType">
                        <item name="INSTALL" desc="Install editor">INSTALL</item>
                        <item name="UNINSTALL" desc="Uninstall editor">UNINSTALL</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <desc>Creates a new View.Present.Editor</desc>
                            <sample for="lua">viewPresentEditor = View.Present.Editor.create()</sample>
                            <return name="handle" type="handle" alias="View.Present.Editor" desc="The new view present editor object"/>
                        </function>
                        <function name="getType">
                            <desc>Gets the type of the editor.</desc>
                            <sample for="lua">type = View.Present.Editor.getType(handle)</sample>
                            <param name="handle" type="handle" alias="View.Present.Editor" desc="The instance to be used."/>
                            <return name="type" type="enum" ref="EditorType" desc="Type of the editor"/>
                        </function>
                        <function name="getIconicID">
                            <desc>Gets the iconic ID of the editor which is to be installed/uninstalled.</desc>
                            <sample for="lua">iconicId = View.Present.Editor.getIconicID(handle)</sample>
                            <param name="handle" type="handle" alias="View.Present.Editor" desc="The instance to be used."/>
                            <return name="iconicId" type="string" desc="ID of the editor"/>
                        </function>
                    </serves>
                </crown>
                <crown name="Remove">
                    <trait>hidden</trait>
                    <desc>Internal CROWN sent to the viewer in View.Present.OnPresent event to remove iconic objects.</desc>
                    <serves>
                        <function name="create">
                            <desc>Creates a new View.Present.Remove</desc>
                            <sample for="lua">viewPresentRemove = View.Present.Remove.create()</sample>
                            <return name="handle" type="handle" alias="View.Present.Remove" desc="The new view present remove object"/>
                        </function>
                        <function name="getIconicID">
                            <desc>Gets the ID of the iconic which is to be removed.</desc>
                            <sample for="lua">View.Present.Remove.getIconicID(handle)</sample>
                            <param name="handle" type="handle" alias="View.Present.Remove" desc="The instance to be used."/>
                            <return name="iconicId" type="string" desc="ID of the iconic"/>
                        </function>
                    </serves>
                </crown>
                <crown name="UpdateDecoration">
                    <trait>hidden</trait>
                    <desc>Internal CROWN sent to the viewer in View.Present.OnPresent event to update decorations of already existing objects.</desc>
                    <serves>
                        <function name="create">
                            <desc>Creates a new View.Present.UpdateDecoration</desc>
                            <sample for="lua">cam = View.Present.UpdateDecoration.create()</sample>
                            <return name="handle" type="handle" alias="View.Present.UpdateDecoration" desc="The new view present UpdateDecoration object"/>
                        </function>
                    </serves>
                </crown>
                <crown name="UpdateTransform">
                    <trait>hidden</trait>
                    <desc>Internal CROWN sent to the viewer in View.Present.OnPresent event to set the transformation of already existing objects.</desc>
                    <serves>
                        <function name="create">
                            <desc>Creates a new View.Present.UpdateTransform</desc>
                            <sample for="lua">cam = View.Present.UpdateTransform.create()</sample>
                            <return name="handle" type="handle" alias="View.Present.UpdateTransform" desc="The new view present UpdateTransform object"/>
                        </function>
                    </serves>
                </crown>
                <crown name="UpdateCamera">
                    <trait>hidden</trait>
                    <desc>Internal CROWN sent to the viewer in View.Present.OnPresent event to set the camera pose of already existing objects.</desc>
                    <serves>
                        <function name="create">
                            <desc>Creates a new View.Present.UpdateCamera</desc>
                            <sample for="lua">cam = View.Present.UpdateCamera.create()</sample>
                            <return name="handle" type="handle" alias="View.Present.UpdateCamera" desc="The new view present UpdateCamera object"/>
                        </function>
                    </serves>
                </crown>
            </crown>
            <crown name="ShapeDecoration">
                <trait>released</trait>
                <desc>Decoration object that describes visualization properties for shapes and points.</desc>
                <enum name="PointType">
                    <item name="DOT" desc="a dot to present the point">DOT</item>
                    <item name="CROSS" desc="a cross to present the point">CROSS</item>
                </enum>
                <serves>
                    <function name="create">
                        <desc>Creates a new ShapeDecoration.

The default values for the decoration are:

- lineWidth = 1.0
- lineColor = (0, 0, 0, 255)
- fillColor = (0, 0, 0, 0)
- pointType = "DOT"
- pointSize = 3.0

These values can be changed by using the corresponding functions.</desc>
                        <sample for="lua">shapeDecoration = View.ShapeDecoration.create()</sample>
                        <return name="deco" type="object" alias="View.ShapeDecoration" desc="The new ShapeDecoration"/>
                    </function>
                    <function name="setLineWidth">
                        <desc>Set the line width.</desc>
                        <sample for="lua">shapeDecoration = View.ShapeDecoration.setLineWidth(shapeDecoration, 2.3)</sample>
                        <param name="deco" type="object" alias="View.ShapeDecoration" desc="The instance to be used."/>
                        <param name="width" type="float" desc="Width"/>
                        <return name="shapeDecoration" type="object" alias="View.ShapeDecoration" desc="The updated ShapeDecoration."/>
                    </function>
                    <function name="setLineColor">
                        <desc>Sets the line color. It will be used for line, points and text iconics as well as stroke color for shape iconics.</desc>
                        <sample for="lua">shapeDecoration = View.ShapeDecoration.setLineColor(shapeDecoration, 255, 0, 0, 255)</sample>
                        <param name="deco" type="object" alias="View.ShapeDecoration" desc="The instance to be used."/>
                        <param name="red" type="int" desc="Red"/>
                        <param name="green" type="int" desc="Green"/>
                        <param name="blue" type="int" desc="Blue"/>
                        <param name="alpha" type="int" multiplicity="?" desc="Alpha"/>
                        <return name="shapeDecoration" type="object" alias="View.ShapeDecoration" desc="The updated ShapeDecoration."/>
                    </function>
                    <function name="setFillColor">
                        <desc>Sets the fill color. It will be used to fill shape iconics.</desc>
                        <sample for="lua">shapeDecoration = View.ShapeDecoration.setFillColor(shapeDecoration, 255, 0, 0, 255)</sample>
                        <param name="deco" type="object" alias="View.ShapeDecoration" desc="The instance to be used."/>
                        <param name="red" type="int" desc="Red"/>
                        <param name="green" type="int" desc="Green"/>
                        <param name="blue" type="int" desc="Blue"/>
                        <param name="alpha" type="int" multiplicity="?" desc="Alpha"/>
                        <return name="shapeDecoration" type="object" alias="View.ShapeDecoration" desc="The updated ShapeDecoration."/>
                    </function>
                    <function name="setPointType">
                        <desc>Sets the display type for point iconics.</desc>
                        <sample for="lua">shapeDecoration = View.ShapeDecoration.setPointType(shapeDecoration, "CROSS")</sample>
                        <param name="deco" type="object" alias="View.ShapeDecoration" desc="The instance to be used."/>
                        <param name="type" type="enum" ref="PointType" desc="The point type (DOT or CROSS)."/>
                        <return name="shapeDecoration" type="object" alias="View.ShapeDecoration" desc="The updated ShapeDecoration."/>
                    </function>
                    <function name="setPointSize">
                        <desc>Sets the point size for point iconics.</desc>
                        <sample for="lua">shapeDecoration = View.ShapeDecoration.setPointSize(shapeDecoration, 3.5)</sample>
                        <param name="deco" type="object" alias="View.ShapeDecoration" desc="The instance to be used."/>
                        <param name="size" type="float" desc="Size"/>
                        <return name="shapeDecoration" type="object" alias="View.ShapeDecoration" desc="The updated ShapeDecoration."/>
                    </function>
                    <function name="toString">
                        <desc>Gets a user-friendly string description of the shape decoration.</desc>
                        <sample for="lua">str = View.ShapeDecoration.toString(shapeDecoration)</sample>
                        <param name="shapeDecoration" type="const object" alias="View.ShapeDecoration" desc="The decoration object."/>
                        <return name="str" type="string" desc="User-friendly description of the shape decoration."/>
                    </function>
                </serves>
            </crown>
            <crown name="ImageDecoration">
                <trait>released</trait>
                <desc>Decoration object that describes visualization properties for an image.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new ImageDecoration. The default values for the decoration are:
- range = [0,255]
- colorMapID = 0</desc>
                        <sample for="lua">imageDecoration = View.ImageDecoration.create()</sample>
                        <return name="imageDecorator" type="object" alias="View.ImageDecoration" desc="The new ImageDecoration"/>
                    </function>
                    <function name="setRange">
                        <desc>Sets the pixel value range to visualize. For example, if the range [100,500] is set, all pixel values below 100 should be mapped to black and all pixel values above 500 should be mapped to white.
Please note that this function has no effect for UINT8 and RGB24 images.</desc>
                        <sample for="lua">imageDecorator = View.ImageDecoration.setRange(imageDecorator, 100, 500)</sample>
                        <param name="imageDecorator" type="object" alias="View.ImageDecoration" desc="The instance to be used."/>
                        <param name="minRange" type="float" desc="The lower bound of the range to visualize."/>
                        <param name="maxRange" type="float" desc="The upper bound of the range to visualize."/>
                        <return name="imageDecorator" type="object" alias="View.ImageDecoration" desc="The updated ImageDecoration."/>
                    </function>
                    <function name="setColormap">
                        <desc>Sets an integer ID for the color map to use. An image viewer can have a predefined set of color maps to show scalar images false-coded in color for better contrast.</desc>
                        <sample for="lua">imageDecorator = View.ImageDecoration.setColormap(imageDecorator, 2)</sample>
                        <param name="imageDecorator" type="object" alias="View.ImageDecoration" desc="The instance to be used."/>
                        <param name="colorMapID" type="int" desc="An integer ID for the color map to use. The set of color maps available depends on the viewer component."/>
                        <return name="imageDecorator" type="object" alias="View.ImageDecoration" desc="The updated ImageDecoration."/>
                    </function>
                    <function name="toString">
                        <desc>Gets a user-friendly string description of the image decoration.</desc>
                        <sample for="lua">str = View.ImageDecoration.toString(imageDecoration)</sample>
                        <param name="imageDecoration" type="const object" alias="View.ImageDecoration" desc="The decoration object."/>
                        <return name="str" type="string" desc="User-friendly description of the image decoration."/>
                    </function>
                </serves>
            </crown>
            <crown name="TextDecoration">
                <trait>released</trait>
                <desc>Decoration object that describes visualization properties for text overlays. Note that a viewer might not support all properties.</desc>
                <enum name="HorizontalAlignment">
                    <item name="LEFT" desc="Align text to the left of the given position.">LEFT</item>
                    <item name="CENTER" desc="Align text centered horizontally relative to given position.">CENTER</item>
                    <item name="RIGHT" desc="Align text to the right of the given position.">RIGHT</item>
                    <item name="JUSTIFY" desc="Align text in a justified mode (stretch spaces to fill the bound's width).">JUSTIFY</item>
                </enum>
                <enum name="VerticalAlignment">
                    <item name="BOTTOM" desc="Align bottom of text with the given position.">BOTTOM</item>
                    <item name="CENTER" desc="Align center of text with the given position.">CENTER</item>
                    <item name="TOP" desc="Align top of text with the given position.">TOP</item>
                </enum>
                <enum name="FontFamily">
                    <item name="SANSSERIF" desc="Sans Serif font, e.g., Arial, Helvetica style.">SANSSERIF</item>
                    <item name="MONOSPACE" desc="Mono-spaced font, e.g., Courier style.">MONOSPACE</item>
                    <item name="SERIF" desc="Serif font, e.g., Times New Roman style.">SERIF</item>
                </enum>
                <serves>
                    <function name="create">
                        <desc>Creates a new TextDecoration.</desc>
                        <sample for="lua">textDecorator = View.TextDecoration.create()</sample>
                        <return name="textDecorator" type="object" alias="View.TextDecoration" desc="The new TextDecoration"/>
                    </function>
                    <function name="setSize">
                        <desc>Sets the text font size.</desc>
                        <sample for="lua">textDecorator = View.TextDecoration.setSize(textDecorator, 10)</sample>
                        <param name="textDecorator" type="object" alias="View.TextDecoration" desc="The instance to be used."/>
                        <param name="fontSize" type="float" desc="The text font size. The default value is 10."/>
                        <return name="textDecorator" type="object" alias="View.TextDecoration" desc="The updated TextDecoration."/>
                    </function>
                    <function name="setLineSpacing">
                        <desc>Sets the line spacing in % of the text size.</desc>
                        <sample for="lua">textDecorator = View.TextDecoration.setLineSpacing(textDecorator, 1.2)</sample>
                        <param name="textDecorator" type="object" alias="View.TextDecoration" desc="The instance to be used."/>
                        <param name="lineSpacing" type="float" desc="The line spacing factor. The default value is 1.1."/>
                        <return name="textDecorator" type="object" alias="View.TextDecoration" desc="The updated TextDecoration."/>
                    </function>
                    <function name="setRotation">
                        <desc>Sets the text rotation in radians around the given text position and around the given axis.</desc>
                        <sample for="lua">textDecorator = View.TextDecoration.setRotation(textDecorator, 1.5708, {0,1,0})</sample>
                        <param name="textDecorator" type="object" alias="View.TextDecoration" desc="The instance to be used."/>
                        <param name="rotation" type="float" desc="Text rotation in radians. The default value is 0."/>
                        <param name="axis" type="float" multiplicity="*" desc="A 3d vector which describes the rotation axis. Default is {0,0,-1}."/>
                        <return name="textDecorator" type="object" alias="View.TextDecoration" desc="The updated TextDecoration."/>
                    </function>
                    <function name="setBillboardActive">
                        <desc>Enable billboard mode. Default is off. When active, the text always faces the camera, and setRotation has no effect.</desc>
                        <sample for="lua">textDecorator = View.TextDecoration.setBillboardActive(textDecorator, true)</sample>
                        <param name="textDecorator" type="object" alias="View.TextDecoration" desc="The instance to be used."/>
                        <param name="active" type="bool" desc="Set true to activate billboard."/>
                        <return name="textDecorator" type="object" alias="View.TextDecoration" desc="The updated TextDecoration."/>
                    </function>
                    <function name="setPosition">
                        <desc>Sets the text position.</desc>
                        <sample for="lua">textDecorator = View.TextDecoration.setPosition(textDecorator, 10, 10)</sample>
                        <param name="textDecorator" type="object" alias="View.TextDecoration" desc="The instance to be used."/>
                        <param name="positionX" type="float" desc="The text position x-coordinate."/>
                        <param name="positionY" type="float" desc="The text position y-coordinate."/>
                        <param name="positionZ" type="float" multiplicity="?" desc="The text position z-coordinate. Optional, only useful if a 3D viewer is used."/>
                        <return name="textDecorator" type="object" alias="View.TextDecoration" desc="The updated TextDecoration."/>
                    </function>
                    <function name="setBounds">
                        <desc>Sets the size of the enclosing bounding box. If set, the text is aligned inside these bounds. The box has its origin at position.</desc>
                        <sample for="lua">textDecorator = View.TextDecoration.setBounds(textDecorator, 300, 100)</sample>
                        <param name="textDecorator" type="object" alias="View.TextDecoration" desc="The instance to be used."/>
                        <param name="width" type="int" desc="The bounds width."/>
                        <param name="height" type="int" desc="The bounds height."/>
                        <return name="textDecorator" type="object" alias="View.TextDecoration" desc="The updated TextDecoration."/>
                    </function>
                    <function name="setColor">
                        <desc>Sets the text color.</desc>
                        <sample for="lua">textDecorator = View.TextDecoration.setColor(textDecorator, 255, 0, 0, 255)</sample>
                        <param name="textDecorator" type="object" alias="View.TextDecoration" desc="The instance to be used."/>
                        <param name="red" type="int" desc="Red value in range [0,255]."/>
                        <param name="green" type="int" desc="Green value in range [0,255]."/>
                        <param name="blue" type="int" desc="Blue value in range [0,255]."/>
                        <param name="alpha" type="int" multiplicity="?" desc="Optional alpha value in range [0,255]."/>
                        <return name="textDecorator" type="object" alias="View.TextDecoration" desc="The updated TextDecoration."/>
                    </function>
                    <function name="setHorizontalAlignment">
                        <desc>Sets the horizontal alignment of the text relative to the given text position.</desc>
                        <sample for="lua">textDecorator = View.TextDecoration.setHorizontalAlignment(textDecorator, "CENTER")</sample>
                        <param name="textDecorator" type="object" alias="View.TextDecoration" desc="The instance to be used."/>
                        <param name="horizontalAlignment" type="enum" ref="HorizontalAlignment" desc="Horizontal alignment (LEFT, CENTER, RIGHT). Default is LEFT."/>
                        <return name="textDecorator" type="object" alias="View.TextDecoration" desc="The updated TextDecoration."/>
                    </function>
                    <function name="setVerticalAlignment">
                        <desc>Sets the vertical alignment of the text relative to the given text position.</desc>
                        <sample for="lua">textDecorator = View.TextDecoration.setVerticalAlignment(textDecorator, "CENTER")</sample>
                        <param name="textDecorator" type="object" alias="View.TextDecoration" desc="The instance to be used."/>
                        <param name="verticalAlignment" type="enum" ref="VerticalAlignment" desc="Vertical alignment (BOTTOM, CENTER, TOP). Default is BOTTOM."/>
                        <return name="textDecorator" type="object" alias="View.TextDecoration" desc="The updated TextDecoration."/>
                    </function>
                    <function name="setFontFamily">
                        <desc>Sets the font style family of the text, e.g., sans serif, mono-spaced or serif font style. Depending on the platform the viewer runs on, a concrete font is selected within the given font family.</desc>
                        <sample for="lua">textDecorator = View.TextDecoration.setFontFamily(textDecorator, "MONOSPACE")</sample>
                        <param name="textDecorator" type="object" alias="View.TextDecoration" desc="The instance to be used."/>
                        <param name="fontFamily" type="enum" ref="FontFamily" desc="Font family (SANSSERIF, MONOSPACE, SERIF). Default is SANSSERIF."/>
                        <return name="textDecorator" type="object" alias="View.TextDecoration" desc="The updated TextDecoration."/>
                    </function>
                    <function name="toString">
                        <desc>Gets a human-friendly string description of the text decoration, containing all properties.</desc>
                        <sample for="lua">str = View.TextDecoration.toString(textDecoration)</sample>
                        <param name="textDecoration" type="const object" alias="View.TextDecoration" desc="The decoration object."/>
                        <return name="str" type="string" desc="User-friendly description of the text decoration."/>
                    </function>
                </serves>
            </crown>
            <crown name="Camera">
                <trait>released</trait>
                <desc>Camera object that describes camera properties for the scene in the viewer. To be set with View.setCamera().</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new View.Camera</desc>
                        <sample for="lua">cam = View.Camera.create()</sample>
                        <return name="camera" type="handle" alias="View.Camera" desc="The new camera"/>
                    </function>
                    <function name="setPosition">
                        <desc>Set the position of the camera.</desc>
                        <sample for="lua">View.Camera.setPosition(cam, 0, -1, 1000)</sample>
                        <param name="camera" type="handle" alias="View.Camera" desc="The instance to be used."/>
                        <param name="posX" type="float" desc="X"/>
                        <param name="posY" type="float" desc="Y"/>
                        <param name="posZ" type="float" desc="Z"/>
                    </function>
                    <function name="setUp">
                        <desc>Set the up-vector of the camera.</desc>
                        <sample for="lua">View.Camera.setUp(cam, 0, 0, 1)</sample>
                        <param name="camera" type="handle" alias="View.Camera" desc="The instance to be used."/>
                        <param name="posX" type="float" desc="X"/>
                        <param name="posY" type="float" desc="Y"/>
                        <param name="posZ" type="float" desc="Z"/>
                    </function>
                    <function name="setTarget">
                        <desc>Set the target-vector of the camera.</desc>
                        <sample for="lua">View.Camera.setTarget(cam, 0, 0, 0)</sample>
                        <param name="camera" type="handle" alias="View.Camera" desc="The instance to be used."/>
                        <param name="posX" type="float" desc="X"/>
                        <param name="posY" type="float" desc="Y"/>
                        <param name="posZ" type="float" desc="Z"/>
                    </function>
                </serves>
            </crown>
            <crown name="PixelRegionDecoration">
                <trait>released</trait>
                <desc>Decoration object that describes visualization properties for a pixel region.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new PixelRegionDecoration.</desc>
                        <sample for="lua">pixelRegionDecoration = View.PixelRegionDecoration.create()</sample>
                        <return name="pixelRegionDecorator" type="object" alias="View.PixelRegionDecoration" desc="The new PixelRegionDecoration"/>
                    </function>
                    <function name="setColor">
                        <desc>Sets the pixel region color.</desc>
                        <sample for="lua">pixelRegionDecorator = View.PixelRegionDecoration.setColor(pixelRegionDecorator, 255, 0, 0, 255)</sample>
                        <param name="pixelRegionDecorator" type="object" alias="View.PixelRegionDecoration" desc="The instance to be used."/>
                        <param name="red" type="int" desc="Red value in range [0,255]."/>
                        <param name="green" type="int" desc="Green value in range [0,255]."/>
                        <param name="blue" type="int" desc="Blue value in range [0,255]."/>
                        <param name="alpha" type="int" multiplicity="?" desc="Optional alpha value in range [0,255]."/>
                        <return name="pixelRegionDecorator" type="object" alias="View.PixelRegionDecoration" desc="The updated PixelRegionDecoration."/>
                    </function>
                    <function name="toString">
                        <desc>Gets a user-friendly string description of the pixel region decoration.</desc>
                        <sample for="lua">str = View.PixelRegionDecoration.toString(pixelRegionDecoration)</sample>
                        <param name="pixelRegionDecoration" type="const object" alias="View.PixelRegionDecoration" desc="The decoration object."/>
                        <return name="str" type="string" desc="User-friendly description of the pixel region decoration."/>
                    </function>
                </serves>
            </crown>
            <crown name="PointCloudDecoration">
                <trait>released</trait>
                <desc>Decoration object that describes visualization properties for a point cloud.</desc>
                <serves>
                    <function name="create">
                        <desc>Create a new PointCloudDecoration.</desc>
                        <sample for="lua">local pointCloudDecoration = View.PointCloudDecoration.create()</sample>
                        <return name="pointCloudDecoration" type="object" alias="View.PointCloudDecoration" desc="The new PointCloudDecoration"/>
                    </function>
                    <function name="setXRange">
                        <desc>Set the lower and upper bound of this component.</desc>
                        <sample for="lua">pointCloudDecoration = View.PointCloudDecoration.setXRange(pointCloudDecoration, -100, 100)</sample>
                        <param name="pointCloudDecoration" type="object" alias="View.PointCloudDecoration" desc="The instance to be used."/>
                        <param name="minValue" type="float" desc="The lower bound of the x range to visualize."/>
                        <param name="maxValue" type="float" desc="The upper bound of the x range to visualize."/>
                        <return name="pointCloudDecoration" type="object" alias="View.PointCloudDecoration" desc="The updated PointCloudDecoration."/>
                    </function>
                    <function name="setXColormap">
                        <desc>Set an integer ID for the color map to use for the X range (0 = gray scale).</desc>
                        <sample for="lua">pointCloudDecoration = View.PointCloudDecoration.setXColormap(pointCloudDecoration, 2)</sample>
                        <param name="pointCloudDecoration" type="object" alias="View.PointCloudDecoration" desc="The instance to be used."/>
                        <param name="colorMapID" type="int" desc="An integer ID for the color map to use. The set of color maps available depends on the viewer component."/>
                        <return name="pointCloudDecoration" type="object" alias="View.PointCloudDecoration" desc="The updated PointCloudDecoration."/>
                    </function>
                    <function name="setYRange">
                        <desc>Set the lower and upper bound of this component.</desc>
                        <sample for="lua">pointCloudDecoration = View.PointCloudDecoration.setYRange(pointCloudDecoration, -100, 100)</sample>
                        <param name="pointCloudDecoration" type="object" alias="View.PointCloudDecoration" desc="The instance to be used."/>
                        <param name="minValue" type="float" desc="The lower bound of the y range to visualize."/>
                        <param name="maxValue" type="float" desc="The upper bound of the y range to visualize."/>
                        <return name="pointCloudDecoration" type="object" alias="View.PointCloudDecoration" desc="The updated PointCloudDecoration."/>
                    </function>
                    <function name="setYColormap">
                        <desc>Set an integer ID for the color map to use for the Y range (0 = gray scale).</desc>
                        <sample for="lua">pointCloudDecoration = View.PointCloudDecoration.setYColormap(pointCloudDecoration, 2)</sample>
                        <param name="pointCloudDecoration" type="object" alias="View.PointCloudDecoration" desc="The instance to be used."/>
                        <param name="colorMapID" type="int" desc="An integer ID for the color map to use. The set of color maps available depends on the viewer component."/>
                        <return name="pointCloudDecoration" type="object" alias="View.PointCloudDecoration" desc="The updated PointCloudDecoration."/>
                    </function>
                    <function name="setZRange">
                        <desc>Set the lower and upper bound of this component.</desc>
                        <sample for="lua">pointCloudDecoration = View.PointCloudDecoration.setZRange(pointCloudDecoration, -100, 100)</sample>
                        <param name="pointCloudDecoration" type="object" alias="View.PointCloudDecoration" desc="The instance to be used."/>
                        <param name="minValue" type="float" desc="The lower bound of the z range to visualize."/>
                        <param name="maxValue" type="float" desc="The upper bound of the z range to visualize."/>
                        <return name="pointCloudDecoration" type="object" alias="View.PointCloudDecoration" desc="The updated PointCloudDecoration."/>
                    </function>
                    <function name="setZColormap">
                        <desc>Set an integer ID for the color map to use for the Z range (0 = gray scale).</desc>
                        <sample for="lua">pointCloudDecoration = View.PointCloudDecoration.setZColormap(pointCloudDecoration, 2)</sample>
                        <param name="pointCloudDecoration" type="object" alias="View.PointCloudDecoration" desc="The instance to be used."/>
                        <param name="colorMapID" type="int" desc="An integer ID for the color map to use. The set of color maps available depends on the viewer component."/>
                        <return name="pointCloudDecoration" type="object" alias="View.PointCloudDecoration" desc="The updated PointCloudDecoration."/>
                    </function>
                    <function name="setIntensityRange">
                        <desc>Set the lower and upper bound of this component.</desc>
                        <sample for="lua">pointCloudDecoration = View.PointCloudDecoration.setIntensityRange(pointCloudDecoration, 0.1, 0.9)</sample>
                        <param name="pointCloudDecoration" type="object" alias="View.PointCloudDecoration" desc="The instance to be used."/>
                        <param name="minValue" type="float" desc="The lower bound of the intensity range to visualize."/>
                        <param name="maxValue" type="float" desc="The upper bound of the intensity range to visualize."/>
                        <return name="pointCloudDecoration" type="object" alias="View.PointCloudDecoration" desc="The updated PointCloudDecoration."/>
                    </function>
                    <function name="setIntensityColormap">
                        <desc>Set an integer ID for the color map to use for the Intensity range (0 = gray scale).</desc>
                        <sample for="lua">pointCloudDecoration = View.PointCloudDecoration.setIntensityColormap(pointCloudDecoration, 2)</sample>
                        <param name="pointCloudDecoration" type="object" alias="View.PointCloudDecoration" desc="The instance to be used."/>
                        <param name="colorMapID" type="int" desc="An integer ID for the color map to use. The set of color maps available depends on the viewer component."/>
                        <return name="pointCloudDecoration" type="object" alias="View.PointCloudDecoration" desc="The updated PointCloudDecoration."/>
                    </function>
                    <function name="setPointSize">
                        <desc>Set the size of displayed points.</desc>
                        <sample for="lua">pointCloudDecoration = View.PointCloudDecoration.setPointSize(pointCloudDecoration, 2)</sample>
                        <param name="pointCloudDecoration" type="object" alias="View.PointCloudDecoration" desc="The instance to be used."/>
                        <param name="pointSize" type="float" desc="The size of a point"/>
                        <return name="pointCloudDecoration" type="object" alias="View.PointCloudDecoration" desc="The updated PointCloudDecoration."/>
                    </function>
                    <function name="toString">
                        <desc>Get a user-friendly string description of the point cloud decoration.</desc>
                        <sample for="lua">str = View.PointCloudDecoration.toString(pointCloudDecoration)</sample>
                        <param name="pointCloudDecoration" type="const object" alias="View.PointCloudDecoration" desc="The decoration object."/>
                        <return name="str" type="string" desc="User-friendly description of the point cloud decoration."/>
                    </function>
                </serves>
            </crown>
            <crown name="MeshDecoration">
                <trait>released</trait>
                <desc>Decoration object that describes visualization properties for a mesh.</desc>
                <enum name="VisibleFaces">
                    <item name="FRONT" desc="Renders the front faces. A front face exists if the triangle vertices, in order, rotate clockwise around the triangle's center.">FRONT</item>
                    <item name="BACK" desc="Renders the back faces. A back face exists if the triangle vertices, in order, rotate counter-clockwise around the triangle's center.">BACK</item>
                    <item name="FRONT_AND_BACK" desc="Renders both front and back faces.">FRONT_AND_BACK</item>
                    <item name="NONE" desc="Does not render the triangle faces. It can be used for example if only the vertex points are rendered.">NONE</item>
                </enum>
                <serves>
                    <function name="create">
                        <trait>released</trait>
                        <desc>Create a new MeshDecoration.</desc>
                        <sample for="lua">local meshDecorator = View.MeshDecoration.create()</sample>
                        <return name="meshDecorator" type="object" alias="View.MeshDecoration" desc="The new MeshDecoration"/>
                    </function>
                    <function name="setSurfaceColor">
                        <trait>released</trait>
                        <desc>Set the color of the surface. This color is assigned to the ambient and diffuse material properties.
Note that the alpha channel is currently unsupported and will have no effect.</desc>
                        <sample for="lua">meshDecorator = View.MeshDecoration.setSurfaceColor(meshDecorator, 0, 100, 0)</sample>
                        <param name="meshDecorator" type="object" alias="View.MeshDecoration" desc="The instance to be used."/>
                        <param name="r" type="int" desc="Red value in range (0,255)."/>
                        <param name="g" type="int" desc="Green value in range (0,255)."/>
                        <param name="b" type="int" desc="Blue value in range (0,255)."/>
                        <param name="a" type="int" multiplicity="?" desc="Alpha value in range (0,255). Currently unused."/>
                        <return name="meshDecorator" type="object" alias="View.MeshDecoration" desc="The updated MeshDecoration."/>
                    </function>
                    <function name="setVisibleFaces">
                        <trait>released</trait>
                        <desc>Set the triangle face to be rendered.</desc>
                        <sample for="lua">meshDecorator = View.MeshDecoration.setVisibleFaces(meshDecorator, "FRONT_AND_BACK")</sample>
                        <param name="meshDecorator" type="object" alias="View.MeshDecoration" desc="The instance to be used."/>
                        <param name="visibleFaces" type="enum" ref="VisibleFaces" desc="Specifies what face(s) of the triangles to be rendered. By default both faces are rendered."/>
                        <return name="meshDecorator" type="object" alias="View.MeshDecoration" desc="The updated MeshDecoration."/>
                    </function>
                    <function name="toString">
                        <trait>released</trait>
                        <desc>Get a user-friendly string description of the mesh decoration.</desc>
                        <sample for="lua">str = View.MeshDecoration.toString(meshDecorator)</sample>
                        <param name="meshDecorator" type="const object" alias="View.MeshDecoration" desc="The decoration object."/>
                        <return name="str" type="string" desc="User-friendly description of the mesh decoration."/>
                    </function>
                </serves>
            </crown>
            <crown name="GraphDecoration">
                <trait>released</trait>
                <desc>Decoration object that describes visualization properties for graphs. For example, the graph type such as xy-plot (LINE) or histogram (BAR) can be set, as well as colors, text labels, size properties etc.</desc>
                <enum name="GraphType">
                    <item name="DOT" desc="Dot graph">DOT</item>
                    <item name="LINE" desc="Line graph">LINE</item>
                    <item name="BAR" desc="Bar graph">BAR</item>
                </enum>
                <enum name="AspectRatio">
                    <item name="EQUAL" desc="Equal aspect ratio (both axis has the same scaling)">EQUAL</item>
                    <item name="SQUARE" desc="Square aspect ratio">SQUARE</item>
                    <item name="FIT" desc="Fitting the viewer">FIT</item>
                </enum>
                <serves>
                    <function name="create">
                        <desc>Creates a new GraphDecoration object.</desc>
                        <sample for="lua">local graphDecoration = View.GraphDecoration.create()</sample>
                        <return name="deco" type="object" alias="View.GraphDecoration" desc="The new GraphDecoration"/>
                    </function>
                    <function name="setAxisColor">
                        <desc>Sets color of graph axes.</desc>
                        <sample for="lua">graphDecoration = View.GraphDecoration.setAxisColor(graphDecoration, 255, 0, 0, 255)</sample>
                        <param name="deco" type="object" alias="View.GraphDecoration" desc="The instance to be used"/>
                        <param name="red" type="int" desc="Red value in range [0,255]"/>
                        <param name="green" type="int" desc="Green value in range [0,255]"/>
                        <param name="blue" type="int" desc="Blue value in range [0,255]"/>
                        <param name="a" type="int" multiplicity="?" desc="Alpha value in range [0,255]. Optional, default value is 255."/>
                        <return name="graphDecoration" type="object" alias="View.GraphDecoration" desc="The updated GraphDecoration."/>
                    </function>
                    <function name="setBackgroundColor">
                        <desc>Sets background color of the plot.</desc>
                        <sample for="lua">graphDecoration = View.GraphDecoration.setBackgroundColor(graphDecoration, 255, 0, 0, 255)</sample>
                        <param name="deco" type="object" alias="View.GraphDecoration" desc="The instance to be used"/>
                        <param name="red" type="int" desc="Red value in range [0,255]"/>
                        <param name="green" type="int" desc="Green value in range [0,255]"/>
                        <param name="blue" type="int" desc="Blue value in range [0,255]"/>
                        <param name="a" type="int" multiplicity="?" desc="Alpha value in range [0,255]. Optional, default value is 255."/>
                        <return name="graphDecoration" type="object" alias="View.GraphDecoration" desc="The updated GraphDecoration."/>
                    </function>
                    <function name="setGraphColor">
                        <desc>Sets color of the graph lines, dots or bars.</desc>
                        <sample for="lua">graphDecoration = View.GraphDecoration.setGraphColor(graphDecoration, 255, 0, 0, 255)</sample>
                        <param name="deco" type="object" alias="View.GraphDecoration" desc="The instance to be used"/>
                        <param name="red" type="int" desc="Red value in range [0,255]"/>
                        <param name="green" type="int" desc="Green value in range [0,255]"/>
                        <param name="blue" type="int" desc="Blue value in range [0,255]"/>
                        <param name="a" type="int" multiplicity="?" desc="Alpha value in range [0,255]. Optional, default value is 255."/>
                        <return name="graphDecoration" type="object" alias="View.GraphDecoration" desc="The updated GraphDecoration."/>
                    </function>
                    <function name="setGridColor">
                        <desc>Sets color of the grid lines.</desc>
                        <sample for="lua">graphDecoration = View.GraphDecoration.setGridColor(graphDecoration, 255, 0, 0, 255)</sample>
                        <param name="deco" type="object" alias="View.GraphDecoration" desc="The instance to be used"/>
                        <param name="red" type="int" desc="Red value in range [0,255]"/>
                        <param name="green" type="int" desc="Green value in range [0,255]"/>
                        <param name="blue" type="int" desc="Blue value in range [0,255]"/>
                        <param name="a" type="int" multiplicity="?" desc="Alpha value in range [0,255]. Optional, default value is 255."/>
                        <return name="graphDecoration" type="object" alias="View.GraphDecoration" desc="The updated GraphDecoration."/>
                    </function>
                    <function name="setLabelColor">
                        <desc>Sets color of the text labels.</desc>
                        <sample for="lua">graphDecoration = View.GraphDecoration.setLabelColor(graphDecoration, 255, 0, 0, 255)</sample>
                        <param name="deco" type="object" alias="View.GraphDecoration" desc="The instance to be used"/>
                        <param name="red" type="int" desc="Red value in range [0,255]"/>
                        <param name="green" type="int" desc="Green value in range [0,255]"/>
                        <param name="blue" type="int" desc="Blue value in range [0,255]"/>
                        <param name="a" type="int" multiplicity="?" desc="Alpha value in range [0,255]. Optional, default value is 255."/>
                        <return name="graphDecoration" type="object" alias="View.GraphDecoration" desc="The updated GraphDecoration."/>
                    </function>
                    <function name="setGraphType">
                        <desc>Sets the graph type to draw lines, dots or bars.</desc>
                        <sample for="lua">graphDecoration = View.GraphDecoration.setGraphType(graphDecoration, "BAR")</sample>
                        <param name="deco" type="object" alias="View.GraphDecoration" desc="The instance to be used"/>
                        <param name="type" type="enum" ref="GraphType" desc="The graph type, DOT, LINE or BAR. Default value is LINE."/>
                        <return name="graphDecoration" type="object" alias="View.GraphDecoration" desc="The updated GraphDecoration."/>
                    </function>
                    <function name="setAspectRatio">
                        <desc>Sets the graphs aspect ratio.</desc>
                        <sample for="lua">graphDecoration = View.GraphDecoration.setAspectRatio(graphDecoration, "FIT")</sample>
                        <param name="deco" type="object" alias="View.GraphDecoration" desc="The instance to be used"/>
                        <param name="type" type="enum" ref="AspectRatio" desc="The graphs aspect ratio, EQUAL, SQUARE or FIT. Default value is FIT."/>
                        <return name="graphDecoration" type="object" alias="View.GraphDecoration" desc="The updated GraphDecoration."/>
                    </function>
                    <function name="setAxisVisible">
                        <desc>Sets whether to show or hide the axes.</desc>
                        <sample for="lua">graphDecoration = View.GraphDecoration.setAxisVisible(graphDecoration, false)</sample>
                        <param name="deco" type="object" alias="View.GraphDecoration" desc="The instance to be used"/>
                        <param name="visible" type="bool" desc="True if axis should be visible, default value is true."/>
                        <return name="graphDecoration" type="object" alias="View.GraphDecoration" desc="The updated GraphDecoration."/>
                    </function>
                    <function name="setBackgroundVisible">
                        <desc>Sets whether the background should be visible or not.</desc>
                        <sample for="lua">graphDecoration = View.GraphDecoration.setBackgroundVisible(graphDecoration, false)</sample>
                        <param name="deco" type="object" alias="View.GraphDecoration" desc="The instance to be used"/>
                        <param name="visible" type="bool" desc="True if background should be visible, default value is true."/>
                        <return name="graphDecoration" type="object" alias="View.GraphDecoration" desc="The updated GraphDecoration."/>
                    </function>
                    <function name="setGridVisible">
                        <desc>Sets whether to show or hide the grid lines.</desc>
                        <sample for="lua">graphDecoration = View.GraphDecoration.setGridVisible(graphDecoration, false)</sample>
                        <param name="deco" type="object" alias="View.GraphDecoration" desc="The instance to be used"/>
                        <param name="visible" type="bool" desc="True if grid should be visible, default value is true."/>
                        <return name="graphDecoration" type="object" alias="View.GraphDecoration" desc="The updated GraphDecoration."/>
                    </function>
                    <function name="setLabelsVisible">
                        <desc>Sets whether to show or hide the axes labels.</desc>
                        <sample for="lua">graphDecoration = View.GraphDecoration.setLabelsVisible(graphDecoration, false)</sample>
                        <param name="deco" type="object" alias="View.GraphDecoration" desc="The instance to be used"/>
                        <param name="visible" type="bool" desc="True if labels should be visible, default value is true."/>
                        <return name="graphDecoration" type="object" alias="View.GraphDecoration" desc="The updated GraphDecoration."/>
                    </function>
                    <function name="setTicksVisible">
                        <desc>Sets whether to show or hide the axes ticks.</desc>
                        <sample for="lua">graphDecoration = View.GraphDecoration.setTicksVisible(graphDecoration, false)</sample>
                        <param name="deco" type="object" alias="View.GraphDecoration" desc="The instance to be used"/>
                        <param name="visible" type="bool" desc="True if ticks should be visible, default value is true."/>
                        <return name="graphDecoration" type="object" alias="View.GraphDecoration" desc="The updated GraphDecoration."/>
                    </function>
                    <function name="setIndexCoordinates">
                        <desc>Sets whether to use the index in the value vector as x value or use the supplied coordinate vector.</desc>
                        <sample for="lua">graphDecoration = View.GraphDecoration.setIndexCoordinates(graphDecoration, true)</sample>
                        <param name="deco" type="object" alias="View.GraphDecoration" desc="The instance to be used"/>
                        <param name="indexAsX" type="bool" desc="True if index rather then the coordinate should be used as x value, default value is false."/>
                        <return name="graphDecoration" type="object" alias="View.GraphDecoration" desc="The updated GraphDecoration."/>
                    </function>
                    <function name="setPolarPlot">
                        <desc>Sets whether to use a polar or a linear visualization. If a polar visualization is chosen the coordinates of the graph will be used as angle (in radians) and the value as distance.</desc>
                        <sample for="lua">graphDecoration = View.GraphDecoration.setPolarPlot(graphDecoration, true)</sample>
                        <param name="deco" type="object" alias="View.GraphDecoration" desc="The instance to be used"/>
                        <param name="polarVisualization" type="bool" desc="True if a polar visualization should be used, default value is false."/>
                        <return name="graphDecoration" type="object" alias="View.GraphDecoration" desc="The updated GraphDecoration."/>
                    </function>
                    <function name="setDynamicSizing">
                        <desc>Sets whether sizes should be dynamic and therefore independent from the zoom, or should be larger when zoomed in (default). Dynamic sizing also results in a dynamic tick distance, getting finer when zooming.</desc>
                        <sample for="lua">graphDecoration = View.GraphDecoration.setDynamicSizing(graphDecoration, true)</sample>
                        <param name="deco" type="object" alias="View.GraphDecoration" desc="The instance to be used"/>
                        <param name="dynamicSizing" type="bool" desc="True if sizing should be dynamic instead of fixed, default value is false."/>
                        <return name="graphDecoration" type="object" alias="View.GraphDecoration" desc="The updated GraphDecoration."/>
                    </function>
                    <function name="setDrawSize">
                        <desc>Sets the graph drawing size depending on the graph type set (size of points or width of lines or width of bars).</desc>
                        <sample for="lua">graphDecoration = View.GraphDecoration.setDrawSize(graphDecoration, 3)</sample>
                        <param name="deco" type="object" alias="View.GraphDecoration" desc="The instance to be used"/>
                        <param name="size" type="float" desc="Draw size. The default value is 0, which lets the viewer automatically decide the size."/>
                        <return name="graphDecoration" type="object" alias="View.GraphDecoration" desc="The updated GraphDecoration."/>
                    </function>
                    <function name="setAxisWidth">
                        <desc>Sets the graphs axis line width.</desc>
                        <sample for="lua">graphDecoration = View.GraphDecoration.setAxisWidth(graphDecoration, 2.5)</sample>
                        <param name="deco" type="object" alias="View.GraphDecoration" desc="The instance to be used"/>
                        <param name="width" type="float" desc="Axis width. The default value is 0, which lets the viewer automatically decide the size.."/>
                        <return name="graphDecoration" type="object" alias="View.GraphDecoration" desc="The updated GraphDecoration."/>
                    </function>
                    <function name="setLabelSize">
                        <desc>Sets the text size of labels on the axes.</desc>
                        <sample for="lua">graphDecoration = View.GraphDecoration.setLabelSize(graphDecoration, 3)</sample>
                        <param name="deco" type="object" alias="View.GraphDecoration" desc="The instance to be used"/>
                        <param name="size" type="float" desc="Label text size. The default value is 0, which lets the viewer automatically decide the size."/>
                        <return name="graphDecoration" type="object" alias="View.GraphDecoration" desc="The updated GraphDecoration."/>
                    </function>
                    <function name="setTitleSize">
                        <desc>Sets the text size of the graph title.</desc>
                        <sample for="lua">graphDecoration = View.GraphDecoration.setTitleSize(graphDecoration, 3)</sample>
                        <param name="deco" type="object" alias="View.GraphDecoration" desc="The instance to be used"/>
                        <param name="size" type="float" desc="Title size. The default value is 0, which lets the viewer automatically decide the size."/>
                        <return name="graphDecoration" type="object" alias="View.GraphDecoration" desc="The updated GraphDecoration."/>
                    </function>
                    <function name="setXBounds">
                        <desc>Sets the graphs dimensions in x direction if lowerBound &lt; upperBound, otherwise the dimension will be adjusted automatically</desc>
                        <sample for="lua">graphDecoration = View.GraphDecoration.setXBounds(graphDecoration, 0, 250)</sample>
                        <param name="deco" type="object" alias="View.GraphDecoration" desc="The instance to be used"/>
                        <param name="lowerBound" type="float" desc="Lower bound. The default value is 0, which lets the viewer automatically decide the value."/>
                        <param name="upperBound" type="float" desc="Upper bound. The default value is 0, which lets the viewer automatically decide the value."/>
                        <return name="graphDecoration" type="object" alias="View.GraphDecoration" desc="The updated GraphDecoration."/>
                    </function>
                    <function name="setYBounds">
                        <desc>Sets the graphs dimensions in y direction if lowerBound &lt; upperBound, otherwise the dimension will be adjusted automatically</desc>
                        <sample for="lua">graphDecoration = View.GraphDecoration.setYBounds(graphDecoration, -250, 250)</sample>
                        <param name="deco" type="object" alias="View.GraphDecoration" desc="The instance to be used"/>
                        <param name="lowerBound" type="float" desc="Lower bound. The default value is 0, which lets the viewer automatically decide the value."/>
                        <param name="upperBound" type="float" desc="Upper bound. The default value is 0, which lets the viewer automatically decide the value."/>
                        <return name="graphDecoration" type="object" alias="View.GraphDecoration" desc="The updated GraphDecoration."/>
                    </function>
                    <function name="setLabels">
                        <desc>Sets the label text of the x and y axes.</desc>
                        <sample for="lua">graphDecoration = View.GraphDecoration.setLabels(graphDecoration, "Time [ms]", "Quantity")</sample>
                        <param name="deco" type="object" alias="View.GraphDecoration" desc="The instance to be used"/>
                        <param name="xLabel" type="string" desc="x-axis text label, empty by default."/>
                        <param name="yLabel" type="string" desc="y-axis text label, empty by default."/>
                        <return name="graphDecoration" type="object" alias="View.GraphDecoration" desc="The updated GraphDecoration."/>
                    </function>
                    <function name="setTitle">
                        <desc>Sets the title text.</desc>
                        <sample for="lua">graphDecoration = View.GraphDecoration.setTitle(graphDecoration, "Value over Time")</sample>
                        <param name="deco" type="object" alias="View.GraphDecoration" desc="The instance to be used"/>
                        <param name="title" type="string" desc="Title of the graph. Empty by default"/>
                        <return name="graphDecoration" type="object" alias="View.GraphDecoration" desc="The updated GraphDecoration."/>
                    </function>
                    <function name="toString">
                        <desc>Gets a user-friendly string description of the graph decoration.</desc>
                        <sample for="lua">str = View.GraphDecoration.toString(graphDecoration)</sample>
                        <param name="deco" type="const object" alias="View.GraphDecoration" desc="The instance to be used"/>
                        <return name="str" type="string" desc="User-friendly description of the graph decoration."/>
                    </function>
                </serves>
            </crown>
            <crown name="ScanDecoration">
                <trait>released</trait>
                <desc>Decoration object that describes visualization properties for a scan.</desc>
                <serves>
                    <function name="create">
                        <desc>Create a new ScanDecoration to colorize the points in a scan.</desc>
                        <sample for="lua">scanDecoration = View.ScanDecoration.create()</sample>
                        <return name="handle" type="handle" alias="View.ScanDecoration" desc="The new ScanDecoration"/>
                    </function>
                    <function name="setPointSize">
                        <desc>Set the size of displayed points.</desc>
                        <sample for="lua">View.ScanDecoration.setPointSize(handle, 2)</sample>
                        <param name="handle" type="handle" alias="View.ScanDecoration" desc="The instance to be used."/>
                        <param name="pointSize" type="int" desc="The size of a point"/>
                    </function>
                    <function name="setColor">
                        <desc>Set colors for different echoes or for the different properties from the 'PROPERTIES' channel.</desc>
                        <sample for="lua">View.ScanDecoration.setColor(handle, 255, 0, 0, 1)</sample>
                        <param name="handle" type="handle" alias="View.ScanDecoration" desc="The instance to be used."/>
                        <param name="red" type="int" desc="Red value in range (0,255)."/>
                        <param name="green" type="int" desc="Green value in range (0,255)."/>
                        <param name="blue" type="int" desc="Blue value in range (0,255)."/>
                        <param name="echo" type="int" multiplicity="?" desc="The echo on which the color is set. Echo index starting from 0. If the parameter is not passed, all echoes are colored with the r, g, b values."/>
                        <param name="channelType" type="enum" multiplicity="?" ref="Scan.ChannelType" desc="The channel to be used for coloring. Supported channel type: 'PROPERTIES'. If the parameter is not passed, all points are colored regardless of the channel type."/>
                        <param name="channelTypeKey" type="string" multiplicity="?" desc="The concrete value of the ChannelType, this parameter must only be passed if the parameter ChannelType was also passed."/>
                        <return name="success" type="bool" desc="returns true if successfully set the color."/>
                    </function>
                    <function name="setColorMap">
                        <desc>Colorize the scan points with a gradient. E.g. Distance, RSSI, Theta, Phi</desc>
                        <sample for="lua">View.ScanDecoration.setColorMap(handle, colorMapHandle, "RSSI", 0)</sample>
                        <param name="handle" type="handle" alias="View.ScanDecoration" desc="The instance to be used."/>
                        <param name="colorMap" type="object" alias="View.ColorMap" desc="The color map to be used"/>
                        <param name="channelType" type="enum" ref="Scan.ChannelType" desc="The channel to be used for coloring. Supported channel types ('Distance', 'RSSI', 'Theta', 'Phi')."/>
                        <param name="echo" type="int" multiplicity="?" desc="The echo on which the color map is set. Echo index starting from 0. If the parameter is not passed, all echoes are colored."/>
                    </function>
                    <function name="toString">
                        <desc>Get a user-friendly string description of the scan decoration.</desc>
                        <sample for="lua">str = View.ScanDecoration.toString(handle)</sample>
                        <param name="handle" type="const object" alias="View.ScanDecoration" desc="The decoration object."/>
                        <return name="str" type="string" desc="User-friendly description of the scan decoration."/>
                    </function>
                </serves>
            </crown>
            <crown name="ColorMap">
                <trait>released</trait>
                <desc>Create a custom LINEAR color gradient in which colors are specified as entries in a vector with RGBA.</desc>
                <enum name="ColorMapType">
                    <item name="LINEAR" desc="Smooth linear transition between color stops">LINEAR</item>
                    <item name="DISCRETE" desc="Discrete color jumps at the color stops">DISCRETE</item>
                </enum>
                <enum name="PredefinedColorMap">
                    <item name="AUTUMN" desc="red -&gt; yellow">AUTUMN</item>
                    <item name="BLUE_WHITE_RED" desc="blue -&gt; white -&gt; red">BLUE_WHITE_RED</item>
                    <item name="COOL" desc="aqua -&gt; fuchsia">COOL</item>
                    <item name="GRAY" desc="black -&gt; white">GRAY</item>
                    <item name="HOT" desc="black -&gt; red -&gt; yellow -&gt; white">HOT</item>
                    <item name="HSV" desc="red -&gt; yellow -&gt; green -&gt; aqua -&gt; blue -&gt; fuchsia -&gt; red">HSV</item>
                    <item name="JET" desc="blue -&gt; aqua -&gt; green -&gt; yellow -&gt; red">JET</item>
                    <item name="RAINBOW" desc="red -&gt; fuchsia -&gt; blue -&gt; aqua -&gt; green -&gt; yellow -&gt; red">RAINBOW</item>
                    <item name="SPRING" desc="fuchsia -&gt; yellow">SPRING</item>
                    <item name="SUMMER" desc="deep sea -&gt; lemon">SUMMER</item>
                    <item name="THERMAL" desc="black -&gt; pink -&gt; orange -&gt; yellow -&gt; white">THERMAL</item>
                    <item name="TRAFFIC_LIGHT" desc="red -&gt; yellow -&gt; green">TRAFFIC_LIGHT</item>
                    <item name="WINTER" desc="blue -&gt; spring green">WINTER</item>
                    <item name="RGB" desc="red -&gt; green -&gt; blue">RGB</item>
                </enum>
                <serves>
                    <function name="create">
                        <desc>Create a new ColorMap.</desc>
                        <sample for="lua">handle = View.ColorMap.create()</sample>
                        <param name="rangeStart" type="float" multiplicity="?" desc="Define the start of the value range. Default is 0.0 (optional)."/>
                        <param name="rangeStop" type="float" multiplicity="?" desc="Define the stop of the value range. Default is 1.0 (optional)."/>
                        <return name="handle" type="handle" alias="View.ColorMap" desc="The new ColorMap"/>
                    </function>
                    <function name="addStop">
                        <desc>Adds a color stop (value, R, G, B, A) to the ColorMap. If the value for a stop is outside the defined range, the stop is discarded.</desc>
                        <sample for="lua">View.ColorMap.addStop(handle, 255, 0, 0)</sample>
                        <param name="handle" type="handle" alias="View.ColorMap" desc="The instance handle to use"/>
                        <param name="value" type="float" desc="Represents a position between 0 and 1 at which a color for the gradient is defined. If the value equals the value of an existing color stop, the existing color stop is replaced. "/>
                        <param name="red" type="int" desc="Red value in range (0, 255)."/>
                        <param name="green" type="int" desc="Green value in range (0, 255)."/>
                        <param name="blue" type="int" desc="Blue value in range (0, 255)."/>
                        <param name="alpha" type="int" multiplicity="?" desc="Alpha/opacity component in range [0-255] (optional)."/>
                    </function>
                    <function name="fromMap">
                        <desc>Create a gradient with predefined steps. The ColorMap will be cleared before.</desc>
                        <sample for="lua">View.ColorMap.fromMap(handle, "RAINBOW")</sample>
                        <param name="handle" type="handle" alias="View.ColorMap" desc="The instance handle to use"/>
                        <param name="predefinedMap" type="enum" multiplicity="?" ref="PredefinedColorMap" desc="Create a gradient with predefined steps."/>
                    </function>
                    <function name="setType">
                        <desc>A enum value indicating whether the ColorMap makes DISCRETE color jumps, or smooth LINEAR transition between color stops.</desc>
                        <sample for="lua">View.ColorMap.setType(handle, "DISCRETE")</sample>
                        <param name="handle" type="handle" alias="View.ColorMap" desc="The instance handle to use"/>
                        <param name="type" type="enum" ref="ColorMapType" desc="ColorMap type"/>
                    </function>
                    <function name="toImage">
                        <desc>Convert the ColorMap to an image which represents the ColorMap from left to right.</desc>
                        <sample for="lua">image = View.ColorMap.toImage(handle, 100, 200)</sample>
                        <param name="handle" type="handle" alias="View.ColorMap" desc="The instance handle to use"/>
                        <param name="width" type="int" desc="Width of the image."/>
                        <param name="height" type="int" desc="Height of the image."/>
                        <return name="image" type="object" multiplicity="?" alias="Image" desc="The color map as image object."/>
                    </function>
                    <function name="toString">
                        <desc>Get a user-friendly string description of the ColorMap.</desc>
                        <sample for="lua">str = View.ColorMap.toString(handle)</sample>
                        <param name="handle" type="const object" alias="View.ColorMap" desc="The ColorMap object."/>
                        <return name="str" type="string" desc="User-friendly description of the ColorMap."/>
                    </function>
                </serves>
            </crown>
        </crown>
        <crown name="Text">
            <trait>deprecated</trait>
            <desc>Iconic object used for displaying text in a View.
Deprecated, please use plain strings and a TextDecoration object instead.</desc>
            <serves>
                <function name="create">
                    <desc>Creates a new Text.</desc>
                    <sample for="lua">text = Text.create()</sample>
                    <return name="text" type="object" alias="Text" desc="A new text"/>
                </function>
                <function name="setText">
                    <desc>Set the textual content.</desc>
                    <sample for="lua">Text.setText(text, "This is a text.")</sample>
                    <param name="text" type="object" alias="Text" desc="The instance to be used."/>
                    <param name="textstring" type="string" desc="The text"/>
                </function>
                <function name="setSize">
                    <desc>Set the font size.</desc>
                    <sample for="lua">Text.setSize(text, 10)</sample>
                    <param name="text" type="object" alias="Text" desc="The instance to be used."/>
                    <param name="fonSize" type="int" desc="The font size."/>
                    <param name="lineSpacing" type="float" multiplicity="?" desc="The line spacing in % of the font-size. Default is 1.1"/>
                </function>
                <function name="setPosition">
                    <desc>Set the text position.</desc>
                    <sample for="lua">Text.setPosition(text, 10, 10)</sample>
                    <param name="text" type="object" alias="Text" desc="The instance to be used."/>
                    <param name="posX" type="int" desc="X"/>
                    <param name="posY" type="int" desc="Y"/>
                    <param name="posZ" type="int" multiplicity="?" desc="Z (only useful if 3D viewer is used)."/>
                </function>
            </serves>
        </crown>
        <crown name="Image">
            <trait>released</trait>
            <desc>Object for images, height maps, distance maps and similar data sampled on a regularly spaced grid. The samples are referred to as pixels whose values can be represented using different types such as unsigned integers (e.g., uint8, uint16), signed integers (e.g., int8, int16), floats (e.g., float32, float64) or RGB24 (3 times uint8 for the red, green and blue channels).
The locations of the regular grid points can be described in physical world units, typically in millimeters, using the so-called image world coordinate system. The image world coordinate system is left-handed and aligned with the image axes, with the x-axis pointing from left to right, and a y-axis pointing from top towards bottom, and the origin at the upper left pixel.
As the coordinate system is left-handed, positive rotations are specified clock-wise. The image coordinate system is specified as a world origin coordinate of the upper left pixel (pixel center) and a pixel size (e.g., in millimeters) in the x- and y-dimensions. The image world origin and pixel size are provided as meta data in the Image object. For regular gray scale/reflectance images captured by a 2D camera, the default world origin and pixel size are (0,0) and (1,1) respectively, so that the pixel index and image world coordinate system are the same.

For height map and depth maps for which pixel values represent ranges in the physical world, there is also a scale factor available from raw pixel value to a physical world unit (typically millimeter). For compact notation, this scaling factor is referred to as pixel size in the z-dimension, and there is also a corresponding world origin in the z-dimension. The Image object meta data also has a 'missing data' flag that indicates if the value 0 is a reserved number representing the absence of measurement rather than the actual numeric value 0. Algorithms will then try to ignore missing data pixels in calculations instead of using the actual value 0. The missing data flag is only supported for unsigned integer types (uint8, uint16, etc) and not for signed types (int16, float32, etc.)</desc>
            <enum name="ImageType">
                <item name="int8" desc="signed 8-bit integer">INT8</item>
                <item name="int16" desc="signed 16-bit integer">INT16</item>
                <item name="int32" desc="signed 32-bit integer">INT32</item>
                <item name="int64" desc="signed 64-bit integer">INT64</item>
                <item name="uint8" desc="unsigned 8-bit integer">UINT8</item>
                <item name="uint16" desc="unsigned 16-bit integer">UINT16</item>
                <item name="uint32" desc="unsigned 32-bit integer">UINT32</item>
                <item name="uint64" desc="unsigned 64-bit integer">UINT64</item>
                <item name="float32" desc="32-bit floating-point">FLOAT32</item>
                <item name="float64" desc="64-bit floating-point">FLOAT64</item>
                <item name="RGB24" desc="24-bit RGB color image (stored in BGR byte order)">RGB24</item>
            </enum>
            <enum name="DetectionMethod">
                <item name="Max" desc="Find the brightest pixel. No subpixel precision.">MAX</item>
                <item name="CoG" desc="Find the center of gravity around the brightest pixel. With subpixel precision.">COG</item>
                <item name="Hi3D" desc="Find the best fit around the brightest pixel. With subpixel precision.">HI3D</item>
            </enum>
            <enum name="InterpolationMethod" trait="released">
                <item name="nearest" desc="Resample using a nearest-neighbor interpolation">NEAREST</item>
                <item name="linear" desc="Resample using 2x2 bilinear interpolation">LINEAR</item>
            </enum>
            <enum name="OutputGrid" trait="released">
                <item name="SAME" desc="The output is painted on the same pixel grid as the input.">SAME</item>
                <item name="FULL" desc="The origin and size of the output image is adjusted to fit the entire output. The world pixel size of the input image is used.">FULL</item>
            </enum>
            <enum name="ColorSpace" trait="released">
                <item name="RGB" desc="RGB color space">COLORSPACE_RGB</item>
                <item name="HSV" desc="HSV color space">COLORSPACE_HSV</item>
                <item name="LAB" desc="LAB color space">COLORSPACE_LAB</item>
            </enum>
            <enum name="MetricType" trait="released">
                <item name="ABS" desc="Compute as L1 norm">ABS</item>
                <item name="MAGNITUDE" desc="Compute as L2 norm">MAGNITUDE</item>
            </enum>
            <enum name="BorderType" trait="released">
                <item name="CONSTANT" desc="Example: iiii abcdef iiii">CONSTANT</item>
                <item name="REPLICATE" desc="Example: aaaa abcdef ffff">REPLICATE</item>
                <item name="REFLECT" desc="Example: dcba abcdef fedc">REFLECT</item>
                <item name="WRAP" desc="Example: cdef abcdef abcd">WRAP</item>
            </enum>
            <enum name="MorphologicalTransform" trait="released">
                <item name="ERODE" desc="Morphological erosion.">ERODE</item>
                <item name="DILATE" desc="Morphological dilation.">DILATE</item>
                <item name="OPEN" desc="Morphological opening">OPEN</item>
                <item name="CLOSE" desc="Morphological closure">CLOSE</item>
                <item name="GRADIENT" desc="Morphological gradient">GRADIENT</item>
                <item name="TOPHAT" desc="Morphological tophat">TOPHAT</item>
                <item name="BLACKHAT" desc="Morphological blackhat">BLACKHAT</item>
            </enum>
            <enum name="ConcatenationDirection" trait="released">
                <item name="ABOVE" desc="Concatenate image2 above image1">ABOVE</item>
                <item name="BELOW" desc="Concatenate image2 below image1">BELOW</item>
                <item name="LEFT" desc="Concatenate image2 to the left of image1">LEFT</item>
                <item name="RIGHT" desc="Concatenate image2 to the right of image1">RIGHT</item>
            </enum>
            <enum name="MissingDataMethod" trait="released">
                <item name="MAX" desc="Setting missing data pixels to the maximum valid value in the neighborhood.">MAX</item>
                <item name="MIN" desc="Setting missing data pixels to the minimum valid value in the neighborhood.">MIN</item>
                <item name="MEAN" desc="Setting missing data pixels to the mean of all valid values in the neighborhood.">MEAN</item>
                <item name="MEDIAN" desc="Setting missing data pixels to the median of all valid values in the neighborhood.">MEDIAN</item>
                <item name="EDGE" desc="Removing missing data by interpolating neighbor pixels in an edge-preserving way.">EDGE</item>
            </enum>
            <enum name="ProcessingDimension" trait="released">
                <item name="ROW" desc="Do processing row-wise">ROW</item>
                <item name="COLUMN" desc="Do processing column-wise">COLUMN</item>
            </enum>
            <enum name="AggregateOperation" trait="released">
                <item name="MIN" desc="Calculate the minimum.">MIN</item>
                <item name="MAX" desc="Calculate the maximum.">MAX</item>
                <item name="MEAN" desc="Calculate the mean.">MEAN</item>
                <item name="SUM" desc="Calculate the sum.">SUM</item>
            </enum>
            <enum name="ExtremaType" trait="released">
                <item name="MAX" desc="Local maxima">MAX</item>
                <item name="MIN" desc="Local minima">MIN</item>
            </enum>
            <enum name="ContrastDifferenceMode" trait="released">
                <item name="one" desc="At least one point in the neighborhood should have the specified value margin to the extremal point.">ONE</item>
            </enum>
            <enum name="InpaintMethod" trait="released">
                <item name="NAVIER-STOKES" desc="Navier-Stokes equations based inpainting method.">NAVIER_STOKES</item>
                <item name="ALEXANDRU TELEA" desc="An Image Inpainting Technique Based on the Fast Marching Method.">ALEXANDRU_TELEA</item>
            </enum>
            <enum name="DifferenceMode" trait="released">
                <item name="ABS" desc="Absolute difference.">ABS</item>
                <item name="SQUARE" desc="Squared difference.">SQUARE</item>
            </enum>
            <enum name="GaussianFilterType" trait="released">
                <item name="SIZE_SELECT" desc="Choose implementation depending on filter size, default.">SIZE_SELECT</item>
                <item name="TRUNCATED" desc="Use convolution with a truncated kernel, this is faster for small filter sizes.">TRUNCATED</item>
                <item name="RECURSIVE" desc="Use a recursive filter to approximate the kernel. The run-time is independent of filter size and is recommended for large filter sizes.">RECURSIVE</item>
            </enum>
            <serves>
                <function name="create">
                    <desc>Creates a new image of a certain size and pixel type.</desc>
                    <sample for="lua">local image = Image.create(800,600,"UINT8")</sample>
                    <param name="width" type="int" desc="The image width in pixels."/>
                    <param name="height" type="int" desc="The image height in pixels."/>
                    <param name="type" type="enum" ref="ImageType" desc="The pixel type, for example UINT8, INT16, FLOAT64."/>
                    <return name="image" type="object" multiplicity="?" alias="Image" desc="The new image object."/>
                </function>
                <function name="createLinePitch">
                    <trait>hidden</trait>
                    <desc>Creates a new image of a certain size and pixel type, with the underlying line pitch parameter also available to set. This function is for testing purposes only.</desc>
                    <sample for="lua">local image = Image.createLinePitch(800,600,"UINT8", 850)</sample>
                    <param name="width" type="int" desc="The image width in pixels."/>
                    <param name="height" type="int" desc="The image height in pixels."/>
                    <param name="type" type="enum" ref="ImageType" desc="The pixel type, for example UINT8, INT16, FLOAT64."/>
                    <param name="linePitch" type="int" desc="The line pitch parameter. Must be equal or larger than the image width."/>
                    <return name="image" type="object" multiplicity="?" alias="Image" desc="The new image object."/>
                </function>
                <function name="createFromMemory">
                    <desc>Creates a new image of a certain size and pixel type by copying the data of a binary buffer.</desc>
                    <sample for="lua">local image = Image.createFromMemory(buffer,800,600,"UINT8")</sample>
                    <param name="buffer" type="binary" desc="The buffer containing the raw image data."/>
                    <param name="width" type="int" desc="The image width in pixels."/>
                    <param name="height" type="int" desc="The image height in pixels."/>
                    <param name="type" type="enum" ref="ImageType" desc="The pixel type, for example UINT8, INT16, FLOAT64."/>
                    <return name="image" type="object" multiplicity="?" alias="Image" desc="The new image object."/>
                </function>
                <function name="clone">
                    <desc>Returns a duplicated instance of the input image. New memory to copy all pixel data is allocated.</desc>
                    <sample for="lua">local imageClone = Image.clone(image)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image to clone."/>
                    <return name="clone" type="object" alias="Image" desc="The new cloned image object."/>
                </function>
                <function name="getSize">
                    <links>Image.getHeight, Image.getWidth</links>
                    <desc>Returns the width and height of an image.</desc>
                    <sample for="lua">local width, height = Image.getSize(image)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image to get the size of."/>
                    <return name="width" type="int" desc="Width of the image in pixels."/>
                    <return name="height" type="int" desc="Height of the image in pixels."/>
                </function>
                <function name="getWidth">
                    <links>Image.getHeight, Image.getSize</links>
                    <desc>Returns the width of an image.</desc>
                    <sample for="lua">local width = Image.getWidth(image)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image to get the width of."/>
                    <return name="width" type="int" desc="Width of the image in pixels."/>
                </function>
                <function name="getHeight">
                    <links>Image.getWidth, Image.getSize, Image.getWorldZ</links>
                    <desc>Returns the height of an image.</desc>
                    <sample for="lua">local height = Image.getHeight(image)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image to get the height of."/>
                    <return name="height" type="int" desc="Height of the image in pixels."/>
                </function>
                <function name="getPixel">
                    <links>Image.getWorldZ, Image.setPixel</links>
                    <desc>Returns the raw pixel value of an image at position (x,y) in pixel coordinates.
For monochrome image types this is a single float value, for RGB24 a vector of three float values in the order red, green, blue.</desc>
                    <sample for="lua">local value = Image.getPixel(image, 5, 6)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image to get the pixel from."/>
                    <param name="x" type="int" desc="The x pixel coordinate."/>
                    <param name="y" type="int" desc="The y pixel coordinate."/>
                    <return name="value" type="float" multiplicity="[?*]" desc="The raw pixel value, or a vector of RGB values, or nil for invalid coordinates."/>
                </function>
                <function name="setPixel">
                    <links>Image.getPixel, Image.setAll</links>
                    <desc>Set the raw pixel value or a vector of pixel values in an image at position(s) (x,y) to the given raw pixel value.
For monochrome image types this is a single float value, for RGB24 a vector of three float values in the order red, green, blue.</desc>
                    <sample for="lua">Image.setPixel(image, 5, 6, 127)
Image.setPixel(imageRGB, {5, 5}, {6, 7}, {0, 127, 255})</sample>
                    <param name="image" type="object" alias="Image" desc="The image to set the pixels to"/>
                    <param name="x" type="int" multiplicity="[1+]" desc="The x coordinate, or a vector of x coordinates, of the pixel(s) to set."/>
                    <param name="y" type="int" multiplicity="[1+]" desc="The y coordinate, or a vector of y coordinates, of the pixel(s) to set."/>
                    <param name="value" type="float" multiplicity="[1+]" desc="The raw pixel value, or a vector of RGB values, to set."/>
                </function>
                <function name="getType">
                    <desc>Returns the pixel type of the image.</desc>
                    <sample for="lua">local pixelType = Image.getType(image)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image."/>
                    <return name="pixelType" type="enum" ref="ImageType" desc="The pixel type (e.g.: uint8, int16, float64)."/>
                </function>
                <function name="load">
                    <links>Object.load, File</links>
                    <desc>Loads an image from the specified file path.
The format is defined by the file extension:
.bmp: Bitmap
.png: PNG
.jpg: JPEG (not supported by all devices)
.json:    JSON
.msgpack: MessagePack</desc>
                    <sample for="lua">local image = Image.load("resources/image.bmp")</sample>
                    <param name="filepath" type="string" desc="The path and name of the file to load the image from."/>
                    <return name="image" type="object" multiplicity="?" alias="Image" desc="The Image object which is loaded."/>
                </function>
                <function name="save">
                    <links>Object.save, File</links>
                    <desc>Saves an image to the specified file path.
Overwrites the file if it already exists.
Supported pixel types are: UINT8, UINT16, INT8, INT16, INT32, FLOAT32 and FLOAT64.
The format is defined by the file extension:
.bmp:     Bitmap, no data compression. (Optional compression parameter not supported). Image origin, pixel size and missing data flag are not saved.
.png:     PNG, lossless data compression. (Compression level can be controlled by compression parameter. Allowed values are "0" to "9". Default is "6".) Image origin, pixel size and missing data flag are not saved. For pixel types INT8, INT16, INT32, FLOAT32 and FLOAT64 the values are clamped to 0-255.
.jpg:     JPEG, lossy data compression. Not supported on all devices. (Quality can be controlled by compression parameter. Allowed values are "0" to "100". Default is "95") Image origin, pixel size and missing data flag are not saved.
.json:    JSON, no compression. (Optional compression parameter not supported). Image origin, pixel size and missing data flag are saved.
.msgpack: MessagePack, no compression. (Optional compression parameter not supported). Image origin, pixel size and missing data flag are saved.</desc>
                    <sample for="lua">Image.save(image, "private/image.bmp")</sample>
                    <param name="image" type="const object" alias="Image" desc="The image to save."/>
                    <param name="filepath" type="string" desc="The path and name of the file to write the image to."/>
                    <param name="compression" type="string" multiplicity="?" desc="Optional parameters controlling compression ratio for certain file formats."/>
                    <return name="success" type="bool" desc="Returns true on success."/>
                </function>
                <function name="toBitmapBuffer">
                    <trait>hidden</trait>
                    <desc>Converts the given image to a BMP binary buffer.
Deprecated, please use Image.Format.BMP.encode instead.</desc>
                    <sample for="lua">local bitmapBuffer = Image.toBitmapBuffer(image)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image to convert."/>
                    <return name="buffer" type="binary" desc="Bitmap binary data of the given image."/>
                </function>
                <function name="toPngBuffer">
                    <trait>hidden</trait>
                    <desc>Converts the given image to a PNG binary buffer.
Deprecated, please use Image.Format.PNG.encode instead.</desc>
                    <sample for="lua">local pngBuffer = Image.toPngBuffer(image)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image to convert."/>
                    <return name="buffer" type="binary" desc="PNG binary data of the given image."/>
                </function>
                <function name="toString">
                    <desc>Gets a user-friendly string description of the image, containing all properties but no actual pixel values.</desc>
                    <sample for="lua">str = Image.toString(image)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image to describe."/>
                    <return name="str" type="string" desc="User-friendly description of the image."/>
                </function>
                <function name="crop">
                    <links>Image.cropRegion, Image.mosaic</links>
                    <desc>Crops a subpart of an image, specified in pixel coordinates. A cropped image is a clone of the source data.</desc>
                    <sample for="lua">local imageCropped = Image.crop(fullImage, 10, 10, 100, 100)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image to crop."/>
                    <param name="x" type="int" desc="The x position of the top-left corner of the cropped image in the source image."/>
                    <param name="y" type="int" desc="The y position of the top-left corner of the cropped image in the source image."/>
                    <param name="width" type="int" desc="The width of the cropped image."/>
                    <param name="height" type="int" desc="The height of the cropped image."/>
                    <return name="imageCropped" type="object" multiplicity="?" alias="Image" desc="Cropped image or nil on error."/>
                </function>
                <function name="cropWorld">
                    <trait>hidden</trait>
                    <desc>Crops an image in world coordinates. A cropped image is a clone of a part of the source data.</desc>
                    <sample for="lua">local imageCropped = Image.cropWorld(fullImage, 1.5, 1.5, 12.5, 12.5)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image."/>
                    <param name="xWorld" type="float" desc="The x position of the top-left corner of the cropped image in the source image, in world coordinates."/>
                    <param name="yWorld" type="float" desc="The y position of the top-left corner of the cropped image in the source image, in world coordinates."/>
                    <param name="widthWorld" type="float" desc="The width of the cropped image, in world coordinates."/>
                    <param name="heightWorld" type="float" desc="The height of the cropped image, in world coordinates."/>
                    <return name="imageCropped" type="object" multiplicity="?" alias="Image" desc="Cropped image or nil on error."/>
                </function>
                <function name="mosaic">
                    <desc>Crops an image into a vector of smaller tiles. The mosaic tiles can be specified to overlap. A valid tile must be completely within the source image, i.e., tiles that would partly extend outside the image at the right and bottom borders of the source image are not included in the output vector. The vector of tiles is sorted row wise so that all the tiles covering the uppermost part of the image come first.</desc>
                    <sample for="lua">local imageTiles, nx, ny = Image.mosaic(im, 32, 32)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image."/>
                    <param name="tileWidth" type="int" desc="The width of a tile in pixels."/>
                    <param name="tileHeight" type="int" desc="The height of a tile in pixels."/>
                    <param name="xOverlap" type="int" multiplicity="?" desc="Optional overlap between tiles in the x-direction in pixels. Default is no overlap, i.e., 0 pixels."/>
                    <param name="yOverlap" type="int" multiplicity="?" desc="Optional overlap between tiles in the y-direction in pixels. Default is no overlap, i.e., 0 pixels."/>
                    <return name="imageTiles" type="object" multiplicity="+" alias="Image" desc="Vector of image tiles."/>
                    <return name="xTileCount" type="int" desc="Number of tiles in the x-direction."/>
                    <return name="yTileCount" type="int" desc="Number if tiles in the y-direction."/>
                </function>
                <function name="setAll">
                    <links>Image.setPixel</links>
                    <desc>Sets all raw pixel values in an image to the specified value. Currently only supports scalar pixel types, i.e., not RGB. Pixels with missing data are also set. Setting all pixels to zero on an image with the global missing data flag set, all pixels will be marked as missing.</desc>
                    <sample for="lua">Image.setAll(image, 0.0)</sample>
                    <param name="image" type="object" alias="Image" desc="The image."/>
                    <param name="value" type="float" desc="The raw pixel value to set."/>
                </function>
                <function name="isWithinBounds">
                    <desc>Checks whether a pixel coordinate is within the bounds of the image.</desc>
                    <sample for="lua">local isInBounds = Image.isWithinBounds(image, 15, 15)</sample>
                    <param name="image" type="const object" alias="Image" desc=""/>
                    <param name="x" type="int" desc="The x pixel coordinate of the point to be checked."/>
                    <param name="y" type="int" desc="The y pixel coordinate of the point to be checked."/>
                    <return name="isInBounds" type="bool" desc="Returns true if the point is within the image, false otherwise."/>
                </function>
                <function name="isWithinBoundsWorld">
                    <trait>hidden</trait>
                    <desc>Checks whether a world coordinate is within the bounds of the image.</desc>
                    <sample for="lua">local isInBounds = Image.isWithinBoundsWorld(image, 1.5, 1.5)</sample>
                    <param name="image" type="const object" alias="Image" desc=""/>
                    <param name="xWorld" type="float" desc="The x coordinate of the point to be checked, in world coordinates."/>
                    <param name="yWorld" type="float" desc="The y coordinate of the point to be checked, in world coordinates."/>
                    <return name="isInBounds" type="bool" desc="Returns true if the point is within the image, false otherwise."/>
                </function>
                <function name="getOrigin">
                    <links>Image.setOrigin, Image.getOriginZ</links>
                    <desc>Retrieves the origin of the image world coordinate in the image. The origin corresponds to the world coordinate of the top-left image pixel.</desc>
                    <sample for="lua">local origin = Image.getOrigin(image)</sample>
                    <param name="image" type="const object" alias="Image" desc=""/>
                    <return name="origin" type="object" alias="Point" desc="Returns the origin as a point in 3D."/>
                </function>
                <function name="getOriginZ">
                    <links>Image.setOriginZ, Image.getOrigin</links>
                    <desc>Retrieves the z-origin of the image world coordinate in the image.</desc>
                    <sample for="lua">local originZ = Image.getOriginZ(image)</sample>
                    <param name="image" type="const object" alias="Image" desc=""/>
                    <return name="originZ" type="float" desc="The z-origin of the image."/>
                </function>
                <function name="setOrigin">
                    <links>Image.getOrigin, Image.setOriginZ</links>
                    <desc>Sets the origin of the image world coordinate system in the image. The origin corresponds to the image world coordinate of the top-left pixel. If a 2D point is provided, the origin is unchanged in the z-direction.</desc>
                    <sample for="lua">local success = Image.setOrigin(image, origin)</sample>
                    <param name="image" type="object" alias="Image" desc=""/>
                    <param name="origin" type="const object" alias="Point" desc="A 3D point describing the world coordinate of the top-left image pixel."/>
                    <return name="success" type="bool" desc="Returns true if successfully set the origin."/>
                </function>
                <function name="setOriginZ">
                    <links>Image.getOriginZ, Image.setOrigin, Image.adjustOriginZ</links>
                    <desc>Sets the z-origin of the image world coordinate system in the image.</desc>
                    <sample for="lua">Image.setOriginZ(image, originZ)</sample>
                    <param name="image" type="object" alias="Image" desc="Image object to update."/>
                    <param name="originZ" type="float" desc="The new z-origin."/>
                </function>
                <function name="getPixelSize">
                    <links>Image.setPixelSize, Image.getPixelSizeZ, Image.getMissingDataFlag</links>
                    <desc>Retrieves the pixel size of the image world coordinate system.</desc>
                    <sample for="lua">local sizeX, sizeY, sizeZ = Image.getPixelSize(image)</sample>
                    <param name="image" type="const object" alias="Image" desc=""/>
                    <return name="sizeX" type="float" desc="Returns the size of a pixel in the X dimension in world coordinate units."/>
                    <return name="sizeY" type="float" desc="Returns the size of a pixel in the Y dimension in world coordinate units."/>
                    <return name="sizeZ" type="float" desc="Returns the size of a pixel in the Z dimension in world coordinate units."/>
                </function>
                <function name="getPixelSizeZ">
                    <links>Image.setPixelSizeZ, Image.getPixelSize, Image.getMissingDataFlag</links>
                    <desc>Retrieves the pixel size in the z-dimension of the image world coordinate system.</desc>
                    <sample for="lua">local sizeZ = Image.getPixelSizeZ(image)</sample>
                    <param name="image" type="const object" alias="Image" desc=""/>
                    <return name="sizeZ" type="float" desc="Returns the size of a pixel in the Z dimension in world coordinate units."/>
                </function>
                <function name="setPixelSize">
                    <links>Image.getPixelSize, Image.setPixelSizeZ</links>
                    <desc>Sets the pixel size in world coordinates. If the size in the Z direction is omitted, the Z size is unchanged.</desc>
                    <sample for="lua">Image.setPixelSize(image, sizeX, sizeY, sizeZ)</sample>
                    <param name="image" type="object" alias="Image" desc=""/>
                    <param name="sizeX" type="float" desc="The size of a pixel in the X dimension in world coordinate units."/>
                    <param name="sizeY" type="float" desc="The size of a pixel in the Y dimension in world coordinate units."/>
                    <param name="sizeZ" type="float" multiplicity="?" desc="The size of a pixel in the Z dimension in world coordinate units (optional)."/>
                </function>
                <function name="setPixelSizeZ">
                    <links>Image.getPixelSizeZ, Image.setPixelSize</links>
                    <desc>Sets the pixel size in the z-dimension in world coordinates, e.g., the number of millimeters each pixel value integer increment corresponds to.</desc>
                    <sample for="lua">Image.setPixelSizeZ(image, sizeZ)</sample>
                    <param name="image" type="object" alias="Image" desc=""/>
                    <param name="sizeZ" type="float" desc="The size/scale along the z-dimension."/>
                </function>
                <function name="getMissingDataFlag">
                    <links>Image.setMissingDataFlag</links>
                    <desc>Gets the missing data setting in the image. 0 means no missing data handling, 1 means that the value 0 is treated as missing data.</desc>
                    <sample for="lua">local missingDataFlag = Image.getMissingDataFlag(image)</sample>
                    <param name="image" type="const object" alias="Image" desc=""/>
                    <return name="missingDataFlag" type="int" desc="Returns the missing data setting."/>
                </function>
                <function name="setMissingDataFlag">
                    <links>Image.getMissingDataFlag</links>
                    <desc>Sets the missing data setting in the image. 0 means no missing data handling, 1 means that the value 0 is treated as missing data.</desc>
                    <sample for="lua">Image.setMissingDataFlag(image, 1)</sample>
                    <param name="image" type="object" alias="Image" desc=""/>
                    <param name="missingDataFlag" type="int" desc="0 means no missing data handling, 1 means that the value 0 is treated as missing data."/>
                </function>
                <function name="toPixelCoordinate">
                    <links>Image.toWorldCoordinate, Image.toPixelZ</links>
                    <desc>Converts an image world coordinate to a pixel coordinate.</desc>
                    <sample for="lua">local pixelCoordinate = Image.toPixelCoordinate(image, worldCoordinate)</sample>
                    <param name="image" type="const object" alias="Image" desc=""/>
                    <param name="worldCoordinate" type="const object" alias="Point" desc="The world coordinate point."/>
                    <return name="pixelCoordinate" type="object" alias="Point" desc="Returns the pixel coordinate."/>
                </function>
                <function name="toWorldCoordinate">
                    <links>Image.toPixelCoordinate, Image.toWorldZ</links>
                    <desc>Converts a pixel coordinate to an image world coordinate.</desc>
                    <sample for="lua">local worldCoordinate = Image.toWorldCoordinate(image, pixelCoordinate)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image"/>
                    <param name="pixelCoordinate" type="const object" multiplicity="[1+]" alias="Point" desc="The pixel coordinate point."/>
                    <return name="worldCoordinate" type="object" multiplicity="[1+]" alias="Point" desc="Returns the world coordinate."/>
                </function>
                <function name="toWorldZ">
                    <links>Image.toPixelCoordinate, Image.toPixelZ, Image.getWorldZ</links>
                    <desc>Converts a pixel raw value to a z world coordinate value using the image world coordinate system supplied by the input reference image. The mapping worldZCoordinate = pixelValue*pixelSizeZ + originZ is made.</desc>
                    <sample for="lua">local worldZCoordinate = Image.toWorldZ(image, pixelValue)</sample>
                    <param name="image" type="const object" alias="Image" desc="Image carrying the image world coordinate system. No other information from the image is used."/>
                    <param name="pixelValue" type="float" multiplicity="[1+]" desc="Raw pixel value(s)."/>
                    <return name="worldZCoordinate" type="float" multiplicity="[1+]" desc="World z coordinate(s), e.g., millimeters."/>
                </function>
                <function name="toPixelZ">
                    <links>Image.toPixelCoordinate, Image.toWorldZ</links>
                    <desc>Converts a z world coordinate value to a raw pixel value using the image world coordinate system supplied by the input reference image. The mapping pixelValue = (worldZCoordinate - originZ)/pixelSizeZ is made.</desc>
                    <sample for="lua">local pixelValue = Image.toPixelZ(image, worldZCoordinate)</sample>
                    <param name="refImage" type="const object" alias="Image" desc="Image carrying the image world coordinate system. No other information from the image is used."/>
                    <param name="worldZCoordinate" type="float" multiplicity="[1+]" desc="World z coordinate(s), e.g., millimeters."/>
                    <return name="pixelValue" type="float" multiplicity="[1+]" desc="Raw pixel value(s)."/>
                </function>
                <function name="toThumbnail">
                    <trait>hidden</trait>
                    <desc>Creates a thumbnail of the image.</desc>
                    <sample for="lua">local thumbnail = Image.toThumbnail(inputImage, edgeSize)</sample>
                    <param name="inputImage" type="const object" alias="Image" desc="The input image."/>
                    <param name="maxEdgeSize" type="int" desc="Size of the largest edge of the thumbnail."/>
                    <return name="thumbnailImage" type="object" alias="Image" desc="The thumbnail image."/>
                </function>
                <function name="toMatrix">
                    <desc>Creates a matrix from a monochrome image.
Each entry in the matrix corresponds to the pixel value scaled by the image world Z coordinates.
Missing data is set to NaN in the matrix.</desc>
                    <sample for="lua">local matrix = Image.toMatrix(inputImage)</sample>
                    <param name="inputImage" type="const object" alias="Image" desc="The input image."/>
                    <return name="matrix" type="object" multiplicity="?" alias="Matrix" desc="The matrix with the image content."/>
                </function>
                <function name="toVector">
                    <links>Image.splitRGB, Image.toPixelZ, Image.toMatrix</links>
                    <desc>Creates a vector from a monochrome image. If the vectors of each channel of a color image are needed please first split the channels using Image.splitRGB.
Each entry in the vector corresponds to the raw pixel value.
Missing data is set to 0.
Please note, this function should be used with care for large images, because it can exhaust the memory of the device.</desc>
                    <sample for="lua">local vector = Image.toVector(inputImage)</sample>
                    <param name="inputImage" type="const object" alias="Image" desc="The input image."/>
                    <return name="vector" type="float" multiplicity="*" desc="The vector with the raw image content."/>
                </function>
                <function name="findColumnMax">
                    <trait>released</trait>
                    <keywords>peak, laser, triangulation</keywords>
                    <links>Image.SheetOfLight</links>
                    <desc>Extract the position of the brightest values in each column of an image. The methods employed does not only find one bright pixel but uses the neighborhood of each pixel to find a robust subpixel positions of the peak.
In reality the line is typically created by a laser projector and this function is used for laser triangulation, although it may be used in other ways.
Detection can be improved by providing an axis aligned rectangle shape for the region to search in. This both helps with performance and noise suppression as points outside of the region will be omitted from consideration.
The intensity threshold determines how bright a column has to be to give a value in the output profile. Setting the intensity threshold too high removes detections completely.
The certainty threshold determines what certainty is required for the valid flag of the profile to be true. Setting the certainty threshold high will still give detections, but will mark the concerned entries as invalid.

Image world coordinate system handling:
The x-axis origin and pixel size are not used. Each column will generate one coordinate in the output profile.
The y-axis origin and pixel size are used to decide the final values of the profile.
The z-axis origin and pixel size are not used. The max is found in raw coordinates.

Missing data handling:
Missing data is not supported.</desc>
                    <sample for="lua">local profile, certainty = Image.findColumnMax(image)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image in which to do the detection. Must be of type UINT8."/>
                    <param name="region" type="const object" multiplicity="?" alias="Shape" desc="Axis aligned rectangle to look in during detection."/>
                    <param name="method" type="enum" multiplicity="?" ref="DetectionMethod" desc="Select the method to use. Defaults to HI3D if unset."/>
                    <param name="intensityThreshold" type="float" multiplicity="?" desc="Select a intensity threshold for a point to be detected. Defaults to 0 if unset. Normal values are between 0 and 50, but depends on light conditions."/>
                    <param name="certaintyThreshold" type="float" multiplicity="?" desc="Select a certainty threshold for discarding points after detection. Defaults to 0 is unset. Normal values are between 0 and 50."/>
                    <return name="profile" type="object" multiplicity="?" alias="Profile" desc="The detected max per column as a profile. Nil on failure."/>
                    <return name="certainty" type="object" multiplicity="?" alias="Profile" desc="An estimate of the line certainty per point. Can in some cases be used as an approximation of object intensity. For a typical UINT8 the values are normally in the range between 0 and 255, but are not strictly upper bounded."/>
                </function>
                <function name="findLineSegments">
                    <trait>released</trait>
                    <keywords>hough, edge</keywords>
                    <links>Image.houghTransformLine</links>
                    <desc>Finds line segments in an image. Returns a list of 2D line segments represented as a Shape type. An empty list is returned when no line segments were found during an otherwise successful call. This function is currently limited to uint8 pixel type images.

Image world coordinate system handling:
The output Shape line segments are expressed using the image world coordinate system in the xy-dimensions. The z-dimension is not used in this function.

Missing data handling:
This function does not support images with missing data. Fill in missing data before hand, using e.g., missingDataSetAll.</desc>
                    <sample for="lua">lineSegments = Image.findLineSegments(image)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image. Support currently limited to uint8 pixel type."/>
                    <param name="scale" type="float" multiplicity="?" desc="The scale of the image that will be used to find the lines. Accepted values are strictly larger than zero and smaller or equal to one. Optional, default is 0.8."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. If supplied, the filter operation is only performed within the bounding box of its region. This can save a lot of computation time, if the region is small."/>
                    <param name="mergeLines" type="bool" multiplicity="?" desc="Optional flag to merge line segments that are on the same line. Defaults to false."/>
                    <return name="lineSegments" type="object" multiplicity="*" alias="Shape" desc="The detected line segments in image world coordinates, or nil on failure."/>
                </function>
                <function name="readPngHeightMap">
                    <trait>hidden</trait>
                    <desc>Read the Trispector png height format. TODO: Only intended for developers! Will be removed or reworked.</desc>
                    <sample for="lua">heightImage, intensityImage = Image.readPngHeightMap(path)</sample>
                    <param name="path" type="string" desc="Path to input file."/>
                    <return name="heightImage" type="object" multiplicity="?" alias="Image" desc="Height map"/>
                    <return name="intensityImage" type="object" multiplicity="?" alias="Image" desc="Intensity image"/>
                </function>
                <function name="writePngHeightMap">
                    <trait>hidden</trait>
                    <desc>Write heightmap and intensity image in the Trispector png height format. TODO: Only intended for developers! Will be removed or reworked.</desc>
                    <sample for="lua">local success = Image.writePngHeightMap(heightImage, intensityImage, path)</sample>
                    <param name="path" type="string" desc="Path to input file."/>
                    <param name="heightImage" type="const object" alias="Image" desc="Height map"/>
                    <param name="intensityImage" type="const object" multiplicity="?" alias="Image" desc="Optional intensity image"/>
                    <return name="success" type="bool" desc="True if image could be successfully written."/>
                </function>
                <function name="readIvcHeightMap">
                    <trait>hidden</trait>
                    <desc>Read the IVC raw height map format. TODO: Only intended for developers! Will be removed or reworked.</desc>
                    <sample for="lua">heightImage = Image.readIvcHeightMap(path)</sample>
                    <param name="path" type="string" desc="Path to input file."/>
                    <return name="heightImage" type="object" multiplicity="?" alias="Image" desc="Height map"/>
                </function>
                <function name="readIconData">
                    <trait>hidden</trait>
                    <desc>Read icon buffers. TODO: Only intended for developers! Will be removed or reworked.</desc>
                    <sample for="lua">container = Image.readIconData(path)</sample>
                    <param name="path" type="string" desc="Path to input file."/>
                    <return name="container" type="object" multiplicity="?" alias="Container" desc="Data"/>
                </function>
                <function name="threshold">
                    <trait>released</trait>
                    <keywords>segmentation, background, foreground, blob, region</keywords>
                    <links>Image.binarize, Image.thresholdCompare, Image.binarizeCompare, Image.binarizeAdaptive, Image.thresholdPlane, Image.binarizePlane, Image.BackgroundModel</links>
                    <desc>Threshold the image by keeping all pixels with a value between lowerThreshold and upperThreshold (inclusive). Return the result as a PixelRegion object.

Image world coordinate system handling:
The input thresholds are interpreted in the image world coordinate system considering the z-origin and z-pixelsize, e.g., in millimeter scale if the image would represent a range image with z-origin different from 0 of a z-pixelsize different from 1. A conversion is done within the function to raw pixel value thresholds.

Missing data handling:
Missing data pixels are excluded from the output PixelRegion object.</desc>
                    <sample for="lua">region = Image.threshold(image, 1, 255) -- Gets a region containing all non-zero values of an uint8 image</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image."/>
                    <param name="lowerThreshold" type="float" desc="Lower threshold. Expressed in image world coordinates if applicable."/>
                    <param name="upperThreshold" type="float" multiplicity="?" desc="Upper threshold. Optional, default is no upper threshold (only include pixels larger than the lower threshold)"/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. If supplied, the threshold operation is only performed within this region. This can save a lot of computation time, if the region is small."/>
                    <return name="region" type="object" multiplicity="?" alias="Image.PixelRegion" desc="Pixel region containing all pixels with value between the thresholds."/>
                </function>
                <function name="thresholdCompare">
                    <trait>released</trait>
                    <keywords>binarize, adaptive, segmentation, background, foreground, blob, region</keywords>
                    <links>Image.threshold, Image.binarizeCompare, Image.binarize, Image.binarizeAdaptive, Image.thresholdPlane, Image.binarizePlane, Image.BackgroundModel</links>
                    <desc>Threshold an image by pixelwise comparison with a reference image. All pixels with a value greater than or equal to the corresponding reference image value are included in the output PixelRegion object. An optional margin (positive or negative) may be provided, adjusting the reference image values prior to the comparison. A larger positive margin results in fewer included pixels. The optional flag findBright may be set to false, returning the region where the image is lower/darker than the reference image. A region of interest can be provided, limiting the processing to that region. The images must be of the same pixel type and be of equal size. This function gives a PixelRegion objects as output, to get a binary image as output use binarizeCompare instead.

Image world coordinate system handling:
To allow for an efficient comparison, the z-pixelsizes of the input images must be equal but the z-offsets may differ. The margin parameter is interpreted in image world coordinates, e.g., as a millimeter margin if the input is a range image.

Missing data handling:
Missing data pixels are excluded from the output PixelRegion object.</desc>
                    <sample for="lua">region = Image.thresholdCompare(image, referenceImage, marginWorld, findBright, regionOfInterest)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image to threshold."/>
                    <param name="referenceImage" type="const object" alias="Image" desc="Reference image to compare the input image with."/>
                    <param name="marginWorld" type="float" multiplicity="?" desc="Optional margin added to the reference image. Default value is 0."/>
                    <param name="findBright" type="bool" multiplicity="?" desc="Optional flag indicating if pixels brighter/higher or darker/lower than the reference image should be included. Default is true, returning brighter pixels."/>
                    <param name="regionOfInterest" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. If supplied, the threshold operation is only performed within this region. This can save a lot of computation time, if the region is small. The default region is the entire image."/>
                    <return name="region" type="object" multiplicity="?" alias="Image.PixelRegion" desc="PixelRegion object containing all pixels passing the comparison operation."/>
                </function>
                <function name="binarizeCompare">
                    <trait>released</trait>
                    <keywords>segmentation, background, foreground, adaptive</keywords>
                    <links>Image.threshold, Image.thresholdCompare, Image.binarize, Image.binarizeAdaptive, Image.thresholdPlane, Image.binarizePlane</links>
                    <desc>Binarizes an image by pixelwise comparison with a reference image. All pixels with a value greater than or equal to the corresponding reference image value are included in the binary output image. An optional margin (positive or negative) may be provided, adjusting the reference image values prior to the comparison. A larger positive margin results in fewer included pixels. The optional flag findBright may be set to false, returning the region where the image is lower/darker than the reference image. A region of interest can be provided, limiting the processing to that region. The images must be of the same pixel type and be of equal size. This function gives an Image object as output, to get a PixelRegion output use thresholdCompare instead.

Image world coordinate system handling:
To allow for an efficient comparison, the z-pixelsizes of the input images must be equal but the z-offsets may differ. The margin parameter is interpreted in image world coordinates, e.g., as a millimeter margin if the input is a range image. The output image inherits x,y-origin and x,y-pixelsizes but the z-origin is set to 0 and z-pixelsize to 1.

Missing data handling:
Missing data pixels are excluded from the output.</desc>
                    <sample for="lua">maskImage = Image.binarizeCompare(image, referenceImage, marginWorld, findBright, outputValue, regionOfInterest)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image to binarize."/>
                    <param name="referenceImage" type="const object" alias="Image" desc="Reference image to compare the input image with."/>
                    <param name="marginWorld" type="float" multiplicity="?" desc="Optional offset of the reference image. Default value is 0."/>
                    <param name="findBright" type="bool" multiplicity="?" desc="Optional flag indicating if pixels brighter/higher or darker/lower than the reference image should be included. Default is true, returning brighter pixels."/>
                    <param name="outputValue" type="float" multiplicity="?" desc="Optional value for  pixels in the output image mask, default 255."/>
                    <param name="regionOfInterest" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. If supplied, the threshold operation is only performed within this region. This can save a lot of computation time, if the region is small. The default region is the entire image."/>
                    <return name="maskImage" type="object" multiplicity="?" alias="Image" desc="Image containing all pixels passing the comparison operation."/>
                </function>
                <function name="extractSuperPixels">
                    <trait>hidden</trait>
                    <desc>Segments an image into superpixels</desc>
                    <sample for="lua">superPixels = Image.SuperPixel.extractSuperPixels(image, spacing, numIterations)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image"/>
                    <param name="spacing" type="float" desc="Average spacing between superpixels"/>
                    <param name="numIterations" type="int" desc="Number of SLIC iterations"/>
                    <return name="superPixels" type="object" multiplicity="+" alias="Image.PixelRegion" desc="Superpixels"/>
                </function>
                <function name="toLabelImage">
                    <trait>hidden</trait>
                    <desc>Converts superpixels to an image</desc>
                    <sample for="lua">superPixelImage = Image.SuperPixel.toLabelImage(superPixels, referenceImage)</sample>
                    <param name="superPixels" type="const object" multiplicity="+" alias="Image.PixelRegion" desc="Superpixels"/>
                    <param name="referenceImage" type="const object" alias="Image" desc="Original image used as reference"/>
                    <return name="superPixelImage" type="object" alias="Image" desc="Converted image visualizing the superpixels"/>
                </function>
                <function name="getHistogram">
                    <trait>released</trait>
                    <links>Image.PixelRegion.getHistogram, Profile.getHistogram</links>
                    <desc>Get a histogram of the image values. If the image supports missing data, pixels marked as missing are not included in the histogram. The histogram is computed using world coordinates (z-axis offset and scaling have influence). If the bounds are skipped, the entire image value range is used for 8-channel images, and the range between the current minimum and maximum value is used for other image types. Pixels with values outside the interval are not counted. See also Image.PixelRegion.getHistogram.</desc>
                    <sample for="lua">histogram, centers = Image.getHistogram(image, 64)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image, specifying values to use in the histogram."/>
                    <param name="binCount" type="int" multiplicity="?" desc="Number of bins. Uses 32 bins as default."/>
                    <param name="minValue" type="float" multiplicity="?" desc="Minimum of the value range to cover. Uses an automatic range if omitted."/>
                    <param name="maxValue" type="float" multiplicity="?" desc="Maximum of the value range to cover. Uses an automatic range if omitted."/>
                    <return name="histogram" type="float" multiplicity="*" desc="Histogram, represented as a vector of floats."/>
                    <return name="binCenters" type="float" multiplicity="*" desc="The center of each histogram bin in the input value range."/>
                </function>
                <function name="getMissingDataImage">
                    <trait>released</trait>
                    <links>Image.getMissingDataRegion, Image.getValidDataRegion</links>
                    <desc>Creates a binary image indicating the missing data pixels in the source image.

Image world coordinate system handling:
The output binary image gets the same x,y-origin and x,y-pixelsize as the input image, but the z-origin is set to 0 and the z-pixelsize to 1.

Missing data handling:
The output image has no missing data flag set as it is a binary image.</desc>
                    <sample for="lua">result = Image.getMissingDataImage(image)</sample>
                    <param name="image" type="const object" alias="Image" desc="The source image."/>
                    <param name="missingValue" type="int" multiplicity="?" desc="The value to assign result pixels for missing data in the source image. Default = 1"/>
                    <param name="dataValue" type="int" multiplicity="?" desc="The value to assign result pixels for data in the source image. Default = 0"/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="The resulting binary image, always of uint8 pixel type"/>
                </function>
                <function name="getMissingDataRegion">
                    <trait>released</trait>
                    <links>Image.getValidDataRegion, Image.getMissingDataImage, Image.fillRegion</links>
                    <desc>Creates a PixelRegion object of all missing data pixels in the source image.</desc>
                    <sample for="lua">region = Image.getMissingDataRegion(image)</sample>
                    <param name="image" type="const object" alias="Image" desc="The source image."/>
                    <return name="region" type="object" multiplicity="?" alias="Image.PixelRegion" desc="The region containing all missing data pixels."/>
                </function>
                <function name="getValidDataRegion">
                    <trait>released</trait>
                    <links>Image.getMissingDataRegion, Image.getMissingDataImage, Image.fillRegion</links>
                    <desc>Creates a PixelRegion object of all non-missing data pixels in the source image.</desc>
                    <sample for="lua">local region = Image.getValidDataRegion(image)</sample>
                    <param name="image" type="const object" alias="Image" desc="The source image."/>
                    <return name="region" type="object" multiplicity="?" alias="Image.PixelRegion" desc="A PixelRegion containing all valid data pixels."/>
                </function>
                <function name="missingDataSetAll">
                    <trait>released</trait>
                    <links>Image.missingDataSetAllInplace, Image.missingDataReduce, Image.missingDataSetSurface</links>
                    <desc>Sets all missing data pixels in the entire image or within a specified region to a given value. All missing pixels are set and the missing data flag of the image is cleared. If a region is provided, only pixels within the region are considered. The missing data flag of the image is still cleared, leaving any pixels with missing data outside the region in an undetermined state.

Image world coordinate system handling:
The specified value parameter is interpreted in image world coordinates, e.g., in millimeters if the source image is a range image with a z-origin different than 0 and a z-pixelsize different than 1. The output image inherits the image world coordinate system of the input image.

Missing data handling:
The missing data flag is removed from the output image, also if the operation is only performed within a region of interest.</desc>
                    <sample for="lua">result = Image.missingDataSetAll(image, value, region)</sample>
                    <param name="image" type="const object" alias="Image" desc="The input image."/>
                    <param name="valueWorld" type="float" desc="The value to set, in world coordinates considering z-origin and z-pixelsize if applicable."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="A region of interest to operate within. Optional, default is operate on the entire image."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="The output image."/>
                </function>
                <function name="missingDataSetAllInplace">
                    <trait>released</trait>
                    <links>Image.missingDataSetAll</links>
                    <desc>Inplace version of the Image.missingDataSetAll function that modifies the input image. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.missingDataSetAllInplace(image, value, region)</sample>
                    <param name="image" type="object" alias="Image" desc="The image to set missing data in. This image is overwritten with the result image."/>
                    <param name="valueWorld" type="float" desc="The value to set, in world coordinates considering z-origin and z-pixelsize if applicable."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="A region of interest to operate within. Optional, default is operate on the entire image."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="cropRectify">
                    <trait>released</trait>
                    <keywords>cut, warp, transform, rotate, align, box, rectangle, homography</keywords>
                    <links>Image.crop, Image.cropRegion, Image.transformInto, Image.rotate, Image.warpSector, Image.Calibration.Correction</links>
                    <desc>Crops the region defined by a rotated rectangle or a closed polyline, and also rotates/transforms the cropped image patch to become axis-aligned using a linear interpolation operation. The size of the output image is determined automatically to obtain approximately the same pixel resolution as the input image has. If the crop region extends outside the input image borders, the corresponding pixels in the output image get the value 0.

For a Shape Rectangle type region input, the function crops and rotates the content within the rectangle to a new image. The rotation of the input rectangle is reversed so that the output is defined by a zero-degree-rotated rectangle with the same width and height as the input rectangle.

For a Shape Polyline type region input, it is a requirement that the polyline has exactly 4 points and that it encloses a convex region, e.g., it must not self-intersect. The function then crops the defined region and applies a homography transform to transform the content into an axis-aligned bounding box. The order of the four points in the polyline is relevant. The following mapping from points in the polyline to corners in the output image patch is made:
- 1st point maps to upper left corner
- 2nd point maps to upper right corner
- 3rd point maps to lower right corner
- 4th point maps to lower left corner.

The transform from the input shape (Rectangle or Polyline region) and the output image is also provided. With this transform it is possible to map features, e.g., points, from the input image to the cropped image, and vice versa with the inverse of the transform. The transform is of rigid type when possible and of homography type otherwise.

Image world coordinate system handling:
New x,y pixel sizes are calculated, based on the input shape and input image. For example, a 90 degree rotated rectangle as a shape would just swap the pixel sizes in x and y in the output image. For non-rectangular shapes the average pixel sizes in the x,y-dimensions are used.

Missing-data handling:
For images with the missing data flag set, missing data aware sampling will be used and the output image will also set its missing data flag. Values being sampled outside of the image will get the value 0.</desc>
                    <sample for="lua">imageCropped, transform = Image.cropRectify(image, shape)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image to crop."/>
                    <param name="shape" type="const object" alias="Shape" desc="Input Shape defining the region to crop. Must either be of Rectangle type or of Polyline type with 4 points enclosing a convex region with an area greater than 1."/>
                    <return name="imageCropped" type="object" multiplicity="?" alias="Image" desc="Cropped and rectified image."/>
                    <return name="transform" type="object" multiplicity="?" alias="Transform" desc="Transformation from the input shape to the new image. The transform is of rigid type for a Rectangle shape input and of homography type otherwise."/>
                </function>
                <function name="cropRegion">
                    <trait>released</trait>
                    <keywords>cut, bounding box</keywords>
                    <links>Image.crop, Image.cropRectify</links>
                    <desc>Crops the region defined by the bounding box of an input pixelregion. Optionally, padding around the bounding box can also be specified in order to extend it. The pixelregion bounding box is defined by the limits of its non-empty pixels. If the pixelregion contains values outside of the input image the intersection of the pixelregion with the image region is used.

The output cropped pixelregion is a copy of the region corresponding to the padded pixelregion bounding box (crop region). The cropped image contains a copy of the values inside the crop region. The image size is equal to the size of the crop region, the pixel size is the same as the input image and the image origin value is equal to the top left corner of the crop region.

Image world coordinate system handling:
The image world coordinate system is copied from the input image, only the origin changes to the value of the top left corner of the crop region.

Missing-data handling:
The missing data information is kept from the input image.</desc>
                    <sample for="lua">imageCropped, regionCropped = Image.cropRegion(image, region)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image to crop"/>
                    <param name="region" type="const object" alias="Image.PixelRegion" desc="Input region to crop around. The crop region is defined by the bounding box of the region."/>
                    <param name="paddingPix" type="int" multiplicity="?" desc="How much padding around the bounding box of the region that should be added in pixels. Optional, default value is 0."/>
                    <return name="imageCropped" type="object" multiplicity="?" alias="Image" desc="The cropped image. Returns nil if the input padded pixelregion bounding box does not overlap with the input image."/>
                    <return name="regionCropped" type="object" multiplicity="?" alias="Image.PixelRegion" desc="The region corresponding to the input pixelregion bounding box plus padding if used. Returns nil if the input padded pixelregion bounding box does not overlap with the input image."/>
                </function>
                <function name="fillRegion">
                    <trait>released</trait>
                    <keywords>flood, inpaint</keywords>
                    <links>Image.replace, Image.drawPixelRegion, Image.drawShape, Image.inpaint, Image.growRegion, Image.PixelRegion.fillRegion, Image.fillRegionInplace</links>
                    <desc>Set all pixels within the given region(s) in the target image to a specific value in world coordinates. The pixels outside the input region keep their original values. A new image with updated values is returned, and the input image is left unchanged.

Image world coordinate system handling:
The specified value parameter is interpreted in image world coordinates, e.g., in millimeters if the source image is a range image with a z-origin different than 0 and a z-pixelsize different than 1. If the value parameter is outside the image value range it will be clamped to the closest valid value. The output image inherits the image world coordinate system of the input image.

Missing data handling:
The missing data flag is kept in the output image, but the pixels in the fill region will be updated with non missing data.</desc>
                    <sample for="lua">outputImage = Image.fillRegion(inputImage, region, value)</sample>
                    <param name="inputImage" type="const object" alias="Image" desc="Input image."/>
                    <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="The region(s) to fill."/>
                    <param name="value" type="float" multiplicity="[1+]" desc="World coordinate value to set for pixels within the region. A vector with three values must be given if the input image is an RGB image."/>
                    <return name="outputImage" type="object" multiplicity="?" alias="Image" desc="Result image or nil if operation failed."/>
                </function>
                <function name="fillRegionInplace">
                    <trait>released</trait>
                    <keywords>flood, inpaint</keywords>
                    <links>Image.replace, Image.fillRegion, Image.PixelRegion.fillRegionInplace, Image.drawPixelRegion</links>
                    <desc>Inplace version of the Image.fillRegion function that modifies the input image. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.fillRegionInplace(image, region, value)</sample>
                    <param name="image" type="object" alias="Image" desc="The image. This image is overwritten with the result image."/>
                    <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="The region(s) to fill."/>
                    <param name="value" type="float" multiplicity="[1+]" desc="World coordinate value to set for pixels within the region. A vector with three values must be given if the input image is an RGB image."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="extractProfile">
                    <trait>released</trait>
                    <keywords>sample, line segment</keywords>
                    <links>Profile, Image.extractRowProfile, Image.extractColumnProfile, Image.subtractProfile</links>
                    <desc>Samples image values evenly along a contour defined by a 2D Shape object and generates a Profile object. Supported shape types are line segment, arc, circle and polyline.

Coordinate system handling:
The image world coordinate system is considered when generating the Profile object, i.e., the image origin and pixelsizes in the (x,y) dimensions will be reflected in the coordinates of the Profile object. The z-origin and z-pixelsize are considered when generating the measurement values in the Profile object. The coordinate representation in the generated Profile object will be of implicit type if the contour shape allows it. For example, coordinates along a line segment contour can be represented using the implicit start + delta vector representation. For more complex contours such as a circle, an explicit coordinate representation is used in the Profile object where all the sample points are stored as individual entries. If the contour shape is closed, e.g., a circle, the closed flag in the Profile is also set.

Missing data handling:
Valid data flags are enabled in the output profile if and only if the image has missing data activated. Points sampled on missing data are marked as invalid. Points sampled outside the image are marked as invalid. In the latter case and if the image does not have missing data activated, the valid flags of the generated profile are set accordingly but are not enabled.</desc>
                    <sample for="lua">local profile = Image.extractProfile(image, shape, sampleCount, interpolation)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image. All pixel types are supported."/>
                    <param name="shape" type="const object" alias="Shape" desc="The shape to sample along. Supported shapes are line segment, arc, circle and polyline."/>
                    <param name="sampleCount" type="int" desc="The number of samples to take, evenly spaced along the input shape."/>
                    <param name="interpolation" type="enum" multiplicity="?" ref="InterpolationMethod" desc="Interpolation method, NEAREST or LINEAR. Default is NEAREST."/>
                    <return name="profile" type="object" multiplicity="?" alias="Profile" desc="Generated Profile object, or nil if unsuccessful."/>
                </function>
                <function name="extractRowProfile">
                    <trait>released</trait>
                    <links>Profile, Image.extractProfile, Image.extractColumnProfile, Image.subtractProfile</links>
                    <desc>Extracts one profile from an image row. The number of samples in the profile is always the same as the number of pixels between the start and end column (end position is included).

Coordinate system handling:
The image world coordinate system is considered when generating the Profile object, i.e., the image origin and pixelsizes in the (x,y) dimensions will be reflected in the coordinates of the Profile object. The z-origin and z-pixelsize are considered when generating the measurement values in the Profile object. The image row to extract from is provided as a zero-based integer pixel coordinate. The coordinate representation in the generated Profile object will be of implicit 2D or 1D type. Default is 2D, where the start point is the (x,y) world coordinates of the first extracted pixel in the image row and the delta vector the spacing between pixels in the x-dimension. Optionally, 1D coordinates can be returned, in which case the sample coordinates are set to the x-coordinates of the sampled pixels.

Missing data handling:
Valid data flags are enabled in the output profile if and only if the image contains missing data. Points sampled on missing data pixels are marked as invalid.</desc>
                    <sample for="lua">local profile = Image.extractRowProfile(image, row, startColumn, stopColumn, sampleCoordinates1D)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image. All pixel types are supported."/>
                    <param name="row" type="int" desc="The row to extract as a profile, zero-based."/>
                    <param name="startColumn" type="int" multiplicity="?" desc="The first column index to extract, zero-based. If no index is given 0 will be used."/>
                    <param name="stopColumn" type="int" multiplicity="?" desc="The last column index extract, zero-based. If no index is given the image width-1 will be used."/>
                    <param name="sampleCoordinates1D" type="bool" multiplicity="?" desc="If set to true, the output profile will have implicit 1D coordinates, keeping only the x-coordinates of the sample points. Default is false, generating implicit 2D sample coordinates."/>
                    <return name="profile" type="object" multiplicity="?" alias="Profile" desc="Sampled profile, or nil if unsuccessful."/>
                </function>
                <function name="extractColumnProfile">
                    <trait>released</trait>
                    <links>Profile, Image.extractRowProfile, Image.extractProfile, Image.subtractProfile</links>
                    <desc>Extracts one profile from an image column. The number of samples in the profile is always the same as the number of pixels between the start and end row (end position is included).

Coordinate system handling:
The image world coordinate system is considered when generating the Profile object, i.e., the image origin and pixelsizes in the (x,y) dimensions will be reflected in the coordinates of the Profile object. The z-origin and z-pixelsize are considered when generating the measurement values in the Profile object. The image column to extract from is provided as a zero-based integer pixel coordinate. The coordinate representation in the generated Profile object will be of implicit 2D or 1D type. Default is 2D, where the start point is the (x,y) world coordinates of the first extracted pixel in the image column and the delta vector the spacing between pixels in the y-dimension. Optionally, 1D coordinates can be returned, in which case the sample coordinates are set to the y-coordinates of the sampled pixels.

Missing data handling:
Valid data flags are enabled in the output profile if and only if the image contains missing data. Points sampled on missing data pixels are marked as invalid.</desc>
                    <sample for="lua">local profile = Image.extractColumnProfile(image, column, startRow, stopRow)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image. All pixel types are supported."/>
                    <param name="column" type="int" desc="The column to extract as a profile."/>
                    <param name="startRow" type="int" multiplicity="?" desc="The first row index to extract. If no index is given 0 will be used."/>
                    <param name="stopRow" type="int" multiplicity="?" desc="The last row index extract. If no index is given the image height-1 will be used."/>
                    <param name="sampleCoordinates1D" type="bool" multiplicity="?" desc="If set to true, the output profile will have implicit 1D coordinates, keeping only the y-coordinates of the sample points. Default is false, generating implicit 2D sample coordinates."/>
                    <return name="profile" type="object" multiplicity="?" alias="Profile" desc="Sampled profile, or nil if unsuccessful."/>
                </function>
                <function name="extractEdgeProfile">
                    <trait>released</trait>
                    <keywords>sample, line segment</keywords>
                    <links>Profile, Image.extractRowProfile, Image.extractColumnProfile, Image.subtractProfile</links>
                    <desc>Samples an edge relative to a polyline. The sampling is done by placing a number of probe lines along the polyline. The probe lines are placed orthogonal to each segment of the polyline. If an edge point is not found along a given probe line, the corresponding sample in the output profiles is marked as invalid. The distance between each probe line along the polyline is min(pixelSizeX, pixelSizeY).

Coordinate system handling:
The sample coordinates in the edgeDistance profile are the 1D distances along the polyline, in world coordinates. The sample coordinates in the edgeStrength profile are the positions of the found edges in the image, in world coordinates.

Missing data handling:
Edges between data and missing data are valid in images with missing data.</desc>
                    <sample for="lua">local edgeDistances, edgeStrength = Image.extractEdgeProfile(image, polyLine, maxDistance, contrastThreshold, selection, polarity, side, edgeDistance, edgeStrength)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image. All pixel types are supported."/>
                    <param name="polyLine" type="const object" alias="Shape" desc="Polyline to sample along, in world coordinates."/>
                    <param name="maxDistance" type="float" multiplicity="?" desc="Maximum distance to edge from polyline in world units. Optional, default 10.0."/>
                    <param name="contrastThreshold" type="float" multiplicity="?" desc="Edge strength threshold. Optional, no threshold is default."/>
                    <param name="selection" type="enum" multiplicity="?" ref="Image.ShapeFitter.EdgeSelection" desc="Edge selection criteria. See Image.ShapeFitter.setSelection() for details. Default: STRONGEST."/>
                    <param name="polarity" type="enum" multiplicity="?" ref="Profile.SlopePolarity" desc="Edge polarity. See Image.ShapeFitter.setPolarity() for details. Default: ANY."/>
                    <param name="side" type="enum" multiplicity="?" ref="Profile.EdgeSide" desc="Edge side. See Image.ShapeFitter.setSide() for details. Default: CENTER."/>
                    <return name="edgeDistance" type="object" multiplicity="?" alias="Profile" desc="Profile with distances to edges in world coordinates, or nil if unsuccessful."/>
                    <return name="edgeStrength" type="object" multiplicity="?" alias="Profile" desc="Profile with edge strength, or nil if unsuccessful."/>
                </function>
                <function name="setRow">
                    <trait>released</trait>
                    <links>Image.setColumn, Image.setRowProfile, Image.setColumnProfile, Image.extractRowProfile, Image.extractProfile, Image.extractColumnProfile, Image.subtractProfile, Profile.toImage</links>
                    <desc>Fills in a row of an image with the value(s) provided. Values are given in world coordinates (e.g. millimeters). Note that this function operates inplace. If a scalar value is provided, all columns from startColumn to the image width will be filled with the value. If the provided value(s) is a vector of length N, N columns will be filled with these values starting at column startColumn.

Coordinate system handling:
The image world coordinate system is only considered along the value range. Values are clamped to fit the pixel value range of the target image.

Missing data handling:
A missing data image may be used as the target image. Values to be set are clamped to the valid range of the target image, that is, the value to be set is clamped such that it is always marked as a valid value. Temporarily disable the missing data flag to allow setting values that will be regarded as missing (raw pixel value zero).</desc>
                    <sample for="lua">local success = Image.setRow(image, values, row, startColumn)</sample>
                    <param name="image" type="object" alias="Image" desc="The target image. All pixel types except RGB are supported."/>
                    <param name="values" type="float" multiplicity="[1+]" desc="The values to be set, in world coordinates."/>
                    <param name="row" type="int" desc="Index of row to fill, zero-based."/>
                    <param name="startColumn" type="int" multiplicity="?" desc="The first column index to fill, zero-based. If no index is given 0 will be used."/>
                    <return name="success" type="bool" desc="True if values could be set."/>
                </function>
                <function name="setRowProfile">
                    <trait>released</trait>
                    <links>Image.setColumnProfile, Image.extractRowProfile, Image.extractProfile, Image.extractColumnProfile, Image.subtractProfile, Profile.toImage</links>
                    <desc>Fills in a row of an image with the values taken from a profile. Note that this function operates inplace. The values in the profile is filled into the image row starting at column startColumn. The number of values set are equal to the length of the profile.

Coordinate system handling:
The image world coordinate system is only considered along the value range, i.e., the profile z origin and pixelsize is used to scale the profile before placing it in the image. The x and y coordinate of the profile and image are ignored and the values are simply placed in the designated image pixels.

Missing data handling:
If the source profile contains invalid points the target image must be a missing data image. Missing data is propagated from profile to image.</desc>
                    <sample for="lua">local success = Image.setRowProfile(image, profile, row, startColumn)</sample>
                    <param name="image" type="object" alias="Image" desc="The target image. All pixel types except RGB are supported."/>
                    <param name="profile" type="const object" alias="Profile" desc="The source profile."/>
                    <param name="row" type="int" desc="Index of row to fill, zero-based."/>
                    <param name="startColumn" type="int" multiplicity="?" desc="The first column index to fill, zero-based. If no index is given 0 will be used."/>
                    <return name="success" type="bool" desc="True if values could be set."/>
                </function>
                <function name="setColumn">
                    <trait>released</trait>
                    <links>Image.setRow, Image.setRowProfile, Image.setColumnProfile, Image.extractColumnProfile, Image.extractRowProfile, Image.extractProfile, Image.subtractProfile</links>
                    <desc>Fills in a column of an image with the value(s) provided. Values are given in world coordinates (e.g. millimeters). Note that this function operates inplace. If a scalar value is provided, all rows from startRow to the image height will be filled with the value. If the provided value(s) is a vector of length N, N rows will be filled with these values starting at row startRow.

Coordinate system handling:
The image world coordinate system is only considered along the value range. Values are clamped to fit the pixel value range of the target image.

Missing data handling:
A missing data image may be used as the target image. Values to be set are clamped to the valid range of the target image, that is, the value to be set is clamped such that it is always marked as a valid value. Temporarily disable the missing data flag to allow setting values that will be regarded as missing (raw pixel value zero).</desc>
                    <sample for="lua">local success = Image.setColumn(image, values, column, startRow)</sample>
                    <param name="image" type="object" alias="Image" desc="The target image. All pixel types except RGB are supported."/>
                    <param name="values" type="float" multiplicity="[1+]" desc="The values to be set, in world coordinates."/>
                    <param name="column" type="int" desc="Index of column to fill, zero-based."/>
                    <param name="startRow" type="int" multiplicity="?" desc="The first row index to fill, zero-based. If no index is given 0 will be used."/>
                    <return name="success" type="bool" desc="True if values could be set."/>
                </function>
                <function name="setColumnProfile">
                    <trait>released</trait>
                    <links>Image.setRowProfile, Image.extractColumnProfile, Image.extractRowProfile, Image.extractProfile, Image.subtractProfile, Profile.toImage</links>
                    <desc>Fills in a column of an image with the values taken from a profile. Note that this function operates inplace. The values in the profile is filled into the image column starting at row startRow. The number of values set are equal to the length of the profile.

Coordinate system handling:
The image world coordinate system is only considered along the value range, i.e., the profile z origin and pixelsize is used to scale the profile before placing it in the image. The x and y coordinate of the profile and image are ignored and the values are simply placed in the designated image pixels.

Missing data handling:
If the source profile contains invalid points the target image must be a missing data image. Missing data is propagated from profile to image.</desc>
                    <sample for="lua">local success = Image.setColumnProfile(image, profile, column, startRow)</sample>
                    <param name="image" type="object" alias="Image" desc="The target image. All pixel types except RGB are supported."/>
                    <param name="profile" type="const object" alias="Profile" desc="The source profile."/>
                    <param name="column" type="int" desc="Index of column to fill, zero-based."/>
                    <param name="startRow" type="int" multiplicity="?" desc="The first row index to fill, zero-based. If no index is given 0 will be used."/>
                    <return name="success" type="bool" desc="True if values could be set."/>
                </function>
                <function name="getWorldZ">
                    <trait>released</trait>
                    <keywords>getHeight</keywords>
                    <links>Image.toWorldZ</links>
                    <desc>Returns the z-values at given 2D (x,y)-points, interpreting the image as a range image. Linear interpolation is used for positions between the pixel grid positions. For points outside the image the z-origin value is return corresponding to raw pixel value 0.

Coordinate system handling:
The image world coordinate system is used in this operation, i.e., the input 2D points are interpreted using the pixelsizes and origin in the (x,y)-dimensions and the output z value is also in world coordinates.

Missing data handling:
Missing data is respected so that missing data pixels are ignored in the interpolation calculation.</desc>
                    <sample for="lua">local valuesZ = Image.getWorldZ(image, points)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image."/>
                    <param name="points" type="const object" multiplicity="[1+]" alias="Point" desc="The 2D point to sample at, or a list of 2D points, in world coordinates."/>
                    <return name="valuesZ" type="float" multiplicity="[?*]" desc="Z value or values in world coordinates, or nil if unsuccessful."/>
                </function>
                <function name="growRegion">
                    <trait>released</trait>
                    <keywords>floodfill, seeded, segmentation</keywords>
                    <links>Image.fillRegion, Image.threshold</links>
                    <desc>Starting from the seed regions, the regions are expanded to fill the pixel areas whose world pixel values in the image lies between the lower and upper threshold in world coordinates. Pixels with missing data are not grown into. Pixels included in the seed region will always be included in the output region, independent of the corresponding pixel value and missing status.

Image world coordinate system handling:
The thresholds are interpreted in image world coordinates, e.g., in millimeters if the source image is a range image with a z-origin different than 0 or a z-pixelsize different than 1.

Missing data handling:
Pixels with missing data are not included in the grown region, unless covered by the seed region.</desc>
                    <sample for="lua">grownRegion = Image.growRegion(image, seedRegion, minThreshold, maxThreshold)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image indicating where the region should grow."/>
                    <param name="seedRegion" type="const object" alias="Image.PixelRegion" desc="The region to grow."/>
                    <param name="minThreshold" type="float" multiplicity="?" desc="Minimum value to allow growth. Optional, default is the smallest representable value."/>
                    <param name="maxThreshold" type="float" multiplicity="?" desc="Maximum value to allow growth. Optional, default is the largest representable value."/>
                    <return name="grownRegion" type="object" multiplicity="?" alias="Image.PixelRegion" desc="Result region or nil if operation failed."/>
                </function>
                <function name="convolve">
                    <trait>released</trait>
                    <keywords>convolution, correlation</keywords>
                    <links>Image.sobel, Image.sobelMagnitude, Image.canny, Image.laplace, Image.median, Image.morphology</links>
                    <desc>Calculates the cross correlation of the input image with the selected kernel.
Please note that although the filter is named convolve a cross correlation is calculated and not a convolution. If a convolution is required it can be achieved by rotating the kernel.
The result of the cross correlation is cropped so that the output image has the same size as the input image. If the complete cross correlation output is required please pad the input image according to the kernel size. The pad function also allows to specify what border type to use.
Border handling is so that the values outside the image are treated as zero.

Image world coordinate system handling:
The convolve filter kernel is specified in pixel coordinates, i.e., the xy-image world coordinates of the image are not considered in the interpretation of the kernel size. The output image inherits the image world coordinate system of the input image in the xy-dimensions. In the z-dimension, the z-origin is set to 0 but the z-pixelsize is inherited from the input image to be able to relate ensuing thresholding of the output image to the input world z-scale.

Missing data handling:
This function does not accept missing data images, fill in the missing data pixels or toggle the missing data flag prior to calling this function.</desc>
                    <sample for="lua">convolvedImage = Image.convolve(image, kernel)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image. Supported image types are uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32 and float64."/>
                    <param name="kernel" type="const object" alias="Matrix" desc="Input kernel matrix."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. If supplied, the filter operation is only performed within the bounding box of its region. This can save a lot of computation time, if the region is small. Pixel values outside the region are undefined."/>
                    <return name="convolvedImage" type="object" multiplicity="?" alias="Image" desc="Convolved output image. Nil on failure."/>
                </function>
                <function name="sobel">
                    <trait>released</trait>
                    <keywords>edge, derivative, gradient, convolve</keywords>
                    <links>Image.sobelMagnitude, Image.canny, Image.laplace, Image.convolve</links>
                    <desc>Applies the standard 3x3 Sobel filter operator to find gradients and edges in the x- and y-directions.

Image world coordinate system handling:
The Sobel filter kernel is specified in pixel coordinates, i.e., the xy-image world coordinates of the image are not considered in the interpretation of the kernel size. The output image inherits the image world coordinate system of the input image in the xy-dimensions. In the z-dimension, the z-origin is set to 0 but the z-pixelsize is inherited from the input image to be able to related ensuing thresholding of the output image to the input world z-scale.

Missing data handling:
This function does not accept missing data images, fill in the missing data pixels prior to calling this function.</desc>
                    <sample for="lua">gx, gy = Image.sobel(image)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image. Supported image types are uint8, uint16, int16, float32 and float64."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. If supplied, the filter operation is only performed within the bounding box of its region. This can save a lot of computation time, if the region is small. Pixel values outside the region are undefined."/>
                    <return name="gx" type="object" multiplicity="?" alias="Image" desc="Output image with gradient x."/>
                    <return name="gy" type="object" multiplicity="?" alias="Image" desc="Output image with gradient y."/>
                </function>
                <function name="sobelMagnitude">
                    <trait>released</trait>
                    <keywords>edge, derivative, gradient, convolve</keywords>
                    <links>Image.sobel, Image.canny, Image.laplace, Image.convolve</links>
                    <desc>Calculates the magnitude of the standard 3x3 Sobel operator gradient responses dx and dy to find edges in the input image.

Image world coordinate system handling:
The Sobel filter kernel is specified in pixel coordinates, i.e., the xy-image world coordinates of the image are not considered in the interpretation of the kernel size. The output image inherits the image world coordinate system of the input image in the xy-dimensions. In the z-dimension, the z-origin is set to 0 but the z-pixelsize is inherited from the input image to be able to related ensuing thresholding of the output image to the input world z-scale.

Missing data handling:
This function does not accept missing data images, fill in the missing data pixels prior to calling this function.</desc>
                    <sample for="lua">imageMag = Image.sobelMagnitude(image)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image. Supported image types are uint8, uint16, uint32, int8, int16, int32, float32 and float64."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. Enter the value nil to filter the entire image. If a non-empty region is supplied, the filter operation is only performed within the bounding box of its region. This can save a lot of computation time, if the region is small."/>
                    <param name="metric" type="enum" multiplicity="?" ref="MetricType" desc="Select if the faster abs(dx)+abs(dy) or the more precise sqrt(dx^2+dy^2) should be used. Default is 'ABS'."/>
                    <return name="imageMag" type="object" multiplicity="?" alias="Image" desc="Output image with gradient magnitude."/>
                </function>
                <function name="laplace">
                    <trait>released</trait>
                    <keywords>edge, derivative, gradient, convolve</keywords>
                    <links>Image.sobel, Image.sobelMagnitude, Image.canny, Image.convolve</links>
                    <desc>Applies a Laplace filter to the input image, i.e., the sum of the local second-order gradients in the x- and y-directions.

Image world coordinate system handling:
The Laplace filter kernel is specified in pixel coordinates, i.e., the xy-image world coordinates of the image are not considered in the interpretation of the kernel size. The output image inherits the image world coordinate system of the input image in the xy-dimensions. In the z-dimension, the z-origin is set to 0 but the z-pixelsize is inherited from the input image to be able to related ensuing thresholding of the output image to the input world z-scale.

Missing data handling:
This function does not accept missing data images, fill in the missing data pixels prior to calling this function.</desc>
                    <sample for="lua">laplaceImage = Image.laplace(image, kernelSizePix)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image. Supported image types are uint8, uint16, float32 and float64."/>
                    <param name="kernelSizePix" type="int" desc="Size of the kernel, must be positive, odd and not larger than 29."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. If supplied, the filter operation is only performed within the bounding box of its region. This can save a lot of computation time, if the region is small. Pixel values outside the region are undefined."/>
                    <return name="laplaceImage" type="object" multiplicity="?" alias="Image" desc="Output image with the Laplace values."/>
                </function>
                <function name="median">
                    <trait>released</trait>
                    <keywords>smooth, denoise, filter, edge preserving</keywords>
                    <links>Image.gauss, Image.blur, Image.bilateral, Image.convolve</links>
                    <desc>Applies median filter to the image to smooth and remove noise.

Image world coordinate system handling:
The median filter kernel is specified in pixel coordinates, i.e., the xy-image world coordinates of the image are not considered in the interpretation of the kernel size. The output image inherits the image world coordinate system of the input image.

Missing data handling:
For an image with the missing data flag set, the filtering will ignore the missing data pixels in the filtering operation so that they do not influence the result. Note that it is computationally more expensive to filter a missing data image though. While filtering, there is an option to fill in missing data pixels locally if possible. The amount filled in depends on the kernel size. If this option is not used, an missing data input pixel will generate a missing data output pixel. The output image inherits the missing data flag of the input image.</desc>
                    <sample for="lua">medianImage = Image.median(image, kernelSizePix)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image. Supported image types are uint8, uint16, int16, float32 and rgb."/>
                    <param name="kernelSizePix" type="int" desc="Size of the kernel, must be positive and odd. For kernel sizes larger than 5 the only supported image type is uint8."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. Enter the value nil to filter the entire image. If a non-empty region is supplied, the filter operation is only performed within the bounding box of its region. This can save a lot of computation time, if the region is small. Output pixel values outside the region are undefined."/>
                    <param name="fillMissingData" type="bool" multiplicity="?" desc="Optional flag to also fill in missing data pixels when smoothing images containing missing data. Default is false."/>
                    <param name="preserveDetails" type="bool" multiplicity="?" desc="Optional flag to reduce detail loss. Default is false."/>
                    <return name="medianImage" type="object" multiplicity="?" alias="Image" desc="Output image blurred by the median filter."/>
                </function>
                <function name="gauss">
                    <trait>released</trait>
                    <keywords>smooth, denoise, filter, blur, convolve</keywords>
                    <links>Image.blur, Image.median, Image.bilateral, Image.convolve</links>
                    <desc>Applies a Gaussian filter to smooth an image.

Image world coordinate system handling:
The Gaussian filter kernel is specified in pixel coordinates, i.e., the xy-image world coordinates of the image are not considered in the interpretation of the kernel size. The output image inherits the image world coordinate system of the input image.

Missing data handling:
For an image with the missing data flag set, the filtering will ignore the missing data pixels in the filtering operation so that they do not influence the result. Note that it is computationally more expensive to filter a missing data image though. While filtering, there is an option to fill in missing data pixels locally if possible. The amount filled in depends on the kernel size. If this option is not used, an missing data input pixel will generate a missing data output pixel. The output image inherits the missing data flag of the input image.</desc>
                    <sample for="lua">smoothImage = Image.gauss(image, kernelSizePix)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image. Supported image types are uint8, uint16, int16, float32 and float64."/>
                    <param name="kernelSizePix" type="int" desc="Size of the kernel, must be positive and odd."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. Enter the value nil to filter the entire image. If a non-empty region is supplied, the filter operation is only performed within the bounding box of its region. This can save a lot of computation time, if the region is small. Output pixel values outside the region are undefined."/>
                    <param name="fillMissingData" type="bool" multiplicity="?" desc="Optional flag to also fill in missing data pixels when smoothing images containing missing data. Default is false."/>
                    <param name="gaussianFilterType" type="enum" multiplicity="?" ref="GaussianFilterType" desc="Optional selection of which algorithm to use for Gaussian smoothing. Default is dependent on the filter size, a Gaussian kernel is used for small filters and an IIR approximation is used for large filters."/>
                    <return name="smoothImage" type="object" multiplicity="?" alias="Image" desc="Output image smoothed by the Gaussian filter. Same type as input image."/>
                </function>
                <function name="blur">
                    <trait>released</trait>
                    <keywords>smooth, denoise, filter, convolve, box, boxcar</keywords>
                    <links>Image.gauss, Image.median, Image.bilateral, Image.convolve</links>
                    <desc>Blurs an image using a constant normalized box filter kernel.

Image world coordinate system handling:
The box filter kernel is specified in pixel coordinates, i.e., the xy-image world coordinates of the image are not considered in the interpretation of the kernel size. The output image inherits the image world coordinate system of the input image.

Missing data handling:
For an image with the missing data flag set, the filtering will ignore the missing data pixels in the filtering operation so that they do not influence the result. Note that it is computationally more expensive to filter a missing data image though. While filtering, there is an option to fill in missing data pixels locally if possible. The amount filled in depends on the kernel size. If this option is not used, an missing data input pixel will generate a missing data output pixel. The output image inherits the missing data flag of the input image.</desc>
                    <sample for="lua">smoothImage = Image.blur(image, kernelSizePix)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image. Supported image types are uint8, uint16, int16, float32 and float64."/>
                    <param name="kernelSizePix" type="int" desc="Size of the kernel, must be positive."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. Enter the value nil to filter the entire image. If a non-empty region is supplied, the filter operation is only performed within the bounding box of its region. This can save a lot of computation time, if the region is small. Output pixel values outside the region are undefined."/>
                    <param name="fillMissingData" type="bool" multiplicity="?" desc="Optional flag to also fill in missing data pixels when smoothing images containing missing data. Default is false."/>
                    <return name="smoothImage" type="object" multiplicity="?" alias="Image" desc="Output image blurred by the blur filter. Same type as input image."/>
                </function>
                <function name="canny">
                    <trait>released</trait>
                    <keywords>edge, derivative, gradient</keywords>
                    <links>Image.sobelMagnitude, Image.sobel, Image.laplace, Image.convolve</links>
                    <desc>Applies Canny edge detection to find edges in an image. The Canny edge detection works with a dual threshold procedure: first strong edges are found using a high threshold value. A second lower threshold also detects weaker edges in the image, and the weaker edges that are connected with the stronger edges are kept in the output edge image. A non-maximum suppression operation is also applied to obtain 1-pixel wide edge responses. The Canny function currently only operates on uint8 images.

Image world coordinate system handling:
The input thresholds are interpreted in world scale, e.g., millimeters, they are internally divided by the z-pixelsize to get raw pixel value thresholds. The output image inherits the image world coordinates in the x,y-dimensions, but the z-pixelsize is set to 1 and the z-origin to 0.

Missing data handling:
This function does not handle missing data images. Fill in the missing data pixels and/or remove the missing data flag from the image before calling.</desc>
                    <sample for="lua">cannyImage = Image.canny(image, thresholdHigh, thresholdLow)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image. Currently only uint8 pixel type is supported."/>
                    <param name="thresholdHigh" type="float" desc="First/high threshold to find strong edges, for example a value of 100."/>
                    <param name="thresholdLow" type="float" desc="Second/low threshold for finding weaker edges connected with the strong edges, for example a value of 50."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. If supplied, the filter operation is only performed within the bounding box of its region. This can save a lot of computation time, if the region is small. Output pixel values outside the region are undefined."/>
                    <return name="cannyImage" type="object" multiplicity="?" alias="Image" desc="Output image."/>
                </function>
                <function name="binarize">
                    <trait>released</trait>
                    <links>Image.threshold, Image.binarizeAdaptive, Image.binarizeCompare, Image.binarizePlane, Image.thresholdCompare</links>
                    <desc>Applies a threshold interval (lowerThreshold, upperThreshold) to the image to create a binary image. It is possible to binarize only a specified region. This function produces an image output, to directly produce a PixelRegion output use the threshold() function instead.

Image world coordinate system handling:
The input threshold values are interpreted in image world coordinates, i.e., they are converted to raw pixel thresholds within the function using the z-origin and z-pixelsize. As the output image is binary the output z-origin is set to 0 and the z-pixelsize to 1. The output image inherits the image world coordinates in the xy-dimensions.

Missing data handling:
Missing data pixels are set to background, i.e., to 0 in the output image. The output image has its missing data flag turned off regardless of the flag of the input image.</desc>
                    <sample for="lua">thresholdImage = Image.binarize(image, lowerThreshold, upperThreshold, outputValue, region)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image. Supported image types are uint8, uint16, uint32, uint64, int8, int16, int32, int64, float32 and float64."/>
                    <param name="lowerThreshold" type="float" desc="Lower threshold for the binarization in image world coordinates, i.e., the z-pixel size and origin are used so that the threshold is interpreted in millimeters in case the image is a height map/distance/range image."/>
                    <param name="upperThreshold" type="float" multiplicity="?" desc="Upper threshold for the binarization in world coordinates. Optional, defaults to max value of the pixel type."/>
                    <param name="outputValue" type="int" multiplicity="?" desc="Value assigned to the pixels within the threshold interval, uint8 range. Optional, default value is 255."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest to consider when binarizing, values outside are set to zero."/>
                    <return name="binarizedImage" type="object" multiplicity="?" alias="Image" desc="Binarized image of pixel type uint8."/>
                </function>
                <function name="binarizeAdaptive">
                    <trait>released</trait>
                    <links>Image.binarize, Image.binarizeCompare, Image.binarizePlane, Image.threshold, Image.thresholdCompare</links>
                    <desc>Applies an adaptive filter to the image to create a binary image. A pixel is set in the binary output image if the value is significantly larger than the average value in a surrounding region of specified size. The threshold is set as a delta value how much larger the pixel value must be in world coordinates, i.e, the delta threshold value is scaled internally with the pixel size in the z-dimension. In its base form, bright objects on dark background are found. There is a parameter to instead find dark objects on a bright background.</desc>
                    <sample for="lua">filteredImage = Image.binarizeAdaptive(image, deltaThresholdWorld, kernelSizePix, findBright, outputValue, region)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image, currently only uint8 format is supported."/>
                    <param name="deltaThresholdWorld" type="float" desc="Threshold value, all pixels with a value higher than the mean in the surrounding region plus this threshold is set to outputValue"/>
                    <param name="kernelSizePix" type="int" desc="Size of the kernel in number of pixels, must be odd and greater than one."/>
                    <param name="findBright" type="bool" multiplicity="?" desc="Set to true to find bright objects on dark background. Set to false to find dark objects on a bright background. Optional, default is true."/>
                    <param name="outputValue" type="int" multiplicity="?" desc="Value assigned to the pixels within the threshold interval, uint8 range. Optional, default value is 255."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. If supplied, the filter operation is only performed within the bounding box of its region. This can save a lot of computation time, if the region is small."/>
                    <return name="binarizedImage" type="object" multiplicity="?" alias="Image" desc="Adaptively binarized image."/>
                </function>
                <function name="missingDataReduce">
                    <trait>released</trait>
                    <links>Image.missingDataSetAll, Image.missingDataSetSurface, Image.inpaint</links>
                    <desc>Reduces missing data pixels in an image by using valid values in the neighborhood. Valid pixel values are unaffected. This will fill in scattered missing data values but larger patches of missing data will remain. The type of operation performed to fill a missing pixel is selected using the method parameter. Optionally, reduction of missing data can be limited to a region in the image. Valid pixel values within a neighborhood but outside the region will still be used to fill missing data. To fill a missing pixel, at least one quarter of the neighbor pixels need to have valid values.

The available methods are:
MAX - Sets missing pixels to the maximum valid value in the neighborhood.
MIN - Sets missing pixels to the minimum valid value in the neighborhood.
MEAN - Sets missing pixels to the mean of all valid values in the neighborhood.
MEDIAN - Sets missing pixels to the median of all valid values in the neighborhood.
EDGE - Fills missing values by edge-preserving interpolation among pixels in the 3x3 pixel neighborhood. A missing data pixel will be filled in only if there are valid values on both sides of a pixel.

For all methods except EDGE, the neighborhood is nSize-by-nSize pixels. nSize must be odd and at least three. For method EDGE, nSize determines how many times the algorithm will be repeated. For EDGE, nSize must be a positive integer.</desc>
                    <sample for="lua">outputImage = Image.missingDataReduce(inputImage, method, nSize, region)</sample>
                    <param name="inputImage" type="const object" alias="Image" desc="The input image. An error is returned if the input image does not have the missing data flag set."/>
                    <param name="method" type="enum" ref="MissingDataMethod" desc="Method to be used for reducing missing data."/>
                    <param name="nSize" type="int" multiplicity="?" desc="The size of the neighborhood for most methods, the number of iterations for EDGE. Default is 3."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. If supplied, the filter operation is only performed within this region. This can save a lot of computation time, if the region is small."/>
                    <return name="outputImage" type="object" multiplicity="?" alias="Image" desc="The output image, or nil if an error occurred."/>
                </function>
                <function name="houghTransformCircle">
                    <trait>released</trait>
                    <links>Image.houghTransformExtremaToCircles, Image.houghTransformLine, Image.findLocalExtrema</links>
                    <desc>Finds circle candidates with a given radius in an edge image where any non-zero pixel is considered an edge. The output is an accumulator image binned over circle centers in world coordinates.
The world coordinates of the output accumulator directly matches circle centers, i.e. the world coordinates of a maxima in the accumulator image corresponds directly to the input image circle center in world coordinates. Use Image.houghTransformExtremaToCircles to create circles from accumulator image maxima (as a pixel region), or extract maxima as points and use Shape.createCircle(points, radius) directly.

Image world coordinate system handling:
Input image world coordinates are used. The radius is in world coordinates. The accumulator world coordinates directly relate maxima to circle centers. Pixel values in the input image are interpreted in raw pixel values.

Missing data handling:
Missing data are interpreted as not edges.</desc>
                    <sample for="lua">houghAccumulator = Image.houghTransformCircle(edgeImage, radius, resolutionX, resolutionY)</sample>
                    <param name="edgeImage" type="const object" alias="Image" desc="Input image. Supported image types are uint8 and uint16. Non-zero pixels are counted as edges."/>
                    <param name="radius" type="float" desc="The radius of circles to search for, in world coordinates."/>
                    <param name="resolutionX" type="int" multiplicity="?" desc="The number of bins to use for the x-position of the circles, also the width of the output image, default 200."/>
                    <param name="resolutionY" type="int" multiplicity="?" desc="The number of bins to use for the y-position of the circles, also the height of the output image, default 200."/>
                    <return name="houghAccumulator" type="object" multiplicity="?" alias="Image" desc="Circle candidate center accumulator image."/>
                </function>
                <function name="houghTransformExtremaToCircles">
                    <trait>released</trait>
                    <links>Image.houghTransformCircle</links>
                    <desc>Converts pixels extracted from an accumulator image obtained from houghTransformCircle to geometrical circles. The accumulator image is required to get the world coordinate system and accumulator values. Results are sorted in descending order by accumulator value.

Image world coordinate system handling:
Pixel region of extremas should be related to the accumulator image. Circles are returned in world coordinates.

Missing data handling:
Not applicable, there is no missing data in the input accumulator image.</desc>
                    <sample for="lua">circles, accumulatorValues = Image.houghTransformExtremaToCircles(accumulatorImage, extremalRegion, radius</sample>
                    <param name="accumulatorImage" type="const object" alias="Image" desc="Accumulator image as returned from houghTransformCircle."/>
                    <param name="extremalRegion" type="const object" alias="Image.PixelRegion" desc="Pixel region with extremal points extracted from the accumulator image, will be recalculated to the corresponding circles."/>
                    <param name="radius" type="float" desc="Radius of the circles to create."/>
                    <return name="circles" type="object" multiplicity="*" alias="Shape" desc="Circles as shapes, or nil on error."/>
                    <return name="accumulatorValues" type="float" multiplicity="*" desc="Accumulator image value corresponding to each circle."/>
                </function>
                <function name="houghTransformLine">
                    <trait>released</trait>
                    <links>Image.houghTransformExtremaToLines, Image.houghTransformCircle, Image.findLocalExtrema</links>
                    <desc>Finds line candidates in an edge image where any non-zero pixel is considered an edge. The output is an accumulator image binned over line candidate direction and signed distance from the center of the input image. E.g. a line candidate with direction pi/2 and distance -5 is a vertical line located five world coordinate units to the left of the center point of the input image.
Line candidates are on the form x*sin(theta) + y*cos(theta) = d, where x and y are input image positions relative to the center of the input image, d is the signed distance from the center of the input image and theta is the line direction. All are expressed in world coordinates. d is binned over distanceBins bins which also is the width of the output image. Theta is binned over directionBins bins. The range of theta is from zero to pi, d is from minus to plus half the diagonal of the input image. Since the direction parameter is circular in nature, a maxima at the upper and lower accumulator image border (theta is zero or pi) with opposite signs of d correspond to the same line. Since maxima extraction routines tend to skip maxima close to image borders, a few extra rows are added to the bottom of the accumulator image, corresponding to the first rows of accumulators. The number of extra rows is set by the overlapBins parameters, recommended to be set to the maxima extraction filter size. The accumulator image height is thus directionBins + overlapBins.
The search space can be limited by setting the directionCenter and directionRange parameters. The direction search range is centered around the direction center. If set, the rows of the accumulator image are distributed over the specified direction range and no overlap bins are added. The first row of the accumulator image corresponds to directionCenter - directionRange/2.
The canny function can be used to generate an edge image suitable as input. The threshold or findLocalExtrema functions can be used to find extrema in the accumulator image. Use houghTransformExtremaToLines to transform extrema from the accumulator image into Shape lines.

Image world coordinate system handling:
Input image world coordinates are used. All output values are with respect to the center of the input image. The output image world coordinates are set to directly get d and theta values. Raw pixel values of the input image are used.

Missing data handling:
Missing data are interpreted as not edges.</desc>
                    <sample for="lua">houghAccumulator = Image.houghTransformLine(edgeImage, distanceBins, directionBins, overlapBins)</sample>
                    <param name="edgeImage" type="const object" alias="Image" desc="Input image. Supported image types are uint8 and uint16. Non-zero pixels are counted as edges."/>
                    <param name="distanceBins" type="int" multiplicity="?" desc="The number of bins to use for the distance to the line from the edge image center, the width of the output image, default 200."/>
                    <param name="directionBins" type="int" multiplicity="?" desc="The number of bins to use for the direction of the line, the height of the output image, default 360."/>
                    <param name="overlapBins" type="int" multiplicity="?" desc="The number of extra rows to add at the bottom of the accumulator image, overlapping with the first rows. Recommended value is the size of the maxima filter to be used, default is 5."/>
                    <param name="directionCenter" type="float" multiplicity="?" desc="The central direction when searching for lines with directions within a limited range in radians. Horizontal lines have direction zero, vertical lines have direction pi/2. Default is to search the full range."/>
                    <param name="directionRange" type="float" multiplicity="?" desc="The range of directions for a limited range search, in radians (between zero and pi) and centered around the specified central direction. Default is nil, searching for lines with any direction."/>
                    <return name="houghAccumulator" type="object" multiplicity="?" alias="Image" desc="Line candidate accumulator image."/>
                </function>
                <function name="houghTransformExtremaToLines">
                    <trait>released</trait>
                    <links>Image.houghTransformLine, Image.findLocalExtrema</links>
                    <desc>Converts pixels extracted from an accumulator image obtained from houghTransformLine to geometrical lines. Both the accumulator and edge images are required to get the world coordinate system. Since horizontal lines end up just where the accumulator image wraps around, the accumulator is usually extended with a few extra rows. These may result in duplicate line detections (the direction differ by pi, with opposite sign of the distance to the image center). By default, such duplicate lines are removed but this feature can be turned off. The accumulator value corresponding to each line candidate is returned. Results are sorted in descending order by accumulator value.

Image world coordinate system handling:
Pixel region of extremas should be related to the accumulator image. Lines are returned in world coordinates of the original input image.

Missing data handling:
Not applicable, there is no missing data in the input accumulator image.</desc>
                    <sample for="lua">lines = Image.houghTransformExtremaToLines(accumulatorImage, extremalRegion, edgeImage, removeDuplicates)</sample>
                    <param name="accumulatorImage" type="const object" alias="Image" desc="Accumulator image as returned from houghTransformLines."/>
                    <param name="extremalRegion" type="const object" alias="Image.PixelRegion" desc="Pixel region with extremal points extracted from the accumulator image, will be recalculated to the corresponding lines."/>
                    <param name="edgeImage" type="const object" alias="Image" desc="Input image as sent to houghTransformLine, used for coordinate reference."/>
                    <param name="removeDuplicates" type="bool" multiplicity="?" desc="Flag indicating if duplicate lines should be removed, default is true."/>
                    <return name="lines" type="object" multiplicity="*" alias="Shape" desc="Lines as shapes, or nil on error."/>
                    <return name="accumulatorValues" type="float" multiplicity="*" desc="Accumulator image value corresponding to each line."/>
                </function>
                <function name="findLocalExtrema">
                    <trait>released</trait>
                    <keywords>max, min, minima, maxima</keywords>
                    <desc>Finds local extreme points (minima or maxima) in an image. A point is a local maxima if it is larger than all points within a neighborhood of the specified size. An optional contrast threshold level can be defined that sets a required value difference between the local maxima and the smallest value in the neighborhood. For local plateaus, where several pixels have the same value, the top left pixel is reported. An absolute threshold can be specified, if so, point values must exceed the threshold value to be reported. Local minima are detected similarly.
Early stopping is used, the neighborhood is only searched until it is clear that the pixel at hand is not an extremal point, starting with the four closest neighbor pixels. The function thus runs faster on smooth images. The absoluteThreshold can also be used to speed up the processing, only considering pixels larger (smaller) than the threshold. The entire neighborhood must fit within the image around extreme points e.g. if neighborhoodSize = 5, no extreme points will be detected closer than three pixels from the image border.

Image world coordinate system handling:
The thresholds are specified in world values, taking z-origin and pixel size into account. The output pixel region is defined on the pixel grid of the image.

Missing data handling:
This function does not handle missing data. Remove missing data before calling this function.</desc>
                    <sample for="lua">extremalRegions = Image.findLocalExtrema(image, extremaType, neighborhoodSize, contrastThreshold, contrastDifferenceMode, absoluteThreshold, region)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image. Supported image types are uint8, uint16, uint32, int8, int16, float32 and float64."/>
                    <param name="extremaType" type="enum" ref="ExtremaType" desc="Which type of extrema to look for. MIN or MAX."/>
                    <param name="neighborhoodSize" type="int" multiplicity="?" desc="The neighborhood size, width and height in pixels. Must be odd and &gt;= 3. Default is 3."/>
                    <param name="contrastThreshold" type="float" multiplicity="?" desc="Required height of the peak/valley (world coordinate value difference between the extreme point and surrounding points). Set to zero to disable (default)."/>
                    <param name="contrastDifferenceMode" type="enum" multiplicity="?" ref="ContrastDifferenceMode" desc="Determines how the difference between the extreme point and the surrounding points is calculated. Default is ONE, at least one point in the neighborhood should differ more than contrastThreshold from the local extremal point."/>
                    <param name="absoluteThreshold" type="float" multiplicity="?" desc="Absolute threshold, extremal points must be above (maxima) or below (minima) this value to be included in the output. By default, this threshold is not used."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. If supplied, the filter operation is only performed within the bounding box of its region. This can save a lot of computation time, if the region is small."/>
                    <return name="extremalRegions" type="object" multiplicity="?" alias="Image.PixelRegion" desc="PixelRegion with local extremal points."/>
                </function>
                <function name="pad">
                    <trait>released</trait>
                    <keywords>extend, replicate</keywords>
                    <links>Image.concatenate</links>
                    <desc>Image padding, adds a border to the image.

Image world coordinate system handling:
The image world coordinate system is used to update the output image origin, it is calculated as follows: (Oxout, Oyout, Ozout) =  (Oxin - pixelSizeX * leftPaddingPix, Oyin - pixelSizeY * topPaddingPix, Ozin), the world pixel sizes remain the same. The boundary paddings are in pixel units, i.e., not scaled with the world pixel sizes in x and y.

Missing data handling:
This function does not use the missing data flag. If the padding contains zeros it will be treated as missing data if the flag is on.</desc>
                    <sample for="lua">imageOut = Image.pad(imageIn, topPaddingPix, bottomPaddingPix, leftPaddingPix, rightPaddingPix, borderType, intensity)</sample>
                    <param name="imageIn" type="const object" alias="Image" desc="Input image. Supported image types are uint8, uint16, int8, int16, int32, float32, float64 and RGB."/>
                    <param name="topPaddingPix" type="int" desc="The top padding in pixels"/>
                    <param name="bottomPaddingPix" type="int" desc="The bottom padding in pixels"/>
                    <param name="leftPaddingPix" type="int" desc="The left padding in pixels"/>
                    <param name="rightPaddingPix" type="int" desc="The right padding in pixels"/>
                    <param name="borderType" type="enum" ref="BorderType" desc="The border type to use for the padding, currently CONSTANT, REPLICATE, REFLECT and WRAP are available. If the border type is not CONSTANT the padding value is not used."/>
                    <param name="intensity" type="float" multiplicity="[?*]" desc="The padding intensity. In case the image type is RGB then an array of 3 elements (one per channel) must be provided. If the border type is not CONSTANT this value does not need to be specified."/>
                    <return name="imageOut" type="object" multiplicity="?" alias="Image" desc="Padded Image"/>
                </function>
                <function name="morphology">
                    <trait>released</trait>
                    <keywords>dilate, erode, open, close, tophat, blackhat, binary</keywords>
                    <links>Image.PixelRegion.dilate, Image.PixelRegion.erode, Image.convolve</links>
                    <desc>A morphological transformation applied to grayscale images. The possible transformation types are: ERODE, DILATE, OPEN, CLOSE, GRADIENT, TOPHAT and BLACKHAT. A circular structuring element/kernel is used for all types. The diameter of the kernel can be specified by diameterPix. For erosion the basic idea is just like soil erosion, it erodes away the boundaries of an object making it thinner. The dilation is the opposite transformation. The elements of the kernel contain: 0-background or 1-foreground. It is centered at each image pixel and defines the neighborhood pixels to be used. For grayscale erosion the new pixel value corresponds to the minimum value of the image pixels under the structuring element foreground. Similarly, for grayscale dilation the maximum of the neighborhood is used. The remaining transformations are:  opening - erosion followed by dilation; closing - dilation followed by erosion; morphological gradient - difference between dilation and erosion; top hat - difference between input image and opening; black hat - difference between closing and input image.

Image world coordinate system handling:
The image world coordinate system is copied from the input image, only the image content is changed. The diameter of the structuring element is in pixel units, i.e., not scaled with the world pixel sizes in x and y.

Missing data handling:
This function does not handle missing data images. Fill in the missing data pixels and/or remove the missing data flag from the image before calling.</desc>
                    <sample for="lua">imageOut = Image.morphology(imageIn, diameterPix, transform, region)</sample>
                    <param name="imageIn" type="const object" alias="Image" desc="Input image. Supported image types are uint8, uint16, int8, int16, int32, float32 and float64."/>
                    <param name="diameterPix" type="int" desc="The diameter of the circular structuring element/kernel in pixels. The value must be odd and between 3 and 51."/>
                    <param name="transform" type="enum" ref="MorphologicalTransform" desc="The morphological transformation, possible types are: ERODE, DILATE, OPEN, CLOSE, GRADIENT, TOPHAT and BLACKHAT."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. If supplied, the filter operation is only performed within the bounding box of its region. This can save a lot of computation time, if the region is small."/>
                    <return name="imageOut" type="object" multiplicity="?" alias="Image" desc="Morphology transformed image"/>
                </function>
                <function name="applyColormap">
                    <trait>released</trait>
                    <keywords>colorize, paint</keywords>
                    <links>View.addImage, Image.drawShape, Image.drawPoint, Image.drawPixelRegion, Image.drawText</links>
                    <desc>Render an image into an RGB target image in the same way as the View.addImage function would.

Image world coordinate system handling:
The image content is converted and the coordinate system preserved except for the value dimensions. The value dimension is scaled according to the input parameters.
Input RGB images are not supported.

Missing data handling:
Missing data values in the input will always be represented as a gray value independent of color map and datatype.</desc>
                    <sample for="lua">image = Image.applyColormap(image, colormap, min, max)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image to render into the output image."/>
                    <param name="colormap" type="const object" alias="View.ColorMap" desc="Provide the color map to use when converting the image."/>
                    <param name="minZ" type="float" multiplicity="?" desc="The minimum world unit value in the source image that will be represented by the color map."/>
                    <param name="maxZ" type="float" multiplicity="?" desc="The maximum world unit value in the source image that will be represetned by the color map."/>
                    <param name="samples" type="int" multiplicity="?" desc="The resolution of the color map. Default is 256 colors."/>
                    <param name="invert" type="bool" multiplicity="?" desc="Select if the color map should be inverted. Eg. swapping all colors so that the first color is used last."/>
                    <return name="image" type="object" multiplicity="?" alias="Image" desc="Converted RGB image."/>
                </function>
                <function name="drawPoint">
                    <trait>released</trait>
                    <keywords>rasterize, overlay, plot, render, display, paint, print</keywords>
                    <links>View.addShape, Image.toRGB, Image.applyColormap, Shape.toImage, Image.drawShape, Image.drawPointInplace, Image.drawPixelRegion, Image.drawText</links>
                    <desc>Render the position of one or several points into an RGB image. The input image must be of either RGB or UINT8 type. Use Image.toRGB or Image.applyColormap to convert other image types to RGB. to RGB.

The View.ShapeDecoration object is used to set graphical properties. The following parameters in the ShapeDecoration object are supported:
- The LineColor property is used to set the color of the points.
- The PointType property is used to render points as circles or crosses.
- The PointSize property is used to set the size of the rendered points.

Image world coordinate system handling:
The points coordinates are interpreted as world coordinates. That is, the coordinate system of the image is used to place the points properly.

Missing data handling:
This function does not use the missing data flag.</desc>
                    <sample for="lua">image = Image.drawPoint(image, points, decoration)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image to render the point(s) into. Supported image types are UINT8 and RGB."/>
                    <param name="points" type="const object" multiplicity="[1+]" alias="Point" desc="The points (2D) that are to be rendered in the image."/>
                    <param name="decoration" type="const object" alias="View.ShapeDecoration" desc="A decorator that describes how the point(s) are to be rendered. Not all properties of the ShapeDecoration object are supported, see the main function description."/>
                    <return name="image" type="object" multiplicity="?" alias="Image" desc="RGB image with rendered overlay."/>
                </function>
                <function name="drawPointInplace">
                    <trait>released</trait>
                    <keywords>rasterize, overlay, plot, render, display, paint, print</keywords>
                    <links>View.addShape, Image.toRGB, Image.applyColormap, Shape.toImage, Image.drawShape, Image.drawPoint, Image.drawPixelRegion, Image.drawText</links>
                    <desc>Inplace version of the Image.drawPoint function which modifies the input image. See base function for full documentation.</desc>
                    <sample for="lua">image = Image.drawPointInplace(image, points, decoration)</sample>
                    <param name="image" type="object" alias="Image" desc="The image to render the point(s) into. Supported image type is RGB."/>
                    <param name="points" type="const object" multiplicity="[1+]" alias="Point" desc="The points (2D) that are to be rendered in the image."/>
                    <param name="decoration" type="const object" alias="View.ShapeDecoration" desc="A decorator that describes how the point(s) are to be rendered. Not all properties of the ShapeDecoration object are supported, see the main function description."/>
                    <return name="image" type="object" multiplicity="?" alias="Image" desc="RGB image with rendered overlay. Reference to input image."/>
                </function>
                <function name="drawShape">
                    <trait>released</trait>
                    <keywords>rasterize, overlay, plot, render, display, paint, print</keywords>
                    <links>View.addShape, Image.toRGB, Image.applyColormap, Shape.toImage, Image.drawShapeInplace, Image.drawPoint, Image.drawPixelRegion, Image.drawText</links>
                    <desc>Render the position of one or several shapes into an RGB image. The input image must be of either RGB or UINT8 type. Use Image.toRGB or Image.applyColormap to convert other image types to RGB.

The View.ShapeDecoration object is used to set graphical properties. The following parameters in the ShapeDecoration object are supported:
- The LineColor property is used to set the border color of the rendered shape.
- The FillColor property is used to set the fill color of the rendered shape.
- The LineWidth property is used to set width of the border.

Image world coordinate system handling:
The shape coordinates are interpreted as world coordinates. That is, the coordinate system of the image is used to place the shapes properly.

Missing data handling:
This function does not use the missing data flag.</desc>
                    <sample for="lua">image = Image.drawShape(image, shapes, decoration)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image to render the shape(s) into. Supported image types are UINT8 and RGB."/>
                    <param name="shapes" type="const object" multiplicity="[1+]" alias="Shape" desc="The shape(s) that are to be rendered in the image."/>
                    <param name="decoration" type="const object" alias="View.ShapeDecoration" desc="A decorator that describes how the shape(s) are to be rendered. Not all properties of the ShapeDecoration object are supported, see the main function description."/>
                    <return name="image" type="object" multiplicity="?" alias="Image" desc="RGB image with rendered overlay."/>
                </function>
                <function name="drawShapeInplace">
                    <trait>released</trait>
                    <keywords>rasterize, overlay, plot, render, display, paint, print</keywords>
                    <links>View.addShape, Image.toRGB, Image.applyColormap, Shape.toImage, Image.drawShape, Image.drawPoint, Image.drawPixelRegion, Image.drawText</links>
                    <desc>Inplace version of the Image.drawShape function which modifies the input image. See base function for full documentation.</desc>
                    <sample for="lua">image = Image.drawShapeInplace(image, shapes, decoration)</sample>
                    <param name="image" type="object" alias="Image" desc="The image to render the shape(s) into. Supported image type is RGB."/>
                    <param name="shapes" type="const object" multiplicity="[1+]" alias="Shape" desc="The shape(s) that are to be rendered in the image."/>
                    <param name="decoration" type="const object" alias="View.ShapeDecoration" desc="A decorator that describes how the shape(s) are to be rendered. Not all properties of the ShapeDecoration object are supported, see the main function description."/>
                    <return name="image" type="object" multiplicity="?" alias="Image" desc="RGB image with rendered overlay. Reference to input image."/>
                </function>
                <function name="drawPixelRegion">
                    <trait>released</trait>
                    <keywords>rasterize, overlay, fill, plot, render, display, paint, print</keywords>
                    <links>View.addPixelRegion, Image.toRGB, Image.applyColormap, Image.PixelRegion.toImage, Image.drawShape, Image.drawPoint, Image.drawText</links>
                    <desc>Render one or several PixelRegions into an RGB image. The input image must be of either RGB or UINT8 type. Use Image.toRGB or Image.applyColormap to convert other image types to RGB.

The View.PixelRegionDecoration object is used to set the color of the rendered regions.

Image world coordinate system handling:
The input PixelRegion is interpreted in raw pixel coordinates, the image world coordinate system is not considered.

Missing data handling:
This function does not use the missing data flag.</desc>
                    <sample for="lua">image = Image.drawPixelRegion(image, regions, decoration)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image to render the region(s) into. Supported image types are UINT8 and RGB."/>
                    <param name="regions" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="The region(s) that are to be rendered in the image."/>
                    <param name="decoration" type="const object" alias="View.PixelRegionDecoration" desc="A decorator that describes how the region(s) are to be rendered."/>
                    <return name="image" type="object" multiplicity="?" alias="Image" desc="RGB image with rendered overlay."/>
                </function>
                <function name="drawPixelRegionInplace">
                    <trait>released</trait>
                    <keywords>rasterize, overlay, fill, plot, render, display, paint, print</keywords>
                    <links>View.addPixelRegion, Image.toRGB, Image.applyColormap, Image.PixelRegion.toImage, Image.applyColormap, Image.drawShape, Image.drawPoint, Image.drawPixelRegion, Image.drawText</links>
                    <desc>Inplace version of the Image.drawPixelRegion function which modifies the input image. See base function for full documentation.</desc>
                    <sample for="lua">image = Image.drawPixelRegionInplace(image, regions, decoration)</sample>
                    <param name="image" type="object" alias="Image" desc="The image to render the region(s) into. Supported image type is RGB."/>
                    <param name="shapes" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="The region(s) that are to be rendered in the image."/>
                    <param name="decoration" type="const object" alias="View.PixelRegionDecoration" desc="A decorator that describes how the region(s) are to be rendered."/>
                    <return name="image" type="object" multiplicity="?" alias="Image" desc="RGB image with rendered overlay. Reference to input image."/>
                </function>
                <function name="drawProfile">
                    <trait>released</trait>
                    <keywords>rasterize, overlay, fill, plot, render, display, paint, print</keywords>
                    <links>Image.toRGB, Image.applyColormap, Image.drawShape, Image.drawPoint, Image.drawText, Image.drawPixelRegion, Image.drawProfileInplace</links>
                    <desc>Render one or several profiles into an image. The input image must be of either RGB or UINT8 type. Use Image.toRGB or Image.applyColormap to convert other image types to RGB. For profiles with 1D coordinates the coordinate vector is mapped to the x-axis of the image and the value vector to the y-axis. Each sample in the profile is then drawn in the image world coordinate system. For profiles with 2D coordinates the value vector is discarded and the profile is drawn on its coordinates in the image world coordinate system.

Note: This function differs from the View.addProfile function in that it does not provide the full graph plotting functionality as a dedicated graph viewer does, e.g., coordinate axes, background grids etc. are not rendered with the drawProfile function.
Color and line width properties are controlled using the View.GraphDecoration object. The two properties used for this are the GraphColor and DrawSize properties in the GraphDecoration object. No other properties in the GraphDecoration are currently supported.

Image world coordinate system handling:
The world coordinate system of the image if respected and each profile is drawn at the corresponding image position.

Missing data handling:
This function does not use the missing data flag.</desc>
                    <sample for="lua">image = Image.drawProfile(image, profiles, decoration)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image to render the profile(s) into. Supported image types are UINT8 and RGB."/>
                    <param name="profiles" type="const object" multiplicity="[1+]" alias="Profile" desc="The profile(s) that are to be rendered in the image."/>
                    <param name="decoration" type="const object" alias="View.GraphDecoration" desc="A decorator that describes how the profiles(s) are to be rendered. The DrawSize (line width) and GraphColor (line color) properties are supported."/>
                    <return name="image" type="object" multiplicity="?" alias="Image" desc="RGB image with rendered overlay."/>
                </function>
                <function name="drawProfileInplace">
                    <trait>released</trait>
                    <keywords>rasterize, overlay, fill, plot, render, display, paint, print</keywords>
                    <links>Image.toRGB, Image.applyColormap, Image.drawShape, Image.drawPoint, Image.drawText, Image.drawPixelRegion, Image.drawProfile</links>
                    <desc>Inplace version of the Image.drawProfile function which modifies the input image. See base function for full documentation.</desc>
                    <sample for="lua">image = Image.drawProfileInplace(image, profiles, decoration)</sample>
                    <param name="image" type="object" alias="Image" desc="The image to render the profile(s) into. Supported image type is RGB."/>
                    <param name="profiles" type="const object" multiplicity="[1+]" alias="Profile" desc="The profile(s) that are to be rendered in the image."/>
                    <param name="decoration" type="const object" alias="View.GraphDecoration" desc="A decorator that describes how the profiles(s) are to be rendered. The DrawSize (line width) and GraphColor (line color) properties are supported."/>
                    <return name="image" type="object" multiplicity="?" alias="Image" desc="RGB image with rendered overlay."/>
                </function>
                <function name="drawPointCloud">
                    <trait>released</trait>
                    <keywords>rasterize, overlay, fill, plot, render, display, paint, print</keywords>
                    <links>Image.toRGB, Image.applyColormap, Image.drawShape, Image.drawPoint, Image.drawText, Image.drawPixelRegion, Image.drawProfile, Image.drawPointCloudInplace</links>
                    <desc>Render one or several pointclouds into an image. The input image must be of either RGB or UINT8 type. Use Image.toRGB or Image.applyColormap to convert other image types to RGB. The x- and y- coordinates of each point in the pointcloud are used to place each point into the image world coordinate system.

Points are rendered using the information in the PointCloudDecoration object. The following properties in the PointCloudDecoration object are supported:
- The ZRange or IntensityRange parameters: If there is a ZRange set, the colors of the rendered points will be based on the z-values. Otherwise the intensity component of each point is used, either using the IntensityRange parameter or using the default range for intensity colors which is 0 to 1.

- The PointSize parameter.

Image world coordinate system handling:
The world coordinate system of the image if respected and each point in the pointcloud is drawn at the corresponding image position.

Missing data handling:
This function does not use the missing data flag.</desc>
                    <sample for="lua">image = Image.drawPointCloud(image, pointcloud, decoration)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image to render the point clouds(s) into. Supported image types are UINT8 and RGB."/>
                    <param name="pointcloud" type="const object" multiplicity="[1+]" alias="PointCloud" desc="The point clouds(s) that are to be rendered in the image."/>
                    <param name="decoration" type="const object" alias="View.PointCloudDecoration" desc="A decorator that describes how the point clouds(s) are to be rendered. Not all properties of the PointCloudDecoration object are supported, see the main function description."/>
                    <return name="image" type="object" multiplicity="?" alias="Image" desc="RGB image with rendered overlay."/>
                </function>
                <function name="drawPointCloudInplace">
                    <trait>released</trait>
                    <keywords>rasterize, overlay, fill, plot, render, display, paint, print</keywords>
                    <links>Image.drawPointCloud, Image.toRGB, Image.applyColormap, Image.drawShape, Image.drawPoint, Image.drawText, Image.drawPixelRegion, Image.drawProfile</links>
                    <desc>Inplace version of the Image.drawPointCloud function which modifies the input image. See base function for full documentation.</desc>
                    <sample for="lua">image = Image.drawPointCloudInplace(image, pointcloud, decoration)</sample>
                    <param name="image" type="object" alias="Image" desc="The image to render the point clouds(s) into. Supported image type is RGB."/>
                    <param name="pointcloud" type="const object" multiplicity="[1+]" alias="PointCloud" desc="The point clouds(s) that are to be rendered in the image."/>
                    <param name="decoration" type="const object" alias="View.PointCloudDecoration" desc="A decorator that describes how the point clouds(s) are to be rendered. Not all properties of the PointCloudDecoration object are supported, see the main function description."/>
                    <return name="image" type="object" multiplicity="?" alias="Image" desc="RGB image with rendered overlay."/>
                </function>
                <function name="drawText">
                    <trait>released</trait>
                    <keywords>rasterize, overlay, characters, letters, write, draw, plot, render, display, paint, print</keywords>
                    <links>View.addText, Image.renderText, Image.renderTextInplace, Image.drawShape, Image.drawPoint, Image.drawPixelRegion, Image.drawTextInplace</links>
                    <desc>Renders text into an image by modifying the pixel values. The input image must be of either RGB or UINT8 type. Use Image.toRGB or Image.applyColormap to convert other image types to RGB.
Not all features of the TextDecoration input are supported. Features that are supported are the following:
* Position - Fully supported.
* Color - Does not support opacity.
* Size - Approximately matching to viewer settings.
* Font family - SANSSERIF and SERIF are supported, MONOSPACE is unsupported.
* Font weight - Fully supported, but does not exactly match viewer behavior.
* Horizontal alignment - Full support apart from JUSTIFY, but does not exactly match viewer behavior.
* Vertical alignment - Fully supported, but does not exactly match viewer behavior

Image world coordinate system handling:
The image world coordinate system is copied from the input image, only the image content is changed. The font position will adjust to the image coordinate system, but the font size will only scale with the y-resolution.

Missing data handling:
This function does not use the missing data flag.</desc>
                    <sample for="lua">result = Image.drawText(image, text, decoration)</sample>
                    <param name="image" type="const object" multiplicity="1" alias="Image" desc="The image to render the text into. This image is overwritten with the rendered text. Supported image types are UINT8 and RGB."/>
                    <param name="text" type="string" desc="The characters that cannot be rendered using the specified font are replaced by question marks."/>
                    <param name="decoration" type="const object" alias="View.TextDecoration" desc="A decorator that describes how the text should be rendered."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="RGB image with rendered overlay."/>
                </function>
                <function name="drawTextInplace">
                    <trait>released</trait>
                    <keywords>rasterize, overlay, characters, letters, write, draw, plot, render, display, paint, print</keywords>
                    <links>View.addText, Image.renderText, Image.renderTextInplace, Image.drawShape, Image.drawPoint, Image.drawPixelRegion, Image.drawText</links>
                    <desc>Inplace version of the Image.drawText function that modifies the input image. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.drawTextInplace(image, text, decoration)</sample>
                    <param name="image" type="object" multiplicity="1" alias="Image" desc="The image to render the text into. This image is overwritten with the rendered text. Supported image type is RGB."/>
                    <param name="text" type="string" desc="The characters that cannot be rendered using the specified font are replaced by question marks."/>
                    <param name="decoration" type="const object" alias="View.TextDecoration" desc="A decorator that describes how the region(s) should be rendered."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="RGB image with rendered overlay. Reference to input image."/>
                </function>
                <function name="renderText">
                    <trait>released</trait>
                    <keywords>draw, characters, letters</keywords>
                    <links>Image.renderTextInplace, Image.drawText</links>
                    <desc>Renders text into an image by modifying the pixel values.

Image world coordinate system handling:
The image world coordinate system is copied from the input image, only the image content is changed. The font parameters and text position are in pixel units, i.e., not scaled with the world pixel sizes in x and y.

Missing data handling:
This function does not use the missing data flag.</desc>
                    <sample for="lua">image = Image.renderText(image, text, positionWorld, fontSizePix, fontThicknessPix, value)</sample>
                    <param name="image" type="object" alias="Image" desc="The image to render the text into. Supported image types are uint8, uint16, int8, int16, int32, float32, float64 and RGB."/>
                    <param name="text" type="string" desc="The characters that cannot be rendered using the specified font are replaced by question marks."/>
                    <param name="positionWorld" type="const object" alias="Point" desc="The position of the text inside the image, in world coordinates. The text is aligned to the bottom-left corner."/>
                    <param name="fontSizePix" type="int" desc="The font size in pixels."/>
                    <param name="fontThicknessPix" type="int" desc="The font line thickness radius in pixels. To calculate the overall thickness the following equation can be used: thickness=(fontThicknessPix*2+1)."/>
                    <param name="value" type="float" multiplicity="[1+]" desc="The text (intensity/color) value. In case the image type is RGB then an array of 3 elements (one per channel) must be provided."/>
                    <return name="image" type="object" multiplicity="?" alias="Image" desc="Image with rendered text"/>
                </function>
                <function name="renderTextInplace">
                    <trait>released</trait>
                    <keywords>draw, characters, letters</keywords>
                    <links>Image.renderText, Image.drawText</links>
                    <desc>Inplace version of the Image.renderText function that modifies the input image. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.renderTextInplace(image, text, positionWorld, fontSizePix, fontThicknessPix, value)</sample>
                    <param name="image" type="object" multiplicity="1" alias="Image" desc="The image to render the text into. This image is overwritten with the rendered text. Supported image types are uint8, uint16, int8, int16, int32, float32, float64 and RGB."/>
                    <param name="text" type="string" desc="The characters that cannot be rendered using the specified font are replaced by question marks."/>
                    <param name="positionWorld" type="const object" alias="Point" desc="The position of the text inside the image, in world coordinates. The text is aligned to the bottom-left corner."/>
                    <param name="fontSizePix" type="int" desc="The font size in pixels."/>
                    <param name="fontThicknessPix" type="int" desc="The font line thickness radius in pixels. To calculate the overall thickness the following equation can be used: thickness=(fontThicknessPix*2+1)."/>
                    <param name="value" type="float" multiplicity="[1+]" desc="The text (intensity/color) value. In case the image type is RGB then an array of 3 elements (one per channel) must be provided."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="concatenate">
                    <trait>released</trait>
                    <keywords>join, union</keywords>
                    <links>Image.pad</links>
                    <desc>Concatenates two images.

Image world coordinate system handling:
The image world coordinate system is used to update the output image origin. The new origin depends on how image2 is placed in relation to image1 (direction), the different possibilities are:
- ABOVE (Oxout, Oyout, Ozout) =  (Oximage1, Oyimage1-image2Height*image2PixelSizeY, Ozimage1)
- BELOW (Oxout, Oyout, Ozout) =  (Oximage1, Oyimage1, Ozimage1)
- RIGHT (Oxout, Oyout, Ozout) =   (Oximage1, Oyimage1, Ozimage1)
- LEFT (Oxout, Oyout, Ozout) =   (Oximage1-image2Width*image2PixelSizeX, Oyimage1, Ozimage1)
Both input images must have the same pixel size, inherited by the output image.

Missing data handling:
The output image missing data flag is inherited from image1.</desc>
                    <sample for="lua">local imageOut = Image.concatenate(image1, image2, 1)</sample>
                    <param name="image1" type="const object" alias="Image" desc="The first image."/>
                    <param name="image2" type="const object" alias="Image" desc="The second image."/>
                    <param name="direction" type="enum" multiplicity="?" ref="ConcatenationDirection" desc="The direction of the concatenation, i.e. where to place image2 in relation to image1, default is to the right of image1."/>
                    <return name="imageOut" type="object" multiplicity="?" alias="Image" desc="The concatenated image."/>
                </function>
                <function name="bilateral">
                    <trait>released</trait>
                    <keywords>denoise, filter, sigma, gauss, edge preserving</keywords>
                    <links>Image.gauss, Image.blur, Image.median, Image.convolve</links>
                    <desc>Applies a bilateral filter to an image. The bilateral filter is similar to a Gauss filter but it also adaptively modifies the filter kernel to avoid smoothing over image boundaries.

Image world coordinate system handling:
The kernel size in the range/z-dimension is interpreted in world scale, e.g., millimeters, it is internally divided by the z-pixelsize to get raw pixel value thresholds. The output image inherits the image world coordinates.

Missing data handling:
This function does not handle missing data images. Fill in the missing data pixels and/or remove the missing data flag from the image before calling.</desc>
                    <sample for="lua">filteredImage = Image.bilateral(image, kernelSizeSpatialPix, kernelSizeRange)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image. Supported image types are uint8, float32 and rgb24."/>
                    <param name="kernelSizeSpatialPix" type="int" desc="Size of the kernel in pixels, must be positive and odd."/>
                    <param name="kernelSizeRange" type="float" desc="Range of intensity values that affect the filtering, must be positive."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. If supplied, the filter operation is only performed within the bounding box of its region. This can save a lot of computation time, if the region is small. Output pixel values outside the region are undefined."/>
                    <return name="filteredImage" type="object" multiplicity="?" alias="Image" desc="Filtered image"/>
                </function>
                <function name="equalizeHistogram">
                    <trait>released</trait>
                    <keywords>scale, normalize, stretch, contrast, intensity</keywords>
                    <links>Image.normalize</links>
                    <desc>Applies histogram equalization to an image.</desc>
                    <sample for="lua">equalizedImage = Image.equalizeHistogram(image)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image. Only uint8 type supported."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. If supplied, the operation is only performed within the bounding box of its region. This can save a lot of computation time, if the region is small."/>
                    <return name="equalizedImage" type="object" multiplicity="?" alias="Image" desc="Equalized image"/>
                </function>
                <function name="distanceTransform">
                    <trait>released</trait>
                    <keywords>euclidian, chamfer, manhattan, skeleton</keywords>
                    <links>Image.thin</links>
                    <desc>Applies the distance transform operation on the input image. Each pixel in the output image gives the approximate Euclidean distance to the closest background pixel (value = 0) in the input image. Typically the input image is a binarized image with 0:s representing the background and some other value (e.g. 1 or 255) representing the foreground. Currently only the uint8 pixel type is supported.

Image world coordinate system handling:
The image world coordinate system is not considered in this function. The distances in the output image are in pixel units, i.e., not scaled with the world pixel sizes in x and y. The output image inherits the image world coordinate system of the input image in the x,y dimensions, but the z-origin is set to 0 and the z-pixelsize is set to 1 regardless of the input values.

Missing data handling:
The function does not consider the missing data flag of the input image. The missing data flag of the output will be set to false, i.e., no missing data.</desc>
                    <sample for="lua">distanceImage = Image.distanceTransform(image)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image, expected to be binary. Only uint8 type supported."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. If supplied, the operation is only performed within the bounding box of its region. This can save a lot of computation time, if the region is small. Output pixel values outside the region are undefined."/>
                    <return name="distanceImage" type="object" multiplicity="?" alias="Image" desc="Distance image with approximate Euclidean distance values, float32 type."/>
                </function>
                <function name="normalize">
                    <trait>released</trait>
                    <keywords>equalize, scale, stretch, intensity, contrast</keywords>
                    <links>Image.equalizeHistogram, Image.multiplyConstant, Image.multiplyAddConstant, Image.toType</links>
                    <desc>Scales the raw pixel values linearly so that all pixels fit into a given range (lowerBound, upperBound). Keeps the world values constant. Target bounds outside the representable range of the image type are accepted. In that case, pixel values are clamped to the representable range.

Image world coordinate system handling:
The world coordinate system of the output image along the value axis z is chosen such that the world pixel values remains unchanged unless clamping occurs. For integer type images, rounding to integer raw pixel values will change the world values slightly. Other meta data are copied from the input image.

Missing data handling:
Pixels with missing data remain marked as missing in the output. For images with the missing data flag set, raw pixel values are clamped to 1 instead of 0 to avoid introducing more pixels marked as missing.</desc>
                    <sample for="lua">normalizedImage = Image.normalize(image)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image. Supported image types are uint8, uint16, int8, int16, int32, float32 and float64."/>
                    <param name="lowerBound" type="float" multiplicity="?" desc="Lower bound (raw pixel value). Default value is minimum value of underlying datatype."/>
                    <param name="upperBound" type="float" multiplicity="?" desc="Upper bound (raw pixel value). Default value is maximum value of underlying datatype."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. If supplied, the operation is only performed within the bounding box of its region. This can save a lot of computation time, if the region is small."/>
                    <return name="normalizedImage" type="object" multiplicity="?" alias="Image" desc="Normalized image"/>
                </function>
                <function name="thin">
                    <trait>released</trait>
                    <keywords>skeleton, morphology</keywords>
                    <links>Image.PixelRegion.thin</links>
                    <desc>Applies a morphological thinning, also known as skeletonization, using the Guo-Hall algorithm. It is typically performed on an already binarized input image. Zeros in the input image (raw pixel value) are interpreted as background pixels.
Note: The algorithm can be slow for large images with many non-zeros (large binary objects). Consider operating on regions of interest if possible. Pixels outside the region of interest may be set to any value.

The output is a binary image with the skeleton indicated by pixels set to 1.

Image world coordinate system handling:
The image world coordinate system is not considered in this function. The output image inherits the x,y origin and x,y pixelsize. The z-origin should be set to 0 and z-pixelsize to 1 in the input image.

Missing data handling:
The missing data flag should be cleared in the input image and is cleared in the output image.</desc>
                    <sample for="lua">skeletonImage = Image.thin(image)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image, expected to be binary. Supported image types are uint8 and uint16."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. If supplied, the operation is only performed within the bounding box of its region. This can save a lot of computation time, if the region is small."/>
                    <return name="skeletonImage" type="object" multiplicity="?" alias="Image" desc="Skeleton image."/>
                </function>
                <function name="transform">
                    <trait>released</trait>
                    <keywords>warp, rotate, shift, scale, linear, shear</keywords>
                    <links>Image.transformInto, Image.rotate, Image.resize, Image.resizeFactor, Image.warpSector, Image.crop, Image.cropRectify, Image.Calibration.Correction</links>
                    <desc>Applies a linear geometric transform to an image. The result image uses the same pixel grid as the input image, if the SAME output grid is selected.

Image world coordinate system handling:
If the image has a non-default image world coordinate system, for example after calibration or in a height map, distance or range image, the operation is interpreted in image world coordinate units, e.g., millimeters. The image metadata is copied from the input image and the transformed image is by default (output grid SAME) repainted onto this coordinate system. Using output grid FULL, the output image size and origin is set to fit the entire output.

Missing data handling:
If using LINEAR as the method input, for an image with missing data, a missing data aware operation is performed. In situations were only one value is missing in the source image the target image is interpolated using the other valid samples. In cases with more than one missing value, missing data is returned in the output image. For method NEAREST missing data will remain if it is the nearest neighbor of the transformed pixels in the source image.</desc>
                    <sample for="lua">transformedImage = Image.transform(image, transform, method)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image."/>
                    <param name="transform" type="const object" alias="Transform" desc="A linear transform defined by a Transform object."/>
                    <param name="method" type="enum" multiplicity="?" ref="InterpolationMethod" desc="The resampling method. Default is NEAREST."/>
                    <param name="grid" type="enum" multiplicity="?" ref="OutputGrid" desc="The pixel grid to use for the output, default is SAME, the same as the input image."/>
                    <return name="transformedImage" type="object" multiplicity="?" alias="Image" desc="Transformed image."/>
                </function>
                <function name="transformInto">
                    <trait>released</trait>
                    <keywords>warp, rotate, shift, scale, linear, shear</keywords>
                    <links>Image.transform, Image.rotate, Image.resize, Image.resizeFactor, Image.warpSector, Image.crop, Image.cropRectify, Image.Calibration.Correction</links>
                    <desc>Applies a linear geometric transform to an image and writes the result into the pixel grid defined by the destination image. The pixel grid and coordinate system of the destination image is used for transform operation. Compared to the Image.transform function, this function gives a higher degree of control over the following parameters:
- The size of the output image
- The pixel sizes of the output image
- The world origin of the output image

All the above properties are set by the input destination image.
For example, a unit transform where the destination image has a world coordinate system different from the input image will resample the image.

Image world coordinate system handling:
If the image or destination image has a non-default image world coordinate system, for example after calibration or in a height map, distance or range image, the operation is interpreted in image world coordinate units, e.g., millimeters. The image metadata is kept in the destination image and the transformed image is painted onto this coordinate system.

Missing data handling:
If using LINEAR as the method input, for an image with missing data, a missing data aware operation is performed. In situations were only one value is missing in the source image the target image is interpolated using the other valid samples. In cases with more than one missing value, missing data is returned in the output image. For method NEAREST missing data will remain if it is the nearest neighbor of the transformed pixels in the source image. The missing data flags of the input and destination images must match.</desc>
                    <sample for="lua">transformedImage = Image.transformInto(sourceImage, transform, destinationImage, method)</sample>
                    <param name="sourceImage" type="const object" alias="Image" desc="Source image."/>
                    <param name="transform" type="const object" alias="Transform" desc="A linear transform defined by a Transform object."/>
                    <param name="destinationImage" type="object" alias="Image" desc="Destination image, the output will be placed into this image. The image size, pixels sizes and world origin from this image are used."/>
                    <param name="method" type="enum" multiplicity="?" ref="InterpolationMethod" desc="The resampling method. Default is NEAREST."/>
                    <return name="transformedImage" type="object" multiplicity="?" alias="Image" desc="A reference to the input destinationImage. Nil on failure."/>
                </function>
                <function name="transformInto3D">
                    <trait>released</trait>
                    <keywords>warp, rotate, shift, scale, linear, shear</keywords>
                    <links>Image.transform, Image.transformInto, Image.rotate, Image.resize, Image.resizeFactor, Image.warpSector, Image.crop, Image.Calibration.Correction</links>
                    <desc>Applies a 3D linear geometric transform to an image and writes the result into the pixel grid defined by the destination image. Compared to the transformInto function, this function adds the possibility for 3D tilts. The function is typically used for heightmap image data.

The pixel grid and coordinate system of the destination image are used for the transform operation. Compared to the Image.transform function, this function gives a higher degree of control over the following parameters:
- The size of the output image
- The pixel sizes of the output image
- The world origin of the output image

All the above properties are set by the input destination image.
For example, a unit transform where the destination image has a world coordinate system different from the input image will resample the image.

Image world coordinate system handling:
If the image or reference image has a non-default image world coordinate system, for example after calibration or in a height map, distance or range image, the operation is interpreted in image world coordinate units, e.g., millimeters. The image metadata is copied from the reference image and the transformed image is repainted onto this coordinate system.

Missing data handling:
If using LINEAR as the method input, for an image with missing data, a missing data aware operation is performed. In situations were only one value is missing in the source image the target image is interpolated using the other valid samples. In cases with more than one missing value, missing data is returned in the output image. For method NEAREST missing data will remain if it is the nearest neighbor of the transformed pixels in the source image.</desc>
                    <sample for="lua">transformedImage = Image.transformInto3D(sourceImage, transform, destinationImage, method)</sample>
                    <param name="sourceImage" type="const object" alias="Image" desc="Source image."/>
                    <param name="transform" type="const object" alias="Transform" desc="A linear affine 3D transform defined by a Transform object."/>
                    <param name="destinationImage" type="object" alias="Image" desc="Destination image, the output will be placed into this image. The image size, pixels sizes and world origin from this image are used."/>
                    <param name="method" type="enum" multiplicity="?" ref="InterpolationMethod" desc="The resampling method. Default is NEAREST."/>
                    <param name="splatX" type="int" multiplicity="?" desc="The influence distance of a source point in the target image x direction. Default is 3."/>
                    <param name="splatY" type="int" multiplicity="?" desc="The influence distance of a source point in the target image y direction. Defaults to splatX if unset."/>
                    <param name="clearTarget" type="bool" multiplicity="?" desc="Select if the destinationImage should be reset to missing data before transforming the source image into it."/>
                    <return name="transformedImage" type="object" multiplicity="?" alias="Image" desc="A reference to the input destinationImage. Nil on failure."/>
                </function>
                <function name="resize">
                    <trait>released</trait>
                    <keywords>scale, downsample, resample, subsample, upsample, decimate, transform</keywords>
                    <links>Image.resizeScale, Image.transform, Image.toSquarePixels, Image.Pyramid</links>
                    <desc>Resizes an image to a given size in pixels. Different interpolation methods can be used.

Image world coordinate system handling:
The coordinate system of the output image will be slightly adjusted in relation to the input to take into account pixel size changes. Eg. both the origin and pixel size of the image will typically change. World positions in the image should be retained such that for example overlay graphics can remain on the same position after a rescaling. Values in z, both origin and pixel size, are copied directly from the input image.

Missing data handling:
If using LINEAR as the method input, for an image with missing data, a missing data aware operation is performed. In situations were only one value is missing in the source image the target image is interpolated using the other valid samples. In cases with more than one missing value, missing data is returned in the output image. For method NEAREST missing data will remain if it is the nearest neighbor of the transformed pixels in the source image.</desc>
                    <sample for="lua">resizedImage = Image.resize(image, 300, 400, "LINEAR")</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image"/>
                    <param name="width" type="int" desc="The width of the result"/>
                    <param name="height" type="int" desc="The height of the result."/>
                    <param name="method" type="enum" multiplicity="?" ref="InterpolationMethod" desc="The resampling method. Default is LINEAR."/>
                    <return name="resizedImage" type="object" multiplicity="?" alias="Image" desc="Image with new size."/>
                </function>
                <function name="resizeScale">
                    <trait>released</trait>
                    <keywords>scale, downsample, resample, subsample, upsample, decimate, transform</keywords>
                    <links>Image.resize, Image.transform, Image.toSquarePixels, Image.Pyramid</links>
                    <desc>Resizes an image by a scale factor. Different interpolation methods can be used.

Image world coordinate system handling:
The coordinate system of the output image will be slightly adjusted in relation to the input to take into account pixel size changes. Eg. both the origin and pixel size of the image will typically change. World positions in the image should be retained such that for example overlay graphics can remain on the same position after a rescaling. Values in z, both origin and pixel size, are copied directly from the input image.

Missing data handling:
If using LINEAR as the method input, for an image with missing data, a missing data aware operation is performed. In situations were only one value is missing in the source image the target image is interpolated using the other valid samples. In cases with more than one missing value, missing data is returned in the output image. For method NEAREST missing data will remain if it is the nearest neighbor of the transformed pixels in the source image.</desc>
                    <sample for="lua">resizedImage = Image.resizeScale(image, 1.5, 1.5, "LINEAR")</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image"/>
                    <param name="fx" type="float" desc="Scaling factor along the x-axis."/>
                    <param name="fy" type="float" multiplicity="?" desc="Scaling factor along the y-axis. Optional, if omitted the same as the x-scale is used."/>
                    <param name="method" type="enum" multiplicity="?" ref="InterpolationMethod" desc="The resampling method. Default is LINEAR."/>
                    <return name="resizedImage" type="object" multiplicity="?" alias="Image" desc="Image with new size."/>
                </function>
                <function name="toSquarePixels">
                    <trait>released</trait>
                    <keywords>anisotropic, resample, scale, transform</keywords>
                    <links>Image.transform, Image.resize, Image.resizeScale</links>
                    <desc>Resizes an image to have square pixels, i.e., to have equal pixelsizes in the x and y dimensions. Having square pixels is sometimes required for further processing.

Image world coordinate system handling:
The coordinate system of the output image will be slightly adjusted in relation to the input to take into account pixel size changes. Eg. both the origin and pixel size of the image will typically change. World positions in the image should be retained such that for example overlay graphics can remain on the same position after a rescaling. Values in z, both origin and pixel size, will be copied directly from the input image.

Missing data handling:
If using LINEAR as the method input, for an image with missing data, a missing data aware operation is performed. In situations were only one value is missing in the source image the target image is interpolated using the other valid samples. In cases with more than one missing value, missing data is returned in the output image. For method NEAREST missing data will remain if it is the nearest neighbor of the transformed pixels in the source image.</desc>
                    <sample for="lua">squarePixelImage = Image.toSquarePixels(image)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image"/>
                    <param name="upsample" type="bool" multiplicity="?" desc="Select if to upsample one axis or downsample the other. Default is false."/>
                    <param name="method" type="enum" multiplicity="?" ref="InterpolationMethod" desc="The resampling method. Default is LINEAR."/>
                    <return name="squarePixelImage" type="object" multiplicity="?" alias="Image" desc="Image with square pixels."/>
                </function>
                <function name="rotate">
                    <trait>released</trait>
                    <links>Image.rotate90, Image.transform, Image.mirror, Image.cropRectify</links>
                    <desc>Rotates an image around the center of the image. Optionally a different origin of rotation can be specified.

Image world coordinate system handling:
If the image has a non-default image world coordinate system, for example after calibration or in a height map, distance or range image, the operation is interpreted in image world coordinate units, e.g., millimeters. The image metadata is copied from the input image and the transformed image is by default (output grid SAME) repainted onto this coordinate system. Using output grid FULL, the output image size and origin is set to fit the entire output.

Missing data handling:
If using LINEAR as the method input, for an image with missing data, a missing data aware operation is performed. In situations were only one value is missing in the source image the target image is interpolated using the other valid samples. In cases with more than one missing value, missing data is returned in the output image. For method NEAREST missing data will remain if it is the nearest neighbor of the transformed pixels in the source image.</desc>
                    <sample for="lua">rotatedImage = Image.rotate(image, rotationRad)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image"/>
                    <param name="rotationRad" type="float" desc="Rotation in radians. As the image has a left-handed coordinate system, a positive rotation is in a counter clockwise direction."/>
                    <param name="origin" type="const object" multiplicity="?" alias="Point" desc="Optional origin of rotation if other than center of image. Represented as a 2D Point type."/>
                    <param name="method" type="enum" multiplicity="?" ref="InterpolationMethod" desc="The resampling method."/>
                    <param name="grid" type="enum" multiplicity="?" ref="OutputGrid" desc="The pixel grid to use for the output, default is SAME, the same as the input image."/>
                    <return name="rotatedImage" type="object" multiplicity="?" alias="Image" desc="The rotated image."/>
                </function>
                <function name="rotate90">
                    <trait>released</trait>
                    <links>Image.rotate, Image.transform, Image.mirror</links>
                    <desc>Rotates an image +90, -90 or 180 degrees. A positive rotation is in the clockwise direction. The pixels are rearranged and no interpolation takes place, making the operation faster than a general rotation.

Image world coordinate system handling:
For plus and minus 90 degree rotations, the x- and y-pixel sizes are swapped so that the width and height are also swapped. The image origin is copied from the input image.

Missing data handling:
Missing data is rotated in the same way as the input image.</desc>
                    <sample for="lua">rotatedImage = Image.rotate90(image, rotationSteps)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image"/>
                    <param name="rotationSteps" type="int" desc="The number of 90-degree steps to rotate the image in, e.g. -1, 1 or 2. Other integers are allowed, representing the same rotations. A positive rotation is in a clockwise direction."/>
                    <return name="rotatedImage" type="object" multiplicity="?" alias="Image" desc="The rotated image."/>
                </function>
                <function name="mirror">
                    <trait>released</trait>
                    <keywords>flip</keywords>
                    <links>Image.transform, Image.rotate, Image.rotate90</links>
                    <desc>Mirrors an image in the horizontal or vertical axis.

Image world coordinate system handling:
The image world coordinate system is copied from the input image, only the image content is mirrored.

Missing data handling:
All missing data values will be retained after mirroring.</desc>
                    <sample for="lua">mirroredImage = Image.mirror(image, mirrorHorizontally)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image."/>
                    <param name="mirrorHorizontally" type="bool" desc="Set to true to mirror horizontally in the vertical axis, set to false to mirror vertically in the horizontal axis."/>
                    <return name="mirroredImage" type="object" multiplicity="?" alias="Image" desc="The mirrored image"/>
                </function>
                <function name="warpSector">
                    <trait>released</trait>
                    <keywords>unwrap, rectify</keywords>
                    <links>Image.transform, Image.cropRectify</links>
                    <desc>Warps the inner area of a sector shape to a rectilinear Cartesian grid.</desc>
                    <sample for="lua">warpedImage = Image.warpSector(image, sector, interpolation)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image."/>
                    <param name="sector" type="const object" alias="Shape" desc="A sector shape defining the area in the source image to warp from."/>
                    <param name="interpolation" type="enum" multiplicity="?" ref="InterpolationMethod" desc="Interpolation method to use. Currently only LINEAR is available."/>
                    <return name="warpedImage" type="object" multiplicity="?" alias="Image" desc="The warped image, or nil on failure."/>
                </function>
                <function name="toHSV">
                    <trait>released</trait>
                    <keywords>color, hue, saturation, HSL, RGB</keywords>
                    <links>Image.toGray, Image.toRGB, Image.splitRGB, Image.toLab</links>
                    <desc>Converts an RGB image into individual HSV color space components. The Hue-component is usually represented as an angle in the interval [0,360], but to fit in a uint8 image the value is divided by 2 to be in the interval [0,180].</desc>
                    <sample for="lua">imageH, imageS, imageV = Image.toHSV(imageRGB)</sample>
                    <param name="imageRGB" type="const object" multiplicity="1" alias="Image" desc="RGB image (8-bit) to convert."/>
                    <return name="imageH" type="object" multiplicity="?" alias="Image" desc="Hue image, uint8 pixel type and in range [0,180]"/>
                    <return name="imageS" type="object" multiplicity="?" alias="Image" desc="Saturation image, uint8 pixel type and in range [0,255]"/>
                    <return name="imageV" type="object" multiplicity="?" alias="Image" desc="Value image, uint8 pixel type and in range [0,255]"/>
                </function>
                <function name="toLab">
                    <trait>released</trait>
                    <keywords>color, RGB</keywords>
                    <links>Image.toGray, Image.toRGB, Image.splitRGB, Image.toHSV</links>
                    <desc>Converts an RGB image into individual Lab color space components.</desc>
                    <sample for="lua">imageL, imageA, imageB = Image.toLab(imageRGB)</sample>
                    <param name="imageRGB" type="const object" multiplicity="1" alias="Image" desc="RGB image (8-bit) to convert."/>
                    <return name="imageL" type="object" multiplicity="?" alias="Image" desc="Lightness image, uint8 pixel type and in range [0,255]"/>
                    <return name="imageA" type="object" multiplicity="?" alias="Image" desc="'a' color component image, uint8 pixel type and in range [1,255]"/>
                    <return name="imageB" type="object" multiplicity="?" alias="Image" desc="'b' color component image, uint8 pixel type and in range [1,255]"/>
                </function>
                <function name="toType">
                    <trait>released</trait>
                    <keywords>grey, conversion, RGB</keywords>
                    <links>Image.splitRGB, Image.toRGB</links>
                    <desc>Converts an image to a new image of specified pixel type. The raw pixel values are casted and there may be underflow/overflow effects when casting to a type of lower capacity. For example, the value 256 in a uint16 image will overflow to 0 if converted to a uint8 type. To avoid such effects, clamp the input pixel values to the min and max values of the target pixel type. When converting from a monochrome image to RGB, all channels are set to the same value. Use toRGB to convert three monochrome images into a color image or splitRGB to split a color image into three monochrome images.</desc>
                    <sample for="lua">local convertedImage = Image.toType(image, "UINT8")</sample>
                    <param name="image" type="const object" alias="Image" desc="The image to be converted."/>
                    <param name="type" type="enum" ref="ImageType" desc="The pixel type, e.g., UINT8, INT16, FLOAT64, RGB24)."/>
                    <return name="convertedImage" type="object" multiplicity="?" alias="Image" desc="Returns the image of specified type or nil."/>
                </function>
                <function name="toTypeFit">
                    <trait>released</trait>
                    <keywords>grey, conversion, scaling, visualization, plotting</keywords>
                    <links>Image.toType</links>
                    <desc>Converts a gray value image into another gray value image of a different type. The input image values are rescaled to fit the target type.
For integer images without missing data the min and max values provided are mapped to the limits of the data type. World values outside of these limits in the input image are clamped to the min and max of the data type.
For integer images with missing data the clamping option allows to either discard values that are out of range or to clamp them to the limits in the same way as for non-missing data images. Set clamping to false to discard values.
For float images the min and max value provided will be mapped to 0 and 1. The clamping option selects if values outside the provided interval should clamp or be allowed to extend beyond the range 0 and 1.

Image world coordinate system handling:
The boundaries are provided in world coordinates of the input image. The output image is updated with an adjusted world coordinate system that as closely as possible maintain the absolute world values of the input in the result.

Missing data handling:
For missing data images missing data is preserved. Note that for a missing data type input only unsigned integer output types are allowed. If clamping is set to false values outside the selected range are set to missing.</desc>
                    <sample for="lua">imageGray = Image.toTypeFit(image, "UINT8")</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image to convert."/>
                    <param name="targetType" type="enum" ref="ImageType" desc="The target pixel type."/>
                    <param name="minValue" type="float" multiplicity="?" desc="The lowest value in world units in the source image to keep in the result. Default is the smallest representable value of the target type or zero for float targets."/>
                    <param name="maxValue" type="float" multiplicity="?" desc="The highest value in world units in the source image to keep in the result. Default is the largest representable value of the target type or one for float targets."/>
                    <param name="clamp" type="bool" multiplicity="?" desc="Decide how to handle values that are out of range for missing data images. Default is true."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Converted image. Nil on failure."/>
                </function>
                <function name="toGray">
                    <trait>released</trait>
                    <keywords>grey, RGB</keywords>
                    <links>Image.toType, Image.toRGB, Image.splitRGB</links>
                    <desc>Converts an RGB image into a gray value image.</desc>
                    <sample for="lua">imageGray = Image.toGray(imageRGB)</sample>
                    <param name="imageRGB" type="const object" multiplicity="1" alias="Image" desc="RGB image (8-bit) to convert."/>
                    <return name="imageGray" type="object" multiplicity="?" alias="Image" desc="Gray value image of uint8 pixel type."/>
                </function>
                <function name="splitRGB">
                    <trait>released</trait>
                    <keywords>color</keywords>
                    <links>Image.toRGB, Image.toType</links>
                    <desc>Splits an RGB image into the individual R, G, B color components. The input RGB image must be of 8-bit RGB type.</desc>
                    <sample for="lua">imageR, imageG, imageB = Image.splitRGB(imageRGB)</sample>
                    <param name="imageRGB" type="const object" multiplicity="1" alias="Image" desc="RGB image (8-bit) to convert."/>
                    <return name="imageR" type="object" multiplicity="?" alias="Image" desc="Red component as image."/>
                    <return name="imageG" type="object" multiplicity="?" alias="Image" desc="Green component as image."/>
                    <return name="imageB" type="object" multiplicity="?" alias="Image" desc="Blue component as image."/>
                </function>
                <function name="toRGB">
                    <trait>released</trait>
                    <keywords>color</keywords>
                    <links>Image.splitRGB, Image.toType</links>
                    <desc>Creates an RGB image from three grayscale images. The input images must be of uint8 type.</desc>
                    <sample for="lua">imageRGB = Image.toRGB(imageR, imageG, imageB, colorSpace)</sample>
                    <param name="imageR" type="const object" multiplicity="1" alias="Image" desc="Gray value image of uint8 type."/>
                    <param name="imageG" type="const object" multiplicity="1" alias="Image" desc="Gray value image of uint8 type."/>
                    <param name="imageB" type="const object" multiplicity="1" alias="Image" desc="Gray value image of uint8 type."/>
                    <param name="colorSpace" type="enum" ref="ColorSpace" desc="The color space the input images represent."/>
                    <return name="imageRGB" type="object" multiplicity="?" alias="Image" desc="RGB image (8-bit)."/>
                </function>
                <function name="toPointCloud">
                    <trait>released</trait>
                    <keywords>extrude</keywords>
                    <links>Image.PixelRegion.toPoints3D</links>
                    <desc>Creates a pointcloud from image(s).
Typically one heightmap input image is used in which the pixel pitch is constant in each dimension.
The alternative use cases are to supply separate images for either x and z or for x, y and z coordinates. In total there are three ways this can be used:

1. Image.toPointCloud(range, true/false, intensity, region)
2. Image.toPointCloud({X, Z}, true/false, intensity, region)
3. Image.toPointCloud({X, Y, Z}, true/false, intensity, region)

In case 1 the pixel sizes and origin of the range image is used to create the X and Y coordinates.
In case 2 the pixel sizes and origin of of Z is used to create the Y coordinates in the output.
In case 3 all positions are uniquely determined by the input images X, Y and Z. Pixel sizes and origin in the input images are unused.

The intensity and region inputs are optional and can be used to set the intensity of the output pointcloud and to remove points respectively.

Image world coordinate system handling:
in general the image world coordinate system is used to create the pointcloud, i.e. the (x, y, z)-pixel sizes and origins are used to create the (x, y, z)-components of the pointcloud. For details see the longer text above.

Missing data handling:
For images with missing data it is possible to select to keep or remove the missing points. If missing points are kept they are marked as such in the pointcloud and will be black in intensity. If they are removed the grid structure of the image is lost and the point cloud will be considered an unordered point cloud.</desc>
                    <sample for="lua">local pointcloud = Image.toPointCloud(image, removeMissing, intensity, region)</sample>
                    <param name="image" type="const object" multiplicity="[1+]" alias="Image" desc="The source image(s) with range/depth information. Either one range image or 3 coordinate images (X, Y and Z)."/>
                    <param name="removeMissing" type="bool" multiplicity="?" desc="Select if points that are missing data should be removed or not. For images without missing data this has no effect. Default is false."/>
                    <param name="intensity" type="const object" multiplicity="?" alias="Image" desc="Optional uint8 image that will be used for intensity information for each point. The pixel values are divided by 255 to create a number in the range [0,1] for the pointcloud intensity."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional PixelRegion. If supplied, only points within the region are converted."/>
                    <return name="pointcloud" type="object" multiplicity="?" alias="PointCloud" desc="The resulting pointcloud."/>
                </function>
                <function name="toMesh">
                    <trait>released</trait>
                    <keywords>polygon mesh, triangle mesh</keywords>
                    <links>View.addMesh, Image.toPointCloud</links>
                    <desc>Creates a mesh from an image. The image values are interpreted in world units and are used to create one vertex from each pixel.

The intensity input is optional and can be used to set the intensity of the mesh. The mesh intensities are represented as values between 0 and 1. To use a UINT8 image as source set the pixel size in z to 1/255.
The color input is also optional and must be an image of RGB type. It can be used alone or together with the intensity input.
The final mesh color is a mix of the intensity and color data such that the final color is intensity*color.

Image world coordinate system handling:
The image world coordinate system is used to create the mesh, i.e. the (x, y, z)-pixel sizes and origins are used to create the (x, y, z)-vertices of the mesh.

Missing data handling:
For images with missing data the missing values will be represented as mesh coordinates with the z value set to nan.</desc>
                    <sample for="lua">local mesh = Image.toMesh(image, true, intensity, color)</sample>
                    <param name="image" type="const object" alias="Image" desc="The source image with range/depth information."/>
                    <param name="calcNormals" type="bool" multiplicity="?" desc="Select if normals should be estimated from the image. Default is false."/>
                    <param name="intensity" type="const object" multiplicity="?" alias="Image" desc="Optional image that will be used for intensity at each point. The values are interpreted in world coordinates. Default is 1.0 for all points."/>
                    <param name="color" type="const object" multiplicity="?" alias="Image" desc="Optional image that will be used for color at each point. Default is white (255,255,255)."/>
                    <return name="mesh" type="object" multiplicity="?" alias="Mesh" desc="The resulting mesh."/>
                </function>
                <function name="add">
                    <trait>released</trait>
                    <keywords>sum, arithmetic</keywords>
                    <links>Image.addInplace, Image.addConstant, Image.addConstantInplace</links>
                    <desc>Adds two images pixelwise. The images must be of equal size and pixel type. If there is underflow or overflow in the arithmetic operation, the output pixel value is clamped to the min and max limit of the pixel type, with an exception for images containing missing data, see below.

Image world coordinate system handling:
The first input image is treated as the main image whose metadata is copied to the output image. The operation is interpreted as operating on the world z-coordinate values. Pixel sizes and origins in the x- and y-dimensions are not considered and have no effect on the operation.

Missing data handling:
A missing data pixel in any of the two input images generates a missing data pixel in the output image. For missing data images, as the value 0 is reserved, clamping to 1 instead of 0 is done for underflows and when the pixel type is unsigned integer.</desc>
                    <sample for="lua">result = Image.add(image1, image2)</sample>
                    <param name="image1" type="const object" multiplicity="1" alias="Image" desc="The first source image."/>
                    <param name="image2" type="const object" multiplicity="1" alias="Image" desc="The second source image."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="The sum image."/>
                </function>
                <function name="addInplace">
                    <trait>released</trait>
                    <keywords>sum, arithmetic</keywords>
                    <links>Image.add, Image.addConstant, Image.addConstantInplace</links>
                    <desc>Inplace version of the Image.add function which modifies the first input image to contain the sum of the input images. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.addInplace(image1, image2)</sample>
                    <param name="image1" type="object" multiplicity="1" alias="Image" desc="The first source image. This image is overwritten with the sum."/>
                    <param name="image2" type="const object" multiplicity="1" alias="Image" desc="The second source image."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="subtract">
                    <trait>released</trait>
                    <keywords>minus, difference, arithmetic</keywords>
                    <links>Image.subtractInplace, Image.difference</links>
                    <desc>Subtracts two images pixelwise. The images must be of equal size and pixel type. If there is underflow or overflow in the arithmetic operation, the output pixel value is clamped to the min and max limit of the pixel type, with an exception for images containing missing data, see below.

Image world coordinate system handling:
The first input image is treated as the main image whose metadata is copied to the output image. The operation is interpreted as operating on the world z-coordinate values. Pixel sizes and origins in the x- and y-dimensions are not considered and have no effect on the operation.

For unsigned integer types it can be useful to first apply Image.adjustOriginZ() to image1 to avoid clamping the results to 0. For images A, B subtracting B from A would cause clamping when values in B are larger than those in A by such a large amount that the difference exceeds the Z-origin of A. By adjusting the origin of A to a smaller value this can be remedied.

Missing data handling:
A missing data pixel in any of the two input images generates a missing data pixel in the output image. For missing data images, as the value 0 is reserved, clamping to 1 instead of 0 is done for underflows and when the pixel type is unsigned integer.</desc>
                    <sample for="lua">result = Image.subtract(image1, image2)</sample>
                    <param name="image1" type="const object" multiplicity="1" alias="Image" desc="The first source image."/>
                    <param name="image2" type="const object" multiplicity="1" alias="Image" desc="The second source image."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="The difference image."/>
                </function>
                <function name="subtractInplace">
                    <trait>released</trait>
                    <keywords>minus, difference, arithmetic</keywords>
                    <links>Image.subtract, Image.difference</links>
                    <desc>Inplace version of the Image.subtract function which modifies the first input image to contain the difference of the input images. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.subtractInplace(image1, image2)</sample>
                    <param name="image1" type="object" multiplicity="1" alias="Image" desc="The first source image. This image is overwritten with the difference."/>
                    <param name="image2" type="const object" multiplicity="1" alias="Image" desc="The second source image."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="difference">
                    <trait>released</trait>
                    <keywords>subtract, minus, arithmetic</keywords>
                    <links>Image.subtract, Image.subtractInplace</links>
                    <desc>Computes the pixel-wise difference between two images, using a configurable difference operator. The images must be of equal size and pixel type, and have the same pixel size and origin in the z-dimension.

Difference operators:
ABS: Absolute difference, |image1 - image2|.
SQUARE: Squared difference, (image1 - image2)^2.

Return image type:
The return image type for all integer image types is unsigned. For SQUARE difference operator, a larger integer type is returned, e.g. UINT16 if the input is INT8.

Image world coordinate system handling:
The first input image is treated as the main image whose metadata is copied to the output image. Pixel sizes and origins in the x- and y-dimensions are not considered and have no effect on the operation.

Missing data handling:
A missing data pixel in any of the two input images generates a missing data pixel in the output image. For missing data images, as the value 0 is reserved, clamping to 1 instead of 0 is done for underflows and when the pixel type is unsigned integer.</desc>
                    <sample for="lua">result = Image.difference(image1, image2, "SQUARE")</sample>
                    <param name="image1" type="const object" multiplicity="1" alias="Image" desc="The first source image."/>
                    <param name="image2" type="const object" multiplicity="1" alias="Image" desc="The second source image."/>
                    <param name="differenceMode" type="enum" multiplicity="?" ref="DifferenceMode" desc="The type of difference operator to be used. Default is ABS."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="The difference image."/>
                </function>
                <function name="multiply">
                    <trait>released</trait>
                    <keywords>times, scale, arithmetic</keywords>
                    <links>Image.multiplyInplace, Image.multiplyConstant, Image.invert</links>
                    <desc>Multiplies two images pixelwise. The images must be of equal size and pixel type. If there is underflow or overflow in the arithmetic operation, the output pixel value is clamped to the min and max limit of the pixel type,
with an exception for images containing missing data, see below.

Image world coordinate system handling:
The first input image is treated as the main image whose metadata is copied to the output image. The operation is interpreted as operating on the world z-coordinate value. The second image is treated as a unit-less modifier and it must therefore have a standard image world coordinate system with pixel sizes all equal to 1 and origins equal to 0. Pixel sizes and origins in the x- and y-dimensions are not considered and have no effect on the operation.

Missing data handling:
A missing data pixel in any of the two input images generates a missing data pixel in the output image. Note that it is possible to obtain 0 as result of the multiplication and that such pixels then will be considered as missing data in subsequent processing steps.</desc>
                    <sample for="lua">result = Image.multiply(image1, image2)</sample>
                    <param name="image1" type="const object" multiplicity="1" alias="Image" desc="The first source image."/>
                    <param name="image2" type="const object" multiplicity="1" alias="Image" desc="The second source image."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="The product image."/>
                </function>
                <function name="multiplyInplace">
                    <trait>released</trait>
                    <keywords>times, scale, arithmetic</keywords>
                    <links>Image.multiply, Image.multiplyConstant, Image.invert</links>
                    <desc>Inplace version of the Image.multiply function which modifies the first input image to contain the product of the input images. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.multiplyInplace(image1, image2)</sample>
                    <param name="image1" type="object" multiplicity="1" alias="Image" desc="The first source image. This image is overwritten with the product."/>
                    <param name="image2" type="const object" multiplicity="1" alias="Image" desc="The second source image."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="divide">
                    <trait>released</trait>
                    <keywords>ratio, arithmetic</keywords>
                    <links>Image.divideInplace</links>
                    <desc>Divides two images pixelwise. The images must be of equal size and pixel type. A division-by-zero leads to a 0 in the output image. If there is underflow or overflow in the arithmetic operation, the output pixel value is clamped to the min and max limit of the pixel type, with an exception for images containing missing data, see below.

Image world coordinate system handling:
The first input image is treated as the main image whose metadata is copied to the output image. The operation is interpreted as operating on the world z-coordinate value. The second image is treated as a unit-less modifier and it must therefore have a standard image world coordinate system with pixel sizes all equal to 1 and origins equal to 0. Pixel sizes and origins in the x- and y-dimensions are not considered and have no effect on the operation.

Missing data handling:
A missing data pixel in any of the two input images generates a missing data pixel in the output image. In case of an underflow in the arithmetic, raw pixel values are clamped to 1 instead of to 0 in order to avoid creating new missing data in the output image.</desc>
                    <sample for="lua">result = Image.divide(image1, image2)</sample>
                    <param name="image1" type="const object" multiplicity="1" alias="Image" desc="The first source image."/>
                    <param name="image2" type="const object" multiplicity="1" alias="Image" desc="The second source image."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="The quotient image."/>
                </function>
                <function name="divideInplace">
                    <trait>released</trait>
                    <keywords>ratio, arithmetic</keywords>
                    <links>Image.divide</links>
                    <desc>Inplace version of the Image.divide function which modifies the first input image to contain the ratio of the input images. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.divideInplace(image1, image2)</sample>
                    <param name="image1" type="object" multiplicity="1" alias="Image" desc="The first source image. This image is overwritten with the image ratio."/>
                    <param name="image2" type="const object" multiplicity="1" alias="Image" desc="The second source image."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="multiplyConstant">
                    <trait>released</trait>
                    <keywords>times, scale, arithmetic</keywords>
                    <links>Image.multiply, Image.multiplyConstantInplace, Image.invert</links>
                    <desc>Multiplies all pixels in the image with a constant value. If there is underflow or overflow in the arithmetic operation, the output pixel values are clamped to the min or max limit of the pixel data type, with an exception for images containing missing data, see below.

Image world coordinate system handling:
If the image has a non-default image world coordinate system, for example a height map, distance or range image, multiplication of the world z-value is done, considering the z-origin and z-pixelsize. The image metadata from the input image is copied to the output image.

Missing data handling:
Missing data pixels in the input image are also missing data pixels in the output image. In case of an underflow in the arithmetic, raw pixel values are clamped to 1 instead of to 0 in order to avoid creating new missing data in the output image.</desc>
                    <sample for="lua">result = Image.multiplyConstant(image, 2.0)</sample>
                    <param name="image" type="const object" multiplicity="1" alias="Image" desc="The source image."/>
                    <param name="constant" type="float" multiplicity="1" desc="The constant."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="The multiplied image."/>
                </function>
                <function name="multiplyConstantInplace">
                    <trait>released</trait>
                    <keywords>times, scale, arithmetic</keywords>
                    <links>Image.multiply, Image.multiplyConstant, Image.invert</links>
                    <desc>Inplace version of Image.multiplyConstant function which modifies the input image. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.multiplyConstantInplace(image, 2.0)</sample>
                    <param name="image" type="object" multiplicity="1" alias="Image" desc="The source image. This image is overwritten with the result image."/>
                    <param name="constant" type="float" multiplicity="1" desc="The constant."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="multiplyAddConstant">
                    <trait>released</trait>
                    <keywords>offset, scale, arithmetic</keywords>
                    <links>Image.multiplyAddConstantInplace</links>
                    <desc>Multiplies an image pixelwise by a constant alpha and then adds a second constant beta: alpha*Image + beta. If there is underflow or overflow in the arithmetic operation, the output pixel values are clamped to the min or max limit of the pixel data type, with an exception for images containing missing data, see below.

Image world coordinate system handling:
If the image has a non-default image world coordinate system, for example a height map, distance or range image, the operation is interpreted in image world coordinate units, e.g., millimeters, considering the z-origin and z-pixelsize. The image metadata from the input image is copied to the output image.

Missing data handling:
Missing data pixels in the input image are also missing data pixels in the output image. In case of an underflow in the arithmetic, values are clamped to 1 instead of to 0 in order to avoid creating new missing data in the output image.</desc>
                    <sample for="lua">result = Image.multiplyAddConstant(image, alpha, beta)</sample>
                    <param name="image" type="const object" multiplicity="1" alias="Image" desc="The source image."/>
                    <param name="alpha" type="float" multiplicity="1" desc="The constant to multiply with."/>
                    <param name="beta" type="float" multiplicity="1" desc="The constant to add."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="The resulting image."/>
                </function>
                <function name="multiplyAddConstantInplace">
                    <trait>released</trait>
                    <keywords>offset, scale, arithmetic</keywords>
                    <links>Image.multiplyAddConstant</links>
                    <desc>Inplace version of Image.multiplyAddConstant function which modifies the input image. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.multiplyAddConstantInplace(image, alpha, beta)</sample>
                    <param name="image" type="object" multiplicity="1" alias="Image" desc="The source image. This image is overwritten with the result image."/>
                    <param name="alpha" type="float" multiplicity="1" desc="The constant to multiply with."/>
                    <param name="beta" type="float" multiplicity="1" desc="The constant to add."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="addConstant">
                    <trait>released</trait>
                    <keywords>offset, level, plus, arithmetic</keywords>
                    <links>Image.addConstantInplace, Image.addPlane, Image.subtractPlane</links>
                    <desc>Adds a constant value to all pixels in the image. If there is underflow or overflow in the arithmetic operation, the output pixel values are clamped to the min or max limit of the pixel data type.

Image world coordinate system handling:
If the image has a non-default image world coordinate system, for example a height map, distance or range image, the constant is interpreted in image world coordinate units, e.g., millimeters, and is rescaled to a raw pixel value using the z-pixelsize and z-origin of the image. The image metadata from the input image is copied to the output image.

Missing data handling:
Missing data pixels in the input image are also missing data pixels in the output image. In case of an underflow in the arithmetic, values are clamped to 1 instead of to 0 in order to avoid creating new missing data in the output image.</desc>
                    <sample for="lua">result = Image.addConstant(image, constant)</sample>
                    <param name="image" type="const object" multiplicity="1" alias="Image" desc="The source image."/>
                    <param name="constant" type="float" multiplicity="1" desc="The constant interpreted in image world units (z-origin and z-pixelsize taken into account)."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="The sum image."/>
                </function>
                <function name="addConstantInplace">
                    <trait>released</trait>
                    <keywords>offset, level, plus, arithmetic</keywords>
                    <links>Image.addConstant, Image.addPlaneInplace, Image.subtractPlaneInplace</links>
                    <desc>Inplace version of Image.addConstant function which modifies the input image. See base function for full documentation.</desc>
                    <sample for="lua">Image.addConstantInplace(image, constant)</sample>
                    <param name="image" type="object" multiplicity="1" alias="Image" desc="The source image."/>
                    <param name="constant" type="float" multiplicity="1" desc="The constant interpreted in image world units (z-origin and z-pixelsize taken into account)."/>
                    <return name="resultReference" type="object" multiplicity="?" alias="Image" desc="Reference to the sum image."/>
                </function>
                <function name="bitShift">
                    <trait>released</trait>
                    <keywords>multiply, divide, scale, arithmetic</keywords>
                    <links>Image.bitShiftInplace, Image.multiplyConstant</links>
                    <desc>Bit shifts all pixel values in an image of unsigned integer type. This is a fast way of multiplying or dividing (integer division) image values with powers of two. Negative shift length is used for division. Note that there are no overflow or underflow checks for this operation! The operation is performed correctly both for raw pixel values and world pixel values.

There is a slight difference when shifting using positive values compared to a real multiplication when going out of bounds. The bitshift operation simply drops the most significant bit.
For an image of uint8 and a pixel value of 255 this would mean that shifting once with a positive value would shift in one zero and thus producing a lower value than before (254).
Ex.
1111 1111 &lt;&lt; 0 (uint8 255)
1111 1110 &lt;&lt; 0 (uint8 254)
1111 1100 (uint8 252)

As can be seen the behavior is not the ideal once the limit of the data type is reached. To avoid this problem use a sufficiently large image data type, or to get the a saturating behavior, see Image.multiplyConstant.

Image world coordinate system handling:
If the image has a non-zero z-origin, the z-origin of the returned image is adjusted in order to keep the operation valid both for raw- and world pixels. All other origin values and all pixel sizes are respected and copied to the returned image.

Missing data handling:
Missing data pixels in the input image are also missing data pixels in the output image. In case of an underflow in the arithmetic, additional pixels may be marked as missing.</desc>
                    <sample for="lua">result = Image.bitShift(image, shifts)</sample>
                    <param name="image" type="const object" multiplicity="1" alias="Image" desc="The source image."/>
                    <param name="shifts" type="int" multiplicity="1" desc="The shift length in number of bits, each positive shift corresponds to multiplying with two. Each negative shift corresponds to division with two."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="The bit-shifted image."/>
                </function>
                <function name="bitShiftInplace">
                    <trait>released</trait>
                    <keywords>multiply, divide, arithmetic</keywords>
                    <links>Image.bitShift, Image.multiplyConstant</links>
                    <desc>Inplace version of Image.bitShift function which modifies the input image. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.bitShiftInplace(image, shifts)</sample>
                    <param name="image" type="object" multiplicity="1" alias="Image" desc="The source image. This image is overwritten with the result image."/>
                    <param name="shifts" type="int" multiplicity="1" desc="The shift length in number of bits, each positive shift corresponds to multiplying with two. Each negative shift corresponds to division with two."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="addNoise">
                    <trait>released</trait>
                    <keywords>white, uniform, random</keywords>
                    <links>Image.addNoiseInplace</links>
                    <desc>Adds a uniform noise value in the range [a,b] to all pixels in the image. If there is underflow or overflow in the arithmetic operation, the output pixel values are clamped to the min or max limit of the pixel data type.

Image world coordinate system handling:
If the image has a non-default image world coordinate system, for example a heightmap, distance or range image, the noise interval parameters [a,b] are interpreted in image world coordinate units, e.g., millimeters, and is rescaled to a raw pixel value using the z-pixelsize and z-origin of the image. The image metadata from the input image is copied to the output image.

Missing data handling:
Missing data pixels in the input image are also missing data pixels in the output image. In case of an underflow in the arithmetic, values are clamped to 1 instead of to 0 in order to avoid creating new missing data in the output image.</desc>
                    <sample for="lua">result = Image.addNoise(image, 10, 100, 0)</sample>
                    <param name="image" type="const object" multiplicity="1" alias="Image" desc="The source image."/>
                    <param name="a" type="float" desc="Lower interval limit interpreted in image world units (z-origin and z-pixelsize taken into account)."/>
                    <param name="b" type="float" desc="Upper interval limit interpreted in image world units (z-origin and z-pixelsize taken into account)."/>
                    <param name="randSeed" type="int" multiplicity="?" desc="Random seed, optional. Default value is 0."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="The result image."/>
                </function>
                <function name="addNoiseInplace">
                    <trait>released</trait>
                    <keywords>white, uniform, random</keywords>
                    <links>Image.addNoise</links>
                    <desc>Inplace version of the Image.addNoise function that modifies the input image. See base function for full documentation.</desc>
                    <sample for="lua">Image.addNoiseInplace(image, 10, 100, 0)</sample>
                    <param name="image" type="object" multiplicity="1" alias="Image" desc="The source image. This image is overwritten with the result image."/>
                    <param name="a" type="float" desc="Lower interval limit interpreted in image world units (z-origin and z-pixelsize taken into account)."/>
                    <param name="b" type="float" desc="Upper interval limit interpreted in image world units (z-origin and z-pixelsize taken into account)."/>
                    <param name="randSeed" type="int" multiplicity="?" desc="Random seed, optional. Default value is 0."/>
                    <return name="resultReference" type="object" multiplicity="?" alias="Image" desc="A reference to the result image."/>
                </function>
                <function name="abs">
                    <trait>released</trait>
                    <keywords>absolute, magnitude, arithmetic</keywords>
                    <links>Image.absInplace</links>
                    <desc>Computes the absolute value of each pixel.

Image world coordinate system handling:
The operation is not implemented for images with z-origin different from 0.0. The image metadata from the input image is copied to the output image.

Missing data handling:
There is no special handling of missing data as the value 0 remains 0 after the operation.</desc>
                    <sample for="lua">result = Image.abs(image)</sample>
                    <param name="image" type="const object" multiplicity="1" alias="Image" desc="The source image."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="The absolute value image."/>
                </function>
                <function name="absInplace">
                    <trait>released</trait>
                    <keywords>absolute, magnitude, arithmetic</keywords>
                    <links>Image.abs</links>
                    <desc>Inplace version of the Image.abs function that modifies the input image. See base function for full documentation.</desc>
                    <sample for="lua">Image.absInplace(image)</sample>
                    <param name="image" type="object" multiplicity="1" alias="Image" desc="The source image. This image is overwritten with the result image."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="A reference to the result image."/>
                </function>
                <function name="pow">
                    <trait>released</trait>
                    <keywords>power, sqr, square, cube, sqrt, exponent, invert, inverse, exp, arithmetic</keywords>
                    <links>Image.powInplace</links>
                    <desc>Applies an exponent to the value at each pixel. If there is underflow or overflow in the arithmetic operation, the output pixel value is clamped to the min and max limit of the pixel data type respectively.

Image world coordinate system handling:
The z-scale of the image is considered, but the operation is not implemented for images with z-origin different from 0.0. The image metadata from the input image is copied to the output image.

Missing data handling:
In case of an underflow in the arithmetic, values are clamped to 1 instead of to 0 in order to avoid creating new missing data in the output image.</desc>
                    <sample for="lua">result = Image.pow(image, exponent)</sample>
                    <param name="image" type="const object" multiplicity="1" alias="Image" desc="The source image."/>
                    <param name="exponent" type="float" multiplicity="1" desc="The exponent."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="The processed image."/>
                </function>
                <function name="powInplace">
                    <trait>released</trait>
                    <keywords>power, sqr, square, cube, sqrt, exponent, invert, inverse, exp, arithmetic</keywords>
                    <links>Image.pow</links>
                    <desc>Inplace version of the Image.pow function which modifies the input image. See base function for full documentation.</desc>
                    <sample for="lua">Image.powInplace(image, exponent)</sample>
                    <param name="image" type="object" multiplicity="1" alias="Image" desc="The source image. This image is overwritten with the result image."/>
                    <param name="exponent" type="float" multiplicity="1" desc="The exponent."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="A reference to the result image."/>
                </function>
                <function name="min">
                    <trait>released</trait>
                    <keywords>minimum, arithmetic, compare</keywords>
                    <links>Image.minInplace, Image.getMin, Image.getMinMax</links>
                    <desc>Creates an image with the minimum pixel values of the source images. The images must be of equal size and pixel type.

Image world coordinate system handling:
The first input image is treated as the main image whose metadata is copied to the output image. The operation is interpreted as operating on the world z-coordinate values. The input images are allowed to have different image world coordinate systems, but only the z-pixelsizes and z-origins are utilized, pixel sizes and origins in the x- and y-dimensions are not considered and have no effect on the operation.

Missing data handling:
A missing data pixel in any of the two input images generates a missing data pixel in the output image.</desc>
                    <sample for="lua">result = Image.min(image1, image2)</sample>
                    <param name="image1" type="const object" multiplicity="1" alias="Image" desc="The first source image."/>
                    <param name="image2" type="const object" multiplicity="1" alias="Image" desc="The second source image."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="The minimum image."/>
                </function>
                <function name="minInplace">
                    <trait>released</trait>
                    <keywords>minimum, arithmetic, compare</keywords>
                    <links>Image.min, Image.getMin, Image.getMinMax</links>
                    <desc>Inplace version of the Image.min function which modifies the first input image to contain the pixelwise minimum of the input images. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.minInplace(image1, image2)</sample>
                    <param name="image1" type="object" multiplicity="1" alias="Image" desc="The first source image. This image is overwritten with the pixelwise minimum."/>
                    <param name="image2" type="const object" multiplicity="1" alias="Image" desc="The second source image."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="max">
                    <trait>released</trait>
                    <keywords>maximum, arithmetic, compare</keywords>
                    <links>Image.maxInplace, Image.getMax, Image.getMinMax</links>
                    <desc>Creates an image with the maximum pixel values of the source images. The images must be of equal size and pixel type.

Image world coordinate system handling:
The first input image is treated as the main image whose metadata is copied to the output image. The operation is interpreted as operating on the world z-coordinate values. The input images are allowed to have different image world coordinate systems, but only the z-pixelsizes and z-origins are utilized, pixel sizes and origins in the x- and y-dimensions are not considered and have no effect on the operation.

Missing data handling:
A missing data pixel in any of the two input images generates a missing data pixel in the output image.</desc>
                    <sample for="lua">result = Image.max(image1, image2)</sample>
                    <param name="image1" type="const object" multiplicity="1" alias="Image" desc="The first source image."/>
                    <param name="image2" type="const object" multiplicity="1" alias="Image" desc="The second source image."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="The maximum image."/>
                </function>
                <function name="maxInplace">
                    <trait>released</trait>
                    <keywords>maximum, arithmetic, compare</keywords>
                    <links>Image.max, Image.getMax, Image.getMinMax</links>
                    <desc>Inplace version of the Image.max function which modifies the first input image to contain the pixelwise maximum of the input images. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.maxInplace(image1, image2)</sample>
                    <param name="image1" type="object" multiplicity="1" alias="Image" desc="The first source image. This image is overwritten with the pixelwise maximum."/>
                    <param name="image2" type="const object" multiplicity="1" alias="Image" desc="The second source image."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="invert">
                    <trait>released</trait>
                    <keywords>inverse, contrast, brightness</keywords>
                    <links>Image.invertInplace</links>
                    <desc>Inverts the pixel values in the image, so that dark becomes bright and vice versa. The operation imOutput = getMax(imInput) - imInput. To do an inversion in the sense 1/x use the pow-function.

Image world coordinate system handling:
The output image keeps the coordinate system of the input image. The z-component of the output image origin is set to zero, this makes the inversion correct both for world pixel values and raw pixel values.

Missing data handling:
A missing data pixel in the input image results in a missing data pixel in the output image. In case of an underflow in the arithmetic, values are clamped to 1 instead of to 0 in order to avoid creating new missing data in the output image.</desc>
                    <sample for="lua">result = Image.invert(image)</sample>
                    <param name="image" type="const object" multiplicity="1" alias="Image" desc="The source image."/>
                    <param name="maxValue" type="float" multiplicity="?" desc="Optional value to subtract the image from, in world units. The default behavior is to find and use the maximum value in the input image."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="The inverted image."/>
                </function>
                <function name="invertInplace">
                    <trait>released</trait>
                    <keywords>inverse, contrast, brightness</keywords>
                    <links>Image.invert</links>
                    <desc>Inplace version of the Image.invert function that modifies the input image. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.invertInplace(image)</sample>
                    <param name="image" type="object" multiplicity="1" alias="Image" desc="The source image. This image is overwritten with the result image."/>
                    <param name="maxValue" type="float" multiplicity="?" desc="Optional value to invert around. The default behavior is to find and use the maximum value in the input image."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="clamp">
                    <trait>released</trait>
                    <keywords>clip, limit, arithmetic</keywords>
                    <links>Image.clampInplace, Image.clampPlane</links>
                    <desc>Clamps the pixel values to an interval [maxValue, minValue]. An optional region may be provided, limiting the processing to only that region. Pixels outside the region are left in an undefined state.

Image world coordinate system handling:
The [maxValue, minValue] parameters are interpreted as expressed in image world coordinate units, i.e., the clamp limits are scaled internally from world (millimeter) units to raw pixel values using the origin and pixelsize in the z-dimension. The image metadata from the input image is copied to the output image.

Missing data handling:
A missing data pixel in the input image results in a missing data pixel in the output image. In case of an underflow in the arithmetic, values are clamped to 1 instead of to 0 in order to avoid creating new missing data in the output image. Setting the optional fillMissingData flag, missing data pixels will be set to the minimum clamp value. If this flag is set, the output image will have its missing data flag cleared.</desc>
                    <sample for="lua">result = Image.clamp(image, minValue, maxValue, region, fillMissingData)</sample>
                    <param name="image" type="const object" multiplicity="1" alias="Image" desc="The source image."/>
                    <param name="minValueWorld" type="float" multiplicity="1" desc="The minimum value to clamp to interpreted in image world units (z-origin and z-pixelsize taken into account)."/>
                    <param name="maxValueWorld" type="float" multiplicity="1" desc="The maximum value to clamp to in image world units (z-origin and z-pixelsize taken into account)."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region to process. Default is the entire image."/>
                    <param name="fillMissingData" type="bool" multiplicity="?" desc="Optional flag to also fill in missing data pixels when clamping images containing missing data. Default is false."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="The clamped image."/>
                </function>
                <function name="clampInplace">
                    <trait>released</trait>
                    <keywords>clip, limit, arithmetic</keywords>
                    <links>Image.clamp, Image.clampPlaneInplace</links>
                    <desc>Inplace version of the Image.clamp function that modifies the input image. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.clampInplace(image, minValue, maxValue, region, fillMissingData)</sample>
                    <param name="image" type="object" multiplicity="1" alias="Image" desc="The source image. This image is overwritten with the result image."/>
                    <param name="minValueWorld" type="float" multiplicity="1" desc="The minimum value to clamp to interpreted in image world units (z-origin and z-pixelsize taken into account)."/>
                    <param name="maxValueWorld" type="float" multiplicity="1" desc="The maximum value to clamp to in image world units (z-origin and z-pixelsize taken into account)."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region to process. Default is the entire image."/>
                    <param name="fillMissingData" type="bool" multiplicity="?" desc="Optional flag to also fill in missing data pixels when clamping images containing missing data. Default is false."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="isEqual">
                    <trait>released</trait>
                    <keywords>check, similar, compare</keywords>
                    <desc>Checks if two images are equal, both in terms of size, type and pixel content. This function disregards the image world coordinate information and looks only at raw pixel values.</desc>
                    <sample for="lua">result = Image.isEqual(image1, image2)</sample>
                    <param name="image1" type="const object" alias="Image" desc="The first source image."/>
                    <param name="image2" type="const object" alias="Image" desc="The second source image."/>
                    <param name="tolerance" type="float" multiplicity="?" desc="The difference allowed between the images in the pixel value comparison. Value is in pixel coordinates. Default is 0."/>
                    <param name="compareMetaData" type="bool" multiplicity="?" desc="Select if missing data flags, origin or pixel size differences should influence the comparison."/>
                    <return name="result" type="bool" multiplicity="?" desc="True if the images have identical size and pixel type, and equal contents at each pixel."/>
                </function>
                <function name="getMin">
                    <trait>released</trait>
                    <keywords>minimum, statistics, rank</keywords>
                    <links>Image.getMinMax, Image.getMax, Image.max, Image.min</links>
                    <desc>Returns the minimum pixel value in an image. The position of the first minimal value pixel and its uniqueness is also returned. Optionally, a pixel region may be provided.

Image world coordinate system handling:
The output value is specified in image world coordinates, i.e., the origin and pixel size in the z-dimension are used to convert the raw pixel value to world scale.

Missing data handling:
Missing data pixels are ignored.</desc>
                    <sample for="lua">minValue = Image.getMin(image)</sample>
                    <param name="image" type="const object" multiplicity="1" alias="Image" desc="The image."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region in which to find the min and max, default is the entire image."/>
                    <return name="minValue" type="float" multiplicity="?" desc="The minimum pixel value in world coordinates (millimeters)."/>
                    <return name="position" type="object" multiplicity="?" alias="Point" desc="The position of the first minimal value pixel in the image scan order, in world coordinates (millimeters)."/>
                    <return name="unique" type="bool" multiplicity="?" desc="Boolean indicating if there is only one pixel with the minimal value."/>
                </function>
                <function name="getMax">
                    <trait>released</trait>
                    <keywords>maximum, statistics, rank</keywords>
                    <links>Image.getMinMax, Image.getMin, Image.max, Image.min</links>
                    <desc>Returns the maximum pixel value in an image. The position of the first maximal value pixel and its uniqueness is also returned. Optionally, a pixel region may be provided.

Image world coordinate system handling:
The output value is specified in world coordinates, i.e., the origin and pixel size in the z-dimension are used to convert the raw pixel value to world scale.

Missing data handling:
Missing data pixels are ignored.</desc>
                    <sample for="lua">maxValue = Image.getMax(image)</sample>
                    <param name="image" type="const object" multiplicity="1" alias="Image" desc="The image."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region in which to find the min and max, default is the entire image."/>
                    <return name="maxValue" type="float" multiplicity="?" desc="The maximum pixel value in world coordinates (millimeters)."/>
                    <return name="position" type="object" multiplicity="?" alias="Point" desc="The position of the first maximal value pixel in the image scan order, in world coordinates (millimeters)."/>
                    <return name="unique" type="bool" multiplicity="?" desc="Boolean indicating if there is only one pixel with the maximal value."/>
                </function>
                <function name="getMinMax">
                    <trait>released</trait>
                    <keywords>minimum, maximum, statistics, rank</keywords>
                    <links>Image.getMin, Image.getMax, Image.max, Image.min</links>
                    <desc>Returns the minimum and maximum pixel value in an image. Optionally, a pixel region may be provided.

Image world coordinate system handling:
The output min and max values are specified in world coordinates, i.e., the origin and pixel size in the z-dimension are used to convert the raw pixel value to world scale.

Missing data handling:
Missing data pixels are ignored.</desc>
                    <sample for="lua">minValue, maxValue, minPosition, maxPosition, minUnique, maxUnique = Image.getMinMax(image)</sample>
                    <param name="image" type="const object" multiplicity="1" alias="Image" desc="The image."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region in which to find the min and max, default is the entire image."/>
                    <return name="minValue" type="float" multiplicity="?" desc="The minimum pixel value in world coordinates (millimeters)."/>
                    <return name="maxValue" type="float" multiplicity="?" desc="The maximum pixel value in world coordinates (millimeters)."/>
                    <return name="minPosition" type="object" multiplicity="?" alias="Point" desc="The position of the first minimal value pixel in the image scan order, in world coordinates (millimeters)."/>
                    <return name="maxPosition" type="object" multiplicity="?" alias="Point" desc="The position of the first maximal value pixel in the image scan order, in world coordinates (millimeters)."/>
                    <return name="minUnique" type="bool" multiplicity="?" desc="Boolean indicating if there is only one pixel with the minimal value."/>
                    <return name="maxUnique" type="bool" multiplicity="?" desc="Boolean indicating if there is only one pixel with the maximal value."/>
                </function>
                <function name="getMean">
                    <trait>released</trait>
                    <keywords>mean, statistics, average</keywords>
                    <links>Image.getMin, Image.getMax, Image.getSum, Image.getLocalMean, Image.getLocalStatistics</links>
                    <desc>Get the mean pixel value. If a region is provided, the mean is calculated within that region. By default, a reference plane z=0 is used. Another reference plane may be provided, giving the mean difference from that plane. Several regions in a list may be used, in which case one mean value is calculated for each region. When using multiple regions, regions which are empty or have no valid data are reported as having mean value nan.

Image world coordinate system handling:
The output mean value is specified in world coordinates, i.e., the origin and pixel size in the z-dimension are used to convert the raw pixel value to world scale.

Missing data handling:
Missing data pixels are not included.</desc>
                    <sample for="lua">mean = Image.getMean(image, region, referenceSurface)</sample>
                    <param name="image" type="const object" multiplicity="1" alias="Image" desc="Input image, defines the image from which to get pixel value input."/>
                    <param name="region" type="const object" multiplicity="[?*]" alias="Image.PixelRegion" desc="Input region or regions, defines the region of image in which to calculate the mean, default is the entire image. If several regions are provided, a list of mean values is returned."/>
                    <param name="referenceSurface" type="const object" multiplicity="?" alias="Shape3D" desc="Reference plane, defines the zero level in world coordinates. Default is the plane z=0."/>
                    <return name="mean" type="float" multiplicity="[?*]" desc="Mean value or list of mean values. Nil on error"/>
                </function>
                <function name="getLocalMean">
                    <trait>released</trait>
                    <keywords>mean, statistics, average</keywords>
                    <links>Image.getMean, Image.getStatistics, Image.getLocalStatistics, Image.getMedian, Image.getLocalMedian,  Image.getMin, Image.getMax, Image.getSum</links>
                    <desc>Get the mean pixel value within a circular neighborhood of a point.
By default, a reference plane z=0 is used.
Another reference plane may be provided, giving the mean difference from that plane.
When using multiple points, point neighborhoods which are empty or have no valid data are reported as having mean value NaN.

Image world coordinate system handling:
Image world coordinate system values are used.

Missing data handling:
Missing data pixels are not included.</desc>
                    <sample for="lua">mean = Image.getLocalMean(image, points, neighborhoodRadius, referenceSurface)</sample>
                    <param name="image" type="const object" multiplicity="1" alias="Image" desc="Input image, defines the image from which to get pixel value input."/>
                    <param name="points" type="const object" multiplicity="[1+]" alias="Point" desc="Input 2D point or 2D point list in world coordinates"/>
                    <param name="neighborhoodRadius" type="float" multiplicity="[1+]" desc="Input radius or radius list in world coordinates. If points is a single value neighborhoodRadius must also be a single value."/>
                    <param name="referenceSurface" type="const object" multiplicity="?" alias="Shape3D" desc="Reference plane, defines the zero level in world coordinates. Default is the plane z=0."/>
                    <return name="mean" type="float" multiplicity="[?*]" desc="Mean value or list of mean values. Nil on error"/>
                </function>
                <function name="getLocalStd">
                    <trait>released</trait>
                    <keywords>mean, statistics, average</keywords>
                    <links>Image.getStatistics, Image.getLocalStatistics, Image.getMean, Image.getLocalMean, Image.getMin, Image.getMax</links>
                    <desc>Get the standard deviation of the pixel values within a circular neighborhood of a point.
By default, a reference plane z=0 is used.
Another reference plane may be provided, giving the mean difference from that plane.
When using multiple points, point neighborhoods which are empty or have no valid data are reported as having standard deviation value NaN.

Image world coordinate system handling:
Image world coordinate system values are used.

Missing data handling:
Missing data pixels are not included.</desc>
                    <sample for="lua">standardDeviation = Image.getLocalStd(image, points, neighborhoodRadius, referenceSurface)</sample>
                    <param name="image" type="const object" multiplicity="1" alias="Image" desc="Input image, defines the image from which to get pixel value input."/>
                    <param name="points" type="const object" multiplicity="[1+]" alias="Point" desc="Input 2D point or 2D point list in world coordinates"/>
                    <param name="neighborhoodRadius" type="float" multiplicity="[1+]" desc="Input radius or radius list in world coordinates. If points is a single value neighborhoodRadius must also be a single value."/>
                    <param name="referenceSurface" type="const object" multiplicity="?" alias="Shape3D" desc="Reference plane, defines the zero level in world coordinates. Default is the plane z=0."/>
                    <return name="standardDeviation" type="float" multiplicity="[?*]" desc="Standard deviation, or vector of standard deviations with one entry for each point."/>
                </function>
                <function name="getStatistics">
                    <trait>released</trait>
                    <keywords>min, max, mean, statistics, average</keywords>
                    <links>Image.getLocalStatistics, Image.getMin, Image.getMax, Image.getSum, Image.getMean</links>
                    <desc>Get pixel value statistics. If a region is provided, the statistics is calculated within that region. Image world coordinate system values are used and pixels with missing data are excluded. By default, the reference surface z=0 is used. Another reference surface (plane) may be provided, basing the statistics on deviations from that surface. If the statistics can not be calculated, nil is returned. A vector of regions can be provided, in which case four vectors of statistics are returned, one entry for each input region. Any invalid input region in the vector will have the corresponding output entries set to zero.</desc>
                    <sample for="lua">min = Image.getStatistics(image, region, referenceSurface)</sample>
                    <param name="image" type="const object" multiplicity="1" alias="Image" desc="Input image, defines the image from which to get pixel value input."/>
                    <param name="region" type="const object" multiplicity="[?*]" alias="Image.PixelRegion" desc="Input region or regions, defines the region of image in which to calculate the statistics, default is the entire image. If several regions are provided, lists of statistics values are returned."/>
                    <param name="referenceSurface" type="const object" multiplicity="?" alias="Shape3D" desc="Reference plane, defines the zero level in world coordinates. Default is the plane z=0."/>
                    <return name="min" type="float" multiplicity="[?*]" desc="Minimal value, or vector of values with one entry for each region."/>
                    <return name="max" type="float" multiplicity="[?*]" desc="Maximal value, or vector of values with one entry for each region."/>
                    <return name="average" type="float" multiplicity="[?*]" desc="Average value, or vector of values with one entry for each region."/>
                    <return name="standardDeviation" type="float" multiplicity="[?*]" desc="Standard deviation, or vector of standard deviations with one entry for each region."/>
                </function>
                <function name="getLocalStatistics">
                    <trait>released</trait>
                    <keywords>min, max, mean, statistics, average</keywords>
                    <links>Image.getStatistics, Image.getLocalMean, Image.getLocalStd, Image.getMin, Image.getMax, Image.getSum, Image.getMean, Image.getLocalMedian</links>
                    <desc>Get pixel value statistics within a circular neighborhood of a point.
By default, the reference surface z=0 is used.
Another reference surface (plane) may be provided, basing the statistics on deviations from that surface.
If the statistics can not be calculated, nil is returned.
A vector of points can be provided, in which case four vectors of statistics are returned, one entry for each input point.
When using multiple points, point neighborhoods which are empty or have no valid data are reported as having all values NaN.

Image world coordinate system handling:
Image world coordinate system values are used.

Missing data handling:
Missing data pixels are not included.</desc>
                    <sample for="lua">min, max, average, standardDeviation = Image.getLocalStatistics(image, points, neighborhoodRadius, referenceSurface)</sample>
                    <param name="image" type="const object" multiplicity="1" alias="Image" desc="Input image, defines the image from which to get pixel value input."/>
                    <param name="points" type="const object" multiplicity="[1+]" alias="Point" desc="Input 2D point or 2D point list in world coordinates"/>
                    <param name="neighborhoodRadius" type="float" multiplicity="[1+]" desc="Input radius or radius list in world coordinates. If points is a single value neighborhoodRadius must also be a single value."/>
                    <param name="referenceSurface" type="const object" multiplicity="?" alias="Shape3D" desc="Reference plane, defines the zero level in world coordinates. Default is the plane z=0."/>
                    <return name="min" type="float" multiplicity="[?*]" desc="Minimal value, or vector of values with one entry for each region."/>
                    <return name="max" type="float" multiplicity="[?*]" desc="Maximal value, or vector of values with one entry for each region."/>
                    <return name="average" type="float" multiplicity="[?*]" desc="Average value, or vector of values with one entry for each region."/>
                    <return name="standardDeviation" type="float" multiplicity="[?*]" desc="Standard deviation, or vector of standard deviations with one entry for each region."/>
                </function>
                <function name="getMedian">
                    <trait>released</trait>
                    <keywords>statistics, percentile</keywords>
                    <links>Image.getPercentiles, Image.getMean, Image.getLocalMedian, Image.getMin, Image.getMax</links>
                    <desc>Get the median value of the pixels within the region, a special case of Image.getPercentiles. The median is derived from a histogram and it is approximate. Optionally, a reference plane in world coordinates may be provided, in which case the deviations from the reference plane are considered. The default surface is the plane z=0. A vector of points can be provided, the median is then calculated in the neighborhood of each points in the vector. If a median value can't be calculated a NaN value is returned.</desc>
                    <sample for="lua">median = Image.getMedian(image, region, referenceSurface)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image, defines the image from which to get pixel value input."/>
                    <param name="region" type="const object" multiplicity="[?*]" alias="Image.PixelRegion" desc="Input region or regions, defines the region of image in which to calculate the median, default is the entire image. If several regions are provided, a list of median values is returned."/>
                    <param name="referenceSurface" type="const object" multiplicity="?" alias="Shape3D" desc="Zero-reference plane for pixel world coordinate values. Optional, default is the plane z=0."/>
                    <return name="median" type="float" multiplicity="[?*]" desc="The approximate median(s)."/>
                </function>
                <function name="getLocalMedian">
                    <trait>released</trait>
                    <keywords>statistics, percentile</keywords>
                    <links>Image.getPercentiles, Image.getMedian, Image.getMean, Image.getLocalMean</links>
                    <desc>Get the median value of the pixels within a circular neighborhood of a point, a special case of Image.getPercentiles.
The median is derived from a histogram and it is approximate.
Optionally, a reference surface in world coordinates may be provided, in which case the deviations from the reference surface are considered. The default surface is the plane z=0.
When using multiple points, point neighborhoods which are empty or have no valid data are reported as having median value NaN.

Image world coordinate system handling
Image world coordinate system values are used.

Missing data handling:
Missing data pixels are not included.</desc>
                    <sample for="lua">median = Image.getLocalMedian(image, points, neighborhoodRadius, referenceSurface)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image, defines the image from which to get pixel value input."/>
                    <param name="points" type="const object" multiplicity="[1+]" alias="Point" desc="Input 2D point or 2D point list in world coordinates"/>
                    <param name="neighborhoodRadius" type="float" multiplicity="[1+]" desc="Input radius or radius list in world coordinates. If points is a single value neighborhoodRadius must also be a single value."/>
                    <param name="referenceSurface" type="const object" multiplicity="?" alias="Shape3D" desc="Zero-reference 3D surface plane for pixel world coordinate values. Optional, default is the plane z=0."/>
                    <return name="median" type="float" multiplicity="[?*]" desc="The approximate median."/>
                </function>
                <function name="getPercentiles">
                    <trait>released</trait>
                    <keywords>statistics</keywords>
                    <links>Image.getMedian, Image.getLocalMedian</links>
                    <desc>Get a set of rank measurement according to the specified percentile levels. Level 0.5 gives the median, level 0.9 give a value larger than 90% of all image pixels, etc. All values are derived from a histogram and are approximate. Optionally, a reference plane in world coordinates may be provided, in which case the deviations from the reference plane are considered. The default surface is the plane z=0.</desc>
                    <sample for="lua">values = Image.getPercentiles(image, percentileLevels, region, referenceSurface)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image, defines the image from which to get pixel value input."/>
                    <param name="percentileLevels" type="float" multiplicity="+" desc="Percentile levels in the range (0..1)"/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Input region, default is the entire image."/>
                    <param name="referenceSurface" type="const object" multiplicity="?" alias="Shape3D" desc="Zero-reference plane for pixel world coordinate values. Optional, default is the plane z=0."/>
                    <return name="values" type="float" multiplicity="*" desc="Output values"/>
                </function>
                <function name="getSum">
                    <trait>released</trait>
                    <keywords>statistics</keywords>
                    <links>Image.getMean</links>
                    <desc>Returns the sum of the pixel values in an image.

Image world coordinate system handling:
The sum is in world coordinates, i.e., the origin and pixel size in the z-dimension are considered should the image represent a height map, distance or range image.

Missing data handling:
This operation does not support missing data images, fill in missing data before calling this function.</desc>
                    <sample for="lua">imageSum = Image.getSum(image)</sample>
                    <param name="image" type="const object" multiplicity="1" alias="Image" desc="The image."/>
                    <return name="imageSum" type="float" multiplicity="?" desc="The sum of all pixels expressed in world coordinates (millimeters)"/>
                </function>
                <function name="aggregate">
                    <trait>released</trait>
                    <desc>Reduce an image to a profile along one spatial dimension, either rows or columns.
If ROW is specified the aggregation will be in this direction. For a full image this produces a profile of the same length as the height of the input image.
Missing data is handled and the delivered profile is in world coordinate units.</desc>
                    <sample for="lua">local aggregate = Image.aggregate(image, "SUM", "ROW")</sample>
                    <param name="image" type="const object" alias="Image" desc="Image to aggregate."/>
                    <param name="type" type="enum" ref="Image.AggregateOperation" desc="The aggregation method."/>
                    <param name="direction" type="enum" ref="Image.ProcessingDimension" desc="The direction to aggregate along."/>
                    <param name="region" type="const object" multiplicity="[?*]" alias="Image.PixelRegion" desc="One or more optional regions. For each region one profile is returned. If unset one profile is returned for the whole image."/>
                    <return name="aggregate" type="object" multiplicity="[?*]" alias="Profile" desc="Profile(s) holding the combined data. Nil on failure."/>
                </function>
                <function name="subtractProfile">
                    <trait>released</trait>
                    <links>Image.subtractProfileInplace, Image.extractProfile</links>
                    <desc>Returns the image with the profile subtracted from all rows or all columns depending on the dimension argument. The dimension argument is optional and if not provided processing is done row by row.

Image world coordinate system handling:
The input image coordinate system is transferred to the output image.
The input profile is subtracted in world coordinates.

Missing data handling:
Missing data in the input image remains missing in the output image.
For missing data in the profile, the image data will be unchanged.
If missing data, note that the minimum pixel value is always 1 for valid pixels.</desc>
                    <sample for="lua">result = Image.subtractProfile(image, profile, dimension)</sample>
                    <param name="image" type="const object" multiplicity="1" alias="Image" desc="The image."/>
                    <param name="profile" type="const object" multiplicity="1" alias="Profile" desc="The profile."/>
                    <param name="dimension" type="enum" multiplicity="?" ref="ProcessingDimension" desc="Optional processing dimension (row/column)."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Image with profile subtracted along processing dimension."/>
                </function>
                <function name="subtractProfileInplace">
                    <trait>released</trait>
                    <links>Image.subtractProfile, Image.extractProfile</links>
                    <desc>Inplace version of the Image.subtractProfile function that modifies the input image. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.subtractProfileInplace(image, profile, dimension)</sample>
                    <param name="image" type="object" multiplicity="1" alias="Image" desc="The image. This image is overwritten with the result image."/>
                    <param name="profile" type="const object" multiplicity="1" alias="Profile" desc="The profile."/>
                    <param name="dimension" type="enum" multiplicity="?" ref="ProcessingDimension" desc="Optional processing dimension (row/column)."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="multiplyProfile">
                    <trait>released</trait>
                    <links>Image.multiplyProfileInplace, Image.extractProfile</links>
                    <desc>Returns the image with the profile multiplied with all rows or all columns depending on the dimension argument. The dimension argument is optional and if not provided processing is done row by row.

Image world coordinate system handling:
The input image coordinate system is transferred to the output image. The operation is performed in the world coordinate system. The z-origin of the input image must be zero.

Missing data handling:
Missing data in the image will remain in the output image.
Missing data in the profile will leave the corresponding image values unchanged.</desc>
                    <sample for="lua">result = Image.multiplyProfile(image, profile, dimension)</sample>
                    <param name="image" type="const object" multiplicity="1" alias="Image" desc="The image."/>
                    <param name="profile" type="const object" multiplicity="1" alias="Profile" desc="The profile."/>
                    <param name="dimension" type="enum" multiplicity="?" ref="ProcessingDimension" desc="Optional processing dimension (row/column)."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Image with profile multiplied along processing dimension."/>
                </function>
                <function name="multiplyProfileInplace">
                    <trait>released</trait>
                    <links>Image.multiplyProfile, Image.extractProfile</links>
                    <desc>Inplace version of the Image.multiplyProfile function that modifies the input image. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.multiplyProfileInplace(image, profile, dimension)</sample>
                    <param name="image" type="object" multiplicity="1" alias="Image" desc="The image. This image is overwritten with the result image."/>
                    <param name="profile" type="const object" multiplicity="1" alias="Profile" desc="The profile."/>
                    <param name="dimension" type="enum" multiplicity="?" ref="ProcessingDimension" desc="Optional processing dimension (row/column)."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="adjustOriginZ">
                    <trait>released</trait>
                    <links>Image.setOriginZ, Image.adjustOriginZInplace</links>
                    <desc>Adjusts the image z-origin to the given value in world coordinates, changing the raw pixel values such that the represented world coordinate values stays the same. Adjusting the z-origin to -10.0 will allow unsigned types to represent world-coordinate values from -10.0 and larger. Pixel values outside the range of the image type will be clamped. To set a new origin without changing the raw pixel values, offsetting the world coordinate values, see Image.setOriginZ.

Image world coordinate system handling:
The operation keeps pixel values in the world coordinate system constant, unless underflow or overflow occurs.

Missing data handling:
Missing data pixels in the input image are also missing data pixels in the output image. In case of an underflow in the arithmetic, raw values are clamped to 1 instead of to 0 in order to avoid creating new missing data in the output image.</desc>
                    <sample for="lua">resultImage = Image.adjustOriginZ(image, newOriginZ)</sample>
                    <param name="image" type="const object" alias="Image" desc="The input image image."/>
                    <param name="newOriginZ" type="float" desc="New origin in z-direction for image."/>
                    <return name="resultImage" type="object" multiplicity="?" alias="Image" desc="The image with the adjusted origin. Nil if an error occurred."/>
                </function>
                <function name="adjustOriginZInplace">
                    <trait>released</trait>
                    <links>Image.adjustOriginZ, Image.setOriginZ</links>
                    <desc>Inplace version of the Image.adjustOriginZ function that modifies the input image. See base function for full documentation.</desc>
                    <sample for="lua">resultImage = Image.adjustOriginZInplace(image, newOriginZ)</sample>
                    <param name="image" type="object" alias="Image" desc="The input image image."/>
                    <param name="newOriginZ" type="float" desc="New origin in z-direction for image."/>
                    <return name="resultImage" type="object" multiplicity="?" alias="Image" desc="The image with the adjusted origin. Nil if an error occurred."/>
                </function>
                <function name="addPlane">
                    <trait>released</trait>
                    <keywords>ramp, gradient</keywords>
                    <links>Image.addPlaneInplace, Image.subtractPlane, Image.add, Image.addInplace, Image.renderPlane</links>
                    <desc>Adds the value of a plane function (Shape3D) to every pixel in an image. If there is underflow or overflow for integer type images, the output value is clamped to the min and max limit of the pixel data type. A partial region of operation may be selected, reducing the processing time.

Image world coordinate system handling:
The plane is interpreted in world space and added to the image world z-value of each pixel, taking care of the pixel sizes and origins in x,y,z of the image. The metadata of the input image is copied to the output image.

Missing data handling:
Missing data pixels in the input image are also missing data pixels in the output image. In case of an underflow in the arithmetic, raw values are clamped to 1 instead of to 0 in order to avoid creating new missing data in the output image.</desc>
                    <sample for="lua">resultImage = Image.addPlane(image, plane, region)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image."/>
                    <param name="plane" type="const object" alias="Shape3D" desc="The plane to add, must be a Shape3D plane."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Region of the image where the plane should be added, default is the full image. An empty region or nil are interpreted as the full image."/>
                    <return name="resultImage" type="object" multiplicity="?" alias="Image" desc="The image with the added plane. Nil if an error occurred."/>
                </function>
                <function name="addPlaneInplace">
                    <trait>released</trait>
                    <keywords>ramp, gradient</keywords>
                    <links>Image.addPlane, Image.subtractPlaneInplace, Image.add, Image.addInplace, Image.renderPlane</links>
                    <desc>Inplace version of the Image.addPlane function which modifies the input image by adding the value of a given plane. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.addPlaneInplace(image, plane, region)</sample>
                    <param name="image" type="object" multiplicity="1" alias="Image" desc="The image. This image is overwritten with the result image."/>
                    <param name="plane" type="const object" multiplicity="1" alias="Shape3D" desc="The plane to add, must be a Shape3D plane."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Region of the image where the plane should be added, default is the full image. An empty region or nil are interpreted as the full image."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="subtractPlane">
                    <trait>released</trait>
                    <keywords>ramp, gradient</keywords>
                    <links>Image.subtractPlaneInplace, Image.addPlane, Image.add, Image.renderPlane</links>
                    <desc>Subtracts a plane from an image. For every pixel, the corresponding plane z-value is subtracted. If there is underflow or overflow for integer type images, the output value is clamped to the min and max limit of the pixel data type. A partial region of operation may be selected, reducing the processing time. By setting autoAdjustOriginZ true for unsigned integer data, the origin of the result image will be adjusted to avoid clamping at zero. Using automatic origin adjustment on a partial region of the image will not compensate the pixel values outside the region for the new origin, such pixels will appear with an offset in global coordinates.

Image world coordinate system handling:
The plane is interpreted in world space and subtracted from the image world z-value of each pixel, taking care of the pixel sizes and origins in x,y,z of the image. The metadata of the input image is copied to the output image.

Missing data handling:
Missing data pixels in the input image are also missing data pixels in the output image. In case of an underflow in the arithmetic, raw values are clamped to 1 instead of to 0 in order to avoid creating new missing data in the output image.</desc>
                    <sample for="lua">resultImage = Image.subtractPlane(image, plane, region, autoAdjustOriginZ)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image."/>
                    <param name="plane" type="const object" alias="Shape3D" desc="The plane to subtract, must be a Shape3D plane."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Region of the image where the plane should be subtracted, default is the full image. An empty region or nil are interpreted as the full image."/>
                    <param name="autoAdjustOriginZ" type="bool" multiplicity="?" desc="Flag indicating if the origin of the output image should be adjusted to avoid clamping at zero. Default is false, using the same origin as the input image."/>
                    <return name="resultImage" type="object" multiplicity="?" alias="Image" desc="The image with the subtracted plane. Nil if an error occurred."/>
                </function>
                <function name="subtractPlaneInplace">
                    <trait>released</trait>
                    <keywords>ramp, gradient</keywords>
                    <links>Image.subtractPlane, Image.addPlane, Image.add, Image.renderPlane</links>
                    <desc>Inplace version of the Image.subtractPlane function which modifies the input image by subtracting the value of a given plane. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.subtractPlaneInplace(image, plane, region, autoAdjustOriginZ)</sample>
                    <param name="image" type="object" multiplicity="1" alias="Image" desc="The source image. This image is overwritten with the result image."/>
                    <param name="plane" type="const object" multiplicity="1" alias="Shape3D" desc="The plane to subtract, must be a Shape3D plane."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Region of the image where the plane should be subtracted, default is the full image. An empty region or nil are interpreted as the full image."/>
                    <param name="autoAdjustOriginZ" type="bool" multiplicity="?" desc="Flag indicating if the origin of the output image should be adjusted to avoid clamping at zero. Default is false, using the same origin as the input image."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="clampPlane">
                    <trait>released</trait>
                    <keywords>clip, limit</keywords>
                    <links>Image.clamp, Image.subtractPlane, Image.addPlane, Image.clampPlaneInplace, Image.renderPlane</links>
                    <desc>Clamps image pixel values to a plane from below, i.e., values are raised to the plane. In case of overflow, the value is instead clamped to the maximal representable value. A partial region of operation may be selected, reducing the processing time. All pixels outside the region are left in an undefined state.

Image world coordinate system handling:
The plane is interpreted in world space which is compared with image world z-value of each pixel, taking care of the pixel sizes and origins in x,y,z of the image. The metadata of the input image is copied to the output image.

Missing data handling:
By default, a missing data pixel in the input image generates a missing data pixel in the output image. If the fillMissingData flag is set to true, all pixels with missing data will be set to the plane value and the missing data flag of the output image will be cleared. In that case, the full range of raw pixel values may be used.</desc>
                    <sample for="lua">clampedImage = Image.clampPlane(image, plane, region, fillMissingData)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image to clamp."/>
                    <param name="plane" type="const object" alias="Shape3D" desc="The plane to clamp to, must be a Shape3D plane."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region where clamping should be performed, default is the full image. An empty region or nil are interpreted as the full image."/>
                    <param name="fillMissingData" type="bool" multiplicity="?" desc="Optional flag to also fill in missing data pixels when clamping images containing missing data. Default is false."/>
                    <return name="clampedImage" type="object" multiplicity="?" alias="Image" desc="The clamped image. Nil if an error occurred."/>
                </function>
                <function name="clampPlaneInplace">
                    <trait>released</trait>
                    <keywords>clip, limit</keywords>
                    <links>Image.clampPlane, Image.clamp, Image.subtractPlane</links>
                    <desc>Inplace version of the Image.clampPlane function that modifies the input image. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.clampPlaneInplace(image, plane, region, fillMissingData)</sample>
                    <param name="image" type="object" multiplicity="1" alias="Image" desc="The image to clamp. This image is overwritten with the result image."/>
                    <param name="plane" type="const object" multiplicity="1" alias="Shape3D" desc="The plane to clamp to, must be a Shape3D plane."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region where clamping should be performed, default is the full image. An empty region or nil are interpreted as the full image."/>
                    <param name="fillMissingData" type="bool" multiplicity="?" desc="Optional flag to also fill in missing data pixels when clamping images containing missing data. Default is false."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="missingDataSetSurface">
                    <trait>released</trait>
                    <links>Image.missingDataSetAll, Image.missingDataReduce</links>
                    <desc>Sets all missing data pixels to the surface value, values are clamped to the representable range of the image. All valid values are left unchanged. If a region not covering the full image is used, any missing data outside the region will be left in an undetermined state. Currently, either a plane surface represented as a Shape3D or a 2nd order polynomial extracted by the Image.SurfaceFitter is supported, other surface types may be supported in the future.

For a 2nd order polynomial surface, the following representation is expected
z = Ac + Ax*x + Ay*y + Axx*x*x + Axy*x*y + Ayy*y*y
where Ac, Ax, Ay, Axx, Axy, Ayy are the coefficients.

Image world coordinate system handling:
The surface is interpreted in world space which is compared with image world z-value of each pixel, taking care of the pixel sizes and origins in x,y,z of the image. The metadata of the input image is copied to the output image.

Missing data handling:
This function replaces all missing data pixels with the surface value. The missing data flag for the output image is removed, also when this operation is performed only within a specified region of interest.</desc>
                    <sample for="lua">clampedImage = Image.missingDataSetSurface(image, surface, region)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image to set missing data in."/>
                    <param name="surface" type="const auto" multiplicity="[1+]" desc="The surface to clamp to, represented as a 2nd order polynomial or Shape3D. For 3D shapes currently only a plane type is supported, in future more surface types may be supported. A second order order polynomial is represented with as a vector of the 6 coefficients Ac, Ax, Ay, Axx, Axy, Ayy."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region where the operation is to be performed, default is the full image."/>
                    <return name="clampedImage" type="object" multiplicity="?" alias="Image" desc="The image without missing data. Nil if an error occurred."/>
                </function>
                <function name="missingDataSetSurfaceInplace">
                    <trait>released</trait>
                    <desc>Inplace version of the Image.missingDataSetSurface function which sets all missing data pixels to a surface value. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.missingDataSetSurfaceInplace(image, surface, region)</sample>
                    <param name="image" type="object" multiplicity="1" alias="Image" desc="The image to set missing data in. This image is overwritten and the missing data is set according to the surface value."/>
                    <param name="surface" type="const auto" multiplicity="[1+]" desc="The surface to clamp to, represented as a 2nd order polynomial or Shape3D. For 3D shapes currently only a plane type is supported, in future more surface types may be supported. A second order order polynomial is represented with as a vector of the 6 coefficients Ac, Ax, Ay, Axx, Axy, Ayy."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region where the operation is to be performed, default is the full image."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="binarizePlane">
                    <trait>released</trait>
                    <keywords>binarize, adaptive, segmentation, background, foreground</keywords>
                    <links>Image.binarize, Image.threshold, Image.binarizeCompare, Image.binarize, Image.binarizeAdaptive, Image.thresholdPlane</links>
                    <desc>Applies a threshold interval (lowerThreshold, upperThreshold) relative to the given plane to create a binary image from a height map. The threshold values accounts for world coordinates (pixel size and origin in the z-dimension) if applicable. It is possible to binarize only a specified region. The thresholds may both be negative or positive, allowing selecting values strictly below or above the reference. This function produces an image output, to directly produce a PixelRegion output use the thresholdPlane function instead.

Image world coordinate system handling:
The plane is interpreted in world space which is compared with the image world z-value of each pixel, taking care of the pixel sizes and origins in x,y,z of the image. The metadata of the output image mask has the same pixel size and origin in x,y as the input image. Along the value axis z, the pixel size and origin are reset to unit and zero respectively.

Missing data handling:
No pixels marked as missing are included in the output mask. The missing data flag of the output mask image is cleared.</desc>
                    <sample for="lua">binaryImage = Image.binarizePlane(image, lowerThreshold, upperThreshold, plane, outputValue, region)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image. Supported image types are uint8, uint16, uint32, int8, int16, int32, float32 and float64."/>
                    <param name="lowerThreshold" type="float" desc="Lower threshold for the binarization in image world coordinates, i.e., the z-pixel size and origin are used so that the threshold is interpreted in millimeters in case the image is a height map/distance/range image."/>
                    <param name="upperThreshold" type="float" desc="Upper threshold for the binarization in world coordinates."/>
                    <param name="plane" type="const object" alias="Shape3D" desc="The plane to which the lower and upper thresholds are related. The shape should be a plane."/>
                    <param name="outputValue" type="int" multiplicity="?" desc="Value assigned to the pixels within the threshold interval, uint8 range. Optional, default value is 255."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest to consider when binarizing, values outside are set to zero."/>
                    <return name="binaryImage" type="object" multiplicity="?" alias="Image" desc="Binarized image of pixel type uint8."/>
                </function>
                <function name="thresholdPlane">
                    <trait>released</trait>
                    <keywords>binarize, adaptive, segmentation, background, foreground, blob, region</keywords>
                    <links>Image.threshold, Image.thresholdCompare, Image.binarizeCompare, Image.binarize, Image.binarizeAdaptive, Image.binarizePlane, Image.BackgroundModel</links>
                    <desc>Thresholds the image by keeping all pixels with a world value between lowerThreshold and upperThreshold relative to the provided plane (inclusive). Returns the result as a PixelRegion object. Thresholding values strictly below or above the reference plane is also supported, using relative thresholds with the same sign.

Image world coordinate system handling:
The plane is interpreted in world space which is compared with image world z-value of each pixel, taking care of the pixel sizes and origins in x,y,z of the image. Thresholds are interpreted in the world coordinate system.

Missing data handling:
No pixel marked as missing is included in the output region.</desc>
                    <sample for="lua">thresholdedRegion = Image.thresholdPlane(image, lowerThreshold, upperThreshold, plane, region)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image"/>
                    <param name="lowerThreshold" type="float" desc="Lower threshold relative to plane."/>
                    <param name="upperThreshold" type="float" desc="Upper threshold relative to plane."/>
                    <param name="plane" type="const object" alias="Shape3D" desc="The plane, represented as a Shape3D, to which the lower and upper thresholds are related. The shape type must be a plane."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. If supplied, the threshold operation is only performed within this region. This can save a lot of computation time, if the region is small."/>
                    <return name="thresholdedRegion" type="object" multiplicity="?" alias="Image.PixelRegion" desc="Pixel region containing all pixels with value between the thresholds relative to the plane."/>
                </function>
                <function name="renderPlane">
                    <trait>released</trait>
                    <keywords>draw</keywords>
                    <links>Image.renderPlaneInplace</links>
                    <desc>Renders a plane to an image, clamping values to the representable range of the image. The output image is of the same type as the input image.

Image world coordinate system handling:
The surface is rendered in the world space defined by the reference image, taking care of the pixel sizes and origins in x,y,z of the image. The metadata of the reference image is copied to the output image.

Missing data handling:
The missing data flag of the reference image is copied to the output image. If the flag is set, raw pixel values are clamped to 1 instead of 0 to avoid generating pixels with missing data.</desc>
                    <sample for="lua">renderedImage = Image.renderPlane(image, plane)</sample>
                    <param name="image" type="const object" alias="Image" desc="The reference image defining the output image size, type and coordinate system."/>
                    <param name="plane" type="const object" alias="Shape3D" desc="The plane to render, should be a plane shape."/>
                    <return name="renderedImage" type="object" multiplicity="?" alias="Image" desc="The image with the rendered plane. Nil if an error occurred."/>
                </function>
                <function name="renderPlaneInplace">
                    <trait>released</trait>
                    <keywords>draw</keywords>
                    <links>Image.renderPlane</links>
                    <desc>Inplace version of the Image.renderPlane function which modifies the input image by adding the value of a given plane. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.renderPlaneInplace(image, plane)</sample>
                    <param name="image" type="object" multiplicity="1" alias="Image" desc="Reference input image. This image is overwritten with the result image."/>
                    <param name="plane" type="const object" alias="Shape3D" desc="The plane to render, must be a Shape3D plane."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="addPolynomial">
                    <trait>released</trait>
                    <keywords>quadratic</keywords>
                    <links>Image.SurfaceFitter.fitPolynomial, Image.addPolynomialInplace, Image.subtractPolynomial, Image.clampPolynomial, Image.addPlane</links>
                    <desc>Adds the value of a 2nd order polynomial to every pixel in an image. If there is underflow or overflow for integer type images, the output value is clamped to the min and max limit of the pixel data type. A partial region of operation may be selected, reducing the processing time.

The expected input 2nd order polynomial is of the following form
z = Ac + Ax*x + Ay*y + Axx*x*x + Axy*x*y + Ayy*y*y
where Ac, Ax, Ay, Axx, Axy, Ayy are the coefficients.

Image world coordinate system handling:
The polynomial is interpreted in world space and added to the image world z-value of each pixel, taking care of the pixel sizes and origins in x,y,z of the image. The metadata of the input image is copied to the output image.

Missing data handling:
Missing data pixels in the input image are also missing data pixels in the output image. In case of an underflow in the arithmetic, raw values are clamped to 1 instead of to 0 in order to avoid creating new missing data in the output image.</desc>
                    <sample for="lua">resultImage = Image.addPolynomial(image, polynomial, region)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image."/>
                    <param name="polynomial" type="float" multiplicity="+" desc="The polynomial to add represented with the 6 coefficients Ac, Ax, Ay, Axx, Axy, Ayy."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Region of the image where the polynomial is to be added, default is the full image. An empty region or nil are interpreted as the full image."/>
                    <return name="resultImage" type="object" multiplicity="?" alias="Image" desc="The image with the added polynomial. Nil if an error occurred."/>
                </function>
                <function name="addPolynomialInplace">
                    <trait>released</trait>
                    <keywords>quadratic</keywords>
                    <links>Image.SurfaceFitter.fitPolynomial, Image.addPolynomial, Image.subtractPolynomial, Image.addPlane</links>
                    <desc>Inplace version of the Image.addPolynomial function which modifies the input image by adding the value of a given polynomial. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.addPolynomialInplace(image, polynomial, region)</sample>
                    <param name="image" type="object" multiplicity="1" alias="Image" desc="The image. This image is overwritten with the result image."/>
                    <param name="polynomial" type="float" multiplicity="+" desc="The polynomial to add represented with the 6 coefficients Ac, Ax, Ay, Axx, Axy, Ayy."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Region of the image where the polynomial is to be added, default is the full image. An empty region or nil are interpreted as the full image."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="subtractPolynomial">
                    <trait>released</trait>
                    <keywords>quadratic</keywords>
                    <links>Image.SurfaceFitter.fitPolynomial, Image.subtractPolynomialInplace, Image.thresholdPolynomial, Image.binarizePolynomial, Image.addPolynomial, Image.addPlane</links>
                    <desc>Subtracts a 2nd order polynomial from an image. For every pixel, the corresponding polynomial z-value is subtracted. If there is underflow or overflow for integer type images, the output value is clamped to the min and max limit of the pixel data type. A partial region of operation may be selected, reducing the processing time. By setting offsetZ to a value other than zero, the origin of the result image can be adjusted to avoid clamping.

Note that the functions Image.thresholdPolynomial and Image.binarizePolynomial exist for object segmentation.

The expected input 2nd order polynomial is of the following form
z = Ac + Ax*x + Ay*y + Axx*x*x + Axy*x*y + Ayy*y*y
where Ac, Ax, Ay, Axx, Axy, Ayy are the coefficients.

Image world coordinate system handling:
The polynomial is interpreted in world space and subtracted from the image world z-value of each pixel, taking care of the pixel sizes and origins in x,y,z of the image. The metadata of the input image is copied to the output image.

Missing data handling:
Missing data pixels in the input image are also missing data pixels in the output image. In case of an underflow in the arithmetic, raw values are clamped to 1 instead of to 0 in order to avoid creating new missing data in the output image.</desc>
                    <sample for="lua">resultImage = Image.subtractPolynomial(image, polynomial, region, offsetZ)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image."/>
                    <param name="polynomial" type="float" multiplicity="+" desc="The polynomial to add represented with the 6 coefficients Ac, Ax, Ay, Axx, Axy, Ayy."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Region of the image where the polynomial is to be subtracted, default is the full image. An empty region or nil are interpreted as the full image."/>
                    <param name="offsetZ" type="float" multiplicity="?" desc="Optional offset to avoid clamping. The world unit results are added with this offset before being placed in the output. Image z-origin is adjusted to maintain the correct absolute coordinates."/>
                    <return name="resultImage" type="object" multiplicity="?" alias="Image" desc="The image with the subtracted polynomial. Nil if an error occurred."/>
                </function>
                <function name="subtractPolynomialInplace">
                    <trait>released</trait>
                    <keywords>quadratic</keywords>
                    <links>Image.subtractPolynomial, Image.addPolynomial, Image.addPlane</links>
                    <desc>Inplace version of the Image.subtractPolynomial function which modifies the input image by subtracting the value of a given polynomial. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.subtractPolynomialInplace(image, polynomial, region, offsetZ)</sample>
                    <param name="image" type="object" multiplicity="1" alias="Image" desc="The source image. This image is overwritten with the result image."/>
                    <param name="polynomial" type="float" multiplicity="+" desc="The polynomial to add represented with the 6 coefficients Ac, Ax, Ay, Axx, Axy, Ayy."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Region of the image where the polynomial is to be subtracted, default is the full image. An empty region or nil are interpreted as the full image."/>
                    <param name="offsetZ" type="float" multiplicity="?" desc="Optional offset to avoid clamping. The world unit results are added with this offset before being placed in the output. Image z-origin is adjusted to maintain the correct absolute coordinates."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="clampPolynomial">
                    <trait>released</trait>
                    <keywords>clip, limit</keywords>
                    <links>Image.SurfaceFitter.fitPolynomial, Image.clamp, Image.subtractPolynomial, Image.addPolynomial, Image.clampPolynomialInplace, Image.renderPolynomial, Image.clampPlane</links>
                    <desc>Clamps image pixel values to a 2nd order polynomial from below, i.e., pixel values are raised to the polynomial. In case of overflow, the value is instead clamped to the maximal representable value. A partial region of operation may be selected, reducing the processing time. All pixels outside the region are left in an undefined state.

The expected input 2nd order polynomial is of the following form
z = Ac + Ax*x + Ay*y + Axx*x*x + Axy*x*y + Ayy*y*y
where Ac, Ax, Ay, Axx, Axy, Ayy are the coefficients.

Image world coordinate system handling:
The polynomial is interpreted in world space which is compared with image world z-value of each pixel, taking care of the pixel sizes and origins in x,y,z of the image. The metadata of the input image is copied to the output image.

Missing data handling:
By default, a missing data pixel in the input image generates a missing data pixel in the output image. If the fillMissingData flag is set to true, all pixels with missing data will be set to the polynomial value and the missing data flag of the output image will be cleared. In that case, the full range of raw pixel values may be used.</desc>
                    <sample for="lua">clampedImage = Image.clampPolynomial(image, polynomial, region, fillMissingData)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image to clamp."/>
                    <param name="polynomial" type="float" multiplicity="+" desc="The polynomial to add represented with the 6 coefficients Ac, Ax, Ay, Axx, Axy, Ayy."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region where clamping is to be performed, default is the full image. An empty region or nil are interpreted as the full image."/>
                    <param name="fillMissingData" type="bool" multiplicity="?" desc="Optional flag to also fill in missing data pixels when clamping images containing missing data. Default is false."/>
                    <return name="clampedImage" type="object" multiplicity="?" alias="Image" desc="The clamped image. Nil if an error occurred."/>
                </function>
                <function name="clampPolynomialInplace">
                    <trait>released</trait>
                    <keywords>clip, limit</keywords>
                    <links>Image.SurfaceFitter.fitPolynomial, Image.clampPolynomial, Image.subtractPolynomial, Image.clamp, Image.clampPlane</links>
                    <desc>Inplace version of the Image.clampPolynomial function that modifies the input image. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.clampPolynomialInplace(image, polynomial, region, fillMissingData)</sample>
                    <param name="image" type="object" multiplicity="1" alias="Image" desc="The image to clamp. This image is overwritten with the result image."/>
                    <param name="polynomial" type="float" multiplicity="+" desc="The polynomial to add represented with the 6 coefficients Ac, Ax, Ay, Axx, Axy, Ayy."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region where clamping is to be performed, default is the full image. An empty region or nil are interpreted as the full image."/>
                    <param name="fillMissingData" type="bool" multiplicity="?" desc="Optional flag to also fill in missing data pixels when clamping images containing missing data. Default is false."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="binarizePolynomial">
                    <trait>released</trait>
                    <keywords>binarize, adaptive, segmentation, background, foreground</keywords>
                    <links>Image.SurfaceFitter.fitPolynomial, Image.binarize, Image.threshold, Image.binarizeCompare, Image.binarize, Image.binarizeAdaptive, Image.thresholdPlane, Image.subtractPolynomial</links>
                    <desc>Applies a threshold interval (lowerThreshold, upperThreshold) relative to the given 2nd order polynomial to create a binary image. The threshold values accounts for world coordinates (pixel size and origin in the z-dimension) if applicable. It is possible to binarize only a specified region. The thresholds may both be negative or positive, allowing selecting values strictly below or above the reference. This function produces an image output, to directly produce a PixelRegion output use the thresholdPolynomial function instead.

The expected input 2nd order polynomial is of the following form
z = Ac + Ax*x + Ay*y + Axx*x*x + Axy*x*y + Ayy*y*y
where Ac, Ax, Ay, Axx, Axy, Ayy are the coefficients.

Image world coordinate system handling:
The polynomial is interpreted in world space which is compared with the image world z-value of each pixel, taking care of the pixel sizes and origins in x,y,z of the image. The metadata of the output image mask has the same pixel size and origin in x,y as the input image. Along the value axis z, the pixel size and origin are reset to unit and zero respectively.

Missing data handling:
No pixels marked as missing are included in the output mask. The missing data flag of the output mask image is cleared.</desc>
                    <sample for="lua">binaryImage = Image.binarizePolynomial(image, lowerThreshold, upperThreshold, polynomial, outputValue, region)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image."/>
                    <param name="lowerThreshold" type="float" desc="Lower threshold for the binarization in image world coordinates, i.e., the z-pixel size and origin are used so that the threshold is interpreted in millimeters in case the image is a height map/distance/range image."/>
                    <param name="upperThreshold" type="float" desc="Upper threshold for the binarization in world coordinates."/>
                    <param name="polynomial" type="float" multiplicity="+" desc="The polynomial to add represented with the 6 coefficients Ac, Ax, Ay, Axx, Axy, Ayy."/>
                    <param name="outputValue" type="int" multiplicity="?" desc="Value assigned to the pixels within the threshold interval, uint8 range. Optional, default value is 255."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest to consider when binarizing, values outside are set to zero."/>
                    <return name="binaryImage" type="object" multiplicity="?" alias="Image" desc="Binarized image of pixel type uint8."/>
                </function>
                <function name="thresholdPolynomial">
                    <trait>released</trait>
                    <keywords>binarize, adaptive, segmentation, background, foreground, blob, region</keywords>
                    <links>Image.SurfaceFitter.fitPolynomial, Image.threshold, Image.thresholdCompare, Image.binarizeCompare, Image.binarize, Image.binarizeAdaptive, Image.binarizePlane, Image.binarizePolynomial, Image.subtractPolynomial</links>
                    <desc>Thresholds the image by keeping all pixels with a world value between lowerThreshold and upperThreshold relative to the provided 2nd order polynomial. Returns the result as a PixelRegion object. Thresholding values strictly below or above the reference polynomial is also supported, using relative thresholds with the same sign.

The expected input 2nd order polynomial is of the following form
z = Ac + Ax*x + Ay*y + Axx*x*x + Axy*x*y + Ayy*y*y
where Ac, Ax, Ay, Axx, Axy, Ayy are the coefficients.

Image world coordinate system handling:
The polynomial is interpreted in world space which is compared with image world z-value of each pixel, taking care of the pixel sizes and origins in x,y,z of the image. Thresholds are interpreted in the world coordinate system, e.g., in millimeter unit.

Missing data handling:
No pixel marked as missing is included in the output region.</desc>
                    <sample for="lua">thresholdedRegion = Image.thresholdPolynomial(image, lowerThreshold, upperThreshold, polynomial, region)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image"/>
                    <param name="lowerThreshold" type="float" desc="Lower threshold relative to the polynomial in image world units, i.e., the z-pixel size and origin are used so that the threshold is interpreted in millimeters in case the image is a height map/distance/range image."/>
                    <param name="upperThreshold" type="float" desc="Upper threshold relative to the polynomial in image world units."/>
                    <param name="polynomial" type="float" multiplicity="+" desc="The polynomial to add represented with the 6 coefficients Ac, Ax, Ay, Axx, Axy, Ayy."/>
                    <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. If supplied, the threshold operation is only performed within this region. This can save a lot of computation time, if the region is small."/>
                    <return name="thresholdedRegion" type="object" multiplicity="?" alias="Image.PixelRegion" desc="Pixel region containing all pixels with value between the thresholds relative to the polynomial."/>
                </function>
                <function name="renderPolynomial">
                    <trait>released</trait>
                    <keywords>draw</keywords>
                    <links>Image.SurfaceFitter.fitPolynomial, Image.renderPolynomialInplace</links>
                    <desc>Renders a 2nd order polynomial into an image, clamping values to the representable range of the image. The output image is of the same type as the input image.

The expected input 2nd order polynomial is of the following form
z = Ac + Ax*x + Ay*y + Axx*x*x + Axy*x*y + Ayy*y*y
where Ac, Ax, Ay, Axx, Axy, Ayy are the coefficients.

Image world coordinate system handling:
The surface is rendered in the world space defined by the reference image, taking care of the pixel sizes and origins in x,y,z of the image. The metadata of the reference image is copied to the output image.

Missing data handling:
The missing data flag of the reference image is copied to the output image. If the flag is set, raw pixel values are clamped to 1 instead of 0 to avoid generating pixels with missing data.</desc>
                    <sample for="lua">renderedImage = Image.renderPolynomial(image, polynomial)</sample>
                    <param name="image" type="const object" alias="Image" desc="The reference image defining the output image size, type and coordinate system."/>
                    <param name="polynomial" type="float" multiplicity="+" desc="The polynomial to add represented with the 6 coefficients Ac, Ax, Ay, Axx, Axy, Ayy."/>
                    <param name="offsetZ" type="float" multiplicity="?" desc="Optional offset to avoid clamping. The world unit results are added with this offset before being placed in the output. Image z-origin is adjusted to maintain the correct absolute coordinates."/>
                    <return name="renderedImage" type="object" multiplicity="?" alias="Image" desc="The image with the rendered polynomial. Nil if an error occurred."/>
                </function>
                <function name="renderPolynomialInplace">
                    <trait>released</trait>
                    <keywords>draw</keywords>
                    <links>Image.renderPolynomial</links>
                    <desc>Inplace version of the Image.renderPolynomial function which modifies the input image by adding the value of a given polynomial. See base function for full documentation.</desc>
                    <sample for="lua">result = Image.renderPolynomialInplace(image, polynomial)</sample>
                    <param name="image" type="object" multiplicity="1" alias="Image" desc="Reference input image. This image is overwritten with the result image."/>
                    <param name="polynomial" type="float" multiplicity="+" desc="The polynomial to add represented with the 6 coefficients Ac, Ax, Ay, Axx, Axy, Ayy."/>
                    <param name="offsetZ" type="float" multiplicity="?" desc="Optional offset to avoid clamping. The world unit results are added with this offset before being placed in the output. Image z-origin is adjusted to maintain the correct absolute coordinates."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="getFlatness">
                    <trait>released</trait>
                    <keywords>surface, structure, planar, planarity, roughness</keywords>
                    <links>Image.getFlatRegion, Image.threshold</links>
                    <desc>Calculates a flatness measure for each pixel in an image. A pixel with a value close to zero means approximate coplanarity with its neighbors. The algorithm fits a plane to a local neighborhood around each pixel and gives out the maximum deviation from the plane over all pixels in the neighborhood. There is a fast and slow method for the plane fitting, where the slower method uses all pixels in the neighborhood to estimate the plane and the fast method only uses the border values in the neighborhood. Smoothing the input image first using a blur, gauss or median filter can sometimes be advisable.

Image world coordinate system handling:
Every pixel in the flatness image stores the maximum distance to the fitted plane in world units evaluated on the all pixels under the neighborhood.

Missing data handling:
Missing data is accepted, but partly ignored. All pixels that are missing data in the input image will get a negative planarity measure (corresponding to 1 z-pixelsize ). For pixels neighboring missing data the missing data positions are allowed to influence the flatness evaluation, possibly inflating the flatness measure.</desc>
                    <sample for="lua">flatness = Image.getFlatness(image, neighborhoodSize)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image."/>
                    <param name="neighborhoodSize" type="int" multiplicity="?" desc="The size of the neighborhood in pixels. Must be positive and odd. Default value is 13 pixels."/>
                    <param name="fast" type="bool" multiplicity="?" desc="Faster central difference estimate (true) or slower least squares fit (false). Default is true."/>
                    <param name="pixelRegion" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional pixelregion specifying where in the image to perform the operation."/>
                    <return name="flatness" type="object" multiplicity="?" alias="Image" desc="A FLOAT32 image with flatness estimates."/>
                </function>
                <function name="getFlatRegion">
                    <trait>released</trait>
                    <keywords>surface, structure, planar, planarity, roughness</keywords>
                    <links>Image.getFlatness</links>
                    <desc>Find approximately flat regions in an image, typically a heightmap or distance image. The algorithm fits a plane to a local neighborhood around each pixel. If all pixel values / z-values in the neighborhood deviate less than a user-specified threshold from the fitted plane, the central pixel is considered to be in a flat region. There is a fast and slow method for the plane fitting, where the slower method uses all pixels in the neighborhood to estimate the plane and the fast method only uses the border values in the neighborhood. Smoothing the input image first using a blur, gauss or median filter can sometimes be advisable.

Image world coordinate system handling:
Every position in the output region will have a maximum distance to the fitted plane in world units evaluated on the all pixels under the kernel that is lower than the threshold supplied.

Missing data handling:
Missing data is accepted, but partly ignored. No pixels that are missing in the input will be part of the output region. For pixels neighboring missing data the missing data positions are allowed to influence the flatness evaluation, possibly breaking the flatness constraint.</desc>
                    <sample for="lua">outputRegion = Image.getFlatRegion(image, threshold, neighborhoodSize)</sample>
                    <param name="image" type="const object" alias="Image" desc="Input image."/>
                    <param name="threshold" type="float" desc="Distance tolerance from the locally fitted plane in world units, e.g., millimeters. If all pixels in the neighborhood deviate less than the threshold the central pixel is classified as flat. The Image.getFlatness function can give an indication of possible threshold values."/>
                    <param name="neighborhoodSize" type="int" multiplicity="?" desc="The size of the neighborhood in pixels. Must be positive and odd. Default value is 13 pixels."/>
                    <param name="fast" type="bool" multiplicity="?" desc="Faster central difference estimate (true) or slower least squares fit (false) for the plane fitting. Default is true."/>
                    <param name="pixelRegion" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional pixelregion specifying where in the image to perform the operation."/>
                    <return name="outputRegion" type="object" multiplicity="?" alias="Image.PixelRegion" desc="The resulting region of flat pixels."/>
                </function>
                <function name="replace">
                    <trait>released</trait>
                    <links>Image.replaceInplace, Image.fillRegion, Image.inpaint, Image.PixelRegion.fillRegion</links>
                    <desc>Replaces the image content in a specified region with the content of another image. The images must have the same pixel type.

Image world coordinate system handling:
The world coordinate systems of the input images are not used. The output will have the same coordinate system as the first input image.

Missing data handling:
Raw pixel values are copied as they are. If there are missing data within the region in the replacing image, the source image pixels will be replaced by missing data.</desc>
                    <sample for="lua">local result = Image.replace(sourceImage, replacingImage, region)</sample>
                    <param name="sourceImage" type="const object" alias="Image" desc="Base image onto which the other image is painted."/>
                    <param name="replacingImage" type="const object" alias="Image" desc="The image containing the information to replace with."/>
                    <param name="region" type="const object" alias="Image.PixelRegion" desc="The region to replace."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="The composed image."/>
                </function>
                <function name="replaceInplace">
                    <trait>released</trait>
                    <links>Image.replace, Image.fillRegion, Image.inpaint</links>
                    <desc>Inplace version of the Image.replace function which modifies the first input image by replacing pixel values with pixel values from another image. See base function for full documentation.</desc>
                    <sample for="lua">local result = Image.replaceInplace(sourceImage, replacingImage, region)</sample>
                    <param name="sourceImage" type="object" alias="Image" desc="Base image onto which the other image is painted."/>
                    <param name="replacingImage" type="const object" alias="Image" desc="The image containing the information to replace with."/>
                    <param name="region" type="const object" alias="Image.PixelRegion" desc="The region to replace."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                </function>
                <function name="inpaint">
                    <trait>released</trait>
                    <links>Image.fillRegion, Image.replace, Image.growRegion, Image.drawPixelRegion</links>
                    <desc>Replaces the image content in a specified region with the content around the region. This is done in an iterative manner and increasing the radius increases the speed of the algorithm, at the cost of quality of the result.

Image world coordinate system handling:
The world coordinate system of the input image is not used. The output will have the same coordinate system as the input image.

Missing data handling:
Operation is performed in raw pixel values. If there are missing data along the borders of the region it will be used for inpainting.</desc>
                    <sample for="lua">local result = Image.inpaint(image, region)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image in which to perform inpainting."/>
                    <param name="region" type="const object" alias="Image.PixelRegion" desc="The region to be replaced."/>
                    <param name="radius" type="float" multiplicity="?" desc="Pixel radius used by inpainting algorithm. Default is 3.0."/>
                    <param name="method" type="enum" multiplicity="?" ref="InpaintMethod" desc="Inpainting method. Default is NAVIER_STOKES."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="The resulting image."/>
                </function>
                <function name="denoiseWavelet">
                    <trait>hidden</trait>
                    <desc>An edge-preserving smoothing filter using wavelet transformations. The filter reduces
noise by smoothing textures whilst retaining sharp edges.</desc>
                    <sample for="lua">local denoisedImage = Image.denoiseWavelet(image, 100)</sample>
                    <param name="image" type="const object" alias="Image" desc="The image to be denoised"/>
                    <param name="threshold" type="float" desc="The amount of denoising to apply. A higher value gives a smoother image."/>
                    <param name="levels" type="int" multiplicity="?" desc="Wavelet decomposition level. Setting this value higher gives a better result, but requires more computing power. Omit this parameter, or set it to 0 to use the maximum possible value for the image."/>
                    <return name="smoothedImage" type="object" multiplicity="?" alias="Image" desc="Returns the denoised image. Nil on failure."/>
                </function>
            </serves>
            <uses/>
            <crown name="Calibration">
                <trait>released</trait>
                <keywords>correction,rectification,distortion,undistortion,perspective correction,lens correction,pose estimation,alignment</keywords>
                <links>Image.Calibration.Correction</links>
                <desc>Functionality for performing camera calibration on 2D images.</desc>
                <enum name="TargetType">
                    <item name="Plain Empty Checkerboard" desc="Simple black and white checkerboard. Origin will be placed at one of the centrally located checkerboard corners with X-axis down, Y-axis right and Z-axis towards the camera. This means that two cameras observing the same pattern might get different origins.">PLAIN</item>
                    <item name="Three Dot Checkerboard" desc="Checkerboard with an origin marker represented by three dots. The Y-axis goes along the edge between the two neighboring points towards the single point. The coordinate system is right orthogonal with Z up from the calibration pattern. For Y to the right, this gives X down. To find the origin take one step along the Y-axis from the corner between the two neighboring points.">THREE_DOT</item>
                    <item name="Coordinate Code Checkerboard" desc="Checkerboard with simple codes in some of the white squares to encode the origin position. The origin of the coordinate system is normally marked with arrows in the calibration pattern and is typically placed in one of the corners. If the marker is missing the orientation of the coordinate system can be understood by placing the target such that two of the edges of the codes form the letter L. With this placement the coordinate system will have X down, Y to the right and Z straight up from the calibration pattern.">COORDINATE_CODE</item>
                </enum>
                <serves/>
                <uses/>
                <crown name="CameraModel">
                    <trait>released</trait>
                    <desc>Calibration result object of single camera. These objects can be stored to and loaded from file.

The results of the camera calibration satisfy the camera transformation equation from world to the image coordinate system:
xp = KD([R|t] * X)

K = [fx s cx, 0 fy cy, 0 0 1]
D = Brown–Conrady lens model: k1, k2, p1, p2, k3
R = [r11 r12 r13, r21 r22 r23, r31  r32  r33]
t = [tx ty tz]^T</desc>
                    <enum name="CoordinateSystem">
                        <item name="Camera Pixel" desc="Pixel coordinates of the input camera image">CAMERA_PIXEL</item>
                        <item name="Undistorted Pixel" desc="Pixel coordinates of the input camera image with lens distortion removed">UNDISTORTED_PIXEL</item>
                        <item name="External World" desc="Point on the world ground plane (at z=0) as defined by the camera model, usually from a calibration pattern">EXTERNAL_WORLD</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <desc>Create a instance for the calibration result handling</desc>
                            <sample for="lua">cameraModel = Image.Calibration.CameraModel.create()</sample>
                            <return name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="The calibration result object instance."/>
                        </function>
                        <function name="save">
                            <trait>deprecated</trait>
                            <links>Object.save</links>
                            <desc>Save calibration result object to a file.
This function is deprecated, please use Object.save/load instead.</desc>
                            <sample for="lua">local success = Image.Calibration.CameraModel.save(cameraModel, "private/CalibrationResult.xml")</sample>
                            <param name="cameraModel" type="const object" alias="Image.Calibration.CameraModel" desc="The instance to use."/>
                            <param name="fileName" type="string" desc="Filename, including path and file extension."/>
                            <return name="success" type="bool" desc="Returns true if the file is written correctly."/>
                        </function>
                        <function name="load">
                            <trait>deprecated</trait>
                            <links>Object.load</links>
                            <desc>Load calibration result object from a file.
This function is deprecated, please use Object.save/load instead.</desc>
                            <sample for="lua">local cameraModel = Image.Calibration.CameraModel.load("private/CalibrationResult.xml)</sample>
                            <param name="fileName" type="string" desc="Filename, including path and file extension."/>
                            <return name="cameraModel" type="object" multiplicity="?" alias="Image.Calibration.CameraModel" desc="The calibration result object or nil"/>
                        </function>
                        <function name="getEulerAngles">
                            <desc>Get the Euler angle representation (yaw, pitch, roll) of the transform into camera coordinates (in degree).</desc>
                            <sample for="lua">local yaw, pitch, roll = Image.Calibration.CameraModel.getEulerAngles(cameraModel)</sample>
                            <param name="cameraModel" type="const object" alias="Image.Calibration.CameraModel" desc="The instance to use."/>
                            <return name="yaw" type="float" desc="The rotation around x-axis in degree."/>
                            <return name="pitch" type="float" desc="The rotation around y-axis in degree."/>
                            <return name="roll" type="float" desc="The rotation around z-axis in degree."/>
                        </function>
                        <function name="getPosition">
                            <desc>Returns the position of the camera center as a 3D Point. If no extrinsic calibration is available the position will be in origin (0, 0, 0).</desc>
                            <sample for="lua">local center = Image.Calibration.CameraModel.getPosition(cameraModel)</sample>
                            <param name="cameraModel" type="const object" alias="Image.Calibration.CameraModel" desc="The instance to use."/>
                            <return name="center" type="object" alias="Point" desc="Camera center world position as a 3D point."/>
                        </function>
                        <function name="getTransform">
                            <desc>Returns the pose of the camera as Transform object.</desc>
                            <sample for="lua">local transform = Image.Calibration.CameraModel.getTransform(cameraModel)</sample>
                            <param name="cameraModel" type="const object" alias="Image.Calibration.CameraModel" desc="The instance to use."/>
                            <return name="transform" type="object" alias="Transform" desc="Rigid transformation from world to camera coordinates [R,t]."/>
                        </function>
                        <function name="setTransform">
                            <desc>Set the pose transformation of the camera as Transform object.</desc>
                            <sample for="lua">local transform = Image.Calibration.CameraModel.setTransform(cameraModel, transform)</sample>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="The instance to use."/>
                            <param name="transform" type="object" alias="Transform" desc="Rigid transformation describing the transformation from world to camera coordinates [R,t]."/>
                        </function>
                        <function name="getWorldToSensorDistortion">
                            <desc>Get the lens distortion coefficients [k1, k2, p1, p2, k3].</desc>
                            <sample for="lua">local k1, k2, p1, p2, k3 = Image.Calibration.CameraModel.getWorldToSensorDistortion(cameraModel)</sample>
                            <param name="cameraModel" type="const object" alias="Image.Calibration.CameraModel" desc="The instance to use."/>
                            <return name="k1" type="float" desc="Second order radial lens distortion coefficient."/>
                            <return name="k2" type="float" desc="Fourth order radial lens distortion coefficient."/>
                            <return name="p1" type="float" desc="First tangential lens distortion coefficient."/>
                            <return name="p2" type="float" desc="Second tangential lens distortion coefficient."/>
                            <return name="k3" type="float" desc="Sixth order radial lens distortion coefficient."/>
                        </function>
                        <function name="setWorldToSensorDistortion">
                            <desc>Set the lens distortion coefficients [k1, k2, p1, p2, k3].</desc>
                            <sample for="lua">local transform = Image.Calibration.CameraModel.setWorldToSensorDistortion(cameraModel, k1, k2, p1, p2, k3)</sample>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="The instance to use."/>
                            <param name="k1" type="float" multiplicity="?" desc="Set second order radial lens distortion coefficient."/>
                            <param name="k2" type="float" multiplicity="?" desc="Set fourth order radial lens distortion coefficient."/>
                            <param name="p1" type="float" multiplicity="?" desc="Set first tangential lens distortion coefficient."/>
                            <param name="p2" type="float" multiplicity="?" desc="Set second tangential lens distortion coefficient."/>
                            <param name="k3" type="float" multiplicity="?" desc="Set sixth order radial lens distortion coefficient."/>
                        </function>
                        <function name="getSensorToWorldDistortion">
                            <desc>Get the lens distortion coefficients [k1, k2, p1, p2, k3].</desc>
                            <sample for="lua">local k1, k2, p1, p2, k3 = Image.Calibration.CameraModel.getSensorToWorldDistortion(cameraModel)</sample>
                            <param name="cameraModel" type="const object" alias="Image.Calibration.CameraModel" desc="The instance to use."/>
                            <return name="k1" type="float" desc="Second order radial lens distortion coefficient."/>
                            <return name="k2" type="float" desc="Fourth order radial lens distortion coefficient."/>
                            <return name="p1" type="float" desc="First tangential lens distortion coefficient."/>
                            <return name="p2" type="float" desc="Second tangential lens distortion coefficient."/>
                            <return name="k3" type="float" desc="Sixth order radial lens distortion coefficient."/>
                        </function>
                        <function name="setSensorToWorldDistortion">
                            <desc>Set the lens distortion coefficients [k1, k2, p1, p2, k3].</desc>
                            <sample for="lua">local transform = Image.Calibration.CameraModel.setSensorToWorldDistortion(cameraModel, k1, k2, p1, p2, k3)</sample>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="The instance to use."/>
                            <param name="k1" type="float" multiplicity="?" desc="Set second order radial lens distortion coefficient."/>
                            <param name="k2" type="float" multiplicity="?" desc="Set fourth order radial lens distortion coefficient."/>
                            <param name="p1" type="float" multiplicity="?" desc="Set first tangential lens distortion coefficient."/>
                            <param name="p2" type="float" multiplicity="?" desc="Set second tangential lens distortion coefficient."/>
                            <param name="k3" type="float" multiplicity="?" desc="Set sixth order radial lens distortion coefficient."/>
                        </function>
                        <function name="getIntrinsicK">
                            <desc>Get the intrinsic camera matrix.</desc>
                            <sample for="lua">local intrinsic = Image.Calibration.CameraModel.getIntrinsicK(cameraModel)</sample>
                            <param name="cameraModel" type="const object" alias="Image.Calibration.CameraModel" desc="The instance to use."/>
                            <return name="intrinsic" type="object" alias="Matrix" desc="A 3x3 matrix with the intrinsic camera parameters: K = [fx s cx, 0 fy cy, 0 0 1]"/>
                        </function>
                        <function name="setIntrinsicK">
                            <desc>Set the intrinsic camera matrix.</desc>
                            <sample for="lua">Image.Calibration.CameraModel.setIntrinsicK(cameraModel, intrinsic)</sample>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="The instance to use."/>
                            <param name="intrinsic" type="object" alias="Matrix" desc="A 3x3 matrix with the intrinsic camera parameters: K = [fx s cx, 0 fy cy, 0 0 1]"/>
                        </function>
                        <function name="getProjectionMatrix">
                            <desc>Get the 3x4 projection matrix P = K[R|t]. Transformation xp = K*(R*Xw + T), with xp = [u/z, v/z, z/z] = [x,y,1] in homogeneous coordinates and Xw = [X,Y,Z] in 3D world coordinates.</desc>
                            <sample for="lua">local projectionMatrix = Image.Calibration.CameraModel.getProjectionMatrix(cameraModel)</sample>
                            <param name="cameraModel" type="const object" alias="Image.Calibration.CameraModel" desc="The instance to use."/>
                            <return name="projectionMatrix" type="object" alias="Matrix" desc="A 3x4 projection matrix P = K[R|t]."/>
                        </function>
                        <function name="setProjectionMatrix">
                            <desc>Set the 3x4 projection matrix P = K[R|t].</desc>
                            <sample for="lua">Image.Calibration.CameraModel.setProjectionMatrix(cameraModel, projectionMatrix)</sample>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="The instance to use."/>
                            <param name="projectionMatrix" type="object" alias="Matrix" desc="A 3x4 projection matrix P = K[R|t]."/>
                        </function>
                        <function name="getFocalDistance">
                            <desc>Get the camera model focus setting parameter.</desc>
                            <sample for="lua">local focalDistance, unit = Image.Calibration.CameraModel.getFocalDistance(cameraModel)</sample>
                            <param name="cameraModel" type="const object" alias="Image.Calibration.CameraModel" desc="The instance to use."/>
                            <return name="focalDistance" type="float" desc="Distance from the camera to the plane of best image sharpness."/>
                            <return name="unit" type="string" desc="Focal distance unit. Default is mm."/>
                        </function>
                        <function name="setFocalDistance">
                            <desc>Set the camera model focus setting parameter.</desc>
                            <sample for="lua">Image.Calibration.CameraModel.setFocalDistance(cameraModel, focalDistance, unit)</sample>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="The instance to use."/>
                            <param name="focalDistance" type="float" desc="Distance from the camera to the plane of best image sharpness."/>
                            <param name="unit" type="string" desc="Focal distance unit. Default is mm."/>
                        </function>
                        <function name="getCameraID">
                            <desc>Get the unique camera identifier.</desc>
                            <sample for="lua">local cameraID = Image.Calibration.CameraModel.getCameraID(cameraModel)</sample>
                            <param name="cameraModel" type="const object" alias="Image.Calibration.CameraModel" desc="The instance to use."/>
                            <return name="cameraID" type="string" desc="The unique camera identifier."/>
                        </function>
                        <function name="setCameraID">
                            <desc>Set the unique camera identifier.</desc>
                            <sample for="lua">Image.Calibration.CameraModel.setCameraID(cameraModel, cameraID)</sample>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="The instance to use."/>
                            <param name="cameraID" type="string" desc="The unique camera identifier."/>
                        </function>
                        <function name="getCalibrationImageSize">
                            <desc>Get the image size for which the calibration is valid.</desc>
                            <sample for="lua">local imageWidth, imageHeight = Image.Calibration.CameraModel.getCalibrationImageSize(cameraModel)</sample>
                            <param name="cameraModel" type="const object" alias="Image.Calibration.CameraModel" desc="The instance to use."/>
                            <return name="imageWidth" type="int" desc="The image width for which the calibration is valid."/>
                            <return name="imageHeight" type="int" desc="The image height for which the calibration is valid."/>
                        </function>
                        <function name="setCalibrationImageSize">
                            <desc>Set the image size for which the calibration is valid.</desc>
                            <sample for="lua">Image.Calibration.CameraModel.setCalibrationImageSize(cameraModel, imageWidth, imageHeight)</sample>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="The instance to use."/>
                            <param name="imageWidth" type="int" desc="The image width for which the calibration is valid."/>
                            <param name="imageHeight" type="int" desc="The image height for which the calibration is valid."/>
                        </function>
                        <function name="getXMLVersionTag">
                            <desc>Get the version tag of the XML file.</desc>
                            <sample for="lua">local versionTag = Image.Calibration.CameraModel.getXMLVersionTag(cameraModel)</sample>
                            <param name="cameraModel" type="const object" alias="Image.Calibration.CameraModel" desc="The instance to use."/>
                            <return name="versionTag" type="string" desc="The version tag of the XML."/>
                        </function>
                        <function name="toString">
                            <desc>Gets a short string description of the camera model.</desc>
                            <sample for="lua">local str = Image.Calibration.CameraModel.toString(cameraModel)</sample>
                            <param name="cameraModel" type="const object" alias="Image.Calibration.CameraModel" desc="The camera model object."/>
                            <return name="str" type="string" desc="Description of the camera model."/>
                        </function>
                        <function name="mapPoints">
                            <keywords>transform, apply camera model</keywords>
                            <links>Image.Calibration.Correction.mapPoints</links>
                            <desc>Transform points between the three coordinate systems related to a camera model. See the CoordinateSystem enum for details.</desc>
                            <sample for="lua">local pointsOut = Image.Calibration.CameraModel.mapPoints(cameraModel, pointsIn, "CAMERA_PIXEL", "EXTERNAL_WORLD")</sample>
                            <param name="cameraModel" type="const object" alias="Image.Calibration.CameraModel" desc="The instance to use."/>
                            <param name="points" type="const object" multiplicity="[1+]" alias="Point" desc="A single or a list of points to be transformed."/>
                            <param name="sourceSystem" type="enum" ref="CoordinateSystem" desc="Specifies the coordinate system in which the input point is defined."/>
                            <param name="targetSystem" type="enum" ref="CoordinateSystem" desc="Specifies the coordinate system to transform the points into."/>
                            <return name="pointsOut" type="object" multiplicity="[?*]" alias="Point" desc="Transformed points (single point or array)."/>
                        </function>
                        <function name="getRodriguesVector">
                            <desc>Get the Rodrigues representation of the transform into camera coordinates.</desc>
                            <sample for="lua">local rodrigues = Image.Calibration.CameraModel.getRodriguesVector(cameraModel)</sample>
                            <param name="cameraModel" type="const object" alias="Image.Calibration.CameraModel" desc="The instance to use."/>
                            <return name="rodrigues" type="object" alias="Point" desc="Rigid transformation in form of a Rodrigues vector."/>
                        </function>
                        <function name="getFrustum">
                            <trait>released</trait>
                            <keywords>field of view, fov</keywords>
                            <links>Image.Calibration.CameraModel.getFrustumOverlap,Image.Calibration.CameraModel.getVisualization</links>
                            <desc>Calculates camera frustum in a given plane. If a plane is not supplied the overlap will be calculated in the calibration plane pose was calculated, or at unit distance from the camera if uncalibrated.</desc>
                            <sample for="lua">center, topLeft, topRight, bottomRight, bottomLeft = Image.Calibration.CameraModel.getFrustum(cameraModel)</sample>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="Camera model object containing the camera calibration."/>
                            <param name="plane" type="const object" multiplicity="?" alias="Shape3D" desc="The world plane in which to calculate the frustum."/>
                            <return name="center" type="object" multiplicity="?" alias="Point" desc="The camera center in world coordinates."/>
                            <return name="topLeft" type="object" multiplicity="?" alias="Point" desc=""/>
                            <return name="topRight" type="object" multiplicity="?" alias="Point" desc=""/>
                            <return name="bottomRight" type="object" multiplicity="?" alias="Point" desc=""/>
                            <return name="bottomLeft" type="object" multiplicity="?" alias="Point" desc=""/>
                        </function>
                        <function name="getFrustumOverlap">
                            <trait>released</trait>
                            <keywords>field of view, fov</keywords>
                            <links>Image.Calibration.CameraModel.getFrustum,Image.Calibration.CameraModel.getVisualization</links>
                            <desc>Calculates the camera frustum projection onto a world plane for two or more cameras and returns the overlapping region in each camera image.</desc>
                            <sample for="lua">regions, corners = Image.Calibration.CameraModel.getFrustumOverlap(cameraModel)</sample>
                            <param name="cameraModel" type="object" multiplicity="+" alias="Image.Calibration.CameraModel" desc="Camera model objects (at least 2)."/>
                            <param name="plane" type="const object" multiplicity="?" alias="Shape3D" desc="The world plane in which to calculate the overlap."/>
                            <return name="regions" type="object" multiplicity="*" alias="Image.PixelRegion" desc="A list of PixelRegions with the view overlap projected into each view."/>
                            <return name="corners" type="object" multiplicity="*" alias="Point" desc="The world corners of the overlapping region."/>
                        </function>
                        <function name="resize">
                            <trait>released</trait>
                            <keywords>rescale, morph, enlarge, shrink</keywords>
                            <links>Image.resize, Image.Calibration.CameraModel.resizeScale, Image.Calibration.CameraModel.crop, Image.Calibration.CameraModel.translate, Image.Calibration.CameraModel.transform</links>
                            <desc>Function used to calculate a new camera model for a resized version of a calibrated image. That is, if Image.resize has been applied to an image, this function can be used to find a camera model that fits the new image.</desc>
                            <sample for="lua">resizedModel = Image.Calibration.CameraModel.resize(cameraModel, width, height)</sample>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="Camera model object containing the camera calibration."/>
                            <param name="width" type="int" desc="The width of the target."/>
                            <param name="height" type="int" desc="The height of the target."/>
                            <return name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="The camera model adjusted to a resized image."/>
                        </function>
                        <function name="resizeScale">
                            <trait>released</trait>
                            <keywords>rescale, morph, enlarge, shrink</keywords>
                            <links>Image.resizeScale, Image.Calibration.CameraModel.resize, Image.Calibration.CameraModel.crop, Image.Calibration.CameraModel.translate, Image.Calibration.CameraModel.transform</links>
                            <desc>Function used to calculate a new camera model for a resized version of a calibrated image. That is, if Image.resizeScale has been applied to an image, this function can be used to find a camera model that fits the new image.</desc>
                            <sample for="lua">resizedModel = Image.Calibration.CameraModel.resizeScale(cameraModel, scale)</sample>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="Camera model object containing the camera calibration."/>
                            <param name="scaleX" type="float" desc="The scale factor to apply in the horizontal direction."/>
                            <param name="scaleY" type="float" multiplicity="?" desc="The scale factor to apply in the vertical direction. If left out scaleX will be used."/>
                            <return name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="The camera model adjusted to a resized image."/>
                        </function>
                        <function name="crop">
                            <trait>released</trait>
                            <keywords>cut, reduce, shrink</keywords>
                            <links>Image.crop, Image.Calibration.CameraModel.resize, Image.Calibration.CameraModel.resizeScale, Image.Calibration.CameraModel.translate, Image.Calibration.CameraModel.transform</links>
                            <desc>Function used to calculate a new camera model for a cropped version of a calibrated image. That is, if Image.crop has been applied to an image, this function can be used to find a camera model that fits the new image.</desc>
                            <sample for="lua">croppedModel = Image.Calibration.CameraModel.crop(cameraModel, x, y, width, height)</sample>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="Camera model object containing the camera calibration."/>
                            <param name="x" type="int" desc="The x pixel position of the first pixel."/>
                            <param name="y" type="int" desc="The y pixel position of the first pixel."/>
                            <param name="width" type="int" desc="The amount of pixels in the horizontal direction."/>
                            <param name="height" type="int" desc="The amount of pixels in the vertical direction."/>
                            <return name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="The camera model adjusted to a cropped image."/>
                        </function>
                        <function name="translate">
                            <trait>released</trait>
                            <keywords>move, modify pose, align</keywords>
                            <links>Image.Calibration.CameraModel.resize, Image.Calibration.CameraModel.resizeScale, Image.Calibration.CameraModel.crop, Image.Calibration.CameraModel.transform</links>
                            <desc>Calculate camera model objects with poses translated one or more distance(s) along the input direction vector. The variable "distance" can be a scalar or a vector and the output will have the same dimension.</desc>
                            <sample for="lua">cameraModelPoses = Image.Calibration.CameraModel.translate(cameraModel, directionVector, distance)</sample>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="Camera model object containing the camera calibration."/>
                            <param name="directionVector" type="float" multiplicity="+" desc="The direction of the motion represented as a vector (x, y, z)."/>
                            <param name="distance" type="float" multiplicity="[1+]" desc="Exposure distance along the direction vector (can be a scalar or a vector of distances)."/>
                            <return name="cameraModelPoses" type="object" multiplicity="[1+]" desc="Camera model(s) corresponding to the position(s) along the direction vector. Will have the same size as the input distance."/>
                        </function>
                        <function name="transform">
                            <trait>released</trait>
                            <keywords>modify pose, align</keywords>
                            <links>Image.Calibration.CameraModel.resize, Image.Calibration.CameraModel.resizeScale, Image.Calibration.CameraModel.crop, Image.Calibration.CameraModel.translate</links>
                            <desc>Calculate a camera model object with the pose transformed in accordance with the provided transform object. The transformation is applied from the left such that the camera pose transform C becomes C' = transform*C.</desc>
                            <sample for="lua">updatedModel = Image.Calibration.CameraModel.transform(cameraModel, transform)</sample>
                            <param name="cameraModel" type="const object" alias="Image.Calibration.CameraModel" desc="Camera model object containing the camera calibration."/>
                            <param name="transform" type="const object" alias="Transform" desc="The transform object describing how to move the camera."/>
                            <return name="updatedModel" type="object" multiplicity="?" desc="The resulting camera placed at the new location. On failure nil is returned."/>
                        </function>
                    </serves>
                    <uses/>
                </crown>
                <crown name="Pattern">
                    <trait>released</trait>
                    <desc>Different pattern generators and detectors for calibration targets. Currently supports the three types PLAIN, THREE_DOT and COORDINATE_CODE.

PLAIN is recommended for intrinsic camera calibration which can be performed using Image.Calibration.Camera.
THREE_DOT and COORDINATE_CODE are recommended for pose calibration with the corresponding function under Image.Calibration.Pose.

THREE_DOT has the advantage of being simple, while having the limitation that all cameras must see the same three dots to find the origin of the world coordinate system.
COORDINATE_CODE patterns allows cameras to observe completely distinct pieces of the calibration target, while still producing a calibration in the same world coordinate system.</desc>
                    <serves>
                        <function name="getCheckerboardPixel">
                            <trait>released</trait>
                            <keywords></keywords>
                            <links></links>
                            <desc>Generates a checkerboard pattern based on given values in pixels and number of squares.

For details on the different patterns see the enum description.</desc>
                            <sample for="lua">Image.Calibration.Pattern.getCheckerboardPixel(10, 12, 100, "COORDINATE_CODE")</sample>
                            <param name="horizontalSquares" type="int" desc="The number of horizontal squares in the pattern. At least 2, for THREE_DOT at least 5."/>
                            <param name="verticalSquares" type="int" desc="The number of vertical squares in the pattern. At least 2."/>
                            <param name="squareSide" type="int" desc="Specify how many pixels to have along each side of a square in the generated image. Cannot be less than 24."/>
                            <param name="type" type="enum" ref="TargetType" desc="Select the type of pattern to generate."/>
                            <return name="generatedPattern" type="object" multiplicity="?" alias="Image" desc="Returns the generated pattern as an image."/>
                        </function>
                        <function name="getCheckerboardDPI">
                            <trait>released</trait>
                            <keywords></keywords>
                            <links></links>
                            <desc>Generates a checkerboard pattern based on sizes in millimeters.

The generation takes limits on the output image in mm, the desired square size and a DPI resolution.
The square size is internally adjusted to fit to the closest integer position. Therefore the actual size of each square after print is not exactly the selected value. The actual size is returned as the first output.

Note that the DPI needs to be set before print as the image does not carry the DPI setting. Alternatively it's possible to print with the appropriate scale. For example most printers assume 72 DPI and if the pattern was generated using 300 DPI the scale can be set to 0.24 (72/300).

For details on the different patterns see the enum description.</desc>
                            <sample for="lua">Image.Calibration.Pattern.getCheckerboardDPI(297, 210, 15, "COORDINATE_CODE")</sample>
                            <param name="maxWidth" type="float" desc="The maximum width of the image in mm at given resolution."/>
                            <param name="maxHeight" type="float" desc="The maximum height of the image in mm at given resolution."/>
                            <param name="squareSide" type="float" desc="Specify how many mm it is desired to have along each side of a square in the generated image."/>
                            <param name="type" type="enum" ref="TargetType" desc="Select the type of pattern to generate."/>
                            <param name="dpi" type="int" multiplicity="?" desc="Specify the desired dots per inch, i.e. the resolution when printing. Default is 300 dpi."/>
                            <return name="actualSquareSide" type="float" multiplicity="?" desc="The actual size of a square after print if printing at the set resolution."/>
                            <return name="generatedPattern" type="object" multiplicity="?" alias="Image" desc="The generated pattern image."/>
                        </function>
                        <function name="detectCheckerboard">
                            <trait>released</trait>
                            <desc>Finds a checkerboard in an image and returns the image points together with their sorted grid positions.
This can be used to create custom calibration routines or to build other things based on checkerboards.</desc>
                            <sample for="lua">Image.Calibration.Pattern.detectCheckerboard(image, "COORDINATE_CODE")</sample>
                            <param name="image" type="object" alias="Image" desc="The input image in which to find a checkerboard."/>
                            <param name="patternType" type="enum" ref="TargetType" desc="The pattern type to look for when deciding the origin."/>
                            <param name="downsamplefactor" type="int" multiplicity="?" desc="A value larger of equal to 0. A higher value gives faster runtime but possibly less detections. Default is 0."/>
                            <return name="points" type="object" multiplicity="*" alias="Point" desc="Image points that correspond to checkerboard corners."/>
                            <return name="indices" type="object" multiplicity="*" alias="Point" desc="The world grid coordinates corresponding to points."/>
                        </function>
                    </serves>
                </crown>
                <crown name="Camera">
                    <trait>released</trait>
                    <desc>Image.Calibration.Camera can be used to estimate intrinsic and lens distortion parameters of a single camera.

The full checkerboard pattern does not have to be visible in the calibration image for the algorithm to work.
It is recommended to provide multiple images with varying pattern orientation to get an accurate calibration.

The estimation of the intrinsic and extrinsic parameters can be adapted to different requirements.
Therefore the Image.Calibration.Camera handle has multiple methods to enable or disable different camera model parameters.

If you are only interested in extracting checkerboard corners, you can use the "findCornerPoints" method.

The result object of Image.Calibration.Camera is the Image.Calibration.CameraModel with the intrinsic parameter defined as
K = [fx s cx, 0 fy cy, 0 0 1]</desc>
                    <enum name="CalibrationTargetType">
                        <item name="Checkerboard" desc="Checkerboard calibration target">CHECKERBOARD</item>
                        <item name="Checkerboard plus 2D-code" desc="Checkerboard plus 2D-code calibration target">CHECKERBOARD_PLUS_CODE</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <desc>Create a handle for the calibration</desc>
                            <sample for="lua">handle = Image.Calibration.Camera.create()</sample>
                            <return name="handle" type="handle" alias="Image.Calibration.Camera" desc="The calibration object handle."/>
                        </function>
                        <function name="setTargetType">
                            <trait>hidden</trait>
                            <desc>Select which target you want to use. Supported targets are the CHECKERBOARD and the CHECKERBOARD_PLUS_CODE.
The option to use CHECKERBOARD_PLUS_CODE is only relevant when using the CSC system proprietary matrix code. It is not the same as COORDINATE_CODE or THREE_DOT and the add command will fail if one of these targets is used. This mode also requires that the user provides code detection in the addImage call.
Default target is CHECKERBOARD. Use this unless there is a specific reason not to.</desc>
                            <sample for="lua">Image.Calibration.Camera.setTargetType(handle, "CHECKERBOARD")</sample>
                            <param name="handle" type="handle" alias="Image.Calibration.Camera" desc="The instance to use."/>
                            <param name="targetType" type="enum" ref="CalibrationTargetType" desc="Could be 'CHECKERBOARD' or 'CHECKERBOARD_PLUS_CODE'."/>
                        </function>
                        <function name="setDistortionCoefficientsEnabled">
                            <desc>Enable the estimation of radial and tangential distortion [k1, k2, p1, p2, k3]. No distortion is estimated if the parameters are not set.</desc>
                            <sample for="lua">Image.Calibration.Camera.setDistortionCoefficientsEnabled(handle, true, true, false, false, false)</sample>
                            <param name="handle" type="handle" alias="Image.Calibration.Camera" desc="The instance to use."/>
                            <param name="k1" type="bool" multiplicity="?" desc="Enable or disable 2nd order radial lens distortion coefficient."/>
                            <param name="k2" type="bool" multiplicity="?" desc="Enable or disable 4th order radial lens distortion coefficient."/>
                            <param name="p1" type="bool" multiplicity="?" desc="Enable or disable 1st order tangential lens distortion coefficient."/>
                            <param name="p2" type="bool" multiplicity="?" desc="Enable or disable 2nd order tangential lens distortion coefficient."/>
                            <param name="k3" type="bool" multiplicity="?" desc="Enable or disable 6th order radial lens distortion coefficient."/>
                        </function>
                        <function name="setDistortionCoefficientValues">
                            <desc>Set the lens distortion start values for the non-linear optimization.</desc>
                            <sample for="lua">Image.Calibration.Camera.setDistortionCoefficientValues(handle, k1, k2, p1, p2, k3) </sample>
                            <param name="handle" type="handle" alias="Image.Calibration.Camera" desc="The instance to use."/>
                            <param name="k1" type="float" desc="Set initial value for estimating 2nd order radial lens distortion coefficient."/>
                            <param name="k2" type="float" desc="Set initial value for estimating 4th order radial lens distortion coefficient."/>
                            <param name="p1" type="float" multiplicity="?" desc="Set initial value for estimating 1st order tangential lens distortion coefficient."/>
                            <param name="p2" type="float" multiplicity="?" desc="Set initial value for estimating 2nd order tangential lens distortion coefficient."/>
                            <param name="k3" type="float" multiplicity="?" desc="Set initial value for estimating 6th order radial lens distortion coefficient."/>
                        </function>
                        <function name="setSkewEnabled">
                            <desc>Enable the skew estimation of the intrinsic camera matrix K. By default, the skew parameter estimation is deactivated.</desc>
                            <sample for="lua">Image.Calibration.Camera.setSkewEnabled(handle, false)</sample>
                            <param name="handle" type="handle" alias="Image.Calibration.Camera" desc="The instance to use."/>
                            <param name="s" type="bool" desc="Enable intrinsic camera matrix skew parameter estimation."/>
                        </function>
                        <function name="setCheckerSquareSideLength">
                            <desc>Set checkerboard square size in mm. Must be positive.</desc>
                            <sample for="lua">Image.Calibration.Camera.setCheckerSquareSideLength(handle, size) </sample>
                            <param name="handle" type="handle" alias="Image.Calibration.Camera" desc="The instance to use."/>
                            <param name="sideLength" type="float" multiplicity="[1+]" desc="Checkerboard corner side length in mm. If your target is not accurate enough and your checkerboard elements are not quadratic, you can enter the side length dimensions for x, y and z. The algorithm will correct the world corner values. Keep in mind you also have to specify the 'checkerboardDimensions' for the CHECKERBOARD type. Otherwise the algorithm cannot determine which side length belongs to which dimension."/>
                            <param name="checkerboardDimensions" type="int" multiplicity="*" desc="Optional and only for CHECKERBOARD : Number of checkerboard corners in x and y direction. "/>
                        </function>
                        <function name="addImage">
                            <desc>Add an image to the calibration image evaluation. The method returns true if the image is a valid. An image can be valid but too similar to previously added images. If this occurs this is indicated by the imgSelected output. The method is overloaded for the two different calibration patterns. The "optional" arguments are only needed for the CHECKERBOARD_PLUS_CODE calibration pattern.</desc>
                            <sample for="lua">Image.Calibration.Camera.addImage(handle, image, codeContent, codeRegion)</sample>
                            <param name="handle" type="handle" alias="Image.Calibration.Camera" desc="The instance to use."/>
                            <param name="image" type="object" alias="Image" desc="Gray scale image of the calibration target."/>
                            <param name="codeContent" type="binary" multiplicity="*" desc="Optional: List of code contents."/>
                            <param name="codeRegion" type="const object" multiplicity="*" alias="Shape" desc="Optional: List of code ROIs, each represented as a 4-point polyline shape."/>
                            <return name="imgValid" type="bool" desc="Returns true if valid points found."/>
                            <return name="featurePoints2D" type="object" multiplicity="+" alias="Point" desc="2D checkerboard corners in image plane for the result visualization."/>
                            <return name="featurePoints3D" type="object" multiplicity="+" alias="Point" desc="Corresponding 3D world coordinates of the checkerboard corners."/>
                            <return name="imgSelected" type="bool" desc="If the returned value is true the input image will contribute to the calibration."/>
                        </function>
                        <function name="calculate">
                            <trait>deprecated</trait>
                            <desc>Calculate the intrinsic sensor parameters from the set of images containing the calibration target collected under different perspectives.
Deprecated, please use Image.Calibration.Camera.estimate instead.</desc>
                            <sample for="lua">local success, cameraModel = Image.Calibration.Camera.calculate(handle)</sample>
                            <param name="handle" type="handle" alias="Image.Calibration.Camera" desc="The instance to use."/>
                            <return name="success" type="bool" desc="Returns true if a valid solution for the calibration was found."/>
                            <return name="cameraModel" type="object" multiplicity="?" alias="Image.Calibration.CameraModel" desc="Calibration result parameter."/>
                            <return name="calibConfidence" type="float" multiplicity="?" desc="Calibration result confidence value. Range: [100 - 90] percent is very good; [90 - 70] percent is OK; [70 - 50] accuracy is not that high; [50 - 0] re-calibration is suggested"/>
                            <return name="reprojectionError" type="float" multiplicity="?" desc="The square root of the average squared distance between detected 2D feature points and projected 3D feature points using the estimated camera calibration parameters."/>
                            <return name="residuals" type="object" multiplicity="*" desc="The calibration residuals for each calibration point. For each image you receive a vector of vectors of 2D points."/>
                        </function>
                        <function name="estimate">
                            <desc>Estimate the intrinsic sensor parameters from the set of images containing the calibration target collected under different perspectives.</desc>
                            <sample for="lua">local cameraModel, error = Image.Calibration.Camera.estimate(handle)</sample>
                            <param name="handle" type="handle" alias="Image.Calibration.Camera" desc="The instance to use."/>
                            <return name="cameraModel" type="object" multiplicity="?" alias="Image.Calibration.CameraModel" desc="Calibration result parameter."/>
                            <return name="error" type="float" multiplicity="?" desc="The square root of the average squared distance between detected 2D feature points and projected 3D feature points using the estimated camera calibration parameters."/>
                        </function>
                        <function name="getCornerPoints">
                            <desc>Returns the vector of corner points for the n-th image or for all images if index is left empty.</desc>
                            <sample for="lua">local featurePoints2D, featurePoints3D = Image.Calibration.Camera.getCornerPoints(handle, index)</sample>
                            <param name="handle" type="handle" alias="Image.Calibration.Camera" desc="The instance to use."/>
                            <param name="index" type="int" multiplicity="?" desc="Image index."/>
                            <return name="featurePoints2D" type="object" multiplicity="+" alias="Point" desc="2D checkerboard corners in image plane for the result visualization."/>
                            <return name="featurePoints3D" type="object" multiplicity="+" alias="Point" desc="Corresponding 3D world coordinates of the checkerboard corners."/>
                        </function>
                        <function name="getResiduals">
                            <desc>Returns the vector of residuals the n-th image or the residuals for all images if index is left empty.</desc>
                            <sample for="lua">local residuals = Image.Calibration.Camera.getResiduals(handle, index)</sample>
                            <param name="handle" type="handle" alias="Image.Calibration.Camera" desc="The instance to use."/>
                            <param name="index" type="int" multiplicity="?" desc="Image index."/>
                            <return name="residuals" type="object" multiplicity="+" alias="Point" desc="The residuals of 3D points reprojected into the image."/>
                        </function>
                        <function name="findCornerPoints">
                            <desc>Computes the calibration target feature points without adding the result to the camera calibration data set.</desc>
                            <sample for="lua">local imgValid, featurePoints2D, featurePoints3D = Image.Calibration.Camera.findCornerPoints(handle, image)</sample>
                            <param name="handle" type="handle" alias="Image.Calibration.Camera" desc="The instance to use."/>
                            <param name="image" type="object" alias="Image" desc="Gray scale image of the calibration target."/>
                            <param name="codeContent" type="binary" multiplicity="*" desc="Optional: List of code contents."/>
                            <param name="codeRegion" type="const object" multiplicity="*" alias="Shape" desc="Optional: List of code ROIs, each represented as a 4-point polyline shape."/>
                            <return name="imgValid" type="bool" desc="Returns true if valid points found."/>
                            <return name="featurePoints2D" type="object" multiplicity="+" alias="Point" desc="2D checkerboard corners in image plane for the result visualization."/>
                            <return name="featurePoints3D" type="object" multiplicity="+" alias="Point" desc="Corresponding 3D world coordinates of the checkerboard corners."/>
                        </function>
                        <function name="setDownsampleFactor">
                            <trait>released</trait>
                            <desc>Set the minimum number of octaves to downsample the calibration images in the corner detection stage. Large number gives higher speed but requires larger chess squares.</desc>
                            <sample for="lua">Image.Calibration.Camera.setDownsampleFactor(handle, downsamplefactor) </sample>
                            <param name="handle" type="handle" alias="Image.Calibration.Camera" desc="The instance to use."/>
                            <param name="downsamplefactor" type="int" multiplicity="?" desc="Set the number of octaves to downsample the input images."/>
                        </function>
                        <function name="setUniquenessThreshold">
                            <trait>released</trait>
                            <desc>Enable automatic image selection and set the acceptance threshold. Only unique images are stored, that is, images that have not previously been observed in terms of orientation and distance. A lower threshold results in more accepted images.

The threshold relates to three different properties of the input image. The distance between camera and calibration board and the tilt of the calibration board in the horizontal and vertical direction respectively. All measurements are relative and not real world units. Real world units are not accessible until after calibration has been completed. To allow additions of calibration boards closer together than default select a threshold value under 1.0, to instead be more selective select a value above 1.0.

Distance
With the threshold set to 1.0, the images must be at least 15% apart in distance to be accepted. For example, if one accepted image is taken at distance 1.0 m, the next must be at least 1.15 m away to be accepted. The minimum distance change required to take a new image is the (current distance)*(0.15 * threshold).

Tilt (same for X and Y)
With the threshold set to 1.0, the distance variation between corners in the checkerboard along X/Y must be 10% greater or lower than any previously observed image. For example, if one accepted image has no tilt (same distance between all corners on the board), the distance must change from e.g. 1.0 m to 1.1 m when moving along X/Y on the board.</desc>
                            <sample for="lua">Image.Calibration.Camera.setUniquenessThreshold(handle, enable, threshold)</sample>
                            <param name="handle" type="handle" alias="Image.Calibration.Camera" desc="The instance to use."/>
                            <param name="enable" type="bool" desc="True to enable automatic image selection, false to use all input images. Default is true."/>
                            <param name="threshold" type="float" multiplicity="?" desc="Set the threshold. Default is 1.0."/>
                        </function>
                        <function name="evaluateOnImage">
                            <desc>Evaluate the calibration using an image of the calibration target.</desc>
                            <sample for="lua">local success, reprojectionError, residuals, featurePoints2D = Image.Calibration.Camera.evaluateOnImage(handle, image)</sample>
                            <param name="handle" type="handle" alias="Image.Calibration.Camera" desc="The instance to use."/>
                            <param name="image" type="object" alias="Image" desc="Gray scale image of the calibration target."/>
                            <return name="success" type="bool" desc="Returns true if a valid solution for the evaluation was found."/>
                            <return name="reprojectionError" type="float" multiplicity="?" desc="The square root of the average squared distance between detected 2D feature points and projected 3D feature points using the estimated camera calibration parameters."/>
                            <return name="residuals" type="object" multiplicity="*" desc="The calibration residuals for each calibration point."/>
                            <return name="featurePoints2D" type="object" multiplicity="*" alias="Point" desc="2D checkerboard corners in image plane for the result visualization."/>
                        </function>
                        <function name="evaluate">
                            <desc>Evaluate the calibration, either an in the Camera class existing cameraModel or an inserted cameraModel.
The values in the images residualImageX and residualImageY is the mean residual for the corners found in the different image regions.
The values in the image sampleHistogram is the number of corners found in the different image regions.</desc>
                            <sample for="lua">local success, reprojectionError, residualImageX, residualImageY, sampleHistogram, residuals, featurePoints2D = Image.Calibration.Camera.evaluate(handle, cameraModel)</sample>
                            <param name="handle" type="handle" alias="Image.Calibration.Camera" desc="The instance to use."/>
                            <param name="cameraModel" type="object" multiplicity="?" alias="Image.Calibration.CameraModel" desc="Calibration result parameter."/>
                            <return name="success" type="bool" multiplicity="?" desc="Returns true if a valid solution for the evaluation was found."/>
                            <return name="reprojectionError" type="float" multiplicity="?" desc="The square root of the average squared distance between detected 2D feature points and projected 3D feature points using the estimated camera calibration parameters."/>
                            <return name="residualImageX" type="object" multiplicity="?" alias="Image" desc="Mean x residual in image regions."/>
                            <return name="residualImageY" type="object" multiplicity="?" alias="Image" desc="Mean y residual in image regions."/>
                            <return name="sampleHistogram" type="object" multiplicity="?" alias="Image" desc="Histogram of x,y corner positions."/>
                            <return name="residuals" type="object" multiplicity="*" desc="The calibration residuals for each calibration point."/>
                            <return name="featurePoints2D" type="object" multiplicity="*" alias="Point" desc="2D checkerboard corners in image plane for the result visualization."/>
                        </function>
                        <function name="getDataCompleteness">
                            <trait>released</trait>
                            <desc>Returns data completeness estimates. These are useful for visualizing the state of the calibration prior to calling calibrate.</desc>
                            <sample for="lua">local area, tiltX, tiltY, distance, sampleHistogram = Image.Calibration.Camera.getDataCompleteness(handle)</sample>
                            <param name="handle" type="handle" alias="Image.Calibration.Camera" desc="The instance to use."/>
                            <return name="area" type="float" multiplicity="+" desc="Estimate of relative image area covered by the board. 1.0 means the complete image."/>
                            <return name="tiltX" type="float" multiplicity="+" desc="Estimates of the amount of tilt of the board along the X direction. One for each collected image."/>
                            <return name="tiltY" type="float" multiplicity="+" desc="Estimates of the amount of tilt of the board along the Y direction. One for each collected image."/>
                            <return name="distance" type="float" multiplicity="+" desc="Distance to the board estimates. One for each collected image."/>
                            <return name="sampleHistogram" type="object" alias="Image" desc="Histogram of x,y corner positions."/>
                        </function>
                    </serves>
                </crown>
                <crown name="Pose">
                    <trait>released</trait>
                    <desc>Image.Calibration.Pose can be used to estimate the pose (the extrinsic parameters) of one or multiple cameras.
Different calibration targets are supported, for example a simple checkerboard with squared corners for single camera calibration and a checkerboard combined with 2D codes for use in multi-camera systems.</desc>
                    <serves>
                        <function name="estimate">
                            <desc>Calculate the sensor pose (extrinsic parameters) from a reference image of the calibration target. If successful, the results of the pose are added to the "cameraModel" input object. This method uses a simple checkerboard with squared corners. The full checkerboard pattern does not have to be visible in the calibration image for the algorithm to work.</desc>
                            <sample for="lua">local cameraModel = Image.Calibration.Pose.estimate(image, cameraModel, sideLength)</sample>
                            <param name="image" type="const object" alias="Image" desc="A gray scale image of the calibration target."/>
                            <param name="cameraModel" type="const object" alias="Image.Calibration.CameraModel" desc="A CameraModel containing calibration results from a previous intrinsic calibration."/>
                            <param name="sideLength" type="float" multiplicity="[1+]" desc="Checkerboard corner side length in mm. If your target is not accurate enough and your checkerboard elements are not quadratic, you can enter the side length dimensions for x and y. The algorithm will correct the world corner values. Keep in mind you also have to specify the 'checkerboardDimensions' for the CHECKERBOARD type. Otherwise the algorithm cannot determine which side length belongs to which dimension."/>
                            <param name="checkerboardDimensions" type="int" multiplicity="*" desc="Optional and only for CHECKERBOARD : Number of checkerboard corners in x and y direction. "/>
                            <return name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="If successful, a new calibration model containing a valid pose is returned, otherwise nil."/>
                            <return name="reprojectionError" type="float" desc="Sum of squared distances between the detected 2D feature points and the projected 3D feature points using the estimated camera calibration parameter."/>
                            <return name="featurePoints2D" type="object" multiplicity="*" alias="Point" desc="2D checkerboard corners in image plane for the result visualization."/>
                            <return name="featurePoints3D" type="object" multiplicity="*" alias="Point" desc="Corresponding 3D world coordinates of the checkerboard corners."/>
                            <return name="residuals" type="object" multiplicity="*" alias="Point" desc="The calibration residuals for each calibration point consisting in a vector of vectors of 2D points."/>
                        </function>
                        <function name="estimateMatrixCode">
                            <desc>Calculate the absolute sensor pose (extrinsic parameters) from a reference image of the calibration target. If successful, a new "cameraModel" object including the pose is returned. This method uses a checkerboard combined with 2D codes. The code contents and regions are supplied by Image.CodeReader. From one placement of the calibration target it is possible to estimate the extrinsic poses of a multi-camera system.</desc>
                            <sample for="lua">local cameraModel = Image.Calibration.Pose.estimateMatrixCode(image, cameraModel, codeContent, codeRegion)</sample>
                            <param name="image" type="object" alias="Image" desc="A gray scale image of the calibration target."/>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="A CameraModel containing calibration results from a previous intrinsic calibration."/>
                            <param name="codeContent" type="binary" multiplicity="+" desc="Optional: List of code contents."/>
                            <param name="codeRegion" type="const object" multiplicity="+" alias="Shape" desc="Optional: List of code ROIs, each represented as a 4-point polyline shape."/>
                            <param name="sideLength" type="float" multiplicity="[?*]" desc="Checkerboard corner side length in mm. May if your target is not accurate enough and your checkerboard elements are not quadratic you can enter the checker side length dimensions for x,y and z. The algorithm will correct the world corner values."/>
                            <return name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="If successful, a new calibration model containing a valid pose is returned, otherwise nil."/>
                            <return name="reprojectionError" type="float" desc="Sum of squared distances between the detected 2D feature points and the projected 3D feature points using the estimated camera calibration parameter."/>
                            <return name="featurePoints2D" type="object" multiplicity="*" alias="Point" desc="2D checkerboard corners in image plane for the result visualization."/>
                            <return name="featurePoints3D" type="object" multiplicity="*" alias="Point" desc="Corresponding 3D world coordinates of the checkerboard corners."/>
                            <return name="residuals" type="object" multiplicity="*" alias="Point" desc="The calibration residuals for each calibration point consisting in a vector of vectors of 2D points."/>
                        </function>
                        <function name="estimateCodeExternal">
                            <trait>deprecated</trait>
                            <desc>Deprecated, please use Image.Calibration.Pose.estimateMatrixCode instead.

Calculate the absolute sensor pose (extrinsic parameters) from a reference image of the calibration target. If successful, a new "cameraModel" object including the pose is returned. This method uses a checkerboard combined with 2D codes. The code contents and regions are supplied by Image.CodeReader. From one placement of the calibration target it is possible to estimate the extrinsic poses of a multi-camera system.</desc>
                            <sample for="lua">local cameraModel = Image.Calibration.Pose.estimateCodeExternal(image, cameraModel, codeContent, codeRegion)</sample>
                            <param name="image" type="object" alias="Image" desc="A gray scale image of the calibration target."/>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="A CameraModel containing calibration results from a previous intrinsic calibration."/>
                            <param name="codeContent" type="binary" multiplicity="+" desc="Optional: List of code contents."/>
                            <param name="codeRegion" type="const object" multiplicity="+" alias="Shape" desc="Optional: List of code ROIs, each represented as a 4-point polyline shape."/>
                            <param name="sideLength" type="float" multiplicity="[?*]" desc="Checkerboard corner side length in mm. May if your target is not accurate enough and your checkerboard elements are not quadratic you can enter the checker side length dimensions for x,y and z. The algorithm will correct the world corner values."/>
                            <return name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="If successful, a new calibration model containing a valid pose is returned, otherwise nil."/>
                            <return name="reprojectionError" type="float" desc="Sum of squared distances between the detected 2D feature points and the projected 3D feature points using the estimated camera calibration parameter."/>
                            <return name="featurePoints2D" type="object" multiplicity="*" alias="Point" desc="2D checkerboard corners in image plane for the result visualization."/>
                            <return name="featurePoints3D" type="object" multiplicity="*" alias="Point" desc="Corresponding 3D world coordinates of the checkerboard corners."/>
                            <return name="residuals" type="object" multiplicity="*" alias="Point" desc="The calibration residuals for each calibration point consisting in a vector of vectors of 2D points."/>
                        </function>
                        <function name="estimatePlain">
                            <trait>released</trait>
                            <desc>Performs the estimation of the camera pose based on a plain (empty) checkerboard pattern that can be generated using Image.Calibration.Pattern.getCheckerboardDPI or getCheckerboardPixel with the type enum set to "PLAIN".

Note that the pose given by a calibration using a plain target can be used to correct for perspective, but not to align several cameras to the same world coordinate system.
This is because two cameras observing the same calibration target typically will get different world coordinate system origins.

The coordinate system produced is right orthogonal with the Z-axis point up from the calibration target.
At least 20 corners on the calibration target must be seen for the calibration to succeed.</desc>
                            <sample for="lua">cameraModelPose = Image.Calibration.Pose.estimatePlain(cameraModel, image, {10.0})</sample>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="Camera model object containing the intrinsic calibration parameters of the camera."/>
                            <param name="image" type="object" alias="Image" desc="Image that will be used for the calibration."/>
                            <param name="squareSize" type="float" multiplicity="+" desc="The length of the sides of the checkerboard squares. If two values are supplied they should be in X, Y order."/>
                            <param name="thickness" type="float" multiplicity="?" desc="Set this parameter to offset the base plane to compensate for a calibration plate with some thickness."/>
                            <param name="regionOfInterest" type="const object" multiplicity="?" alias="Shape" desc="If the image is cluttered, a Shape rectangle containing the calibration pattern in the image can be supplied. This makes the algorithm more robust to noise. The rectangle should be axis aligned."/>
                            <return name="cameraModelPose" type="object" multiplicity="?" alias="Image.Calibration.CameraModel" desc="If successful a new calibration model containing a valid pose is returned, otherwise nil."/>
                            <return name="reprojectionError" type="float" multiplicity="?" desc="Mean of Euclidean distances between the detected 2D feature points and the projected 3D feature points using the estimated camera calibration parameters."/>
                            <return name="points2D" type="object" multiplicity="*" alias="Point" desc="2D checkerboard corners in image plane for result visualization."/>
                            <return name="points3D" type="object" multiplicity="*" alias="Point" desc="Corresponding 3D world coordinates of the checkerboard corners."/>
                            <return name="residuals" type="object" multiplicity="*" alias="Point" desc="The calibration residuals for each calibration point consisting of a vector of 2D points."/>
                        </function>
                        <function name="estimateThreeDot">
                            <trait>released</trait>
                            <desc>Performs the estimation of the camera pose based on a checkerboard containing three dots, which can be generated using Image.Calibration.Pattern.getCheckerboardDPI or getCheckerboardPixel with the type enum set to "THREE_DOT".

In order for alignment of several cameras to work all cameras must observe the same three dots. It's not supported to use one calibration target with several origin markers.

The coordinate system produced is right orthogonal with the Z-axis point up from the calibration target.
At least 20 corners on the calibration target must be seen for the calibration to succeed.</desc>
                            <sample for="lua">cameraModelPose = Image.Calibration.Pose.estimateThreeDot(cameraModel, image, {10.0})</sample>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="Camera model object containing the intrinsic calibration parameters of the camera."/>
                            <param name="image" type="object" alias="Image" desc="Image that will be used for the calibration."/>
                            <param name="squareSize" type="float" multiplicity="+" desc="The length of the sides of the checkerboard squares. If two values are supplied they should be in X, Y order."/>
                            <param name="thickness" type="float" multiplicity="?" desc="Set this parameter to offset the base plane to compensate for a calibration plate with some thickness."/>
                            <param name="regionOfInterest" type="const object" multiplicity="?" alias="Shape" desc="If the image is cluttered, a Shape rectangle containing the calibration pattern in the image can be supplied. This makes the algorithm more robust to noise. The rectangle should be axis aligned."/>
                            <return name="cameraModelPose" type="object" multiplicity="?" alias="Image.Calibration.CameraModel" desc="If successful a new calibration model containing a valid pose is returned, otherwise nil."/>
                            <return name="reprojectionError" type="float" multiplicity="?" desc="Mean of Euclidean distances between the detected 2D feature points and the projected 3D feature points using the estimated camera calibration parameters."/>
                            <return name="points2D" type="object" multiplicity="*" alias="Point" desc="2D checkerboard corners in image plane for result visualization."/>
                            <return name="points3D" type="object" multiplicity="*" alias="Point" desc="Corresponding 3D world coordinates of the checkerboard corners."/>
                            <return name="residuals" type="object" multiplicity="*" alias="Point" desc="The calibration residuals for each calibration point consisting of a vector of 2D points."/>
                        </function>
                        <function name="estimateCoordinateCode">
                            <trait>released</trait>
                            <desc>Performs the estimation of the camera pose based on a checkerboard with coordinate codes in some squares. The pattern can be generated using Image.Calibration.Pattern.getCheckerboardDPI or getCheckerboardPixel with the type enum set to "COORDINATE_CODE".

In order for alignment to work well each camera should see at least two coordinate codes. Which codes each camera sees, does not matter.

The coordinate system produced is right orthogonal with the Z-axis point up from the calibration target.
At least 20 corners on the calibration target must be seen for the calibration to succeed.</desc>
                            <sample for="lua">cameraModelPose = Image.Calibration.Pose.estimateCoordinateCode(cameraModel, image, {10.0})</sample>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="Camera model object containing the intrinsic calibration parameters of the camera."/>
                            <param name="image" type="object" alias="Image" desc="Image that will be used for the calibration."/>
                            <param name="squareSize" type="float" multiplicity="+" desc="The length of the sides of the checkerboard squares. If two values are supplied they should be in X, Y order."/>
                            <param name="thickness" type="float" multiplicity="?" desc="Set this parameter to offset the base plane to compensate for a calibration plate with some thickness."/>
                            <param name="regionOfInterest" type="const object" multiplicity="?" alias="Shape" desc="If the image is cluttered, a Shape rectangle containing the calibration pattern in the image can be supplied. This makes the algorithm more robust to noise. The rectangle should be axis aligned."/>
                            <return name="cameraModelPose" type="object" multiplicity="?" alias="Image.Calibration.CameraModel" desc="If successful a new calibration model containing a valid pose is returned, otherwise nil."/>
                            <return name="reprojectionError" type="float" multiplicity="?" desc="Mean of Euclidean distances between the detected 2D feature points and the projected 3D feature points using the estimated camera calibration parameters."/>
                            <return name="points2D" type="object" multiplicity="*" alias="Point" desc="2D checkerboard corners in image plane for result visualization."/>
                            <return name="points3D" type="object" multiplicity="*" alias="Point" desc="Corresponding 3D world coordinates of the checkerboard corners."/>
                            <return name="residuals" type="object" multiplicity="*" alias="Point" desc="The calibration residuals for each calibration point consisting of a vector of 2D points."/>
                        </function>
                        <function name="estimateOneShot">
                            <trait>released</trait>
                            <desc>Performs a calibration of a camera based on a planar world assumption.
This means that for measurements outside of the calibrated plane accuracy cannot be guaranteed to be accurate.

The advantage of this model is that only one image is required to get a reasonable image to world transformation.

The coordinate system produced is right orthogonal with the Z-axis point up from the calibration target.
At least 20 corners on the calibration target must be seen for the calibration to succeed.</desc>
                            <sample for="lua">Image.Calibration.Pose.estimateOneShot(image, {10.0}, "COORDINATE_CODE")</sample>
                            <param name="image" type="object" alias="Image" desc="Image that will be used for the calibration."/>
                            <param name="squareSize" type="float" multiplicity="+" desc="The length of the sides of the checkerboard squares. If two values are supplied they should be in X, Y order."/>
                            <param name="type" type="enum" multiplicity="?" ref="TargetType" desc="Select the type of pattern to look for. If left out PLAIN will be used."/>
                            <param name="estimateLensModel" type="bool" multiplicity="?" desc="Select if a lens model should be estimated. Default is true."/>
                            <param name="lockLensCenter" type="bool" multiplicity="?" desc="Select if the lens center should be forced to the center of the screen. Locking the lens center is more robust than allowing it to move. Default is true."/>
                            <param name="regionOfInterest" type="const object" multiplicity="?" alias="Shape" desc="If the image is cluttered, a Shape rectangle containing the calibration pattern in the image can be supplied. This makes the algorithm more robust to noise. The rectangle should be axis aligned."/>
                            <return name="cameraPose" type="object" multiplicity="?" alias="Image.Calibration.CameraModel" desc="If successful a new calibration model containing a valid pose is returned, otherwise nil."/>
                            <return name="reprojectionError" type="float" multiplicity="?" desc="Mean of Euclidean distances between the detected 2D feature points and the projected 3D feature points using the estimated camera calibration parameter."/>
                            <return name="featurePoints2D" type="object" multiplicity="*" alias="Point" desc="2D checkerboard corners in image plane for result visualization."/>
                            <return name="featurePoints3D" type="object" multiplicity="*" alias="Point" desc="Corresponding 3D world coordinates of the checkerboard corners."/>
                            <return name="residuals" type="object" multiplicity="*" alias="Point" desc="The calibration residuals for each calibration point consisting of a vector of 2D points."/>
                        </function>
                    </serves>
                    <crown name="Conveyor">
                        <trait>hidden</trait>
                        <desc>Robust pose calibration for conveyor applications that requires multiple images from all cameras to estimate both a robust pose and direction of movement.

Only supports the "COORDINATE_CODE" checkerboard type.</desc>
                        <serves>
                            <function name="create">
<desc>Creates a new instance of a conveyor calibration object.</desc>
<sample for="lua">conv = Image.Calibration.Pose.Conveyor.create()</sample>
<return name="conv" type="handle" alias="Image.Calibration.Pose.Conveyor" desc="The new calibration object handle."/>
                            </function>
                            <function name="addCamera">
<desc>Use to add a camera. A camera model with calibrated intrinsic parameters should be supplied.</desc>
<sample for="lua">success = Image.Calibration.Pose.Conveyor.addCamera(conv, cameraModel)</sample>
<param name="conv" type="object" alias="Image.Calibration.Pose.Conveyor" desc="The conveyor calibration object to use."/>
<param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="Camera model object containing the intrinsic calibration parameters of the camera."/>
<return name="success" type="bool" desc="True if camera was successfully added."/>
                            </function>
                            <function name="setSquareSideLength">
<desc>Supply the square size of the target.
This must be done prior to adding images or all images will be lost once the parameter is updated.</desc>
<sample for="lua">success = Image.Calibration.Pose.Conveyor.setSquareSideLength(conv, 15.0)</sample>
<param name="conv" type="object" alias="Image.Calibration.Pose.Conveyor" desc="The conveyor calibration object to use."/>
<param name="sideX" type="float" desc="The size of a square in world coordinates in the X-direction."/>
<param name="sideY" type="float" multiplicity="?" desc="The size of a square in world coordinates in the Y-direction."/>
<return name="success" type="bool" desc="True if parameter selection is valid."/>
                            </function>
                            <function name="setTargetThickness">
<desc>Supply the thickness of the calibration target.
This must be done prior to adding images or all images will be lost once the parameter is updated.</desc>
<sample for="lua">success = Image.Calibration.Pose.Conveyor.setTargetThickness(conv, 10.0)</sample>
<param name="conv" type="object" alias="Image.Calibration.Pose.Conveyor" desc="The conveyor calibration object to use."/>
<param name="thickness" type="float" desc="The thickness of the calibration plate. Default i 0."/>
                            </function>
                            <function name="addImage">
<desc>Add images to the configured cameras.

Note that the images should be synchronized between the cameras and that the same amount of images should be added to all cameras.
This is to ensure that there will be no offset between different cameras along the direction of movement.</desc>
<sample for="lua">success = Image.Calibration.Pose.Conveyor.addImage(conv, image, cameraIndex)</sample>
<param name="conv" type="object" alias="Image.Calibration.Pose.Conveyor" desc="The conveyor calibration object to use."/>
<param name="image" type="object" alias="Image" desc="Image that will be used for the calibration."/>
<param name="cameraIndex" type="int" multiplicity="?" desc="The camera index to add the image to. If omitted image is added to the first camera. One based index, the first camera is 1."/>
<return name="success" type="bool" desc="Returns true if the image was found and could be added."/>
                            </function>
                            <function name="getCameraCount">
<desc>Returns the amount of cameras currently in the calibrator object.</desc>
<sample for="lua">numberOfCameras = Image.Calibration.Pose.Conveyor.getCameraCount(conv)</sample>
<param name="conv" type="object" alias="Image.Calibration.Pose.Conveyor" desc="The conveyor calibration object to use."/>
<return name="numberOfCameras" type="int" desc="The number of cameras."/>
                            </function>
                            <function name="getImageCount">
<desc>Returns the amount of poses currently setup for a particular camera. Each pose correspond to one input image.</desc>
<sample for="lua">numberOfPoses = Image.Calibration.Pose.Conveyor.getImageCount(conv, cameraIndex)</sample>
<param name="conv" type="object" alias="Image.Calibration.Pose.Conveyor" desc="The conveyor calibration object to use."/>
<param name="cameraIndex" type="int" multiplicity="?" desc="The camera index to retrieve the amount of poses for. Default is to use the first camera."/>
<return name="numberOfPoses" type="int" desc="The number of poses."/>
                            </function>
                            <function name="clear">
<desc>Clear out all loaded images to perform another calibration or just to reduce memory usage. To remove all cameras simply create a new object.</desc>
<sample for="lua">Image.Calibration.Pose.Conveyor.clear(conv)</sample>
<param name="conv" type="object" alias="Image.Calibration.Pose.Conveyor" desc="The conveyor calibration object to use."/>
                            </function>
                            <function name="calibrate">
<desc>Perform the actual calibration optimization.</desc>
<sample for="lua">cameraModels = Image.Calibration.Pose.Conveyor.calibrate(conv, {10.0}, 0.0)</sample>
<param name="conv" type="object" alias="Image.Calibration.Pose.Conveyor" desc="The conveyor calibration object to use."/>
<param name="alignDirection" type="bool" multiplicity="?" desc="Select if we want to force the direction of movement to be the calibrated Y-axis of our coordinate system. This ignores the direction given by the calibration plate. Default is off."/>
<return name="cameraModels" type="object" multiplicity="*" alias="Image.Calibration.CameraModel" desc="Camera model object(s) containing the new calibration parameters."/>
                            </function>
                            <function name="getCameraModel">
<desc>Retrieve the camera model for a specific camera and image index. Calibration must have successfully completed before use.</desc>
<sample for="lua">cameraModels = Image.Calibration.Pose.Conveyor.getCameraModel(conv, 1, 1)</sample>
<param name="conv" type="object" alias="Image.Calibration.Pose.Conveyor" desc="The conveyor calibration object to use."/>
<param name="cameraIndex" type="int" desc="The camera index to retrieve the model for."/>
<param name="imageIndex" type="int" desc="The image index to retrieve the model for."/>
<return name="cameraModel" type="object" multiplicity="?" alias="Image.Calibration.CameraModel" desc="Camera model object containing the new calibration parameters. Nil if calibration did not succeed."/>
                            </function>
                            <function name="getReprojections">
<desc>After a calibration call this to retrieve reprojections in one selected image.</desc>
<sample for="lua">reprojectionError = Image.Calibration.Pose.Conveyor.getReprojections(conv, cameraIndex, imageIndex)</sample>
<param name="conv" type="object" alias="Image.Calibration.Pose.Conveyor" desc="The conveyor calibration object to use."/>
<param name="imageIndex" type="int" multiplicity="?" desc="The image index to evaluate. Default is to use the first image."/>
<param name="cameraIndex" type="int" multiplicity="?" desc="The camera index to evaluate. Default is to use the first camera."/>
<return name="reprojectionError" type="float" multiplicity="?" desc="Mean of Euclidean distances between the detected 2D feature points and the projected 3D feature points using the estimated camera calibration parameters."/>
<return name="points2D" type="object" multiplicity="*" alias="Point" desc="2D checkerboard corners in image plane for result visualization."/>
<return name="points3D" type="object" multiplicity="*" alias="Point" desc="Corresponding 3D world coordinates of the checkerboard corners."/>
<return name="residuals" type="object" multiplicity="*" alias="Point" desc="The calibration residuals for each calibration point consisting of a vector of 2D points."/>
                            </function>
                            <function name="getDirection">
<desc>Returns the direction of movement in the calibrated coordinate system.</desc>
<sample for="lua">direction = Image.Calibration.Pose.Conveyor.getDirection(conv)</sample>
<param name="conv" type="object" alias="Image.Calibration.Pose.Conveyor" desc="The conveyor calibration object to use."/>
<return name="direction" type="object" multiplicity="?" alias="Point" desc="The global direction of the conveyor in the calibrated coordinate system."/>
                            </function>
                            <function name="getPoseOffset">
<desc>Retrieves the distance from any of the supplied image indices to the base pose of that camera.</desc>
<sample for="lua">imageIndex = Image.Calibration.Pose.Conveyor.getPoseOffset(imageIndex, cameraIndex)</sample>
<param name="conv" type="object" alias="Image.Calibration.Pose.Conveyor" desc="The conveyor calibration object to use."/>
<param name="imageIndex" type="int" multiplicity="?" desc="The image index to retrieve the distance for. Default is to use the first image."/>
<param name="cameraIndex" type="int" multiplicity="?" desc="The camera index to retrieve the distance for. Default is to use the first camera."/>
<return name="offset" type="float" multiplicity="?" desc="The distance in world coordinates from the supplied index to the base pose."/>
                            </function>
                            <function name="getBasePoseIndex">
<desc>Returns the index to the supplied image that was selected for the final pose, i.e. the camera model will use the origin of this image.
When projecting 3D points into the image this index is where the projections will fit. Other projections will need a translation along the estimated direction vector prior to projection.
All cameras will always have the same base pose, to avoid confusion in the final coordinate system images.</desc>
<sample for="lua">imageIndex = Image.Calibration.Pose.Conveyor.getBasePoseIndex(imageIndex)</sample>
<param name="conv" type="object" alias="Image.Calibration.Pose.Conveyor" desc="The conveyor calibration object to use."/>
<return name="imageIndex" type="int" multiplicity="?" desc="Will return the index. If calibration was unsuccessful or did not run at all the function will return -1."/>
                            </function>
                        </serves>
                    </crown>
                </crown>
                <crown name="Correction">
                    <trait>released</trait>
                    <keywords>undistort, unwarp, untilt, distortion, lens, perspective, rectify, rectification</keywords>
                    <links>Image.transform</links>
                    <desc>Correction of image distortions based on a calibrated camera model. Supports correction of lens distortion and perspective distortion from small tilt angles and image rotations.</desc>
                    <enum name="CorrectionCropMode" trait="released">
                        <item name="full" desc="Full mode, creates an output containing all valid pixels and some zero-valued pixels where the corrected image is undefined.">FULL</item>
                        <item name="valid" desc="Valid mode, creates an output containing only valid pixels, cropping out some values to create a rectangular output image.">VALID</item>
                    </enum>
                    <enum name="CoordinateSystem" trait="released">
                        <item name="camera_pixel" desc="Pixel coordinates of the input camera image.">CAMERA_PIXEL</item>
                        <item name="corrected_pixel" desc="Pixel coordinates of the corrected output image.">CORRECTED_PIXEL</item>
                        <item name="corrected_world" desc="Image world coordinates of the corrected output image.">CORRECTED_WORLD</item>
                        <item name="external_world" desc="Point on the world ground plane (at z=0) as defined by the camera model, usually from a calibration pattern.">EXTERNAL_WORLD</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <trait>released</trait>
                            <links>Image.Calibration.Correction.setUndistortMode, Image.Calibration.Correction.setAlignMode, Image.Calibration.Correction.setUntiltMode</links>
                            <desc>Create an image correction object.</desc>
                            <sample for="lua">corr = Image.Calibration.Correction.create()</sample>
                            <return name="corr" type="handle" alias="Image.Calibration.Correction" desc=""/>
                        </function>
                        <function name="setUndistortMode">
                            <trait>released</trait>
                            <links>Image.Calibration.Correction.setUntiltMode, Image.Calibration.Correction.setAlignMode</links>
                            <desc>Setup the correction to compensate for lens distortion only. The other parts of the camera model are ignored.</desc>
                            <sample for="lua">corr:setUndistortMode(cameraModel, cropMode, interpolation)</sample>
                            <param name="corr" type="handle" alias="Image.Calibration.Correction" desc="The correction object to setup."/>
                            <param name="cameraModel" type="const object" alias="Image.Calibration.CameraModel" desc="A model of a calibrated camera, as returned from the Image.Calibration functions."/>
                            <param name="cropMode" type="enum" multiplicity="?" ref="CorrectionCropMode" desc="Crop mode, determines how to crop the output. Default is FULL."/>
                            <param name="interpolation" type="enum" multiplicity="?" ref="InterpolationMethod" desc="Interpolation method to use. Default is LINEAR."/>
                        </function>
                        <function name="setUntiltMode">
                            <trait>released</trait>
                            <links>Image.Calibration.Correction.setUndistortMode, Image.Calibration.Correction.setAlignMode</links>
                            <desc>Setup the correction to compensate for lens distortion and perspective distortions caused by a tilt angle between the world ground plane and the camera. Any in-plane rotation between the camera and world is left unaltered.</desc>
                            <sample for="lua">corr:setUntiltMode(cameraModel, cropMode, interpolation)</sample>
                            <param name="corr" type="handle" alias="Image.Calibration.Correction" desc="The correction object to setup."/>
                            <param name="cameraModel" type="const object" alias="Image.Calibration.CameraModel" desc="A model of a calibrated camera, as returned from the Image.Calibration functions."/>
                            <param name="cropMode" type="enum" multiplicity="?" ref="CorrectionCropMode" desc="Crop mode, determines how to crop the output. Default is FULL."/>
                            <param name="interpolation" type="enum" multiplicity="?" ref="InterpolationMethod" desc="Interpolation method to use. Default is LINEAR."/>
                            <param name="targetWidth" type="int" multiplicity="?" desc="Output image width. Default is same size as the input."/>
                            <param name="targetHeight" type="int" multiplicity="?" desc="Output image height. Default is same size as the input."/>
                        </function>
                        <function name="setAlignMode">
                            <trait>released</trait>
                            <links>Image.Calibration.Correction.setUndistortMode, Image.Calibration.Correction.setUntiltMode</links>
                            <desc>Setup the correction to map specific world ground plane rectangle to an image. This gives precise control of the pixel size and world origin of the output image.</desc>
                            <sample for="lua">corr:setAlignMode(cameraModel, worldRect, pixelSize, interpolation)</sample>
                            <param name="corr" type="handle" alias="Image.Calibration.Correction" desc="The correction object to setup."/>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="A model of a calibrated camera, as returned from the Image.Calibration functions."/>
                            <param name="worldRect" type="const object" alias="Shape" desc="World rectangle describing the world region to cover."/>
                            <param name="pixelSize" type="float" multiplicity="?" desc="Desired pixel size (mm/pixel) of the output image. If omitted, a similar pixel size as in the input image center will be used."/>
                            <param name="interpolation" type="enum" multiplicity="?" ref="InterpolationMethod" desc="Interpolation method to use. Default is LINEAR."/>
                        </function>
                        <function name="setPixelwiseMode">
                            <trait>hidden</trait>
                            <desc>Setup the correction from a direct pixel-to-pixel homography, optionally including a lens distortion component.</desc>
                            <sample for="lua">corr:setPixelwiseMode(pixelHomography, distortion, distCenter, distWidth, distHeight)</sample>
                            <param name="corr" type="handle" alias="Image.Calibration.Correction" desc="The correction object to setup."/>
                            <param name="pixelHomography" type="const object" alias="Matrix" desc="The pixel-to-pixel homography to use."/>
                            <param name="distortion" type="float" multiplicity="+" desc="Distortion coefficients, as represented in the Image.Calibration.CameraModel (k1,k2,p1,p2,k3, where k are radial distortion coefficients and p are tangential)."/>
                            <param name="distCenter" type="const object" alias="Point" desc="Distortion center (pixel coordinates)."/>
                            <param name="distWidth" type="float" desc="Width in pixels of the distortion normalization."/>
                            <param name="distHeight" type="float" desc="Height in pixels of the distortion normalization."/>
                            <param name="targetWidth" type="int" desc="Output image width."/>
                            <param name="targetHeight" type="int" desc="Output image height."/>
                        </function>
                        <function name="apply">
                            <trait>released</trait>
                            <desc>Apply the image correction to an input image.</desc>
                            <sample for="lua">outputImage = corr:apply(inputImage)</sample>
                            <param name="corr" type="handle" alias="Image.Calibration.Correction" desc="The correction object to use."/>
                            <param name="inputImage" type="const object" alias="Image" desc="Input image"/>
                            <return name="outputImage" type="object" multiplicity="?" alias="Image" desc="Output image."/>
                        </function>
                        <function name="getInteriorRectangle">
                            <trait>hidden</trait>
                            <desc>Find an axis-aligned rectangle with the given aspect ratio and maximal size within the input points (TODO: For debugging, move later!)</desc>
                            <sample for="lua">rectangle = corr:getInteriorRectangle(points, aspect)</sample>
                            <param name="corr" type="handle" alias="Image.Calibration.Correction" desc="The correction object to use."/>
                            <param name="points" type="const object" multiplicity="+" alias="Point" desc="Input points."/>
                            <param name="aspect" type="float" desc="Aspect ratio (width/height)"/>
                            <return name="rectangle" type="object" multiplicity="?" alias="Shape" desc="Interior rectangle."/>
                        </function>
                        <function name="getVirtualCamera">
                            <trait>released</trait>
                            <desc>Get a camera model representing the virtual camera producing the corrected image.</desc>
                            <sample for="lua">camera = corr:getVirtualCamera()</sample>
                            <param name="corr" type="handle" alias="Image.Calibration.Correction" desc="The correction object to use."/>
                            <return name="camera" type="object" multiplicity="?" alias="Image.Calibration.CameraModel" desc="Virtual camera of the correction procedure."/>
                        </function>
                        <function name="getValidRegion">
                            <trait>released</trait>
                            <desc>Get a pixel region corresponding to the valid part of the corrected image. The valid part of the output image contains pixel values from the input image, and the invalid part is just set to zero.</desc>
                            <sample for="lua">validRegion = corr:getValidRegion()</sample>
                            <param name="corr" type="handle" alias="Image.Calibration.Correction" desc="The correction object to use."/>
                            <return name="validRegion" type="object" multiplicity="?" alias="Image.PixelRegion" desc="Valid region of the output."/>
                        </function>
                        <function name="mapPoints">
                            <trait>released</trait>
                            <desc>Map points between the four coordinate systems related to the correction process. See the CoordinateSystem enum for details.</desc>
                            <sample for="lua">pointsOut = corr:mapPoints(pointsIn, sourceSystem, targetSystem)</sample>
                            <param name="corr" type="handle" alias="Image.Calibration.Correction" desc="The correction object to use."/>
                            <param name="pointsIn" type="object" multiplicity="[1+]" alias="Point" desc="Points to transform (single point or array)."/>
                            <param name="sourceSystem" type="enum" ref="CoordinateSystem" desc="Specifies the coordinate system in which the input point is defined."/>
                            <param name="targetSystem" type="enum" ref="CoordinateSystem" desc="Specifies the coordinate system to transform the points into."/>
                            <return name="pointsOut" type="object" multiplicity="[1+]" alias="Point" desc="Transformed points (single point or array)."/>
                        </function>
                    </serves>
                </crown>
            </crown>
            <crown name="Format">
                <trait>released</trait>
                <desc>Image file formats/encodings.</desc>
                <serves/>
                <uses/>
                <crown name="BMP">
                    <trait>released</trait>
                    <links>Image.Format.PNG, Image.Format.JPEG</links>
                    <desc>BMP encoding functionality</desc>
                    <serves>
                        <function name="create">
                            <desc>Creates a new instance of the BMP encoder.</desc>
                            <sample for="lua">local handle = Image.Format.BMP.create()</sample>
                            <return name="handle" type="handle" alias="Image.Format.BMP" desc="Handle to the instance."/>
                        </function>
                        <function name="encode">
                            <desc>Create a binary buffer with the BMP encoded image data.
Supported image types: UINT8, RGB24</desc>
                            <sample for="lua">local bmpBuffer = Image.Format.BMP.encode(handle, image)</sample>
                            <param name="handle" type="handle" alias="Image.Format.BMP" desc="Handle to the instance"/>
                            <param name="imageIn" type="const object" alias="Image" desc="image to encode"/>
                            <return name="bmpBuffer" type="binary" multiplicity="?" desc="binary buffer containing the BMP encoded image or nil"/>
                        </function>
                        <function name="decode">
                            <desc>Create an Image object from a binary buffer containing a BMP encoded image.</desc>
                            <sample for="lua">local image = Image.Format.BMP.decode(handle, bmpBuffer)</sample>
                            <param name="handle" type="handle" alias="Image.Format.BMP" desc="Handle to the BMP instance"/>
                            <param name="bmpBuffer" type="binary" multiplicity="?" desc="Binary buffer containing the BMP encoded image"/>
                            <return name="image" type="object" multiplicity="?" alias="Image" desc="Decoded image or nil"/>
                        </function>
                    </serves>
                </crown>
                <crown name="PNG">
                    <trait>released</trait>
                    <links>Image.Format.BMP, Image.Format.JPEG</links>
                    <desc>PNG encoding functionality</desc>
                    <serves>
                        <function name="create">
                            <desc>Creates a new instance of the PNG encoder.</desc>
                            <sample for="lua">local handle = Image.Format.PNG.create()</sample>
                            <return name="handle" type="handle" alias="Image.Format.PNG" desc="Handle to the instance."/>
                        </function>
                        <function name="setCompression">
                            <desc>Configure the PNG encoding compression (0-9), a higher value results in higher compression and higher run time.</desc>
                            <sample for="lua">local success = Image.Format.PNG.setCompression(handle, 1)</sample>
                            <param name="handle" type="handle" alias="Image.Format.PNG" desc="Handle to the PNG instance"/>
                            <param name="compression" type="int" desc="Ranges from 0 (no compression) to 9 (high compression). Default: 6."/>
                            <return name="success" type="bool" desc="True if successful, false otherwise"/>
                        </function>
                        <function name="encode">
                            <desc>Create a binary buffer with the PNG encoded image data.
Supported image types: UINT8, UINT16, RGB24</desc>
                            <sample for="lua">local pngBuffer = Image.Format.PNG.encode(handle, image)</sample>
                            <param name="handle" type="handle" alias="Image.Format.PNG" desc="Handle to the instance"/>
                            <param name="imageIn" type="const object" alias="Image" desc="image to encode"/>
                            <return name="pngBuffer" type="binary" multiplicity="?" desc="binary buffer containing the PNG encoded image or nil"/>
                        </function>
                        <function name="decode">
                            <desc>Create an Image object from a binary buffer containing a PNG encoded image.</desc>
                            <sample for="lua">local image = Image.Format.PNG.decode(handle, pngBuffer)</sample>
                            <param name="handle" type="handle" alias="Image.Format.PNG" desc="Handle to the PNG instance"/>
                            <param name="pngBuffer" type="binary" multiplicity="?" desc="Binary buffer containing the PNG encoded image"/>
                            <return name="image" type="object" multiplicity="?" alias="Image" desc="Decoded image or nil"/>
                        </function>
                    </serves>
                </crown>
                <crown name="JPEG">
                    <trait>released</trait>
                    <links>Image.Format.PNG, Image.Format.BMP</links>
                    <desc>JPEG encoding functionality</desc>
                    <serves>
                        <function name="create">
                            <desc>Creates a new instance of the JPEG encoder. Default quality level is 50.</desc>
                            <sample for="lua">local handle = Image.Format.JPEG.create()</sample>
                            <return name="handle" type="handle" multiplicity="?" alias="Image.Format.JPEG" desc="Handle to the new instance if available. Can be nil if unavailable."/>
                        </function>
                        <function name="setQuality">
                            <desc>Configure the JPEG encoding quality, a lower value results in higher compression.</desc>
                            <sample for="lua">local success = Image.Format.JPEG.setQuality(handle, 50)</sample>
                            <param name="handle" type="handle" alias="Image.Format.JPEG" desc="Handle to the JPEG instance"/>
                            <param name="quality" type="int" desc="The minimum/maximum values depend on the underlying implementation."/>
                            <return name="success" type="bool" desc="True if successful, false otherwise"/>
                        </function>
                        <function name="encode">
                            <desc>Create a binary buffer with the JPEG encoded image data.</desc>
                            <sample for="lua">local jpegBuffer = Image.Format.JPEG.encode(handle, image)</sample>
                            <param name="handle" type="handle" alias="Image.Format.JPEG" desc="Handle to the JPEG instance"/>
                            <param name="imageIn" type="const object" alias="Image" desc="Image to encode"/>
                            <return name="jpegBuffer" type="binary" multiplicity="?" desc="Binary buffer containing the JPEG encoded image or nil"/>
                        </function>
                        <function name="decode">
                            <desc>Create an Image object from a binary buffer containing a JPEG encoded image.</desc>
                            <sample for="lua">local image = Image.Format.JPEG.decode(handle, jpegBuffer)</sample>
                            <param name="handle" type="handle" alias="Image.Format.JPEG" desc="Handle to the JPEG instance"/>
                            <param name="jpegBuffer" type="binary" multiplicity="?" desc="Binary buffer containing the JPEG encoded image"/>
                            <return name="image" type="object" multiplicity="?" alias="Image" desc="Decoded image or nil"/>
                        </function>
                    </serves>
                </crown>
            </crown>
            <crown name="PixelRegion">
                <trait>released</trait>
                <desc>A PixelRegion represents a collection of pixels in an image. A common use-case is to represent regions or masks in an image and the underlying
representation is therefore run-length coded in form of a list of connected row-segments. This makes the representation computationally
efficient to work with. The pixels in a PixelRegion need not be connected though, but can consist of isolated pixels or a set of connected regions.

It is assumed that a PixelRegion is used together with an Image object in which it defines the collection of pixels.
The PixelRegion therefore knows only about pixel coordinates and is not aware of the Image object's world coordinate system. For measurements inside
the given PixelRegion or for transformations of the PixelRegion requiring the Image world coordinate system, the reference Image object must also
be supplied as parameter to the corresponding functions.

The PixelRegion can be obtained as a rasterized Shape object, but there is currently no function for converting a PixelRegion to a Shape object.
A PixelRegion can be generated from an Image object, for example through a threshold operation, and it is possible to render a PixelRegion back into
an Image object.</desc>
                <serves>
                    <function name="createEmpty">
                        <trait>released</trait>
                        <links>Image.PixelRegion.createRectangle, Image.PixelRegion.createCircle</links>
                        <desc>Create an empty region.</desc>
                        <sample for="lua">region = Image.PixelRegion.createEmpty()</sample>
                        <return name="region" type="object" alias="Image.PixelRegion" desc="The created empty pixel region."/>
                    </function>
                    <function name="createRectangle">
                        <trait>released</trait>
                        <links>Image.PixelRegion.createEmpty, Image.PixelRegion.createCircle</links>
                        <desc>Create a pixel region containing all pixels within a rectangle with upper-left corner (x0,y0) and lower-right corner (x1,y1). By providing vectors of corners several pixel regions can be created. All vectors must be of equal length.</desc>
                        <sample for="lua">region3 = Image.PixelRegion.createRectangle(x0, y0, x1, y1)</sample>
                        <param name="x0" type="int" multiplicity="[1+]" desc="x0 (upper-left). Can also be a vector to create several regions."/>
                        <param name="y0" type="int" multiplicity="[1+]" desc="y0 (upper-left). Can also be a vector to create several regions."/>
                        <param name="x1" type="int" multiplicity="[1+]" desc="x1 (lower-right). Can also be a vector to create several regions."/>
                        <param name="y1" type="int" multiplicity="[1+]" desc="y1 (lower-right). Can also be a vector to create several regions."/>
                        <return name="region" type="object" multiplicity="[?*]" alias="Image.PixelRegion" desc="The created pixel region, or vector of pixel regions for for vector input."/>
                    </function>
                    <function name="createCircle">
                        <trait>released</trait>
                        <links>Image.PixelRegion.createEmpty, Image.PixelRegion.createRectangle</links>
                        <desc>Create a pixel region containing all pixels within the given circle. By providing vectors of centers and radii several pixel regions can be created. All vectors must be of equal length.</desc>
                        <sample for="lua">region = Image.PixelRegion.createCircle(Point.create(100,100), 20)</sample>
                        <param name="center" type="const object" multiplicity="[1+]" alias="Point" desc="Circle center. Can also be a vector to create several regions."/>
                        <param name="radius" type="float" multiplicity="[1+]" desc="Circle radius. Can also be a vector to create several regions."/>
                        <return name="region" type="object" multiplicity="[?*]" alias="Image.PixelRegion" desc="The created pixel region, or vector of pixel regions for vector input."/>
                    </function>
                    <function name="isEmpty">
                        <trait>released</trait>
                        <desc>Check if the region contains zero pixels. If a vector of pixel regions is provided the output is a vector of the same length.</desc>
                        <sample for="lua">isEmpty = Image.PixelRegion.isEmpty(region)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input pixel region. Can also be a vector of pixel regions."/>
                        <return name="isEmpty" type="bool" multiplicity="[1+]" desc="True if the region is empty. Can also be a vector of booleans."/>
                    </function>
                    <function name="toString">
                        <trait>released</trait>
                        <keywords>print, help, description</keywords>
                        <desc>Get a brief string description of the pixel region. This is equal to the text shown in the debugger to describe the region. Can also be called with a vector of pixel regions.</desc>
                        <sample for="lua">print("Description: " .. Image.PixelRegion.toString(pixelRegion))</sample>
                        <param name="pixelRegion" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input pixel region. Can also be a vector of pixel regions."/>
                        <return name="str" type="string" multiplicity="[1+]" desc="Description of the region. If the input is a vector the output is a vector of strings."/>
                    </function>
                    <function name="clone">
                        <trait>released</trait>
                        <desc>Create an independent copy of a pixel region in new allocated memory. Can also be called with a vector of pixel regions.</desc>
                        <sample for="lua">local clonedRegion = Image.PixelRegion.clone(region)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="The source pixel region to clone. Can also be a vector of pixel regions."/>
                        <return name="clonedRegion" type="object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Copy of the input pixel region in new allocated memory. If the input is a vector the output is a vector of pixel regions."/>
                    </function>
                    <function name="fillHoles">
                        <trait>released</trait>
                        <links>Image.PixelRegion.fillRegion</links>
                        <desc>Fill any holes in a region.</desc>
                        <sample for="lua">outputRegion = Image.PixelRegion.fillHoles(region)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region."/>
                        <return name="outputRegion" type="object" multiplicity="[?*]" alias="Image.PixelRegion" desc="Output region, where any holes in the input region has been filled."/>
                    </function>
                    <function name="getBorderRegion">
                        <trait>released</trait>
                        <keywords>perimeter, edge</keywords>
                        <links>Image.PixelRegion.getPerimeterLength, Image.PixelRegion.countBorderPixels</links>
                        <desc>Get the border pixels of the input region as a new pixel region. Border pixels are pixels within the input region bordering to pixels outside the region.</desc>
                        <sample for="lua">outputRegion = Image.PixelRegion.getBorderRegion(region)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region or list of regions"/>
                        <return name="borderRegion" type="object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Output border region or list of regions"/>
                    </function>
                    <function name="getHistogram">
                        <trait>released</trait>
                        <links>Image.getHistogram, Profile.getHistogram</links>
                        <desc>Get a histogram of the image values within the specified region. If the image supports missing data, pixels marked as missing are not included in the histogram. If a pixel-world mapping is specified, the histogram is computed using world coordinates. If the bounds are skipped, the entire image value range is used for 8-channel images, and the range between the current minimum and maximum value is used for other image types. Optionally, a reference surface in world coordinates may be provided, in which case the histogram is based on deviations from the reference surface. The default surface is the plane z=0. See also Image.getHistogram.</desc>
                        <sample for="lua">histogram, centers = Image.PixelRegion.getHistogram(region, image, 64)</sample>
                        <param name="region" type="const object" alias="Image.PixelRegion" desc="Region specifying which parts of the image to include in the histogram"/>
                        <param name="image" type="const object" alias="Image" desc="Input image, specifying values to use in the histogram"/>
                        <param name="binCount" type="int" multiplicity="?" desc="Number of bins. Uses 32 bins as default."/>
                        <param name="minValue" type="float" multiplicity="?" desc="Minimum of the value range to cover. Uses an automatic range if omitted."/>
                        <param name="maxValue" type="float" multiplicity="?" desc="Maximum of the value range to cover. Uses an automatic range if omitted."/>
                        <param name="referenceSurface" type="const object" multiplicity="?" alias="Shape3D" desc="Zero-reference surface for the histogram. Optional, default is the plane z=0."/>
                        <return name="histogram" type="float" multiplicity="*" desc="Histogram, represented as a vector of floats"/>
                        <return name="binCenters" type="float" multiplicity="*" desc="The center of each histogram bin in the input value range"/>
                    </function>
                    <function name="getUnion">
                        <trait>released</trait>
                        <links>Image.PixelRegion.getIntersection, Image.PixelRegion.getDifference</links>
                        <desc>Get the set union of two or more regions.

If two regions are give, the function returns the set union of the two regions.
If one list of regions is given, the function returns the set union of all regions in the list.
If one list and one region is given, the function returns a list of regions containing the unions of each region in the list and the single region.
If two lists are given, the function returns a vector of regions containing the pair-wise unions of the regions in the lists. The lists must be the same length.</desc>
                        <sample for="lua">outputRegion = Image.PixelRegion.getUnion(region1, region2)</sample>
                        <param name="region1" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="First input region or list of regions"/>
                        <param name="region2" type="const object" multiplicity="[?*]" alias="Image.PixelRegion" desc="Second input region or list of regions"/>
                        <return name="outputRegion" type="object" multiplicity="[?*]" alias="Image.PixelRegion" desc="Resulting region or list of regions"/>
                    </function>
                    <function name="getIntersection">
                        <trait>released</trait>
                        <links>Image.PixelRegion.getUnion, Image.PixelRegion.getDifference, Image.PixelRegion.intersectImage</links>
                        <desc>Get the set intersection of two regions.

If two regions are give, the function returns the set intersection of the two regions.
If one list and one region is given, the function returns a list of regions containing the intersections of each region in the list and the single region.
If two lists are given, the function returns a list of regions containing the pair-wise intersection of the regions in the lists. The lists must be the same length.</desc>
                        <sample for="lua">outputRegion = Image.PixelRegion.getIntersection(region1, region2)</sample>
                        <param name="region1" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="First input region, or list of regions"/>
                        <param name="region2" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Second input region, or list of regions, subtracted from region1"/>
                        <return name="outputRegion" type="object" multiplicity="[?*]" alias="Image.PixelRegion" desc="Resulting region or list of regions"/>
                    </function>
                    <function name="getDifference">
                        <trait>released</trait>
                        <links>Image.PixelRegion.getUnion, Image.PixelRegion.getDifference, Image.PixelRegion.intersectImage</links>
                        <desc>Get the set difference of the input regions. Returns a new region containing all pixels present in the first region but not in the second.

If two regions are give, the function returns the difference of the two regions.
If one list and one region is given, the function returns a list of regions containing the differences of each region in the list and the single region.
If two lists are given, the function returns a list of regions containing the pair-wise difference of the regions in the lists. The lists must be the same length.</desc>
                        <sample for="lua">outputRegion = Image.PixelRegion.getDifference(region1, region2)</sample>
                        <param name="region1" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="First input region, or list of regions"/>
                        <param name="region2" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Second input region, or list of regions"/>
                        <return name="outputRegion" type="object" multiplicity="[?*]" alias="Image.PixelRegion" desc="Resulting region or list of regions"/>
                    </function>
                    <function name="getConvexHull">
                        <trait>released</trait>
                        <desc>Get the convex hull of the input pixel region.</desc>
                        <sample for="lua">outputRegion = Image.PixelRegion.getConvexHull(sourceRegion)</sample>
                        <param name="sourceRegion" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region or list of regions"/>
                        <return name="outputRegion" type="object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Target region or list of regions, convex hull of the input"/>
                    </function>
                    <function name="invert">
                        <trait>released</trait>
                        <keywords>complement</keywords>
                        <links>Image.PixelRegion.intersectImage</links>
                        <desc>Get the complement within a reference image, returns a pixel region(s) containing all reference image pixels not in the input region(s).</desc>
                        <sample for="lua">outputRegion = Image.PixelRegion.invert(region, referenceImage)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region(s)."/>
                        <param name="referenceImage" type="const object" alias="Image" desc="Reference image, defines the area for inverting the region(s)."/>
                        <return name="outputRegion" type="object" multiplicity="[?*]" alias="Image.PixelRegion" desc="The complement(s) to region(s) within referenceImage, or nil on error."/>
                    </function>
                    <function name="intersectImage">
                        <trait>released</trait>
                        <keywords>difference, complement</keywords>
                        <links>Image.PixelRegion.getIntersection, Image.PixelRegion.invert, Image.PixelRegion.getDifference</links>
                        <desc>Get the part of a pixel region within a reference image.</desc>
                        <sample for="lua">outputRegion = Image.PixelRegion.intersectImage(region, referenceImage)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region or list of regions."/>
                        <param name="referenceImage" type="const object" alias="Image" desc="Reference image, defines the area for cropping the region."/>
                        <return name="outputRegion" type="object" multiplicity="[?*]" alias="Image.PixelRegion" desc="The part of region or list of regions within referenceImage, or nil on error."/>
                    </function>
                    <function name="erode">
                        <trait>released</trait>
                        <keywords>shrink, morphology</keywords>
                        <links>Image.PixelRegion.dilate, Image.morphology</links>
                        <desc>Erode the input region with a disc of the given pixel diameter.</desc>
                        <sample for="lua">outputRegion = Image.PixelRegion.erode(region, diameter)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region or list of regions."/>
                        <param name="diameter" type="int" desc="Disc diameter in pixels (must be odd)."/>
                        <return name="outputRegion" type="object" multiplicity="[?*]" alias="Image.PixelRegion" desc="Eroded region or list of regions, or nil on error."/>
                    </function>
                    <function name="dilate">
                        <trait>released</trait>
                        <keywords>expand, morphology</keywords>
                        <links>Image.PixelRegion.erode, Image.morphology</links>
                        <desc>Dilate the input region with a disc of the given pixel diameter.</desc>
                        <sample for="lua">outputRegion = Image.PixelRegion.dilate(region, diameter)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region or list of regions."/>
                        <param name="diameter" type="int" desc="Disc diameter in pixels (must be odd)."/>
                        <return name="outputRegion" type="object" multiplicity="[?*]" alias="Image.PixelRegion" desc="Dilated region or list of regions, or nil on error."/>
                    </function>
                    <function name="thin">
                        <trait>released</trait>
                        <keywords>skeleton, morphology</keywords>
                        <links>Image.PixelRegion.erode, Image.PixelRegion.dilate, Image.thin, Image.morphology</links>
                        <desc>Creates a skeleton region out of the input region.</desc>
                        <sample for="lua">outputRegion = Image.PixelRegion.thin(region)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region or list of regions."/>
                        <return name="outputRegion" type="object" multiplicity="[?*]" alias="Image.PixelRegion" desc="Skeleton region"/>
                    </function>
                    <function name="contains">
                        <trait>released</trait>
                        <keywords>inside, included</keywords>
                        <links>Shape.contains</links>
                        <desc>Return true if the region(s) contains the given point.
If more than one region is provided true is returned if the point is inside any of the regions.
If more than one point is provided an array is returned with one value for each input point.</desc>
                        <sample for="lua">result = Image.PixelRegion.contains(region, point)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region(s)"/>
                        <param name="point" type="const object" multiplicity="[1+]" alias="Point" desc="Input point(s)"/>
                        <return name="result" type="bool" multiplicity="[1+]" desc="True if the point is within the region(s), otherwise false"/>
                    </function>
                    <function name="downsample">
                        <trait>released</trait>
                        <desc>Downsample the pixel region(s) by an integer factor, keeping only rows and columns with coordinates equal to n*factor, where n = 0,1,2,...</desc>
                        <sample for="lua">outputRegion = Image.PixelRegion.downsample(inputRegion, 2)</sample>
                        <param name="inputRegion" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region(s)."/>
                        <param name="factor" type="int" desc="Downsample factor. Must be larger than zero."/>
                        <return name="outputRegion" type="object" multiplicity="[?*]" alias="Image.PixelRegion" desc="Input region(s) downsampled by the provided factor."/>
                    </function>
                    <function name="fillRegion">
                        <trait>released</trait>
                        <keywords>flood, inpaint</keywords>
                        <links>Image.fillRegion, Image.replace, Image.PixelRegion.fillRegionInplace, Image.drawPixelRegion, Image.PixelRegion.fillHoles</links>
                        <desc>Set all pixels within the given region(s) in the target image to a specific value in world coordinates. The pixels outside the input region keep their original values. A new image with updated values is returned, and the input image is left unchanged.

Image world coordinate system handling:
The specified value parameter is interpreted in image world coordinates, e.g., in millimeters if the source image is a range image with a z-origin different than 0 and a z-pixelsize different than 1. If the value parameter is outside the image value range it will be clamped to the closest valid value. The output image inherits the image world coordinate system of the input image.

Missing data handling:
The missing data flag is kept in the output image, but the pixels in the fill region will be updated with non missing data.</desc>
                        <sample for="lua">outputImage = Image.PixelRegion.fillRegion(region, value, inputImage)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="The region(s) to fill."/>
                        <param name="value" type="float" multiplicity="[1+]" desc="World coordinate value to set for pixels within the region. A vector with three values must be given if the input image is an RGB image."/>
                        <param name="inputImage" type="const object" alias="Image" desc="Input image."/>
                        <return name="outputImage" type="object" multiplicity="?" alias="Image" desc="Result image or nil if operation failed."/>
                    </function>
                    <function name="fillRegionInplace">
                        <trait>released</trait>
                        <keywords>flood, inpaint</keywords>
                        <links>Image.fillRegion, Image.PixelRegion.fillRegionInplace, Image.replace, Image.drawPixelRegion, Image.PixelRegion.fillHoles</links>
                        <desc>Inplace version of the Image.PixelRegion.fillRegion function that modifies the input image. See base function for full documentation.</desc>
                        <sample for="lua">result = Image.PixelRegion.fillRegionInplace(region, value, image)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="The region(s) to fill."/>
                        <param name="value" type="float" multiplicity="[1+]" desc="World coordinate value to set for pixels within the region. A vector with three values must be given if the input image is an RGB image."/>
                        <param name="image" type="object" alias="Image" desc="The image. This image is overwritten with the result image."/>
                        <return name="result" type="object" multiplicity="?" alias="Image" desc="Reference to the result image."/>
                    </function>
                    <function name="toImage">
                        <trait>released</trait>
                        <desc>Convert the region to an image, using a specified value for pixels within the region. The value is in world coordinates and is clamped to the representable range of the image.</desc>
                        <sample for="lua">outputImage = Image.PixelRegion.toImage(region, referenceImage, valueWorld)</sample>
                        <param name="region" type="const object" alias="Image.PixelRegion" desc="Input region"/>
                        <param name="referenceImage" type="const object" alias="Image" desc="Reference image, defines the size, pixel type and image world coordinate system of the output image."/>
                        <param name="valueWorld" type="float" multiplicity="?" desc="World coordinate value to use within the region, default is 255"/>
                        <return name="outputImage" type="object" multiplicity="?" alias="Image" desc="Image containing the region"/>
                    </function>
                    <function name="toPoints2D">
                        <trait>released</trait>
                        <links>Point, Image.PixelRegion.toPoints3D</links>
                        <desc>Get a vector of the pixels contained in the region represented as 2D Point objects. Pixel coordinates are converted to image world coordinates using the reference image. Any parts of the input region that is outside the reference image bounds is ignored.</desc>
                        <sample for="lua">points = Image.PixelRegion.toPoints2D(region, referenceImage)</sample>
                        <param name="region" type="const object" alias="Image.PixelRegion" desc="The region to process"/>
                        <param name="referenceImage" type="const object" alias="Image" desc="Reference image, defines the image world coordinate system"/>
                        <return name="points" type="object" multiplicity="*" alias="Point" desc="Vector of 2D Point objects, expressed in image world coordinates, for each pixel contained within the region."/>
                    </function>
                    <function name="toVector">
                        <trait>released</trait>
                        <links>Image.PixelRegion.toPoints2D</links>
                        <desc>Returns vectors of the Y coordinate and X cordinate start and end, corresponding to the pixel region run length encoded segments.</desc>
                        <sample for="lua">segmentsY, segmentsXStart, segmentsXStop= Image.PixelRegion.toVector(region)</sample>
                        <param name="region" type="const object" alias="Image.PixelRegion" desc="The region to process"/>
                        <return name="segmentsY" type="int" multiplicity="+" desc="Vector of the Y coordinates of a pixel region run length encoded segments."/>
                        <return name="segmentsXStart" type="int" multiplicity="+" desc="Vector of the X coordinates initial position of a pixel region run length encoded segments."/>
                        <return name="segmentsXStop" type="int" multiplicity="+" desc="Vector of the X coordinates end position of a pixel region run length encoded segments."/>
                    </function>
                    <function name="createFromPoints">
                        <trait>released</trait>
                        <keywords>toPixelRegion</keywords>
                        <desc>Create a PixelRegion from a set of 2D points defined in image world coordinates. Any points outside the reference image bounds are ignored. By default, each point sets one pixel in the output region. The region point size can be adjusted by the pointDiameter parameter.</desc>
                        <sample for="lua">region = Image.PixelRegion.createFromPoints(points, referenceImage, pointDiameter)</sample>
                        <param name="points" type="const object" multiplicity="+" alias="Point" desc="List of world coordinates, represented as 2D Point objects, for each pixel in the region."/>
                        <param name="referenceImage" type="const object" alias="Image" desc="Reference image, defines the image world coordinate system."/>
                        <param name="pointDiameter" type="int" multiplicity="?" desc="Diameter of the points to create, in pixels. Point diameter must be odd and positive. A circular kernel is used to dilate the points. Optional, default is one."/>
                        <return name="region" type="object" multiplicity="?" alias="Image.PixelRegion" desc="The generated pixel region"/>
                    </function>
                    <function name="toPoints3D">
                        <trait>released</trait>
                        <links>Point, Image.PixelRegion.toPoints2D, Image.toPointCloud</links>
                        <desc>Get a vector of the pixels contained in the region represented as 3D Point objects, including a z value from the reference image. Any parts of the input region that is outside the image bounds or contains missing data is ignored.</desc>
                        <sample for="lua">points = Image.PixelRegion.toPoints3D(region, referenceImage)</sample>
                        <param name="region" type="const object" alias="Image.PixelRegion" desc="The region to process"/>
                        <param name="referenceImage" type="const object" alias="Image" desc="Input image, defines the pixel-world mapping and is used to get z values (pixel values converted using the z-part of the pixel-world mapping)"/>
                        <return name="points" type="object" multiplicity="*" alias="Point" desc="Vector of 3D Point objects, expressed in image world coordinates, for each pixel contained within the region."/>
                    </function>
                    <function name="transform">
                        <trait>released</trait>
                        <links>Image.transform</links>
                        <desc>Transform the region using a general 2D Transform object, expressed in image world coordinates.</desc>
                        <sample for="lua">outputRegion = Image.PixelRegion.transform(region, transform, referenceImage)</sample>
                        <param name="inputRegion" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region, or a list of regions"/>
                        <param name="transform" type="const object" alias="Transform" desc="Transform to apply, expressed in world coordinates"/>
                        <param name="referenceImage" type="const object" alias="Image" desc="Reference image, used to define the image world coordinate system"/>
                        <return name="outputRegion" type="object" multiplicity="[1+]" alias="Image.PixelRegion" desc="The transformed pixel region or region list"/>
                    </function>
                    <function name="findConnected">
                        <trait>released</trait>
                        <keywords>connected components, labeling, blob extraction</keywords>
                        <links>Image.threshold, Image.PixelRegion.Filter</links>
                        <desc>Find the connected components of an input pixel region, i.e., splits a PixelRegion object into a list of separated regions. Only keeps regions with a size (counted in number of pixels) within the range [minSize, maxSize].</desc>
                        <sample for="lua">regions = Image.PixelRegion.findConnected(inputRegions, 10)</sample>
                        <param name="inputRegions" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region(s)"/>
                        <param name="minSize" type="int" multiplicity="?" desc="Minimum output region size"/>
                        <param name="maxSize" type="int" multiplicity="?" desc="Maximum output region size"/>
                        <param name="maxRegionCount" type="int" multiplicity="?" desc="Maximum number of output regions to return (default is 1000). Used to limit the memory requirements of the algorithm."/>
                        <param name="timeoutSeconds" type="float" multiplicity="?" desc="The algorithm will abort if not finished approximately within this time limit, default is five seconds."/>
                        <return name="regions" type="object" multiplicity="*" alias="Image.PixelRegion" desc="List of connected components represented as pixel regions, sorted by decreasing size"/>
                    </function>
                    <function name="getOverlay">
                        <trait>hidden</trait>
                        <desc>Get overlay XML. Internal function, used for viewing.</desc>
                        <sample for="lua"></sample>
                        <param name="region" type="const object" alias="Image.PixelRegion" desc="The region to show"/>
                        <param name="lineColor" type="const object" desc="rgb values"/>
                        <param name="fillColor" type="const object" desc="not used"/>
                        <param name="lineWidth" type="int" desc="not used"/>
                        <return name="overlay" type="string" desc="The XML overlay as a string"/>
                    </function>
                    <function name="getElongation">
                        <trait>released</trait>
                        <keywords>eccentricity</keywords>
                        <links>Image.PixelRegion.getPrincipalAxes</links>
                        <desc>Get the elongation of the region, defined as the ratio between the principal axes lengths. This measure is also often called eccentricity. The value is 1.0 for circles larger than 1.0 for regions that are elongated in one direction.</desc>
                        <sample for="lua">elongation = Image.PixelRegion.getElongation(region, referenceImage)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region or region list"/>
                        <param name="referenceImage" type="const object" alias="Image" desc="Reference image, used to define the image world coordinate system"/>
                        <return name="elongation" type="float" multiplicity="[1+]" desc="Computed elongation measure (single value or list)"/>
                    </function>
                    <function name="getPercentiles">
                        <trait>released</trait>
                        <keywords>statistics</keywords>
                        <links>Image.PixelRegion.getStatistics, Image.PixelRegion.getMedian, Image.getPercentiles</links>
                        <desc>Get a set of rank measurement according to the specified percentile levels. Level 0.5 gives the median, level 0.9 give a value larger than 90% of all image pixels, etc. All values are derived from a histogram and are approximate. Optionally, a reference surface in world coordinates may be provided, in which case the deviations from the reference surface are considered. The default surface is the plane z=0.</desc>
                        <sample for="lua">values = Image.PixelRegion.getPercentiles(region, image, percentileLevels, referenceSurface)</sample>
                        <param name="region" type="const object" multiplicity="1" alias="Image.PixelRegion" desc="Input region"/>
                        <param name="image" type="const object" alias="Image" desc="Input image, defines the image from which to get pixel value input."/>
                        <param name="percentileLevels" type="float" multiplicity="+" desc="Percentile levels in the range (0..1)"/>
                        <param name="referenceSurface" type="const object" multiplicity="?" alias="Shape3D" desc="Zero-reference 3D surface plane for pixel world coordinate values. Optional, default is the plane z=0."/>
                        <return name="values" type="float" multiplicity="*" desc="Output values"/>
                    </function>
                    <function name="getMedian">
                        <trait>released</trait>
                        <keywords>statistics, percentile</keywords>
                        <links>Image.PixelRegion.getStatistics, Image.PixelRegion.getPercentiles, Image.getMedian</links>
                        <desc>Get the median value of the pixels within the region, a special case of Image.PixelRegion.getPercentiles. The median is derived from a histogram and it is approximate. Optionally, a reference surface in world coordinates may be provided, in which case the deviations from the reference surface are considered. The default surface is the plane z=0.</desc>
                        <sample for="lua">median = Image.PixelRegion.getMedian(region, image, referenceSurface)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region or region list"/>
                        <param name="image" type="const object" alias="Image" desc="Input image, defines the image from which to get pixel value input."/>
                        <param name="referenceSurface" type="const object" multiplicity="?" alias="Shape3D" desc="Zero-reference 3D surface plane for pixel world coordinate values. Optional, default is the plane z=0."/>
                        <return name="median" type="float" multiplicity="[?*]" desc="The approximate median."/>
                    </function>
                    <function name="getPerimeterLength">
                        <trait>released</trait>
                        <links>Image.PixelRegion.getBorderRegion</links>
                        <desc>Get the region perimeter length in world units. The length is computed as the sum of distances between individual pixels. Note that this means that the reported perimeters are different than the analytical perimeter for mathematical objects like circles and rectangles.</desc>
                        <sample for="lua">perimeterLength = Image.PixelRegion.getPerimeterLength(region, referenceImage)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region or region list"/>
                        <param name="referenceImage" type="const object" alias="Image" desc="Reference image, used to define the image world coordinate system."/>
                        <return name="perimeterLength" type="float" multiplicity="[1+]" desc="Computed perimeter length in world units (single value or list)"/>
                    </function>
                    <function name="getPrincipalAxes">
                        <trait>released</trait>
                        <keywords>minor, major, moment, PCA, covariance, eccentricity, elongation</keywords>
                        <links>Image.PixelRegion.getElongation</links>
                        <desc>Get principal axes of the region (orientation and length of major/minor axes, derived from region moments).</desc>
                        <sample for="lua">angleRad, majorAxisWorld, minorAxisWorld = Image.PixelRegion.getPrincipalAxes(region, referenceImage)</sample>
                        <param name="region" type="const object" multiplicity="1" alias="Image.PixelRegion" desc="Input region"/>
                        <param name="referenceImage" type="const object" multiplicity="1" alias="Image" desc="Reference image, defines the image world coordinate system."/>
                        <return name="angleRad" type="float" desc="Rotation angle of the major axis in radians."/>
                        <return name="majorAxisWorld" type="float" desc="Length of the major axis in world units"/>
                        <return name="minorAxisWorld" type="float" desc="Length of the minor axis in world units"/>
                    </function>
                    <function name="getStatistics">
                        <trait>released</trait>
                        <keywords>mean, average, standard deviation, std, min, max, minimum, maximum</keywords>
                        <links>Image.PixelRegion.getMedian, Image.PixelRegion.getPercentiles</links>
                        <desc>Get pixel value statistics for pixels belonging to a pixel region. Image world coordinate system values are used and pixels with missing data are excluded. By default, the reference surface z=0 is used. Another reference surface (plane) may be provided, basing the statistics on deviations from that surface. If the statistics can not be calculated, nil is returned. A vector of regions can be provided, in which case four vectors of statistics are returned, one entry for each input region. Any invalid input region in the vector will have the corresponding output entries set to zero.</desc>
                        <sample for="lua">min, max, average, standardDeviation = Image.PixelRegion.getStatistics(region, image, referenceSurface)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region, defines the region of image in which to gather statistics, or several regions where statistics are calculated individually for each region."/>
                        <param name="image" type="const object" multiplicity="1" alias="Image" desc="Input image, defines the image from which to get pixel value input."/>
                        <param name="referenceSurface" type="const object" multiplicity="?" alias="Shape3D" desc="Reference surface, defines the zero level in world coordinates. Default is the plane z=0."/>
                        <return name="min" type="float" multiplicity="[?*]" desc="Minimal value, or vector of values with one entry for each region."/>
                        <return name="max" type="float" multiplicity="[?*]" desc="Maximal value, or vector of values with one entry for each region."/>
                        <return name="average" type="float" multiplicity="[?*]" desc="Average value, or vector of values with one entry for each region."/>
                        <return name="standardDeviation" type="float" multiplicity="[?*]" desc="Standard deviation, or vector of standard deviations with one entry for each region."/>
                    </function>
                    <function name="getVolume">
                        <trait>released</trait>
                        <links>Image.PixelRegion.getArea</links>
                        <desc>Get the volume between a height map and a reference surface within the region or regions. Image world coordinate system values are used. By default, the reference surface z=0 is used. Another reference surface (plane) may be provided.
NOTE: Values below the reference surface are disregarded (counted as a zero-volume-contribution). Pixels with missing data are disregarded (counted as a zero-volume-contribution). For other ways of handling missing data, such as filling using nearby data, call the appropriate Image.missingData-function before calling getVolume.</desc>
                        <sample for="lua">volume = Image.PixelRegion.getVolume(region, heightMap)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region or region list."/>
                        <param name="heightMap" type="const object" multiplicity="1" alias="Image" desc="Input image that can be interpreted as a height map using the origin and pixelSize properties."/>
                        <param name="referenceSurface" type="const object" multiplicity="?" alias="Shape3D" desc="Reference surface, defines the zero level in world coordinates. Default is the plane z=0."/>
                        <return name="volume" type="float" multiplicity="[?*]" desc="The volume contained below the height map within the input region (single value or list), or nil in case of failure."/>
                    </function>
                    <function name="countHoles">
                        <trait>released</trait>
                        <links>Image.PixelRegion.fillHoles</links>
                        <desc>Return the number of holes in the region. To avoid including very small holes that only represent image noise, consider performing a dilate operation before calling countHoles.</desc>
                        <sample for="lua">holeCount = Image.PixelRegion.countHoles(region)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region or region list"/>
                        <return name="holeCount" type="int" multiplicity="[1+]" desc="Computed number of holes (single value or list)"/>
                    </function>
                    <function name="countPixels">
                        <trait>released</trait>
                        <keywords>area</keywords>
                        <links>Image.PixelRegion.countBorderPixels, Image.PixelRegion.getArea</links>
                        <desc>Return the number of pixels within the region.</desc>
                        <sample for="lua">pixelCount = Image.PixelRegion.countPixels(region)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region or region list"/>
                        <return name="pixelCount" type="int" multiplicity="[1+]" desc="Computed number of pixels (single value or list)"/>
                    </function>
                    <function name="countBorderPixels">
                        <trait>released</trait>
                        <links>Image.PixelRegion.getBorderRegion</links>
                        <desc>Return the number of border pixels of the region. A border pixel is located within the region and with neighboring pixels outside the region. 4-connectivity is used for the neighbor relation.</desc>
                        <sample for="lua">pixelCount = Image.PixelRegion.countBorderPixels(region)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region or region list"/>
                        <return name="pixelCount" type="int" multiplicity="[1+]" desc="Computed number of border pixels (single value or list)"/>
                    </function>
                    <function name="getArea">
                        <trait>released</trait>
                        <links>Image.PixelRegion.getVolume</links>
                        <desc>Return the area of the specified region. This is equal to the number of pixels in the region times the area of each pixel as specified by the pixel sizes in the x,y-dimensions.

Missing data handling:
Any missing data information of the referenceImage is ignored. The area is calculated purely on the pixelRegion and scaled using the pixel scale of the image world coordinate system.</desc>
                        <sample for="lua">area = Image.PixelRegion.getArea(region, referenceImage)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region or region list"/>
                        <param name="referenceImage" type="const object" alias="Image" desc="Reference image, defining the image world coordinate system."/>
                        <return name="area" type="float" multiplicity="[1+]" desc="Region area or areas in world units"/>
                    </function>
                    <function name="getCenterOfGravity">
                        <trait>released</trait>
                        <keywords>cog</keywords>
                        <desc>Return the center of gravity of the region in image world coordinates.

Missing data handling:
Any missing data information of the referenceImage is ignored. The center of gravity is calculated purely on the pixelRegion compensated for image scale and origin.</desc>
                        <sample for="lua">point = Image.PixelRegion.getCenterOfGravity(region, referenceImage)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region or region list"/>
                        <param name="referenceImage" type="const object" alias="Image" desc="Reference image, defining the image world coordinate system"/>
                        <return name="point" type="object" multiplicity="[?*]" alias="Point" desc="Center of gravity represented as a 2D Point object (single point or list of points)"/>
                    </function>
                    <function name="getBoundingBox">
                        <trait>released</trait>
                        <links>Image.PixelRegion.getBoundingBoxOriented</links>
                        <desc>Return an axis-aligned box of the region as a rectangle Shape in image world coordinates. To get the bounding box in pixel coordinates instead, just omit the optional referenceImage parameter.</desc>
                        <sample for="lua">box = Image.PixelRegion.getBoundingBox(region)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region or region list."/>
                        <param name="referenceImage" type="const object" multiplicity="?" alias="Image" desc="Reference image, defining the image world coordinate system."/>
                        <return name="box" type="object" multiplicity="[?*]" alias="Shape" desc="Bounding box, represented as a rectangle Shape object, always with zero rotation (single box or list)."/>
                    </function>
                    <function name="getBoundingBoxOriented">
                        <trait>released</trait>
                        <links>Image.PixelRegion.getBoundingBox</links>
                        <desc>Returns the rectangle (not necessarily axis-aligned) of minimum area containing the object. The area is computed in world coordinates. The rectangle is oriented such that the width is larger or equal to the height and with the orientation angle in the range (0..PI).</desc>
                        <sample for="lua">rectangle = Image.PixelRegion.getBoundingBoxOriented(region, referenceImage)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region or region list"/>
                        <param name="referenceImage" type="const object" alias="Image" desc="Reference image, used to define the image world coordinate system"/>
                        <param name="accuracyRad" type="float" multiplicity="?" desc="Required accuracy of the rotation (maximal error of the reported rotation, in radians). Affects both accuracy and speed."/>
                        <return name="rectangle" type="object" multiplicity="[?*]" alias="Shape" desc="The computed oriented bounding box, represented as a rectangle Shape object (single object or list)"/>
                    </function>
                    <function name="getCircularity">
                        <trait>released</trait>
                        <keywords>roundness</keywords>
                        <links>Image.PixelRegion.getCompactness, Image.PixelRegion.getConvexity, Image.PixelRegion.getConvexity</links>
                        <desc>Returns a circularity measure that is 1.0 for ideal circles and smaller for other shapes. The measure is robust to high-frequency noise like jagged edges along the circle perimeter, so even noisy circles get a measure close to 1.0. The measure is significantly lower if the overall appearance is rather an ellipse, square or other non-circular shape.</desc>
                        <sample for="lua">circularity = Image.PixelRegion.getCircularity(region)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region or region list"/>
                        <return name="circularity" type="float" multiplicity="[1+]" desc="The computed circularity measure (single value or list)"/>
                    </function>
                    <function name="getCompactness">
                        <trait>released</trait>
                        <keywords>roundness</keywords>
                        <links>Image.PixelRegion.getCircularity, Image.PixelRegion.getConvexity, Image.PixelRegion.getConvexity</links>
                        <desc>Returns the compactness measure of the region (4 * PI * Area / Perimeter^2). This is close to 1.0 for circles and smaller for less compact regions.</desc>
                        <sample for="lua">compactness = Image.PixelRegion.getCompactness(region, referenceImage)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region or region list"/>
                        <param name="referenceImage" type="const object" alias="Image" desc="Reference image, used to define the image world coordinate system"/>
                        <return name="compactness" type="float" multiplicity="[1+]" desc="The computed compactness measure (single value or list)"/>
                    </function>
                    <function name="getConvexity">
                        <trait>released</trait>
                        <links>Image.PixelRegion.getCompactness, Image.PixelRegion.getCircularity, Image.PixelRegion.getConvexity, Image.PixelRegion.getConvexHull</links>
                        <desc>Returns the convexity measure of the region (region area divided by area of convex hull). This is 1.0 for convex regions and smaller the more non-convex the region is</desc>
                        <sample for="lua">convexity = Image.PixelRegion.getConvexity(region)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region or region list"/>
                        <return name="convexity" type="float" multiplicity="[1+]" desc="The computed convexity measure (single value or list)"/>
                    </function>
                    <function name="touchesImageBorder">
                        <trait>released</trait>
                        <desc>Returns true if a pixel region touches the border of provided image</desc>
                        <sample for="lua">touches = Image.PixelRegion.touchesImageBorder(region, referenceImage)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region or region list"/>
                        <param name="referenceImage" type="const object" alias="Image" desc="Input image, used only to define the image size"/>
                        <return name="touches" type="bool" multiplicity="[1+]" desc="True if region touches image borders (single value or list)"/>
                    </function>
                    <function name="touchesRegionBorder">
                        <trait>released</trait>
                        <desc>Returns true if a pixel region touches the border of provided reference region</desc>
                        <sample for="lua">touches = Image.PixelRegion.touchesRegionBorder(region, referenceRegion)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Image.PixelRegion" desc="Input region or region list"/>
                        <param name="referenceRegion" type="const object" alias="Image.PixelRegion" desc="Reference region, defines the region border"/>
                        <return name="touches" type="bool" multiplicity="[1+]" desc="True if region touches reference region borders (single value or list)"/>
                    </function>
                </serves>
                <uses/>
                <crown name="Filter">
                    <trait>released</trait>
                    <keywords>features, sorting, extraction, blobs</keywords>
                    <links>Image.findConnected</links>
                    <desc>Filter for pixel regions. Offers convenient filtering and sorting based on all features from Image.PixelRegion. The description of each filter contains a reference to the corresponding function.</desc>
                    <enum name="FeatureType" trait="released">
                        <item name="centroid x" desc="Center of gravity in world coordinates, x part. See getCenterOfGravity.">CENTROIDX</item>
                        <item name="centroid y" desc="Center of gravity in world coordinates, y part. See getCenterOfGravity.">CENTROIDY</item>
                        <item name="pixel count" desc="Number of region pixels. See countPixels">PIXELCOUNT</item>
                        <item name="area" desc="Region area in world units. See getArea.">AREA</item>
                        <item name="volume" desc="Volume in world units. See getVolume.">VOLUME</item>
                        <item name="perimiter" desc="Region perimeter in world units. See getPerimeterLength.">PERIMETER</item>
                        <item name="largest side" desc="Largest side of a minimum area rectangle in world units (min-area rectangle fitted with accuracy 0.1 degrees). See getBoundingBoxOriented.">LARGESTSIDE</item>
                        <item name="smallest side" desc="Smallest side of a minimum area rectangle in world units (min-area rectangle fitted with accuracy 0.1 degrees). See getBoundingBoxOriented.">SMALLESTSIDE</item>
                        <item name="major axis" desc="Length of major principal axis in world units. See getPrincipalAxes.">MAJORAXIS</item>
                        <item name="minor axis" desc="Length of minor principal axis in world units. See getPrincipalAxes.">MINORAXIS</item>
                        <item name="rotation" desc="Rotation of major principal axis in world units. See getPrincipalAxes.">ROTATION</item>
                        <item name="elongation" desc="Ratio of major / minor axis lengths. See getElongation.">ELONGATION</item>
                        <item name="convexity" desc="Ratio of area / convex hull area. See getConvexity.">CONVEXITY</item>
                        <item name="compactness" desc="Compactness measure (4*PI*AREA) / PERIMETER^2. See getCompactness.">COMPACTNESS</item>
                        <item name="holes count" desc="Number of holes. See countHoles.">HOLESCOUNT</item>
                        <item name="touches border" desc="Touches border status (1 if region touches image border, 0 otherwise). See touchesImageBorder.">TOUCHESBORDER</item>
                        <item name="average value" desc="Average image intensity or height map value within the region. See getStatistics.">AVERAGEVALUE</item>
                        <item name="min value" desc="Minimum image intensity or height map value within the region. See getStatistics.">MINVALUE</item>
                        <item name="max value" desc="Maximum image intensity or height map value within the region. See getStatistics.">MAXVALUE</item>
                        <item name="std value" desc="Standard deviation of image intensity or height map value within the region. See getStatistics.">STDDEVVALUE</item>
                        <item name="median value" desc="Median of image intensity or height map value within the region. See getMedian.">MEDIANVALUE</item>
                        <item name="percentile 10 value" desc="10%-level (rank measure) of image intensity or height map value within the region (10% of all values are lower than this value). See getPercentiles.">PERC10VALUE</item>
                        <item name="percentile 90 value" desc="90%-level (rank measure) of image intensity or height map value within the region (90% of all values are lower than this value). See getPercentiles.">PERC90VALUE</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <trait>released</trait>
                            <desc>Create a new PixelRegion filter</desc>
                            <sample for="lua">filter = Image.PixelRegion.Filter.create()</sample>
                            <return name="filter" type="handle" alias="Image.PixelRegion.Filter" desc="The new filter"/>
                        </function>
                        <function name="setRange">
                            <trait>released</trait>
                            <keywords>interval</keywords>
                            <links>Image.PixelRegion.Filter.setCondition</links>
                            <desc>Set a new range constraint to the filter. Only regions with feature value within the given range will be included in the filter output.</desc>
                            <sample for="lua">Image.PixelRegion.Filter.setRange(filter, "CONVEXITY", 0.0, 0.8)</sample>
                            <param name="filter" type="handle" alias="Image.PixelRegion.Filter" desc="Input filter to modify"/>
                            <param name="featureType" type="enum" ref="FeatureType" desc="The feature type that the filter applies to"/>
                            <param name="minValue" type="float" desc="Minimum allowed value (inclusive)"/>
                            <param name="maxValue" type="float" desc="Maximum allowed value (inclusive)"/>
                            <param name="withinRange" type="bool" multiplicity="?" desc="Set to true to setup a within-range check and false for an outside-range check. Default is within-range."/>
                        </function>
                        <function name="setCondition">
                            <trait>released</trait>
                            <keywords>equal, inequal</keywords>
                            <links>Image.PixelRegion.Filter.setRange</links>
                            <desc>Set a new equality/inequality condition to the filter. Only regions with feature value within the given range will be included in the filter output.</desc>
                            <sample for="lua">Image.PixelRegion.Filter.setCondition(filter, "HOLESCOUNT", 0)</sample>
                            <param name="filter" type="handle" alias="Image.PixelRegion.Filter" desc="Input filter to modify"/>
                            <param name="featureType" type="enum" ref="FeatureType" desc="The feature type that the filter applies to. Must be an integer feature type."/>
                            <param name="exactValue" type="int" desc="Exact value to compare to"/>
                            <param name="equality" type="bool" multiplicity="?" desc="Set to true for equality comparison and false for inequality. Default is equality."/>
                        </function>
                        <function name="sortBy">
                            <trait>released</trait>
                            <desc>Defines which feature the output list shall be sorted by</desc>
                            <sample for="lua">Image.PixelRegion.Filter.sortBy(filter, "CENTROIDX")</sample>
                            <param name="filter" type="handle" alias="Image.PixelRegion.Filter" desc="Input filter to modify"/>
                            <param name="featureType" type="enum" ref="FeatureType" desc="The feature type to sort by"/>
                            <param name="ascending" type="bool" multiplicity="?" desc="Set to true to sort in ascending order (default), false for descending"/>
                        </function>
                        <function name="apply">
                            <trait>released</trait>
                            <desc>Apply the filter to a region list. Return the filtered and sorted regions. The actual regions are copied by reference, so changing a region in the input list makes the same region change also in the output list and vice versa. Note that lists in Lua are 1-indexed and matrices are 0-indexed, so the features corresponding to filteredRegions[i] is at row i-1 in the featureValues matrix.
If no blobs are found, the function returns an empty filteredRegions list and no featureValues matrix.</desc>
                            <sample for="lua">filteredRegions, featureValues = Image.PixelRegion.Filter.apply(filter, inputRegions, inputImage)</sample>
                            <param name="filter" type="handle" alias="Image.PixelRegion.Filter" desc="Filter to apply"/>
                            <param name="inputRegions" type="object" multiplicity="+" alias="Image.PixelRegion" desc="Input regions"/>
                            <param name="inputImage" type="object" alias="Image" desc="Input image, used for pixel-world mapping and for pixel values if value statistics features are used (median, average, etc.)"/>
                            <return name="filteredRegions" type="object" multiplicity="*" alias="Image.PixelRegion" desc="Filtered and sorted output regions"/>
                            <return name="featureValues" type="object" multiplicity="?" alias="Matrix" desc="Matrix of computed feature values. Each row corresponds to an output region and each column to a computed feature. The columns are in the same order as the features are mentioned in calls to setRange and setCondition before applying the filter."/>
                        </function>
                        <function name="toString">
                            <trait>released</trait>
                            <desc>Get a user-friendly string description of the filter</desc>
                            <sample for="lua">print("The filter is: " .. Image.PixelRegion.Filter.toString(filter))</sample>
                            <param name="filter" type="handle" alias="Image.PixelRegion.Filter" desc="Input filter"/>
                            <return name="description" type="string" desc="User-friendly description of the filter"/>
                        </function>
                    </serves>
                </crown>
            </crown>
            <crown name="PointCloudConversion">
                <trait>released</trait>
                <links>Image.toPointCloud</links>
                <desc>Image to point cloud converter API for special conversion cases. Choose the appropriate converter for your camera. See also the Image.toPointCloud function for conversion of already rectified images.</desc>
                <crown name="RadialDistance">
                    <trait>released</trait>
                    <desc>Image to point cloud converter for 'RadialDistance' cameras e.g. VisionaryT "V3SXX0".</desc>
                    <serves>
                        <function name="create">
                            <desc>Creates a new instance of an image to point cloud converter for 'RadialDistance' cameras.</desc>
                            <sample for="lua">local handle = Image.PointCloudConversion.RadialDistance.create()</sample>
                            <return name="handle" type="handle" alias="Image.PointCloudConversion.RadialDistance" desc="Handle to the instance."/>
                        </function>
                        <function name="setCameraModel">
                            <desc>Sets the camera model for the image to point cloud conversion.</desc>
                            <sample for="lua">Image.PointCloudConversion.RadialDistance.setCameraModel(handle, cameraModel)</sample>
                            <param name="handle" type="handle" alias="Image.PointCloudConversion.RadialDistance" desc="Handle to the instance"/>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="Camera model to set"/>
                        </function>
                        <function name="toPointCloud">
                            <desc>Converts the distance image with optional intensity data from intensity image to a point cloud. Invalid data in the source image will be omitted from the resulting point cloud.</desc>
                            <sample for="lua">local pointCloud = Image.PointCloudConversion.RadialDistance.toPointCloud(handle, distanceImage, intensityImage)</sample>
                            <param name="handle" type="handle" alias="Image.PointCloudConversion.RadialDistance" desc="Handle to the instance"/>
                            <param name="distanceImage" type="object" alias="Image" desc="Distance image to convert to a PointCloud"/>
                            <param name="intensityImage" type="object" multiplicity="?" alias="Image" desc="Intensity image for PointCloud conversion"/>
                            <param name="pixelRegion" type="object" multiplicity="?" alias="Image" desc="Pixel region which restricts the PointCloud conversion"/>
                            <return name="pointCloud" type="object" multiplicity="?" alias="PointCloud" desc="Converted PointCloud with optional intensity data"/>
                        </function>
                    </serves>
                </crown>
                <crown name="PlanarDistance">
                    <trait>released</trait>
                    <desc>Image to point cloud converter for 'PlanarDistance' cameras e.g. Visionary-S "V3SXX2".</desc>
                    <serves>
                        <function name="create">
                            <desc>Creates a new instance of an image to point cloud converter for 'PlanarDistance' cameras.</desc>
                            <sample for="lua">local handle = Image.PointCloudConversion.PlanarDistance.create()</sample>
                            <return name="handle" type="handle" alias="Image.PointCloudConversion.PlanarDistance" desc="Handle to the instance."/>
                        </function>
                        <function name="setCameraModel">
                            <desc>Sets the camera model for the image to point cloud conversion.</desc>
                            <sample for="lua">Image.PointCloudConversion.PlanarDistance.setCameraModel(handle, cameraModel)</sample>
                            <param name="handle" type="handle" alias="Image.PointCloudConversion.PlanarDistance" desc="Handle to the instance"/>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="Camera model to set"/>
                        </function>
                        <function name="toPointCloud">
                            <desc>Converts the distance image with optional intensity data from intensity image to a point cloud. Invalid data in the source image will be omitted from the resulting point cloud.</desc>
                            <sample for="lua">local pointCloud = Image.PointCloudConversion.PlanarDistance.toPointCloud(handle, distanceImage, intensityImage)</sample>
                            <param name="handle" type="handle" alias="Image.PointCloudConversion.PlanarDistance" desc="Handle to the instance"/>
                            <param name="distanceImage" type="object" alias="Image" desc="Distance image to convert to a PointCloud"/>
                            <param name="intensityImage" type="object" multiplicity="?" alias="Image" desc="Intensity image for PointCloud conversion"/>
                            <param name="pixelRegion" type="object" multiplicity="?" alias="Image" desc="Pixel region which restricts the PointCloud conversion"/>
                            <return name="pointCloud" type="object" multiplicity="?" alias="PointCloud" desc="Converted PointCloud with optional intensity data"/>
                        </function>
                    </serves>
                </crown>
            </crown>
            <crown name="Stitching">
                <trait>released</trait>
                <desc>Image stitching is used for creating a larger combined image from multiple smaller images. The process typically comprises two stages, first the input images are alignment/registered and then the output image is composed. Depending on the application one may have knowledge that helps the alignment process, e.g., knowledge of how an imaged object moves relative to the camera. It may also be important that the stitched image preserves the geometric shape of objects, for example if one wants to perform metric measurements in the stitched image. In this case one needs to provide information about the camera calibration and pose through a CameraModel object. In other applications, e.g., stitching an overview thumbnail image for an image database, preserving metric information is not important. There are for this reason different stitching modes available for different application scenarios.

To obtain a robust and successful image stitching result, there are a number of general prerequisites:
- The images need to have good contrast and be well focused. Blurry and under/overexposed images make the alignment process less robust. Specular reflections may also influence the robustness.
- The scene should be uniformly illuminated, also over time. Spatial and temporal inhomogeneity in the light may create visible seams between the images.
- The images must have sufficient overlap. The amount of overlap needed is scene/object-dependent. If the scene is rich on texture that can be used for alignment, less overlap is required.
- External information such as camera calibration (CameraModel) and encoder values must be accurate. Some stitching methods rely heavily on the external input and any inaccuracies propagate as errors in the stitched image.</desc>
                <enum name="InterpolationMethod">
                    <item name="Nearest" desc="Resample using nearest-neighbor interpolation.">NEAREST</item>
                    <item name="Linear" desc="Resample using 2x2 bilinear interpolation.">LINEAR</item>
                </enum>
                <enum name="FusionMethod">
                    <item name="Default" desc="Blend images where distance to camera center determines the cutoff positions.">DEFAULT</item>
                    <item name="Blend" desc="Mix pixels around source image boundaries to create a smooth transition.">BLEND</item>
                </enum>
                <enum name="ShadingCorrectionMode">
                    <item name="Off" desc="Use images as is. No shading correction is applied.">OFF</item>
                    <item name="On" desc="Estimate and apply a shading correction model to the input images.">ON</item>
                    <item name="OnFixed" desc="Apply a pre-calculated shading model. Typically stitch must run once in ON mode before using ON_FIXED.">ON_FIXED</item>
                </enum>
                <crown name="Conveyor">
                    <trait>hidden</trait>
                    <desc>Object for stitching of 2D images during linear motion.</desc>
                    <enum name="OutputShape">
                        <item name="ConstantPlane" desc="Stitch in the plane set by function setPlane.">CONSTANT_PLANE</item>
                        <item name="DynamicPlane" desc="Prioritize getting a good stitch in the largest flat area.">DYNAMIC_PLANE</item>
                        <item name="TopPlane" desc="Prioritize getting a good stitch for elevated objects.">TOP_PLANE</item>
                    </enum>
                    <enum name="PoseMode">
                        <item name="Robust" desc="Limit risk of failure in exchange for worse quality in shaky environments.">ROBUST</item>
                        <item name="Normal" desc="Normal mode for typical use cases.">NORMAL</item>
                    </enum>
                    <enum name="TriangulationMode">
                        <item name="Fast" desc="The most simple triangulation scheme. Can be sensitive in presence of noise.">FAST</item>
                        <item name="Optimal" desc="Preprocessing of correspondences to increase robustness.">OPTIMAL</item>
                    </enum>
                    <enum name="MultiLayerMode">
                        <item name="None" desc="No explicit handling of multiple layer scenes.">NONE</item>
                        <item name="Small Bins" desc="Image regions are handled separately in bins, to better correct for changing depth. Bins are 64x64 pixels. ">SMALL_BINS</item>
                        <item name="Medium Bins" desc="Image regions are handled separately in bins, to better correct for changing depth. Bins are 128x128 pixels. ">MEDIUM_BINS</item>
                        <item name="Large Bins" desc="Image regions are handled separately in bins, to better correct for changing depth. Bins are 256x256 pixels. ">LARGE_BINS</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <trait>hidden</trait>
                            <desc>Creates a new instance of an image stitcher object.</desc>
                            <sample for="lua">stitcher = Image.Stitching.Conveyor.create()</sample>
                            <return name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The new instance."/>
                        </function>
                        <function name="addImage">
                            <trait>hidden</trait>
                            <desc>Adds a 2D image that is going to be used in the image stitching. There must be several images added before the stitched image can be constructed.</desc>
                            <sample for="lua">success = Image.Stitching.Conveyor.addImage(stitcher, image, encoderValuemm, cameraId, mask)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="image" type="object" alias="Image" desc="A 2D gray scale image."/>
                            <param name="encoderValuemm" type="float" multiplicity="?" desc="The corresponding encoder value in mm (absolute value)."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="ID of the camera that captured the image, obtained from the addCamera() function. If left out 0 is assumed."/>
                            <param name="mask" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="If supplied data outside the region will not disturb the image matching."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="getImageCount">
                            <trait>hidden</trait>
                            <desc>Returns the amount of poses currently setup for a particular camera. Each pose correspond to one input image.</desc>
                            <sample for="lua">numberOfPoses =  Image.Stitching.Conveyor.getImageCount(stitcher, cameraIndex)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The conveyor stitching object to use."/>
                            <param name="cameraIndex" type="int" multiplicity="?" desc="The camera index to retrieve the amount of poses for. Default is to use the first camera."/>
                            <return name="numberOfPoses" type="int" desc="The number of poses."/>
                        </function>
                        <function name="addCamera">
                            <trait>hidden</trait>
                            <desc>Adds a camera with intrinsic parameters specified in the camera model object (extrinsic parameters are also needed if several cameras are to be used). Intrinsic parameters are created by running Camera calibration. Extrinsic parameters are created by running a Pose calibration were all cameras see a common target.</desc>
                            <sample for="lua">cameraId = Image.Stitching.Conveyor.addCamera(stitcher, cameraModel)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="Camera model object containing the camera calibration."/>
                            <return name="cameraId" type="int" desc="Returns the camera ID number."/>
                        </function>
                        <function name="getCameraCount">
                            <trait>hidden</trait>
                            <desc>Returns the amount of cameras currently in the stitcher object.</desc>
                            <sample for="lua">numberOfCameras =  Image.Stitching.Conveyor.getCameraCount(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The conveyor stitching object to use."/>
                            <return name="numberOfCameras" type="int" desc="The number of cameras."/>
                        </function>
                        <function name="setFusionMethod">
                            <trait>hidden</trait>
                            <desc>Sets image fusion method, which determines how the output image is produced.</desc>
                            <sample for="lua">Image.Stitching.Conveyor.setFusionMethod(stitcher, "DEFAULT")</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="method" type="enum" ref="FusionMethod" desc="The stitching fusion method. Default is DEFAULT."/>
                        </function>
                        <function name="getFusionMethod">
                            <trait>hidden</trait>
                            <desc>Gets image fusion method which determines how the output image is produced.</desc>
                            <sample for="lua">method = Image.Stitching.Conveyor.getFusionMethod(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <return name="method" type="enum" ref="FusionMethod" desc="The stitching fusion method."/>
                        </function>
                        <function name="setInterpolationMethod">
                            <trait>hidden</trait>
                            <desc>Sets image interpolation method for the output image.</desc>
                            <sample for="lua">Image.Stitching.Conveyor.setInterpolationMethod(stitcher,"NEAREST")</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="method" type="enum" ref="InterpolationMethod" desc="The interpolation method. Default is BILINEAR."/>
                        </function>
                        <function name="getInterpolationMethod">
                            <trait>hidden</trait>
                            <desc>Gets image interpolation method for the output image.</desc>
                            <sample for="lua">method = Image.Stitching.Conveyor.getInterpolationMethod(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <return name="method" type="enum" ref="InterpolationMethod" desc="The interpolation method."/>
                        </function>
                        <function name="setBlendOverlap">
                            <trait>released</trait>
                            <desc>Sets image blending overlap. This is a cosmetic effect to reduce the visibility of the transitions between input images in the stitched output image. The size of the transition region, the blend overlap, will only be in effect if setFusionMethod is first called with BLEND.

Only even blend overlap values are valid as an equal distance into each image is used. Odd values will be truncated to the closest even value. If the overlap is set larger than the actual overlap of images, holes may appear in the stitched image.</desc>
                            <sample for="lua">success = Image.Stitching.Conveyor.setBlendOverlap(stitcher, 18)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="overlap" type="int" desc="Blending overlap in pixels. Max 100, min 0. Default is 10."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="getBlendOverlap">
                            <trait>released</trait>
                            <desc>Returns the selected image blending overlap.

This is a cosmetic effect to reduce the visibility of the transitions between input images in the stitched output image. The size of the transition region, the blend overlap, will only be in effect if setFusionMethod is first called with BLEND.

Only even blend overlap values are valid as an equal distance into each image is used. Odd values will be truncated to the closest even value. If the overlap is set larger than the actual overlap of images, holes may appear in the stitched image.</desc>
                            <sample for="lua">overlap = Image.Stitching.Conveyor.getBlendOverlap(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <return name="overlap" type="int" desc="Blending overlap in pixels."/>
                        </function>
                        <function name="setDirectionVector">
                            <trait>hidden</trait>
                            <desc>Set the global direction vector to use for all cameras together with an extrinsic calibration.
The vector is automatically normalized internally. To disable the use of a global vector set all inputs to zero.</desc>
                            <sample for="lua">Image.Stitching.Conveyor.setDirectionVector(stitcher, 0.2, 0.4, 0.6)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="nx" type="float" desc="The first component of the direction vector."/>
                            <param name="ny" type="float" desc="The second component of the direction vector."/>
                            <param name="nz" type="float" desc="The third component of the direction vector."/>
                            <return name="success" type="bool" desc="True if parameter was successfully set."/>
                        </function>
                        <function name="getDirectionVector">
                            <trait>hidden</trait>
                            <desc>Get the global direction vector used for all cameras together with an extrinsic calibration.
The vector is is either the vector set by setDirectionVector or an internally estimated direction vector.</desc>
                            <sample for="lua">nx, ny, nz = Image.Stitching.Conveyor.getDirectionVector(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <return name="nx" type="float" desc="The first component of the direction vector."/>
                            <return name="ny" type="float" desc="The second component of the direction vector."/>
                            <return name="nz" type="float" desc="The third component of the direction vector."/>
                        </function>
                        <function name="setPlane">
                            <trait>hidden</trait>
                            <desc>Set the plane in which to stitch the image. This setting will override the internal estimation.
This is a plane in relation to the global calibration.
To turn on internal estimation again use setPlane without the optional plane input.</desc>
                            <sample for="lua">success = Image.Stitching.Conveyor.setPlane(stitcher, plane)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="plane" type="const object" multiplicity="?" alias="Shape3D" desc="The world plane in which to stitch."/>
                            <return name="success" type="bool" desc="True if the plane could be set."/>
                        </function>
                        <function name="getPlane">
                            <trait>hidden</trait>
                            <desc>Get the plane used to stitch the image. This is either internally estimated or set by setPlane.</desc>
                            <sample for="lua">plane = Image.Stitching.Conveyor.getPlane(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <return name="plane" type="object" multiplicity="?" alias="Shape3D" desc="The world plane currently set."/>
                        </function>
                        <function name="setOutputShape">
                            <trait>hidden</trait>
                            <desc>Sets the type of shape to stitch on.</desc>
                            <sample for="lua">Image.Stitching.Conveyor.setOutputShape(stitcher, "CONSTANT_PLANE")</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="method" type="enum" ref="OutputShape" desc="The output shape to use. Default is DYNAMIC_PLANE."/>
                        </function>
                        <function name="getOutputShape">
                            <trait>hidden</trait>
                            <desc>Gets the active selection for</desc>
                            <sample for="lua">method = Image.Stitching.Conveyor.getOutputShape(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <return name="method" type="enum" ref="OutputShape" desc="The active output shape."/>
                        </function>
                        <function name="setOutputScaling">
                            <trait>released</trait>
                            <desc>Sets a scale factor for the size of the stitched output image. Typically this is used to reduce the number of pixels in the output image, i.e., to get a smaller stitched image. For example, setting this parameter to 0.5 gives about half the number of pixels in each image dimension.
The default value is 1.0 and gives and output image of approximately the same resolution as the input images.</desc>
                            <sample for="lua">success = Image.Stitching.Conveyor.setOutputScaling(stitcher, 0.5)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="scaling" type="float" desc="Output scaling. Max 10.0, min 0.05. Default is 1.0."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="getOutputScaling">
                            <trait>released</trait>
                            <desc>Returns the selected output scaling. See setOutputScaling for details.</desc>
                            <sample for="lua">scaling = Image.Stitching.Conveyor.getOutputScaling(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <return name="scaling" type="float" desc="Output scale factor."/>
                        </function>
                        <function name="setUndistort">
                            <trait>released</trait>
                            <desc>Set if lens distortion should be corrected in image stitching.
This usually improves stitching quality at expense of performance.
Default is true (lens distortion correction is applied).</desc>
                            <sample for="lua">Image.Stitching.Conveyor.setUndistort(stitcher,true)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="enable" type="bool" desc="Correct for lens distortion. Default is true."/>
                        </function>
                        <function name="getUndistort">
                            <trait>released</trait>
                            <desc>Return the state of lens distortion. If this parameter is true lens distortion is not compensated.</desc>
                            <sample for="lua">distortionIsIgnored = Image.Stitching.Conveyor.getUndistort(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <return name="distortionIsIgnored" type="bool" desc="Ignore lens distortion."/>
                        </function>
                        <function name="setRandomSeed">
                            <trait>hidden</trait>
                            <desc>Set the seed for random calls inside the algorithm.</desc>
                            <sample for="lua">Image.Stitching.Conveyor.setRandomSeed(stitcher, 232)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="seedValue" type="int" desc="The seed value to use."/>
                        </function>
                        <function name="setPyramidLevelDetector">
                            <trait>hidden</trait>
                            <desc>Select on what subsampling level of the original image to perform feature detection. Setting 0 means full resolution, 1 means half resolution.
Tune this parameter to trade performance for quality. Setting a low value such a 0 results in the highest number of features and possibly the best data, but also the longest processing time.
For strongly repeating patterns in images it might be necessary to use a larger number (and a lower resolution) to avoid confusion in tracking the image flow.</desc>
                            <sample for="lua">success = Image.Stitching.Conveyor.setPyramidLevelDetector(stitcher, level, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="level" type="int" desc="Typical values 0, 1 or 2."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                            <return name="success" type="bool" desc="True if parameter was successfully set."/>
                        </function>
                        <function name="setPyramidLimitFine">
                            <trait>hidden</trait>
                            <desc>Select how hight resolution images to use internally. Compared to setPyramidLevelDetector this is purely a robustness setting, where the detector level also affects number of features.
Typically one can set this a bit higher than the the detector level or so that the image size on a certain subsampling level is around 200 pixels.
For a 2048 x 2048 image input setting 3 would yield a pyramid image size of 256 x 256, which typically is both more robust and a lot faster to process than the full image.
Setting the limit to -1 will automatically select the level which gives at least 256 x 256 pixels.</desc>
                            <sample for="lua">success = Image.Stitching.Conveyor.setPyramidLimitFine(stitcher, limit, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="limit" type="int" desc="Typical values 2, 3, 4."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                            <return name="success" type="bool" desc="True if parameter was successfully set."/>
                        </function>
                        <function name="setPyramidLimitCoarse">
                            <trait>hidden</trait>
                            <desc>Selects how far to down sample the image internally. Setting a hight enough value ensures that all scales available are used. Setting 0 means that no scale search is performed.
Tune this parameter to trade performance for quality. Setting a low value such as 3 results in more locality of features and less global stability.</desc>
                            <sample for="lua">success = Image.Stitching.Conveyor.setPyramidLimitCoarse(stitcher, limit, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="limit" type="int" desc="Typical value is 8 or higher."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                            <return name="success" type="bool" desc="True if parameter was successfully set."/>
                        </function>
                        <function name="setPatchSize">
                            <trait>hidden</trait>
                            <desc>Selects how many pixels to use when matching movement between frames. This greatly affects quality and performance.
The size is given as one side of an image patch in pixels. A value such as 11 corresponds to 121 pixels per patch.
A large value such as 21 would give higher robustness, but longer processing time.</desc>
                            <sample for="lua">success = Image.Stitching.Conveyor.setPatchSize(stitcher, size, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="size" type="int" desc="A typical value is 11 px."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                            <return name="success" type="bool" desc="True if parameter was successfully set."/>
                        </function>
                        <function name="setIterationCount">
                            <trait>hidden</trait>
                            <desc>To get an optimal match for the movement between frames some iterations are usually required internally.
This parameter sets the maximum allowed number of iterations independent of whether convergence is reached or not.
A low value increases the risk of converging to an incorrect solution.</desc>
                            <sample for="lua">success = Image.Stitching.Conveyor.setIterationCount(stitcher, iterations, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="iterations" type="int" desc="Typical value is 5."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                            <return name="success" type="bool" desc="True if parameter was successfully set."/>
                        </function>
                        <function name="setMatchTolerance">
                            <trait>hidden</trait>
                            <desc>To get an optimal match for the movement between frames some iterations are usually required internally.
This parameter sets the match tolerance to determine convergence. If this tolerance is reached the number of iterations might be lower.
A low value increases the risk of converging to an incorrect solution.</desc>
                            <sample for="lua">success = Image.Stitching.Conveyor.setMatchTolerance(stitcher, tolerance, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="tolerance" type="float" desc="Default is 0.01."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                            <return name="success" type="bool" desc="True if parameter was successfully set."/>
                        </function>
                        <function name="setDensityThreshold">
                            <trait>hidden</trait>
                            <desc>Tune this parameter to manage scenes with varying structure. A high value will lead to less locality of features and more global stability.</desc>
                            <sample for="lua">success = Image.Stitching.Conveyor.setDensityThreshold(stitcher, threshold, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="threshold" type="int" desc="Default is 3."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                            <return name="success" type="bool" desc="True if parameter was successfully set."/>
                        </function>
                        <function name="setCorrespondenceThreshold">
                            <trait>hidden</trait>
                            <desc>This is a confidence measure on tracked features.
If a feature that was tracked from one frame to the next and back differs from this original by more than this threshold it is ignored.
The measurement is in pixels and may therefore depend on the image resolution.
This measurement is also known as a track-retrack distance.</desc>
                            <sample for="lua">success = Image.Stitching.Conveyor.setCorrespondenceThreshold(stitcher, distance, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="distance" type="float" desc="Default is 0.2 px."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                            <return name="success" type="bool" desc="True if parameter was successfully set."/>
                        </function>
                        <function name="setMaximumFeatureCount">
                            <trait>hidden</trait>
                            <desc>Tune this parameter to trade performance for quality.
When tracking a set of features are detected to follow the motion between frames. This parameter determines the maximum number of features to detect.
A high value can improve robustness, a low value will reduce the amount of computations.</desc>
                            <sample for="lua">success = Image.Stitching.Conveyor.setMaximumFeatureCount(stitcher, count, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="count" type="int" desc="Default is 3000."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                            <return name="success" type="bool" desc="True if parameter was successfully set."/>
                        </function>
                        <function name="setMovementPredictionStepCount">
                            <trait>hidden</trait>
                            <desc>When initializing the system multiple start guesses are used to increase the chance of correct convergence.
This parameter does not have much effect on continuous processing time, but affects the startup time for a few of the first images.</desc>
                            <sample for="lua">success = Image.Stitching.Conveyor.setMovementPredictionStepCount(stitcher, count, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="count" type="int" desc="Default is 3."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                            <return name="success" type="bool" desc="True if parameter was successfully set."/>
                        </function>
                        <function name="setMovementPredictionStepLength">
                            <trait>hidden</trait>
                            <desc>The distance to move for each start guess in pixels.
To select a good value for this parameter one must consider the resolution of the image and the speed of movement between frames.
For robustness set a lower value here and increase movementPredictionStepCount.</desc>
                            <sample for="lua">success = Image.Stitching.Conveyor.setMovementPredictionStepLength(stitcher, length, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="length" type="float" desc="Default is 100."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                            <return name="success" type="bool" desc="True if parameter was successfully set."/>
                        </function>
                        <function name="setMovementPredictionPointCount">
                            <trait>hidden</trait>
                            <desc>Select how many features to use between frames for continuous tracking.
A high value typically increases robustness.</desc>
                            <sample for="lua">success = Image.Stitching.Conveyor.setMovementPredictionPointCount(stitcher, count, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="count" type="int" desc="Default is 100."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                            <return name="success" type="bool" desc="True if parameter was successfully set."/>
                        </function>
                        <function name="setMovementPredictionCorrespondenceThreshold">
                            <trait>hidden</trait>
                            <desc>This is a confidence measure on motion estimation features.
This means that some features that are not used for continuous tracking might be used for coarse movement prediction or vice versa.
If a feature that was tracked from one frame to the next and back differs from this original by more than this threshold it is ignored.
The measurement is in pixels and may therefore depend on the image resolution.
This measurement is also known as a track-retrack distance.</desc>
                            <sample for="lua">success = Image.Stitching.Conveyor.setMovementPredictionCorrespondenceThreshold(stitcher, distance, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="distance" type="float" desc="Default is 0.5 px."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                            <return name="success" type="bool" desc="True if parameter was successfully set."/>
                        </function>
                        <function name="setPosePointCount">
                            <trait>hidden</trait>
                            <desc>WARNING: THIS MIGHT SAY TOO MUCH ABOUT UNDERLYING METHOD.

The minimum number of points required to estimate the relative position of two exposures.</desc>
                            <sample for="lua">success = Image.Stitching.Conveyor.setPosePointCount(stitcher, count, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="count" type="int" desc="Default is 10."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                            <return name="success" type="bool" desc="True if parameter was successfully set."/>
                        </function>
                        <function name="setPosePointDisplacement">
                            <trait>hidden</trait>
                            <desc>WARNING: THIS MIGHT SAY TOO MUCH ABOUT UNDERLYING METHOD.

The minimum median displacement for tracked points used when estimating the relative position of two exposures.
This parameter exists to ensure a long enough baseline.
Values are a factor of image height such that 0.1 would mean 100 pixels in a 1000x1000 pixel image.</desc>
                            <sample for="lua">success = Image.Stitching.Conveyor.setPosePointDisplacement(stitcher, distance, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="distance" type="float" desc="Default is 0.125."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                            <return name="success" type="bool" desc="True if parameter was successfully set."/>
                        </function>
                        <function name="setReprojectionDistance">
                            <trait>hidden</trait>
                            <desc>WARNING: THIS MIGHT SAY TOO MUCH ABOUT UNDERLYING METHOD.

This is a threshold on what points to keep in 3D reconstruction.
The reprojection distance is the distance between the projection of a 3D point and the corresponding 2D point in an image.
Setting a higher value here allows noisier points, a lower value causes less points to remain.</desc>
                            <sample for="lua">success = Image.Stitching.Conveyor.setReprojectionDistance(stitcher, distance, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="distance" type="float" desc="Default is 0.25 px."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                            <return name="success" type="bool" desc="True if parameter was successfully set."/>
                        </function>
                        <function name="setTriangulationDistance">
                            <trait>hidden</trait>
                            <desc>WARNING: THIS MIGHT SAY TOO MUCH ABOUT UNDERLYING METHOD.
WARNING: THE SCALE OF THIS PARAMETER IS INCONVENIENT AND SHOULD BE CHANGED.

This is a threshold on what points to keep in 3D reconstruction.
The triangulation distance in this case is the distance between instances of the same 3D point when triangulated from different views.
Ideally triangulating the same 2D features should always result in the same 3D position. If this is not the case this parameter is used to eliminate such points.
The value is in local scale meaning that it relates to the baseline of the first two cameras used for triangulation (THIS SHOULD BE CHANGED).</desc>
                            <sample for="lua">success = Image.Stitching.Conveyor.setTriangulationDistance(stitcher, distance, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="distance" type="float" desc="Default is 1.0."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                            <return name="success" type="bool" desc="True if parameter was successfully set."/>
                        </function>
                        <function name="setPoseMode">
                            <trait>hidden</trait>
                            <desc>Selects how camera poses are estimated. ROBUST or NORMAL corresponds to 2 or 4 degrees of freedom for camera placement.
Default is NORMAL.</desc>
                            <sample for="lua">success = Image.Stitching.Conveyor.setPoseMode(stitcher, "ROBUST", cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="mode" type="enum" ref="PoseMode" desc="The mode to use."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                            <return name="success" type="bool" desc="True if parameter was successfully set."/>
                        </function>
                        <function name="setTriangulationMode">
                            <trait>hidden</trait>
                            <desc>Selects how 3D points are triangulated.
Default is FAST.</desc>
                            <sample for="lua">success = Image.Stitching.Conveyor.setTriangulationMode(stitcher, "OPTIMAL", cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="mode" type="enum" ref="TriangulationMode" desc="The mode to use."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                            <return name="success" type="bool" desc="True if parameter was successfully set."/>
                        </function>
                        <function name="setMultiLayerMode">
                            <trait>hidden</trait>
                            <desc>Selects layer handling while tracking. This is useful for scenes with several dominant planes.
Default is NONE.</desc>
                            <sample for="lua">success = Image.Stitching.Conveyor.setMultiLayerMode(stitcher, "MEDIUM_BINS", cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="mode" type="enum" ref="Image.Stitching.Conveyor.MultiLayerMode" desc="The mode to use."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                            <return name="success" type="bool" desc="True if parameter was successfully set."/>
                        </function>
                        <function name="getPyramidLevelDetector">
                            <trait>hidden</trait>
                            <desc>Returns the selected detector pyramid level. See setPyramidLevelDetector for details.</desc>
                            <sample for="lua">level = Image.Stitching.Conveyor.getPyramidLevelDetector(stitcher, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                            <return name="level" type="int" desc="The parameter value."/>
                        </function>
                        <function name="getPyramidLimitFine">
                            <trait>hidden</trait>
                            <desc>Returns the selected fine pyramid limit. See setPyramidLimitFine for details.</desc>
                            <sample for="lua">pyramidLimitFine = Image.Stitching.Conveyor.getPyramidLimitFine(stitcher, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                            <return name="pyramidLimitFine" type="int" desc="The parameter value."/>
                        </function>
                        <function name="getPyramidLimitCoarse">
                            <trait>hidden</trait>
                            <desc>Returns the selected coarse pyramid limit. See setPyramidLimitCoarse for details.</desc>
                            <sample for="lua">pyramidLimitCoarse = Image.Stitching.Conveyor.getPyramidLimitCoarse(stitcher, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                            <return name="pyramidLimitCoarse" type="int" desc="The parameter value."/>
                        </function>
                        <function name="getPatchSize">
                            <trait>hidden</trait>
                            <desc>Returns the selected patch size. See setPatchSize for details.</desc>
                            <sample for="lua">patchSize = Image.Stitching.Conveyor.getPatchSize(stitcher, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                            <return name="patchSize" type="int" desc="The parameter value."/>
                        </function>
                        <function name="getIterationCount">
                            <trait>hidden</trait>
                            <desc>Returns the selected iteration count. See setIterationCount for details.</desc>
                            <sample for="lua">iterationCount = Image.Stitching.Conveyor.getIterationCount(stitcher, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                            <return name="iterationCount" type="int" desc="The parameter value."/>
                        </function>
                        <function name="getMatchTolerance">
                            <trait>hidden</trait>
                            <desc>Returns the selected match tolerance. See setMatchTolerance for details.</desc>
                            <sample for="lua">matchTolerance = Image.Stitching.Conveyor.getMatchTolerance(stitcher, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                            <return name="matchTolerance" type="float" desc="The parameter value."/>
                        </function>
                        <function name="getDensityThreshold">
                            <trait>hidden</trait>
                            <desc>Returns the selected density threshold. See setDensityThreshold for details.</desc>
                            <sample for="lua">densityThreshold = Image.Stitching.Conveyor.getDensityThreshold(stitcher, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                            <return name="densityThreshold" type="int" desc="The parameter value."/>
                        </function>
                        <function name="getCorrespondenceThreshold">
                            <trait>hidden</trait>
                            <desc>Returns the selected correspondence threshold. See setCorrespondenceThreshold for details.</desc>
                            <sample for="lua">threshold = Image.Stitching.Conveyor.getCorrespondenceThreshold(stitcher, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                            <return name="threshold" type="float" desc="The parameter value."/>
                        </function>
                        <function name="getMaximumFeatureCount">
                            <trait>hidden</trait>
                            <desc>Returns the selected maximum number of features to detect. See setMaximumFeatureCount for details.</desc>
                            <sample for="lua">maximumFeatureCount = Image.Stitching.Conveyor.getMaximumFeatureCount(stitcher, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                            <return name="maximumFeatureCount" type="int" desc="The parameter value."/>
                        </function>
                        <function name="getMovementPredictionStepCount">
                            <trait>hidden</trait>
                            <desc>Returns the selected step count for movement prediction. See setMovementPredictionStepCount for details.</desc>
                            <sample for="lua">movementPredictionStepCount = Image.Stitching.Conveyor.getMovementPredictionStepCount(stitcher, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                            <return name="movementPredictionStepCount" type="int" desc="The parameter value."/>
                        </function>
                        <function name="getMovementPredictionStepLength">
                            <trait>hidden</trait>
                            <desc>Returns the selected step length for movement prediction. See setMovementPredictionStepLength for details.</desc>
                            <sample for="lua">movementPredictionStepLength = Image.Stitching.Conveyor.getMovementPredictionStepLength(stitcher, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                            <return name="movementPredictionStepLength" type="float" desc="The parameter value."/>
                        </function>
                        <function name="getMovementPredictionPointCount">
                            <trait>hidden</trait>
                            <desc>Returns the selected number of points to use in movement prediction. See setMovementPredictionPointCount for details.</desc>
                            <sample for="lua">movementPredictionPointCount = Image.Stitching.Conveyor.getMovementPredictionPointCount(stitcher, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                            <return name="movementPredictionPointCount" type="int" desc="The parameter value."/>
                        </function>
                        <function name="getMovementPredictionCorrespondenceThreshold">
                            <trait>hidden</trait>
                            <desc>Returns the selected cross check distance for movement prediction. See setMovementPredictionCorrespondenceThreshold for details.</desc>
                            <sample for="lua">distance = Image.Stitching.Conveyor.getMovementPredictionCorrespondenceThreshold(stitcher, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                            <return name="distance" type="float" desc="The parameter value."/>
                        </function>
                        <function name="getPosePointCount">
                            <trait>hidden</trait>
                            <desc>Returns the selected point count for pose estimation. See setPosePointCount for details.</desc>
                            <sample for="lua">posePointCount = Image.Stitching.Conveyor.getPosePointCount(stitcher, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                            <return name="posePointCount" type="int" desc="The parameter value."/>
                        </function>
                        <function name="getPosePointDisplacement">
                            <trait>hidden</trait>
                            <desc>Returns the selected minimum point displacement for pose estimation. See setPosePointDisplacement for details.</desc>
                            <sample for="lua">posePointDisplacement = Image.Stitching.Conveyor.getPosePointDisplacement(stitcher, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                            <return name="posePointDisplacement" type="float" desc="The parameter value."/>
                        </function>
                        <function name="getReprojectionDistance">
                            <trait>hidden</trait>
                            <desc>WARNING: THIS MIGHT SAY TOO MUCH ABOUT UNDERLYING METHOD.

Returns the selected maximum reprojection distance for 3D points. See setReprojectionDistance for details.</desc>
                            <sample for="lua">reprojectionDistance = Image.Stitching.Conveyor.getReprojectionDistance(stitcher, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                            <return name="reprojectionDistance" type="float" desc="The parameter value."/>
                        </function>
                        <function name="getTriangulationDistance">
                            <trait>hidden</trait>
                            <desc>WARNING: THIS MIGHT SAY TOO MUCH ABOUT UNDERLYING METHOD.

Returns the selected maximum triangulation distance for 3D points. See setTriangulationDistance for details.</desc>
                            <sample for="lua">triangulationDistance = Image.Stitching.Conveyor.getTriangulationDistance(stitcher, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                            <return name="triangulationDistance" type="float" desc="The parameter value."/>
                        </function>
                        <function name="getPoseMode">
                            <trait>hidden</trait>
                            <desc>Retrieve the used pose mode. The pose mode selects how camera poses are estimated. ROBUST or NORMAL corresponds to 2 or 4 degrees of freedom for camera placement.</desc>
                            <sample for="lua">mode = Image.Stitching.Conveyor.getPoseMode(stitcher, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset the parameter that each new camera defaults to is returned."/>
                            <return name="mode" type="enum" ref="PoseMode" desc="The mode used."/>
                        </function>
                        <function name="getTriangulationMode">
                            <trait>hidden</trait>
                            <desc>Retrieve the used triangulation mode. Selects how 3D points are triangulated.</desc>
                            <sample for="lua">mode = Image.Stitching.Conveyor.getTriangulationMode(stitcher, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset the parameter that each new camera defaults to is returned."/>
                            <return name="mode" type="enum" ref="TriangulationMode" desc="The mode used."/>
                        </function>
                        <function name="getMultiLayerMode">
                            <trait>hidden</trait>
                            <desc>Retrieve the used multilayer mode mode.</desc>
                            <sample for="lua">mode = Image.Stitching.Conveyor.getMultiLayerMode(stitcher, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher object to use."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset the parameter that each new camera defaults to is returned."/>
                            <return name="mode" type="enum" ref="Image.Stitching.Conveyor.MultiLayerMode" desc="The mode used."/>
                        </function>
                        <function name="stitch">
                            <trait>released</trait>
                            <desc>Stitch all added images and return a stitched image. Several images must be added before stitch can be called. The optional parameter "clearOnSuccess" decides if the underlying data should be cleared after a successful stitch or not (added cameras are not deleted). The default is "true", but some functions (e.g. toWorldCoordinate) need this data so in this case "false" need to be provided and an explicit call to clear() is needed between different objects.</desc>
                            <sample for="lua">stitchedImage = Image.Stitching.Conveyor.stitch(stitchers)</sample>
                            <param name="stitchers" type="object" multiplicity="[1+]" alias="Image.Stitching.Conveyor" desc="The image stitcher instance(s) to use."/>
                            <param name="clearOnSuccess" type="bool" multiplicity="?" desc="Decides if the underlying data should be cleared after a successful stitch or not (added cameras are not deleted)."/>
                            <return name="stitchedImage" type="object" multiplicity="?" alias="Image" desc="Stitched image."/>
                        </function>
                        <function name="getPointCloud">
                            <trait>hidden</trait>
                            <desc>Get the estimated point cloud.</desc>
                            <sample for="lua">cloud = Image.Stitching.Conveyor.getPointCloud(handles)</sample>
                            <param name="handles" type="handle" multiplicity="[1+]" alias="Image.Stitching.Conveyor" desc="The stitching instance(s) to use."/>
                            <param name="colorBasedOnOrigin" type="bool" multiplicity="?" desc="If set to true points will be given a color to indicate what camera they come from."/>
                            <return name="cloud" type="object" multiplicity="?" alias="PointCloud" desc="Point cloud."/>
                        </function>
                        <function name="getCameraModels">
                            <trait>hidden</trait>
                            <desc>Get all valid exposure camera models from the camera with the provided id.</desc>
                            <sample for="lua">models = Image.Stitching.Conveyor.getCameraModels(handles, 0)</sample>
                            <param name="handles" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="cameraId" type="int" desc="ID of the camera that captured the images, obtained from the addCamera() function."/>
                            <return name="models" type="object" multiplicity="[1+]" desc="Camera model(s) corresponding to all valid exposures for the given camera."/>
                        </function>
                        <function name="clear">
                            <trait>released</trait>
                            <desc>Clears all the images added to the stitching object. Added cameras remain.</desc>
                            <sample for="lua">Image.Stitching.Conveyor.clear(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                        </function>
                        <function name="toWorldCoordinate">
                            <trait>hidden</trait>
                            <desc>Transform points from the stitched image (2D coordinate in (sub)pixels) to a world coordinate on the stitching plane (3D in mm). Pixels which correspond to an object outside the stitching plane will still return a world coordinate as if it was in the plane. The transformation may fail if not all the needed data is already set (when calling stitch, clearOnSuccess need to be false), or if the selected stitched pixel does not correspond to a pixel in any input image.</desc>
                            <sample for="lua">pointsOutMm = Image.Stitching.Conveyor.toWorldCoordinate(stitcher, pointsInPixel)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="pointsInPixel" type="object" multiplicity="[1+]" alias="Point" desc="Points to transform."/>
                            <return name="pointsOutMm" type="object" multiplicity="[?*]" alias="Point" desc="Transformed points."/>
                        </function>
                        <function name="setShadingCorrection">
                            <trait>hidden</trait>
                            <desc>Select if and how image shading correction should be done when stitching.
Two modes can be used. OFF to leave images as they are and ON to create a model and use it.</desc>
                            <sample for="lua">Image.Stitching.Conveyor.setShadingCorrection(stitcher, ON)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <param name="mode" type="enum" ref="ShadingCorrectionMode" desc="Select the operation mode for shading correction."/>
                        </function>
                        <function name="getShadingCorrection">
                            <trait>hidden</trait>
                            <desc>Return the current state of shading correction.</desc>
                            <sample for="lua">mode = Image.Stitching.Conveyor.getShadingCorrection(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Conveyor" desc="The stitcher to use."/>
                            <return name="mode" type="enum" ref="ShadingCorrectionMode" desc="The selected shading mode."/>
                        </function>
                    </serves>
                </crown>
                <crown name="StaticScene">
                    <trait>released</trait>
                    <desc>Stitching of a scene where the cameras are fixed in the same position over time and the scene is static while images are exposed. Compared to the Composer stitcher this functionality offers simpler camera management and help in finding the optimal stitching plane. In order for the plane estimation to work a sufficiently good plane must first be provided as a starting point. Also the image must contain enough structure.

Basic run instructions:
- Create stitcher object
- Add two or more calibrated camera models using addCamera.
- Use setImage to add image data.
- Run stitch(planeGuess) and provide a plane guess in world coordinates.
- Plane and shading correction are activated by default. To disable use setShadingCorrection(false) and setPlaneEstimation(false).

Image world coordinate system handling:
Input images are assumed to have origin in (0,0,0) and pixel size (1,1,1). Other images are accepted, but the coordinate system is discarded.

Only UINT8 input images are currently supported.</desc>
                    <serves>
                        <function name="create">
                            <trait>released</trait>
                            <desc>Creates a new instance of an image stitcher object.</desc>
                            <sample for="lua">stitcher = Image.Stitching.StaticScene.create()</sample>
                            <return name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The new instance."/>
                        </function>
                        <function name="addCamera">
                            <trait>released</trait>
                            <desc>Adds a a camera to the stitcher. The cameras added must be fully calibrated.</desc>
                            <sample for="lua">cameraId = Image.Stitching.StaticScene.addCamera(stitcher, cameraModel)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="Camera model object containing the camera calibration."/>
                            <return name="cameraId" type="int" desc="Returns the camera ID number."/>
                        </function>
                        <function name="setImage">
                            <trait>released</trait>
                            <desc>Sets the image content of a camera that was previously added. This image will be used in the image stitching. For each camera a new image should be set before calling stitch.</desc>
                            <sample for="lua">success = Image.Stitching.StaticScene.setImage(stitcher, image, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <param name="image" type="object" alias="Image" desc="A UINT8 gray scale image."/>
                            <param name="cameraId" type="int" desc="ID of the camera that captured the image, obtained from the addCamera() function."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setFusionMethod">
                            <trait>released</trait>
                            <desc>Sets image fusion method, which determines how the output image is produced.</desc>
                            <sample for="lua">Image.Stitching.StaticScene.setFusionMethod(stitcher, "BLEND")</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <param name="method" type="enum" ref="FusionMethod" desc="The stitching fusion method. Default method is DEFAULT."/>
                        </function>
                        <function name="getFusionMethod">
                            <trait>released</trait>
                            <desc>Returns the active image fusion method which determines how the output image is produced.</desc>
                            <sample for="lua">method = Image.Stitching.StaticScene.getFusionMethod(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <return name="method" type="enum" ref="FusionMethod" desc="The stitching fusion method."/>
                        </function>
                        <function name="setInterpolationMethod">
                            <trait>released</trait>
                            <desc>Sets image interpolation method for the output image.</desc>
                            <sample for="lua">Image.Stitching.StaticScene.setInterpolationMethod(stitcher, "NEAREST")</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <param name="method" type="enum" ref="InterpolationMethod" desc="The interpolation method. Default is LINEAR."/>
                        </function>
                        <function name="getInterpolationMethod">
                            <trait>released</trait>
                            <desc>Returns the image interpolation method for the output image.</desc>
                            <sample for="lua">method = Image.Stitching.StaticScene.getInterpolationMethod(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <return name="method" type="enum" ref="InterpolationMethod" desc="The interpolation method."/>
                        </function>
                        <function name="setBlendOverlap">
                            <trait>released</trait>
                            <desc>Sets image blending overlap. This is a cosmetic effect to reduce the visibility of the transitions between input images in the stitched output image. The size of the transition region, the blend overlap, will only be in effect if setFusionMethod is first called with BLEND.

Only even blend overlap values are valid as an equal distance into each image is used. Odd values will be truncated to the closest even value. If the overlap is set larger than the actual overlap of images, holes may appear in the stitched image.</desc>
                            <sample for="lua">success = Image.Stitching.StaticScene.setBlendOverlap(stitcher, 18)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <param name="overlap" type="int" desc="Blending overlap in pixels. Max 100, min 0. Default is 10."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="getBlendOverlap">
                            <trait>released</trait>
                            <desc>Returns the selected image blending overlap.

For details see setBlendOverlap.</desc>
                            <sample for="lua">overlap = Image.Stitching.StaticScene.getBlendOverlap(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <return name="overlap" type="int" desc="Blending overlap in pixels."/>
                        </function>
                        <function name="setOutputScaling">
                            <trait>released</trait>
                            <desc>Sets a scale factor for the size of the stitched output image. Typically this is used to reduce the number of pixels in the output image, i.e., to get a smaller stitched image. For example, setting this parameter to 0.5 gives about half the number of pixels in each image dimension.
The default value is 1.0 and gives and output image of approximately the same resolution as the input images.</desc>
                            <sample for="lua">success = Image.Stitching.StaticScene.setOutputScaling(stitcher, 0.5)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <param name="scaling" type="float" desc="Output scaling. Max 10.0, min 0.05. Default is 1.0."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="getOutputScaling">
                            <trait>released</trait>
                            <desc>Returns the selected output scaling. See setOutputScaling for details.</desc>
                            <sample for="lua">scaling = Image.Stitching.StaticScene.getOutputScaling(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <return name="scaling" type="float" desc="Output scale factor."/>
                        </function>
                        <function name="setUndistort">
                            <trait>released</trait>
                            <desc>Set if lens distortion should be corrected in image stitching. This usually improves stitching quality at expense of performance.

Default is true (lens distortion correction is applied).</desc>
                            <sample for="lua">Image.Stitching.StaticScene.setUndistort(stitcher, true)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <param name="enable" type="bool" desc="Correct for lens distortion. Default is true."/>
                        </function>
                        <function name="getUndistort">
                            <trait>released</trait>
                            <desc>Return the state of lens distortion. For details see setUndistort.</desc>
                            <sample for="lua">distortionIsIgnored = Image.Stitching.StaticScene.getUndistort(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <return name="distortionIsIgnored" type="bool" desc="Ignore lens distortion."/>
                        </function>
                        <function name="setRandomSeed">
                            <trait>hidden</trait>
                            <desc>Set the seed for random calls inside the algorithm.</desc>
                            <sample for="lua">Image.Stitching.StaticScene.setRandomSeed(handle, 232)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <param name="seedValue" type="int" desc="The seed value to use."/>
                        </function>
                        <function name="setPlaneEstimation">
                            <trait>released</trait>
                            <desc>Select if plane estimation should be done before stitching. Default is on.</desc>
                            <sample for="lua">success = Image.Stitching.StaticScene.setPlaneEstimation(stitcher, true)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <param name="active" type="bool" desc="Set to true to enable plane estimation in stitch call. Default is true."/>
                        </function>
                        <function name="getPlaneEstimation">
                            <trait>released</trait>
                            <desc>Return the current state of plane stitching. True means that estimation is performed.</desc>
                            <sample for="lua">active = Image.Stitching.StaticScene.getPlaneEstimation(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <return name="active" type="bool" desc="Set to true to enable plane estimation in stitch call."/>
                        </function>
                        <function name="setPlaneEstimationAngle">
                            <trait>released</trait>
                            <desc>Set the maximum deviation from the calibration plane normal for the normal of the estimated plane in radians.

If the estimated plane normal deviates by an angle larger than the selected value estimation will abort and the supplied stitching plane guess will be used. If this happens a warning will be printed.</desc>
                            <sample for="lua">success = Image.Stitching.StaticScene.setPlaneEstimationAngle(stitcher, 0.5)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <param name="angle" type="float" desc="The angle in radians. Default is 0.5."/>
                            <return name="success" type="bool" desc="True if the parameter was successfully updated."/>
                        </function>
                        <function name="getPlaneEstimationAngle">
                            <trait>released</trait>
                            <desc>Returns the maximum deviation angle allowed from the calibration plane normal for the normal of the estimated plane.
For details see setPlaneEstimationAngle.</desc>
                            <sample for="lua">angle = Image.Stitching.StaticScene.getPlaneEstimationAngle(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <return name="angle" type="float" desc="The angle in radians."/>
                        </function>
                        <function name="setPlaneEstimationCameras">
                            <trait>hidden</trait>
                            <desc>When automatically optimizing the stitching plane two cameras are used. These can be manually selected based on knowledge of overlap and image content. A big overlap and good image data will give a better result for all views.

To have the algorithm attempt to select a suitable camera pair automatically set cameraId1 or cameraId2 to a negative number.</desc>
                            <sample for="lua">success = Image.Stitching.StaticScene.setPlaneEstimationCameras(stitcher, 0, 1)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <param name="cameraId1" type="int" desc="The ID of the first camera to use for plane estimation."/>
                            <param name="cameraId2" type="int" desc="The ID of the second camera to use for plane estimation."/>
                            <return name="success" type="bool" desc="True if successfully updated."/>
                        </function>
                        <function name="getPlaneEstimationCameras">
                            <trait>hidden</trait>
                            <desc>Returns the IDs of the camera used for plane estimation.

For details see setPlaneEstimationCameras.</desc>
                            <sample for="lua">cameraId1, cameraId2 = Image.Stitching.StaticScene.getPlaneEstimationCameras(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <return name="cameraId1" type="int" multiplicity="?" desc="The ID of the first camera to use for plane estimation. Nil if unset."/>
                            <return name="cameraId2" type="int" multiplicity="?" desc="The ID of the second camera to use for plane estimation. Nil if unset."/>
                        </function>
                        <function name="setPlaneEstimationDownsampleFactor">
                            <trait>released</trait>
                            <desc>Select what resolution to use for plane estimation.

Selecting 2.0 will utilize only a quarter of the image resolution. Which will gain speed, but potentially loose quality. When selecting the downsample factor also keep in mind the number of levels used. Plane estimation is done iteratively over several scale levels and stops at the largest image given by this parameter.

Downsampling is not limited to integer values, 1.5 or 2.1 are also possible selections.</desc>
                            <sample for="lua">success = Image.Stitching.StaticScene.setPlaneEstimationDownsampleFactor(stitcher, 2.0)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <param name="downsampleFactor" type="float" desc="The downsample factor to use. Default is 1.0."/>
                            <return name="success" type="bool" desc="True if parameter was successfully updated."/>
                        </function>
                        <function name="getPlaneEstimationDownsampleFactor">
                            <trait>released</trait>
                            <desc>Return the highest resolution used in plane estimation.
For details set setPlaneEstimationDownsampleFactor.</desc>
                            <sample for="lua">success = Image.Stitching.StaticScene.getPlaneEstimationDownsampleFactor(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <return name="downsampleFactor" type="float" desc="The downsample factor to use."/>
                        </function>
                        <function name="setPlaneEstimationIterations">
                            <trait>hidden</trait>
                            <desc>Select the number of iterations to perform on each level during plane estimation. Each iteration increases the likelihood that the correct solution is found, but will cost some extra computation time.</desc>
                            <sample for="lua">success = Image.Stitching.StaticScene.setPlaneEstimationIterations(stitcher, 500)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <param name="iterations" type="int" desc="The number of iterations to do on each level. Default is 1000."/>
                            <return name="success" type="bool" desc="True if parameter was successfully updated."/>
                        </function>
                        <function name="getPlaneEstimationIterations">
                            <trait>hidden</trait>
                            <desc>Returns the number of iterations to perform on each level during plane estimation. Each iteration increases the likelihood that the correct solution is found, but will cost some extra computation time.</desc>
                            <sample for="lua">success = Image.Stitching.StaticScene.getPlaneEstimationIterations(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <return name="iterations" type="int" desc="The number of iterations to do on each level."/>
                        </function>
                        <function name="setPlaneEstimationLevels">
                            <trait>hidden</trait>
                            <desc>Select the number of downsamples to do from the highest resolution. If the downsample factor is set to 2.0 and the number of levels is set to 3 estimation will be performed on downsample levels 8.0, 4.0, 2.0. Having a higher number of levels usually increases robustness.</desc>
                            <sample for="lua">success = Image.Stitching.StaticScene.setPlaneEstimationLevels(stitcher, 3)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <param name="levels" type="int" desc="The number of levels to use. Default is 10."/>
                            <return name="success" type="bool" desc="True if parameter was successfully updated."/>
                        </function>
                        <function name="getPlaneEstimationLevels">
                            <trait>hidden</trait>
                            <desc>Return the number of downsamples to do from the highest resolution. If the downsample factor is set to 2.0 and the number of levels is set to 3 estimation will be performed on downsample levels 8.0, 4.0, 2.0. Having a higher number of levels usually increases robustness.</desc>
                            <sample for="lua">success = Image.Stitching.StaticScene.getPlaneEstimationLevels(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <return name="levels" type="int" desc="The number of levels to use."/>
                        </function>
                        <function name="setPlaneEstimationThreshold">
                            <trait>released</trait>
                            <desc>Set the threshold to consider a point an inlier during plane estimation. The distance should be given in pixels in the original image resolution. A larger value can sometimes give better convergence, with the risk of finding a sub optimal plane. The default of 1.0 should be good for most cases, but might need tuning depending on image content.</desc>
                            <sample for="lua">success = Image.Stitching.StaticScene.setPlaneEstimationThreshold(stitcher, 2.0)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <param name="distance" type="float" desc="The pixel distance threshold. Default is 1.0."/>
                            <return name="success" type="bool" desc="True if parameter was successfully updated."/>
                        </function>
                        <function name="getPlaneEstimationThreshold">
                            <trait>released</trait>
                            <desc>Return the threshold used to consider a point an inlier inside plane estimation.

For details see setPlaneEstimationThreshold.</desc>
                            <sample for="lua">success = Image.Stitching.StaticScene.getPlaneEstimationThreshold(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <return name="distance" type="float" desc="The pixel distance threshold."/>
                        </function>
                        <function name="setShadingCorrection">
                            <trait>released</trait>
                            <desc>Select if and how image shading correction should be done when stitching. Three modes exists. OFF to leave images as they are, ON_FIXED to use a model that is already estimated and ON to create a model and use it. In order to call ON_FIXED at least one stitch has to be performed with the flag set to ON.</desc>
                            <sample for="lua">Image.Stitching.StaticScene.setShadingCorrection(stitcher, "ON")</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <param name="mode" type="enum" ref="ShadingCorrectionMode" desc="Select the operation mode for shading correction."/>
                        </function>
                        <function name="getShadingCorrection">
                            <trait>released</trait>
                            <desc>Return the current state of shading correction.</desc>
                            <sample for="lua">mode = Image.Stitching.StaticScene.getShadingCorrection(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <return name="mode" type="enum" ref="ShadingCorrectionMode" desc="The selected shading mode."/>
                        </function>
                        <function name="setShadingCorrectionDownsampleFactor">
                            <trait>released</trait>
                            <desc>Select what resolution to use for shading correction estimation. Selecting 2.0 will utilize only a quarter of the image resolution. Which will gain speed, but potentially loose quality.

Downsampling is not limited to integer values, 1.5 or 2.1 are also possible selections.</desc>
                            <sample for="lua">success = Image.Stitching.StaticScene.setShadingCorrectionDownsampleFactor(stitcher, 8.0)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <param name="downsampleFactor" type="float" desc="The downsample factor to use. Default is 5.0."/>
                            <return name="success" type="bool" desc="True if parameter was successfully updated."/>
                        </function>
                        <function name="getShadingCorrectionDownsampleFactor">
                            <trait>released</trait>
                            <desc>Return the resolution used in shading correction estimation.

For details see setShadingCorrectionDownsampleFactor.</desc>
                            <sample for="lua">success = Image.Stitching.StaticScene.getShadingCorrectionDownsampleFactor(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <return name="downsampleFactor" type="float" desc="The downsample factor used."/>
                        </function>
                        <function name="stitch">
                            <trait>released</trait>
                            <desc>Stitch all added images and return a stitched image.
Several cameras must be added and images must be set before a stitch can be called. The optional input plane allows selection of the target world plane to stitch in. If the internal plane adjustment is activated the input plane will be used as a starting point for plane estimation. For the internal estimation to reach a good solution it's required to provide a good enough start solution. A plane at roughly the correct height is usually good enough, but depends on image content. To activate the plane estimation see setPlaneEstimation.

The final stitching plane is used to estimate the shading correction if active. For details on shading correction see setShadingCorrection.</desc>
                            <sample for="lua">stitchedImage, outputPlane = Image.Stitching.StaticScene.stitch(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The image stitcher instance to use."/>
                            <param name="inputPlane" type="const object" multiplicity="?" alias="Shape3D" desc="Optional plane. If not supplied the calibration plane will be assumed."/>
                            <return name="stitchedImage" type="object" multiplicity="?" alias="Image" desc="Stitched image."/>
                            <return name="outputPlane" type="object" multiplicity="?" alias="Shape3D" desc="The plane used for stitching."/>
                        </function>
                        <function name="clear">
                            <trait>released</trait>
                            <desc>Clears all the images added to the stitching object. Added cameras remain.</desc>
                            <sample for="lua">Image.Stitching.StaticScene.clear(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                        </function>
                        <function name="toWorldCoordinate">
                            <trait>released</trait>
                            <desc>Transform points from the stitched image (2D coordinate in (sub)pixels) to a world coordinate on the stitching plane (3D in mm). Pixels which correspond to an object outside the stitching plane will still return a world coordinate as if it was in the plane. The transformation may fail if not all the needed data is already set (when calling stitch, clearOnSuccess need to be false), or if the selected stitched pixel does not correspond to a pixel in any input image.</desc>
                            <sample for="lua">pointsOut = Image.Stitching.StaticScene.toWorldCoordinate(stitcher, pointsIn)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.StaticScene" desc="The stitcher to use."/>
                            <param name="pointsInPixel" type="object" multiplicity="[1+]" alias="Point" desc="Points to transform."/>
                            <return name="pointsOutMm" type="object" multiplicity="[?*]" alias="Point" desc="Transformed points."/>
                        </function>
                    </serves>
                </crown>
                <crown name="Sequence">
                    <trait>released</trait>
                    <desc>Method for stitching a temporal sequence of 2D images from a single or multiple cameras. The images must be provided in temporal order such that a continuous path can be traced through the whole sequence of images. The path need to be smooth, e.g., sudden jumps in movement direction are not allowed. For a robust alignment the overlap between successive input images must be sufficient. As a rule of thumb, images need to overlap about 50%, but depending on the scene/object texture, more or less may be needed. Another rule of thumb is that at least 50% of the first image must contain the scene/object of interest, as some internal parameters are set based on the first image. Avoid adding images where only a small fraction of the scene/object is visible. If multiple cameras are to be used, the addImage command must be called with a vector of images in the correct order meaning that the left-most image should be at the first vector position and the right-most image at the last vector position.

This Sequence stitcher does not require any camera calibration input, only the images themselves. As an effect, metric information is not preserved in the stitched image, i.e., objects can be stretched to compose the stitched image.

Basic run instructions:
- Create stitcher object
- Call addImage several times for each time step using a single image, or a vector of images in the multi camera case.
- Call stitch to get the result image.

Options that control robustness, image quality and speed of the algorithm are:

- Output scaling factor, producing a smaller stitched output image reduces runtime.
- Fusion method setting, blending transition borders takes more time than the default setting not to.
- Interpolation method, nearest neighbor interpolation is faster than linear interpolation.
- Shading compensation, tries to estimate a global shading model to make images look better, but is slower. At least three images per camera need to be added.
- Image masks, if only certain areas should be used for matching, masks can be added together with the images. If it is unavoidable to use images without an object, an empty mask can be used to improve the stitching result.

Other ways to reduce runtime and  memory footprint is to downsample images before adding to the stitching object and to use as few images as possible for solving the application.

The Sequence stitcher is limited to uint8 gray scale images and stitch output will be nil on failure.</desc>
                    <serves>
                        <function name="create">
                            <trait>released</trait>
                            <desc>Creates a new instance of the Sequence stitcher object.</desc>
                            <sample for="lua">stitcher = Image.Stitching.Sequence.create()</sample>
                            <return name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The new stitcher."/>
                        </function>
                        <function name="addImage">
                            <trait>released</trait>
                            <desc>Adds images for stitching. Images must be added in temporal order for each camera by calling addImage several times, and they must all have the same size. See Sequence stitcher top description for hints on overlap and image content, and Image.Stitching description for general requirements on image quality. When using multiple cameras addImage can be called with a vector of images, one image from each camera. The left-most image must be at the first vector position and the right-most image at the last vector position, and corresponding images at the correct positions in between these. Image masks can be used in order to limit the parts used for matching and if they are used, one for each image much be provided. For best stitching result the object should be visible in all images but if this is not possible, e.g. in the beginning or the end of a sequence, using an empty image mask for the corresponding images may improve the stitching result.</desc>
                            <sample for="lua">success = Image.Stitching.Sequence.addImage(stitcher, image, mask)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <param name="image" type="object" multiplicity="[1+]" alias="Image" desc="One or multiple uint8 gray scale image(s)."/>
                            <param name="mask" type="const object" multiplicity="[?*]" alias="Image.PixelRegion" desc="If supplied, data outside the region will not disturb the image matching."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setFusionMethod">
                            <trait>released</trait>
                            <desc>Sets image fusion method, which determines how the output image is produced, e.g., if there should be a smooth blend transition region between images. For details see the FusionMethod enum. Note that this setting has an effect on the execution time and the default setting of not blending between images is the fastest.</desc>
                            <sample for="lua">Image.Stitching.Sequence.setFusionMethod(stitcher, "DEFAULT")</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <param name="method" type="enum" ref="FusionMethod" desc="The stitching fusion method. Default is DEFAULT."/>
                        </function>
                        <function name="getFusionMethod">
                            <trait>released</trait>
                            <desc>Returns the selected image fusion method, which determines how the output image is produced.
For details see the FusionMethod enum.</desc>
                            <sample for="lua">method = Image.Stitching.Sequence.getFusionMethod(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <return name="method" type="enum" ref="FusionMethod" desc="The stitching fusion method."/>
                        </function>
                        <function name="setInterpolationMethod">
                            <trait>released</trait>
                            <desc>Sets image interpolation method for the output image generation. This setting is a trade-off between speed and quality, where NEAREST is the fastest option and LINEAR may give a higher quality result.</desc>
                            <sample for="lua">Image.Stitching.Sequence.setInterpolationMethod(stitcher,"NEAREST")</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <param name="method" type="enum" ref="InterpolationMethod" desc="The interpolation method, NEAREST or LINEAR. Default is LINEAR."/>
                        </function>
                        <function name="getInterpolationMethod">
                            <trait>released</trait>
                            <desc>Returns the selected image interpolation method for the output image.
For details see the InterpolationMethod enum.</desc>
                            <sample for="lua">method = Image.Stitching.Sequence.getInterpolationMethod(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <return name="method" type="enum" ref="InterpolationMethod" desc="The interpolation method."/>
                        </function>
                        <function name="setBlendOverlap">
                            <trait>released</trait>
                            <desc>Sets image blending overlap. This is a cosmetic effect to reduce the visibility of the transitions between input images in the stitched output image. The size of the transition region, the blend overlap, will only be in effect if setFusionMethod is first called with BLEND.

Only even blend overlap values are valid as an equal distance into each image is used. Odd values will be truncated to the closest even value. If the overlap is set larger than the actual overlap of images, holes may appear in the stitched image.</desc>
                            <sample for="lua">success = Image.Stitching.Sequence.setBlendOverlap(stitcher, 18)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <param name="overlap" type="int" desc="Blending overlap in pixels. Max 100, min 0. Default is 10."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="getBlendOverlap">
                            <trait>released</trait>
                            <desc>Returns the selected image blending overlap.

This is a cosmetic effect to reduce the visibility of the transitions between input images in the stitched output image. The size of the transition region, the blend overlap, will only be in effect if setFusionMethod is first called with BLEND.

Only even blend overlap values are valid as an equal distance into each image is used. Odd values will be truncated to the closest even value. If the overlap is set larger than the actual overlap of images, holes may appear in the stitched image.</desc>
                            <sample for="lua">overlap = Image.Stitching.Sequence.getBlendOverlap(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <return name="overlap" type="int" desc="Blending overlap in pixels."/>
                        </function>
                        <function name="setOutputScaling">
                            <trait>released</trait>
                            <desc>Sets a scale factor for the size of the stitched output image. Typically this is used to reduce the number of pixels in the output image, i.e., to get a smaller stitched image. For example, setting this parameter to 0.5 gives about half the number of pixels in each image dimension.
The default value is 1.0 and gives and output image of approximately the same resolution as the input images.</desc>
                            <sample for="lua">success = Image.Stitching.Sequence.setOutputScaling(stitcher, 0.5)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <param name="scaling" type="float" desc="Output scaling. Max 10.0, min 0.05. Default is 1.0."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="getOutputScaling">
                            <trait>released</trait>
                            <desc>Returns the selected output scaling.
For details see setOutputScaling.</desc>
                            <sample for="lua">scaling = Image.Stitching.Sequence.getOutputScaling(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <return name="scaling" type="float" desc="Output scale factor."/>
                        </function>
                        <function name="setDensityThreshold">
                            <trait>hidden</trait>
                            <desc>Tune this parameter to manage scenes with uneven structure content.

A high value ensures a more even distribution of features over the image, while a lower allows more locality.

What is best depends on the image content. A too high value will typically increase the risk of stitching failures and a too low value could give lower quality results.</desc>
                            <sample for="lua">success = Image.Stitching.Sequence.setDensityThreshold(stitcher, threshold)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <param name="threshold" type="int" desc="Default is 8."/>
                            <return name="success" type="bool" desc="True if parameter was successfully set."/>
                        </function>
                        <function name="getDensityThreshold">
                            <trait>hidden</trait>
                            <desc>Returns the selected density threshold.
For details see setDensityThreshold.</desc>
                            <sample for="lua">densityThreshold = Image.Stitching.Sequence.getDensityThreshold(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <return name="densityThreshold" type="int" desc="The parameter value."/>
                        </function>
                        <function name="setCorrespondenceThreshold">
                            <trait>hidden</trait>
                            <desc>This is a confidence measure on tracked features.
If a feature that was tracked from one frame to the next and back differs from its original by more than this threshold it is ignored.
The measurement is in pixels and the optimal choice may therefore depend on the image resolution.
This measurement is also known as a track-retrack distance.</desc>
                            <sample for="lua">success = Image.Stitching.Sequence.setCorrespondenceThreshold(stitcher, threshold, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <param name="threshold" type="float" desc="Default is 0.2 px."/>
                            <return name="success" type="bool" desc="True if parameter was successfully set."/>
                        </function>
                        <function name="getCorrespondenceThreshold">
                            <trait>hidden</trait>
                            <desc>Returns the selected correspondence threshold.
For details see setCorrespondenceThreshold.</desc>
                            <sample for="lua">threshold = Image.Stitching.Sequence.getCorrespondenceThreshold(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <return name="threshold" type="float" desc="The parameter value."/>
                        </function>
                        <function name="setRandomSeed">
                            <trait>hidden</trait>
                            <desc>Set the seed for random calls inside the algorithm.</desc>
                            <sample for="lua">Image.Stitching.Sequence.setRandomSeed(handle, 232)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <param name="seedValue" type="int" desc="The seed value to use."/>
                        </function>
                        <function name="stitch">
                            <trait>released</trait>
                            <desc>Stitch all added images and return a stitched image. If stitching failed nil is returned instead. The optional parameter "clear" decides if the underlying data should be cleared after a stitch or not. If the data is not cleared the clear function should be called before adding another sequence of images. Depending on the scene and image quality it may not be possible to find a matching between different cameras. The usedCameras output can be used to see the camera indices which have been used for the stitching.</desc>
                            <sample for="lua">stitchedImage = Image.Stitching.Sequence.stitch(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <param name="clear" type="bool" multiplicity="?" desc="Decides if the underlying data should be cleared after a stitch or not. Default is true."/>
                            <return name="stitchedImage" type="object" multiplicity="?" alias="Image" desc="Stitched image."/>
                            <return name="usedCameras" type="int" multiplicity="*" desc="Vector of indices corresponding to the used cameras for the stitched image."/>
                        </function>
                        <function name="clear">
                            <trait>released</trait>
                            <desc>Clears all the images added to the stitching object. This function is equivalent to setting the clear variable in stitch to true.</desc>
                            <sample for="lua">Image.Stitching.Sequence.clear(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                        </function>
                        <function name="setShadingCorrection">
                            <trait>released</trait>
                            <desc>Selects if image shading correction should be done when stitching. This setting can only be used together with the "DEFAULT" FusionMethod otherwise it is ignored. Two modes can be used. OFF to leave images as they are and ON to create a model and use it. The shading estimation assumes that all images contain the object and the results may be degraded if empty masks have been used.</desc>
                            <sample for="lua">Image.Stitching.Sequence.setShadingCorrection(stitcher, "ON")</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <param name="mode" type="enum" ref="ShadingCorrectionMode" desc="Select the operation mode for shading correction."/>
                        </function>
                        <function name="getShadingCorrection">
                            <trait>released</trait>
                            <desc>Return the current state of shading correction.</desc>
                            <sample for="lua">mode = Image.Stitching.Sequence.getShadingCorrection(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <return name="mode" type="enum" ref="ShadingCorrectionMode" desc="The selected shading mode."/>
                        </function>
                        <function name="setSequenceMinPointsForHEstimation">
                            <trait>hidden</trait>
                            <desc>Sets the minimum number of points for homography estimation between images from the same camera.</desc>
                            <sample for="lua">Image.Stitching.Sequence.setSequenceMinPointsForHEstimation(stitcher, 20)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <param name="threshold" type="int" desc="Sets the minimum number of points for homography estimation between images from the same camera."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setSequenceNumRansacIterations">
                            <trait>hidden</trait>
                            <desc>Sets the number of RANSAC iterations for homography estimation between images from the same camera.</desc>
                            <sample for="lua">Image.Stitching.Sequence.setSequenceNumRansacIterations(stitcher, 1000)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <param name="threshold" type="int" desc="Sets the number of RANSAC iterations for homography estimation between images from the same camera."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setSequenceRansacThreshold">
                            <trait>hidden</trait>
                            <desc>Sets the RANSAC inlier threshold in pixels for homography estimation between images from the same camera.</desc>
                            <sample for="lua">Image.Stitching.Sequence.setSequenceRansacThreshold(stitcher, 2.0)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <param name="threshold" type="float" desc="Sets the RANSAC inlier threshold in pixels for homography estimation between images from the same camera."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setMultiMinPointsForHEstimation">
                            <trait>hidden</trait>
                            <desc>Sets the minimum number of points for homography estimation between images from different cameras.</desc>
                            <sample for="lua">Image.Stitching.Sequence.setMultiMinPointsForHEstimation(stitcher, 10)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <param name="threshold" type="int" desc="Sets the minimum number of points for homography estimation between images from different cameras."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setMultiNumRansacIterations">
                            <trait>hidden</trait>
                            <desc>Sets the number of RANSAC iterations for homography estimation between images from different cameras.</desc>
                            <sample for="lua">Image.Stitching.Sequence.setMultiNumRansacIterations(stitcher, 5000)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <param name="threshold" type="int" desc="Sets the number of RANSAC iterations for homography estimation between images from different cameras."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setMultiRansacThreshold">
                            <trait>hidden</trait>
                            <desc>Sets the RANSAC inlier threshold in pixels for homography estimation between images from the different cameras.</desc>
                            <sample for="lua">Image.Stitching.Sequence.setMultiRansacThreshold(stitcher, 3.0)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <param name="threshold" type="float" desc="Sets the RANSAC inlier threshold in pixels for homography estimation between images from the different cameras."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setMultiHScaleThreshold">
                            <trait>hidden</trait>
                            <desc>Sets the threshold for the scaling part of the homography estimation between images from the different cameras.</desc>
                            <sample for="lua">Image.Stitching.Sequence.setMultiHScaleThreshold(stitcher, 1.2")</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <param name="threshold" type="float" desc="Sets the threshold for the scaling part of the homography estimation between images from the different cameras."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setMultiH12H21Threshold">
                            <trait>hidden</trait>
                            <desc>Sets the threshold for the H12 and H21 part of the homography estimation between images from the different cameras.</desc>
                            <sample for="lua">Image.Stitching.Sequence.setMultiH12H21Threshold(stitcher, 0.15)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <param name="threshold" type="float" desc="Sets the threshold for the H12 and H21 part of the homography estimation between images from the different cameras."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setOverlapBetweenCameras">
                            <trait>hidden</trait>
                            <desc>Sets the amount of image overlap between two neighboring cameras.</desc>
                            <sample for="lua">Image.Stitching.Sequence.setOverlapBetweenCameras(stitcher, 0.5)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <param name="threshold" type="float" desc="Sets the amount of image overlap between two neighboring cameras."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="getSequenceMinPointsForHEstimation">
                            <trait>hidden</trait>
                            <desc>Gets the minimum number of points for homography estimation between images from the same camera.</desc>
                            <sample for="lua">local parameter = Image.Stitching.Sequence.getSequenceMinPointsForHEstimation(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <return name="threshold" type="int" desc="Gets the minimum number of points for homography estimation between images from the same camera."/>
                        </function>
                        <function name="getSequenceNumRansacIterations">
                            <trait>hidden</trait>
                            <desc>Gets the number of RANSAC iterations for homography estimation between images from the same camera.</desc>
                            <sample for="lua">local parameter = Image.Stitching.Sequence.getSequenceNumRansacIterations(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <return name="threshold" type="int" desc="Gets the number of RANSAC iterations for homography estimation between images from the same camera."/>
                        </function>
                        <function name="getSequenceRansacThreshold">
                            <trait>hidden</trait>
                            <desc>Gets the RANSAC inlier threshold in pixels for homography estimation between images from the same camera.</desc>
                            <sample for="lua">local parameter = Image.Stitching.Sequence.getSequenceRansacThreshold(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <return name="threshold" type="float" desc="Gets the RANSAC inlier threshold in pixels for homography estimation between images from the same camera."/>
                        </function>
                        <function name="getMultiMinPointsForHEstimation">
                            <trait>hidden</trait>
                            <desc>Gets the minimum number of points for homography estimation between images from different cameras.</desc>
                            <sample for="lua">local parameter = Image.Stitching.Sequence.getMultiMinPointsForHEstimation(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <return name="threshold" type="int" desc="Gets the minimum number of points for homography estimation between images from different cameras."/>
                        </function>
                        <function name="getMultiNumRansacIterations">
                            <trait>hidden</trait>
                            <desc>Gets the number of RANSAC iterations for homography estimation between images from different cameras.</desc>
                            <sample for="lua">local parameter = Image.Stitching.Sequence.getMultiNumRansacIterations(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <return name="threshold" type="int" desc="Gets the number of RANSAC iterations for homography estimation between images from different cameras."/>
                        </function>
                        <function name="getMultiRansacThreshold">
                            <trait>hidden</trait>
                            <desc>Gets the RANSAC inlier threshold in pixels for homography estimation between images from the different cameras.</desc>
                            <sample for="lua">local parameter = Image.Stitching.Sequence.getMultiRansacThreshold(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <return name="threshold" type="float" desc="Gets the RANSAC inlier threshold in pixels for homography estimation between images from the different cameras."/>
                        </function>
                        <function name="getMultiHScaleThreshold">
                            <trait>hidden</trait>
                            <desc>Gets the threshold for the scaling part of the homography estimation between images from the different cameras.</desc>
                            <sample for="lua">local parameter = Image.Stitching.Sequence.getMultiHScaleThreshold(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <return name="threshold" type="float" desc="Gets the threshold for the scaling part of the homography estimation between images from the different cameras."/>
                        </function>
                        <function name="getMultiH12H21Threshold">
                            <trait>hidden</trait>
                            <desc>Gets the threshold for the H12 and H21 part of the homography estimation between images from the different cameras.</desc>
                            <sample for="lua">local parameter = Image.Stitching.Sequence.getMultiH12H21Threshold(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <return name="threshold" type="float" desc="Gets the threshold for the H12 and H21 part of the homography estimation between images from the different cameras."/>
                        </function>
                        <function name="getOverlapBetweenCameras">
                            <trait>hidden</trait>
                            <desc>Gets the amount of image overlap between two neighboring cameras.</desc>
                            <sample for="lua">local parameter = Image.Stitching.Sequence.getOverlapBetweenCameras(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <return name="threshold" type="float" desc="Gets the amount of image overlap between two neighboring cameras."/>
                        </function>
                        <function name="setShadingLowIntensityThreshold">
                            <trait>hidden</trait>
                            <desc>Sets the darkest intensity value which should be used in the shading estimation.</desc>
                            <sample for="lua">Image.Stitching.Sequence.setShadingLowIntensityThreshold(stitcher, 10)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <param name="threshold" type="int" desc="Sets the darkest intensity value which should be used in the shading estimation."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setShadingHighIntensityThreshold">
                            <trait>hidden</trait>
                            <desc>Sets the brightest intensity value which should be used in the shading estimation.</desc>
                            <sample for="lua">Image.Stitching.Sequence.setShadingHighIntensityThreshold(stitcher, 10)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <param name="threshold" type="int" desc="Sets the brightest intensity value which should be used in the shading estimation."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setShadingRegularization">
                            <trait>hidden</trait>
                            <desc>Sets the regularization factor which should be used in the shading estimation. Lower means more effect but also more unstable.</desc>
                            <sample for="lua">Image.Stitching.Sequence.setShadingRegularization(stitcher, 10.0)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <param name="regularization" type="float" desc="Sets the regularization factor which should be used in the shading estimation. Lower means more effect but also more unstable."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setShadingPatchRadius">
                            <trait>hidden</trait>
                            <desc>Sets the image patch size which should be used when extracting measurements.</desc>
                            <sample for="lua">Image.Stitching.Sequence.setShadingPatchRadius(stitcher, 5)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <param name="radius" type="int" desc="Sets the image patch size which should be used when extracting measurements."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setShadingNumberOfPointsInSeam">
                            <trait>hidden</trait>
                            <desc>Sets the number of measurement points which should be used when estimating the global intensity between cameras.</desc>
                            <sample for="lua">Image.Stitching.Sequence.setShadingNumberOfPointsInSeam(stitcher, 200)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <param name="numberOfPoints" type="int" desc="Sets the number of measurement points which should be used when estimating the global intensity between cameras."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="getShadingLowIntensityThreshold">
                            <trait>hidden</trait>
                            <desc>Sets the darkest intensity value which should be used in the shading estimation.</desc>
                            <sample for="lua">local parameter = Image.Stitching.Sequence.getShadingLowIntensityThreshold(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <return name="threshold" type="int" desc="Sets the darkest intensity value which should be used in the shading estimation."/>
                        </function>
                        <function name="getShadingHighIntensityThreshold">
                            <trait>hidden</trait>
                            <desc>Sets the brightest intensity value which should be used in the shading estimation.</desc>
                            <sample for="lua">local parameter = Image.Stitching.Sequence.getShadingHighIntensityThreshold(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <return name="threshold" type="int" desc="Sets the brightest intensity value which should be used in the shading estimation."/>
                        </function>
                        <function name="getShadingRegularization">
                            <trait>hidden</trait>
                            <desc>Sets the regularization factor which should be used in the shading estimation. Lower means more effect but also more unstable.</desc>
                            <sample for="lua">local parameter = Image.Stitching.Sequence.getShadingRegularization(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <return name="regularization" type="float" desc="Sets the regularization factor which should be used in the shading estimation. Lower means more effect but also more unstable."/>
                        </function>
                        <function name="getShadingPatchRadius">
                            <trait>hidden</trait>
                            <desc>Sets the image patch size which should be used when extracting measurements.</desc>
                            <sample for="lua">local parameter = Image.Stitching.Sequence.getShadingPatchRadius(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <return name="radius" type="int" desc="Sets the image patch size which should be used when extracting measurements."/>
                        </function>
                        <function name="getShadingNumberOfPointsInSeam">
                            <trait>hidden</trait>
                            <desc>Sets the number of measurement points which should be used when estimating the global intensity between cameras.</desc>
                            <sample for="lua">local parameter = Image.Stitching.Sequence.getShadingNumberOfPointsInSeam(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Sequence" desc="The stitcher to use."/>
                            <return name="numberOfPoints" type="int" desc="Sets the number of measurement points which should be used when estimating the global intensity between cameras."/>
                        </function>
                    </serves>
                </crown>
                <crown name="Composer">
                    <trait>released</trait>
                    <desc>The Composer stitcher composes a stitched imaged based on externally supplied information only, there is no image alignment/registration done internally. As the method does not utilize the content of the input images there is no need for the images to overlap at all. In terms of computational speed, this is the fastest stitching method available.

The required external information is provided through a CameraModel for each input image that describes the pose of the camera at the time of exposure. This information can for example come from an encoder on a conveyor belt or from the knowledge of a robot arm movement. Additionally, the 3D plane in the world in which to stitch must be supplied. This could for example be the z=0 calibration plane for very flat objects or it must be obtained externally. As the Composer stitcher relies entirely on the external information this information needs to be accurate to produce accurate results.

Within the composition process, the algorithm can undistort the input images to remove lens effects. Typically more than one image is acquired with the same physical camera so that the lens distortion effects are the same. To speed up the computation, it is recommended to pre-compute look-up-tables that are then used for the undistortion. It's also possible to disable the undistortion altogether, which will increase computation speed in exchange for a lower quality result.

Other parameters that control image quality and speed of the algorithm are:

- Output scaling factor, producing a smaller stitched output image reduces runtime.
- Fusion method setting, blending transition borders takes more time than the default setting not to.
- Interpolation method, nearest neighbor interpolation is faster than linear interpolation.

Other ways to reduce runtime and memory footprint is to downsample images before adding to the stitching object and to use as few images as possible for solving the application.

The Composer stitcher is currently limited to handle uint8 gray scale images.</desc>
                    <serves>
                        <function name="create">
                            <trait>released</trait>
                            <desc>Creates a new instance of a composer image stitcher object.</desc>
                            <sample for="lua">stitcher = Image.Stitching.Composer.create()</sample>
                            <return name="stitcher" type="handle" alias="Image.Stitching.Composer" desc="The new instance."/>
                        </function>
                        <function name="addImage">
                            <trait>released</trait>
                            <desc>Adds an image as input to the stitching. A camera model object, containing the camera parameters and pose, must be supplied per image.

The camera ID should be supplied if lens correction was enabled using the function setUndistort to avoid a performance penalty when adding images. With undistort enabled it's also recommended to precompute the lens correction using the function initUndistort for each camera ID prior to adding any images.</desc>
                            <sample for="lua">success = Image.Stitching.Composer.addImage(stitcher, image, cameraModel, camId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Composer" desc="The stitcher to use."/>
                            <param name="image" type="object" alias="Image" desc="A 2D gray scale image."/>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="Camera model object containing the camera calibration."/>
                            <param name="cameraId" type="int" multiplicity="?" desc="ID of the camera that captured the image. Only needed when lens correction is enabled."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setFusionMethod">
                            <trait>released</trait>
                            <desc>Sets image fusion method, which determines how the output image is produced, e.g., if there should be a smooth blend transition region between images. For details see the FusionMethod enum. Note that this setting has an effect on the execution time and the default setting of not blending between images is the fastest.</desc>
                            <sample for="lua">Image.Stitching.Composer.setFusionMethod(stitcher, "DEFAULT")</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Composer" desc="The stitcher to use."/>
                            <param name="method" type="enum" ref="FusionMethod" desc="The stitching fusion method. Default is DEFAULT."/>
                        </function>
                        <function name="getFusionMethod">
                            <trait>released</trait>
                            <desc>Returns the selected image fusion method, which determines how the output image is produced.
For details see the FusionMethod enum.</desc>
                            <sample for="lua">method = Image.Stitching.Composer.getFusionMethod(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Composer" desc="The stitcher to use."/>
                            <return name="method" type="enum" ref="FusionMethod" desc="The stitching fusion method."/>
                        </function>
                        <function name="setInterpolationMethod">
                            <trait>released</trait>
                            <desc>Sets image interpolation method for the output image generation. This setting is a trade-off between speed and quality, where NEAREST is the fastest option and LINEAR may give a higher quality result.</desc>
                            <sample for="lua">Image.Stitching.Composer.setInterpolationMethod(stitcher,"nearest")</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Composer" desc="The stitcher to use."/>
                            <param name="method" type="enum" ref="InterpolationMethod" desc="The interpolation method, NEAREST or LINEAR. Default is LINEAR."/>
                        </function>
                        <function name="getInterpolationMethod">
                            <trait>released</trait>
                            <desc>Returns the selected image interpolation method for the output image.
For details see the InterpolationMethod enum.</desc>
                            <sample for="lua">method = Image.Stitching.Composer.getInterpolationMethod(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Composer" desc="The stitcher to use."/>
                            <return name="method" type="enum" ref="InterpolationMethod" desc="The interpolation method."/>
                        </function>
                        <function name="setBlendOverlap">
                            <trait>released</trait>
                            <desc>Sets image blending overlap. This is a cosmetic effect to reduce the visibility of the transitions between input images in the stitched output image. The size of the transition region, the blend overlap, will only be in effect if setFusionMethod is first called with BLEND.

Only even blend overlap values are valid as an equal distance into each image is used. Odd values will be truncated to the closest even value. If the overlap is set larger than the actual overlap of images, holes may appear in the stitched image.</desc>
                            <sample for="lua">success = Image.Stitching.Composer.setBlendOverlap(stitcher, 18)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Composer" desc="The stitcher to use."/>
                            <param name="overlap" type="int" desc="Blending overlap in pixels. Max 100, min 0. Default is 10."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="getBlendOverlap">
                            <trait>released</trait>
                            <desc>Returns the selected image blending overlap.

This is a cosmetic effect to reduce the visibility of the transitions between input images in the stitched output image. The size of the transition region, the blend overlap, will only be in effect if setFusionMethod is first called with BLEND.

Only even blend overlap values are valid as an equal distance into each image is used. Odd values will be truncated to the closest even value. If the overlap is set larger than the actual overlap of images, holes may appear in the stitched image.</desc>
                            <sample for="lua">overlap = Image.Stitching.Composer.getBlendOverlap(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Composer" desc="The stitcher to use."/>
                            <return name="overlap" type="int" desc="Blending overlap in pixels."/>
                        </function>
                        <function name="setPlane">
                            <trait>released</trait>
                            <desc>Set a world plane in which to compute the stitched image.
This plane must be in the global coordinate system defined by the calibration of the input cameras.</desc>
                            <sample for="lua">success = Image.Stitching.Composer.setPlane(stitcher, plane)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Composer" desc="The stitcher to use."/>
                            <param name="plane" type="const object" alias="Shape3D" desc="The world plane."/>
                            <return name="success" type="bool" desc="True if the plane could be set."/>
                        </function>
                        <function name="getPlane">
                            <trait>released</trait>
                            <desc>Returns the currently selected plane.</desc>
                            <sample for="lua">plane = Image.Stitching.Composer.getPlane(handle)</sample>
                            <param name="handle" type="handle" alias="Image.Stitching.Composer" desc="The stitcher to use."/>
                            <return name="plane" type="object" multiplicity="?" alias="Shape3D" desc="The world plane currently set."/>
                        </function>
                        <function name="setOutputScaling">
                            <trait>released</trait>
                            <desc>Sets a scale factor for the size of the stitched output image. Typically this is used to reduce the number of pixels in the output image, i.e., to get a smaller stitched image. For example, setting this parameter to 0.5 gives about half the number of pixels in each image dimension.
The default value is 1.0 and gives and output image of approximately the same resolution as the input images.</desc>
                            <sample for="lua">success = Image.Stitching.Composer.setOutputScaling(stitcher, 0.5)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Composer" desc="The stitcher to use."/>
                            <param name="scaling" type="float" desc="Output scaling. Max 10.0, min 0.05. Default is 1.0."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="getOutputScaling">
                            <trait>released</trait>
                            <desc>Returns the selected output scaling.
For details see setOutputScaling.</desc>
                            <sample for="lua">scaling = Image.Stitching.Composer.getOutputScaling(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Composer" desc="The stitcher to use."/>
                            <return name="scaling" type="float" desc="Output scale factor."/>
                        </function>
                        <function name="setUndistort">
                            <trait>released</trait>
                            <desc>Selects if lens distortion should be corrected before stitching the images.
This typically improves stitching quality at expense of performance.

Default is false (lens distortion correction is not applied).</desc>
                            <sample for="lua">Image.Stitching.Composer.setUndistort(stitcher, true)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Composer" desc="The stitcher to use."/>
                            <param name="enable" type="bool" desc="Correct for lens distortion. Default is false."/>
                        </function>
                        <function name="getUndistort">
                            <trait>released</trait>
                            <desc>Returns a flag indicating if lens correction is enabled or not.
If this parameter is true lens correction is active and is performed on all input images.</desc>
                            <sample for="lua">enabled = Image.Stitching.Composer.getUndistort(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Composer" desc="The stitcher to use."/>
                            <return name="enabled" type="bool" desc="Lens correction flag."/>
                        </function>
                        <function name="setRandomSeed">
                            <trait>hidden</trait>
                            <desc>Set the seed for random calls inside the algorithm.</desc>
                            <sample for="lua">Image.Stitching.Composer.setRandomSeed(stitcher, 232)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Composer" desc="The stitcher to use."/>
                            <param name="seedValue" type="int" desc="The seed value to use."/>
                        </function>
                        <function name="stitch">
                            <trait>released</trait>
                            <desc>Stitch all added images and return a stitched image. The optional parameter "clear" decides if the underlying data should be cleared after a stitch or not. The default is "true", but some functions (e.g. toWorldCoordinate) need this data so in these cases "false" needs to be provided. When clear is set to "false", an explicit call to the function clear() is needed before adding images from another sequence.

Before stitching can take place images must be added using addImage() and the stitching plane must be set by calling setPlane().</desc>
                            <sample for="lua">stitchedImage = Image.Stitching.Composer.stitch(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Composer" desc="The stitcher to use."/>
                            <param name="clear" type="bool" multiplicity="?" desc="Decides if the underlying data should be cleared after a successful stitch or not (added cameras are not deleted)."/>
                            <return name="stitchedImage" type="object" multiplicity="?" alias="Image" desc="Stitched image."/>
                        </function>
                        <function name="clear">
                            <trait>released</trait>
                            <desc>Clears all the images added to the stitching object.
Any precomputed lens lookup tables will remain and should not be recomputed. If new cameras are added either a new stitcher object or new camera IDs should be used. This function is equivalent to setting the clear variable in stitch() to true.</desc>
                            <sample for="lua">Image.Stitching.Composer.clear(stitcher)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Composer" desc="The stitcher to use."/>
                        </function>
                        <function name="initUndistort">
                            <trait>released</trait>
                            <desc>Creates a look up table for lens distortion correction using the parameters in the supplied camera model object. The provided camera ID must later be the same when adding images from the corresponding camera. If lens correction is enabled it's highly recommended to use this function to increase performance while adding images.</desc>
                            <sample for="lua">success = Image.Stitching.Composer.initUndistort(stitcher, cameraModel, cameraId)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Composer" desc="The stitcher to use."/>
                            <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="Camera model object containing the camera calibration."/>
                            <param name="cameraId" type="int" desc="ID of the camera that captured the image."/>
                            <return name="success" type="bool" desc="True if successful."/>
                        </function>
                        <function name="toWorldCoordinate">
                            <trait>released</trait>
                            <desc>Transform points from the stitched image (2D coordinate in (sub)pixels) to a world coordinate on the stitching plane (3D in mm). Pixels which correspond to an object outside the stitching plane will still return a world coordinate as if it was in the plane. The transformation may fail if not all the needed data is already set (when calling stitch, clearOnSuccess need to be false), or if the selected stitched pixel does not correspond to a pixel in any input image.</desc>
                            <sample for="lua">pointsOut = Image.Stitching.Composer.toWorldCoordinate(stitcher, pointsIn)</sample>
                            <param name="stitcher" type="handle" alias="Image.Stitching.Composer" desc="The stitcher to use."/>
                            <param name="pointsInPixel" type="object" multiplicity="[1+]" alias="Point" desc="Points to transform."/>
                            <return name="pointsOutMm" type="object" multiplicity="[?*]" alias="Point" desc="Transformed points. Nil on failure."/>
                        </function>
                    </serves>
                </crown>
            </crown>
            <crown name="StructureFromMotion">
                <trait>hidden</trait>
                <desc>Object for creating geometry from 2D images.</desc>
                <enum name="BoxMethod">
                    <item name="Isotropic" desc="Quick algorithm that gives equal weight to all points.">ISOTROPIC</item>
                    <item name="Anisotropic" desc="More sophisticated method that allows the user to prioritize certain structures in the point cloud.">ANISOTROPIC</item>
                </enum>
                <enum name="PoseMode">
                    <item name="Robust" desc="Limit risk of failure in exchange for worse quality in shaky environments.">ROBUST</item>
                    <item name="Normal" desc="Normal mode for typical use cases.">NORMAL</item>
                </enum>
                <enum name="TriangulationMode">
                    <item name="Fast" desc="The most simple triangulation scheme. Can be sensitive in presence of noise.">FAST</item>
                    <item name="Optimal" desc="Preprocessing of correspondences to increase robustness.">OPTIMAL</item>
                </enum>
                <enum name="MultiLayerMode">
                    <item name="None" desc="No explicit handling of multiple layer scenes.">NONE</item>
                    <item name="Small Bins" desc="Image regions are handled separately in bins, to better correct for changing depth. Bins are 64x64 pixels. ">SMALL_BINS</item>
                    <item name="Medium Bins" desc="Image regions are handled separately in bins, to better correct for changing depth. Bins are 128x128 pixels. ">MEDIUM_BINS</item>
                    <item name="Large Bins" desc="Image regions are handled separately in bins, to better correct for changing depth. Bins are 256x256 pixels. ">LARGE_BINS</item>
                </enum>
                <serves>
                    <function name="create">
                        <trait>hidden</trait>
                        <desc>Creates a new instance of an image GeometryEstimation object.</desc>
                        <sample for="lua">Image.StructureFromMotion.create()</sample>
                        <return name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The new instance."/>
                    </function>
                    <function name="addCamera">
                        <trait>hidden</trait>
                        <desc>Adds a camera with intrinsic parameters specified in the camera model object.
The first camera which is added is the base camera, i.e. the camera with ID 0.</desc>
                        <sample for="lua"></sample>
                        <param name="handle" type="handle" alias="Image.StructureFromMotion" desc="The sfm estimator to use."/>
                        <param name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="Camera model object containing the camera calibration."/>
                        <return name="cameraId" type="int" desc="Returns the camera ID number."/>
                    </function>
                    <function name="getCameraCount">
                        <trait>hidden</trait>
                        <desc>Returns the amount of cameras inside a sfm estimator.</desc>
                        <sample for="lua"></sample>
                        <param name="handle" type="handle" alias="Image.StructureFromMotion" desc="The sfm estimator to use."/>
                        <return name="count" type="int" desc="The number of cameras."/>
                    </function>
                    <function name="addImage">
                        <trait>hidden</trait>
                        <desc>Adds a 2D image that is going to be used in the geometry estimation. There must be several images added before the geometry can be estimated.</desc>
                        <sample for="lua"></sample>
                        <param name="handle" type="handle" alias="Image.StructureFromMotion" desc="The sfm estimator to use."/>
                        <param name="image" type="object" alias="Image" desc="A 2D gray scale image."/>
                        <param name="encoderValuemm" type="float" multiplicity="?" desc="The corresponding encoder value in mm (absolute value)."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="ID of the camera that captured the image, obtained from the addCamera() function. If left out 0 is assumed."/>
                        <param name="mask" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="If supplied data outside the region will not disturb the image matching."/>
                        <return name="success" type="bool" desc="Returns true if successful."/>
                    </function>
                    <function name="getImageCount">
                        <trait>released</trait>
                        <desc>Returns the amount of poses currently setup for a particular camera. Each pose correspond to one input image.</desc>
                        <sample for="lua">numberOfPoses =  Image.StructureFromMotion.getImageCount(sfm, cameraIndex)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="cameraIndex" type="int" multiplicity="?" desc="The camera index to retrieve the amount of poses for. Default is to use the first camera."/>
                        <return name="numberOfPoses" type="int" desc="The number of poses."/>
                    </function>
                    <function name="setRandomSeed">
                        <trait>hidden</trait>
                        <desc>Set the seed for random calls inside the algorithm.</desc>
                        <sample for="lua">Image.StructureFromMotion.setRandomSeed(sfm, 232)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="seedValue" type="int" desc="The seed value to use."/>
                    </function>
                    <function name="setDirectionVector">
                        <trait>hidden</trait>
                        <desc>Set the global direction vector to use for all cameras together with an extrinsic calibration.
The vector is automatically normalized internally. To disable the use of a global vector set all inputs to zero.</desc>
                        <sample for="lua">Image.StructureFromMotion.setDirectionVector(handle, 0.2, 0.4, 0.6)</sample>
                        <param name="handle" type="handle" alias="Image.StructureFromMotion" desc="The sfm estimator to use."/>
                        <param name="nx" type="float" desc="The first component of the direction vector."/>
                        <param name="ny" type="float" desc="The second component of the direction vector."/>
                        <param name="nz" type="float" desc="The third component of the direction vector."/>
                        <return name="success" type="bool" desc="True if parameter was successfully set."/>
                    </function>
                    <function name="getDirectionVector">
                        <trait>hidden</trait>
                        <desc>Get the global direction vector used for all cameras together with an extrinsic calibration.
The vector is is either the vector set by setDirectionVector or an internally estimated direction vector.</desc>
                        <sample for="lua">nx, ny, nz = Image.StructureFromMotion.getDirectionVector(handle)</sample>
                        <param name="handle" type="handle" alias="Image.StructureFromMotion" desc="The sfm estimator to use."/>
                        <return name="nx" type="float" desc="The first component of the direction vector."/>
                        <return name="ny" type="float" desc="The second component of the direction vector."/>
                        <return name="nz" type="float" desc="The third component of the direction vector."/>
                    </function>
                    <function name="getPointCloud">
                        <trait>hidden</trait>
                        <desc>Get the estimated point cloud.</desc>
                        <sample for="lua">cloud = Image.StructureFromMotion.getPointCloud(handles)</sample>
                        <param name="handles" type="handle" multiplicity="[1+]" alias="Image.StructureFromMotion" desc="The GeometryEstimation instance(s) to use."/>
                        <param name="colorBasedOnOrigin" type="bool" multiplicity="?" desc="If set to true points will be given a color to indicate what camera they come from."/>
                        <return name="cloud" type="object" multiplicity="?" alias="PointCloud" desc="Point cloud."/>
                    </function>
                    <function name="getDeadReckoningPointCloud">
                        <trait>hidden</trait>
                        <desc>Get the dead reckoning point cloud.</desc>
                        <sample for="lua">cloud = Image.StructureFromMotion.getDeadReckoningPointCloud(handles)</sample>
                        <param name="handles" type="handle" multiplicity="[1+]" alias="Image.StructureFromMotion" desc="The GeometryEstimation instance(s) to use."/>
                        <param name="colorBasedOnOrigin" type="bool" desc="If set to true points will be given a color to indicate what camera they come from."/>
                        <param name="minBaseLine" type="int" desc="Minimum baseline."/>
                        <param name="maxBaseLine" type="int" desc="Maximum baseline."/>
                        <param name="reprojectionDistance" type="float" desc="Reprojection distance threshold."/>
                        <param name="triangulationDistance" type="float" desc="Triangulation distance threshold."/>
                        <return name="cloud" type="object" multiplicity="?" alias="PointCloud" desc="Point cloud."/>
                    </function>
                    <function name="getCameraModels">
                        <trait>hidden</trait>
                        <desc>Get all valid exposure camera models from the camera with the provided id.</desc>
                        <sample for="lua">local cameraModels = Image.StructureFromMotion.getCameraModels(sfm, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm estimator to use."/>
                        <param name="cameraId" type="int" desc="ID of the camera that captured the images, obtained from the addCamera() function."/>
                        <return name="exposurePoses" type="object" multiplicity="[1+]" desc="Camera model(s) corresponding to all valid exposures for the given camera."/>
                    </function>
                    <function name="clear">
                        <trait>hidden</trait>
                        <desc>Clears all the images added to the GeometryEstimation object. Added cameras remain.</desc>
                        <sample for="lua">Image.StructureFromMotion.clear(sfm)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm estimator to use."/>
                    </function>
                    <function name="setPyramidLevelDetector">
                        <trait>hidden</trait>
                        <desc>Select on what subsampling level of the original image to perform feature detection. Setting 0 means full resolution, 1 means half resolution.
Tune this parameter to trade performance for quality. Setting a low value such a 0 results in the highest number of features and possibly the best data, but also the longest processing time.
For strongly repeating patterns in images it might be necessary to use a larger number (and a lower resolution) to avoid confusion in tracking the image flow.</desc>
                        <sample for="lua">success = Image.StructureFromMotion.setPyramidLevelDetector(sfm, level, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm estimator to use."/>
                        <param name="level" type="int" desc="Typical values 0, 1 or 2."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                        <return name="success" type="bool" desc="True if parameter was successfully set."/>
                    </function>
                    <function name="setPyramidLimitFine">
                        <trait>hidden</trait>
                        <desc>Select how hight resolution images to use internally. Compared to setPyramidLevelDetector this is purely a robustness setting, where the detector level also affects number of features.
Typically one can set this a bit higher than the the detector level or so that the image size on a certain subsampling level is around 200 pixels.
For a 2048 x 2048 image input setting 3 would yield a pyramid image size of 256 x 256, which typically is both more robust and a lot faster to process than the full image.
Setting the limit to -1 will automatically select the level which gives at least 256 x 256 pixels.</desc>
                        <sample for="lua">success = Image.StructureFromMotion.setPyramidLimitFine(sfm, limit, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm estimator to use."/>
                        <param name="limit" type="int" desc="Typical values 2, 3, 4."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                        <return name="success" type="bool" desc="True if parameter was successfully set."/>
                    </function>
                    <function name="setPyramidLimitCoarse">
                        <trait>hidden</trait>
                        <desc>Selects how far to downsample the image internally. Setting a hight enough value ensures that all scales available are used. Setting 0 means that no scale search is performed.
Tune this parameter to trade performance for quality. Setting a low value such as 3 results in more locality of features and less global stability.</desc>
                        <sample for="lua">success = Image.StructureFromMotion.setPyramidLimitCoarse(sfm, limit, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="limit" type="int" desc="Typical value is 8 or higher."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                        <return name="success" type="bool" desc="True if parameter was successfully set."/>
                    </function>
                    <function name="setPatchSize">
                        <trait>hidden</trait>
                        <desc>Selects how many pixels to use when matching movement between frames. This greatly affects quality and performance.
The size is given as one side of an image patch in pixels. A value such as 11 corresponds to 121 pixels per patch.
A large value such as 21 would give higher robustness, but longer processing time.</desc>
                        <sample for="lua">success = Image.StructureFromMotion.setPatchSize(sfm, size, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="size" type="int" desc="A typical value is 11 px."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                        <return name="success" type="bool" desc="True if parameter was successfully set."/>
                    </function>
                    <function name="setIterationCount">
                        <trait>hidden</trait>
                        <desc>To get an optimal match for the movement between frames some iterations are usually required internally.
This parameter sets the maximum allowed number of iterations independent of whether convergence is reached or not.
A low value increases the risk of converging to an incorrect solution.</desc>
                        <sample for="lua">success = Image.StructureFromMotion.setIterationCount(sfm, iterations, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="iterations" type="int" desc="Typical value is 5."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                        <return name="success" type="bool" desc="True if parameter was successfully set."/>
                    </function>
                    <function name="setMatchTolerance">
                        <trait>hidden</trait>
                        <desc>To get an optimal match for the movement between frames some iterations are usually required internally.
This parameter sets the match tolerance to determine convergence. If this tolerance is reached the number of iterations might be lower.
A low value increases the risk of converging to an incorrect solution.</desc>
                        <sample for="lua">success = Image.StructureFromMotion.setMatchTolerance(sfm, tolerance, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="tolerance" type="float" desc="Default is 0.01."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                        <return name="success" type="bool" desc="True if parameter was successfully set."/>
                    </function>
                    <function name="setDensityThreshold">
                        <trait>hidden</trait>
                        <desc>Tune this parameter to manage scenes with varying structure. A high value will lead to less locality of features and more global stability.</desc>
                        <sample for="lua">success = Image.StructureFromMotion.setDensityThreshold(sfm, threshold, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="threshold" type="int" desc="Default is 3."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                        <return name="success" type="bool" desc="True if parameter was successfully set."/>
                    </function>
                    <function name="setCorrespondenceThreshold">
                        <trait>hidden</trait>
                        <desc>This is a confidence measure on tracked features.
If a feature that was tracked from one frame to the next and back differs from this original by more than this threshold it is ignored.
The measurement is in pixels and may therefore depend on the image resolution.
This measurement is also known as a track-retrack distance.</desc>
                        <sample for="lua">success = Image.StructureFromMotion.setCorrespondenceThreshold(sfm, distance, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="distance" type="float" desc="Default is 0.2 px."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                        <return name="success" type="bool" desc="True if parameter was successfully set."/>
                    </function>
                    <function name="setMaximumFeatureCount">
                        <trait>hidden</trait>
                        <desc>Tune this parameter to trade performance for quality.
When tracking a set of features are detected to follow the motion between frames. This parameter determines the maximum number of features to detect.
A high value can improve robustness, a low value will reduce the amount of computations.</desc>
                        <sample for="lua">success = Image.StructureFromMotion.setMaximumFeatureCount(sfm, count, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="count" type="int" desc="Default is 3000."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                        <return name="success" type="bool" desc="True if parameter was successfully set."/>
                    </function>
                    <function name="setMovementPredictionStepCount">
                        <trait>hidden</trait>
                        <desc>When initializing the system multiple start guesses are used to increase the chance of correct convergence.
This parameter does not have much effect on continuous processing time, but affects the startup time for a few of the first images.</desc>
                        <sample for="lua">success = Image.StructureFromMotion.setMovementPredictionStepCount(sfm, count, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="count" type="int" desc="Default is 3."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                        <return name="success" type="bool" desc="True if parameter was successfully set."/>
                    </function>
                    <function name="setMovementPredictionStepLength">
                        <trait>hidden</trait>
                        <desc>The distance to move for each start guess in pixels.
To select a good value for this parameter one must consider the resolution of the image and the speed of movement between frames.
For robustness set a lower value here and increase movementPredictionStepCount.</desc>
                        <sample for="lua">success = Image.StructureFromMotion.setMovementPredictionStepLength(sfm, length, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="length" type="float" desc="Default is 100."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                        <return name="success" type="bool" desc="True if parameter was successfully set."/>
                    </function>
                    <function name="setMovementPredictionPointCount">
                        <trait>hidden</trait>
                        <desc>Select how many features to use between frames for continuous tracking.
A high value typically increases robustness.</desc>
                        <sample for="lua">success = Image.StructureFromMotion.setMovementPredictionPointCount(sfm, count, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="count" type="int" desc="Default is 100."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                        <return name="success" type="bool" desc="True if parameter was successfully set."/>
                    </function>
                    <function name="setMovementPredictionCorrespondenceThreshold">
                        <trait>hidden</trait>
                        <desc>This is a confidence measure on motion estimation features.
This means that some features that are not used for continuous tracking might be used for coarse movement prediction or vice versa.
If a feature that was tracked from one frame to the next and back differs from this original by more than this threshold it is ignored.
The measurement is in pixels and may therefore depend on the image resolution.
This measurement is also known as a track-retrack distance.</desc>
                        <sample for="lua">success = Image.StructureFromMotion.setMovementPredictionCorrespondenceThreshold(sfm, distance, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="distance" type="float" desc="Default is 0.5 px."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                        <return name="success" type="bool" desc="True if parameter was successfully set."/>
                    </function>
                    <function name="setPosePointCount">
                        <trait>hidden</trait>
                        <desc>WARNING: THIS MIGHT SAY TOO MUCH ABOUT UNDERLYING METHOD.

The minimum number of points required to estimate the relative position of two exposures.</desc>
                        <sample for="lua">success = Image.StructureFromMotion.setPosePointCount(sfm, count, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="count" type="int" desc="Default is 10."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                        <return name="success" type="bool" desc="True if parameter was successfully set."/>
                    </function>
                    <function name="setPosePointDisplacement">
                        <trait>hidden</trait>
                        <desc>WARNING: THIS MIGHT SAY TOO MUCH ABOUT UNDERLYING METHOD.

The minimum median displacement for tracked points used when estimating the relative position of two exposures.
This parameter exists to ensure a long enough baseline.
Values are a factor of image height such that 0.1 would mean 100 pixels in a 1000x1000 pixel image.</desc>
                        <sample for="lua">success = Image.StructureFromMotion.setPosePointDisplacement(sfm, distance, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="distance" type="float" desc="Default is 0.125."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                        <return name="success" type="bool" desc="True if parameter was successfully set."/>
                    </function>
                    <function name="setReprojectionDistance">
                        <trait>hidden</trait>
                        <desc>WARNING: THIS MIGHT SAY TOO MUCH ABOUT UNDERLYING METHOD.

This is a threshold on what points to keep in 3D reconstruction.
The reprojection distance is the distance between the projection of a 3D point and the corresponding 2D point in an image.
Setting a higher value here allows noisier points, a lower value causes less points to remain.</desc>
                        <sample for="lua">success = Image.StructureFromMotion.setReprojectionDistance(sfm, distance, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="distance" type="float" desc="Default is 0.25 px."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                        <return name="success" type="bool" desc="True if parameter was successfully set."/>
                    </function>
                    <function name="setTriangulationDistance">
                        <trait>hidden</trait>
                        <desc>WARNING: THIS MIGHT SAY TOO MUCH ABOUT UNDERLYING METHOD.
WARNING: THE SCALE OF THIS PARAMETER IS INCONVENIENT AND SHOULD BE CHANGED.

This is a threshold on what points to keep in 3D reconstruction.
The triangulation distance in this case is the distance between instances of the same 3D point when triangulated from different views.
Ideally triangulating the same 2D features should always result in the same 3D position. If this is not the case this parameter is used to eliminate such points.
The value is in local scale meaning that it relates to the baseline of the first two cameras used for triangulation (THIS SHOULD BE CHANGED).</desc>
                        <sample for="lua">success = Image.StructureFromMotion.setTriangulationDistance(sfm, distance, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="distance" type="float" desc="Default is 1.0."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                        <return name="success" type="bool" desc="True if parameter was successfully set."/>
                    </function>
                    <function name="setPoseMode">
                        <trait>hidden</trait>
                        <desc>Selects how camera poses are estimated. ROBUST, NORMAL and FULL corresponds to 2, 4 and 6 degrees of freedom for camera placement.
Default is NORMAL.</desc>
                        <sample for="lua">success = Image.StructureFromMotion.setPoseMode(sfm, "ROBUST", cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="mode" type="enum" ref="PoseMode" desc="The mode to use."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                        <return name="success" type="bool" desc="True if parameter was successfully set."/>
                    </function>
                    <function name="setTriangulationMode">
                        <trait>hidden</trait>
                        <desc>Selects how 3D points are triangulated.
Default is FAST.</desc>
                        <sample for="lua">success = Image.StructureFromMotion.setTriangulationMode(sfm, "OPTIMAL", cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="mode" type="enum" ref="TriangulationMode" desc="The mode to use."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                        <return name="success" type="bool" desc="True if parameter was successfully set."/>
                    </function>
                    <function name="setMultiLayerMode">
                        <trait>hidden</trait>
                        <desc>Selects layer handling while tracking. This is useful for scenes with several dominant planes.
Default is NONE.</desc>
                        <sample for="lua">success = Image.StructureFromMotion.setMultiLayerMode(sfm, "MEDIUM_BINS", cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="mode" type="enum" ref="Image.StructureFromMotion.MultiLayerMode" desc="The mode to use."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset all cameras are updated."/>
                        <return name="success" type="bool" desc="True if parameter was successfully set."/>
                    </function>
                    <function name="getPyramidLevelDetector">
                        <trait>hidden</trait>
                        <desc>Returns the selected detector pyramid level. See setPyramidLevelDetector for details.</desc>
                        <sample for="lua">level = Image.StructureFromMotion.getPyramidLevelDetector(sfm, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                        <return name="level" type="int" desc="The parameter value."/>
                    </function>
                    <function name="getPyramidLimitFine">
                        <trait>hidden</trait>
                        <desc>Returns the selected fine pyramid limit. See setPyramidLimitFine for details.</desc>
                        <sample for="lua">pyramidLimitFine = Image.StructureFromMotion.getPyramidLimitFine(sfm, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                        <return name="pyramidLimitFine" type="int" desc="The parameter value."/>
                    </function>
                    <function name="getPyramidLimitCoarse">
                        <trait>hidden</trait>
                        <desc>Returns the selected coarse pyramid limit. See setPyramidLimitCoarse for details.</desc>
                        <sample for="lua">pyramidLimitCoarse = Image.StructureFromMotion.getPyramidLimitCoarse(sfm, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                        <return name="pyramidLimitCoarse" type="int" desc="The parameter value."/>
                    </function>
                    <function name="getPatchSize">
                        <trait>hidden</trait>
                        <desc>Returns the selected patch size. See setPatchSize for details.</desc>
                        <sample for="lua">patchSize = Image.StructureFromMotion.getPatchSize(sfm, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                        <return name="patchSize" type="int" desc="The parameter value."/>
                    </function>
                    <function name="getIterationCount">
                        <trait>hidden</trait>
                        <desc>Returns the selected iteration count. See setIterationCount for details.</desc>
                        <sample for="lua">iterationCount = Image.StructureFromMotion.getIterationCount(sfm, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                        <return name="iterationCount" type="int" desc="The parameter value."/>
                    </function>
                    <function name="getMatchTolerance">
                        <trait>hidden</trait>
                        <desc>Returns the selected match tolerance. See setMatchTolerance for details.</desc>
                        <sample for="lua">matchTolerance = Image.StructureFromMotion.getMatchTolerance(sfm, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                        <return name="matchTolerance" type="float" desc="The parameter value."/>
                    </function>
                    <function name="getDensityThreshold">
                        <trait>hidden</trait>
                        <desc>Returns the selected density threshold. See setDensityThreshold for details.</desc>
                        <sample for="lua">densityThreshold = Image.StructureFromMotion.getDensityThreshold(sfm, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                        <return name="densityThreshold" type="int" desc="The parameter value."/>
                    </function>
                    <function name="getCorrespondenceThreshold">
                        <trait>hidden</trait>
                        <desc>Returns the selected correspondence threshold. See setCorrespondenceThreshold for details.</desc>
                        <sample for="lua">threshold = Image.StructureFromMotion.getCorrespondenceThreshold(sfm, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                        <return name="threshold" type="float" desc="The parameter value."/>
                    </function>
                    <function name="getMaximumFeatureCount">
                        <trait>hidden</trait>
                        <desc>Returns the selected maximum number of features to detect. See setMaximumFeatureCount for details.</desc>
                        <sample for="lua">maximumFeatureCount = Image.StructureFromMotion.getMaximumFeatureCount(sfm, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                        <return name="maximumFeatureCount" type="int" desc="The parameter value."/>
                    </function>
                    <function name="getMovementPredictionStepCount">
                        <trait>hidden</trait>
                        <desc>Returns the selected step count for movement prediction. See setMovementPredictionStepCount for details.</desc>
                        <sample for="lua">movementPredictionStepCount = Image.StructureFromMotion.getMovementPredictionStepCount(sfm, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                        <return name="movementPredictionStepCount" type="int" desc="The parameter value."/>
                    </function>
                    <function name="getMovementPredictionStepLength">
                        <trait>hidden</trait>
                        <desc>Returns the selected step length for movement prediction. See setMovementPredictionStepLength for details.</desc>
                        <sample for="lua">movementPredictionStepLength = Image.StructureFromMotion.getMovementPredictionStepLength(sfm, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                        <return name="movementPredictionStepLength" type="float" desc="The parameter value."/>
                    </function>
                    <function name="getMovementPredictionPointCount">
                        <trait>hidden</trait>
                        <desc>Returns the selected number of points to use in movement prediction. See setMovementPredictionPointCount for details.</desc>
                        <sample for="lua">movementPredictionPointCount = Image.StructureFromMotion.getMovementPredictionPointCount(sfm, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                        <return name="movementPredictionPointCount" type="int" desc="The parameter value."/>
                    </function>
                    <function name="getMovementPredictionCorrespondenceThreshold">
                        <trait>hidden</trait>
                        <desc>Returns the selected cross check distance for movement prediction. See setMovementPredictionCorrespondenceThreshold for details.</desc>
                        <sample for="lua">distance = Image.StructureFromMotion.getMovementPredictionCorrespondenceThreshold(sfm, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                        <return name="distance" type="float" desc="The parameter value."/>
                    </function>
                    <function name="getPosePointCount">
                        <trait>hidden</trait>
                        <desc>Returns the selected point count for pose estimation. See setPosePointCount for details.</desc>
                        <sample for="lua">posePointCount = Image.StructureFromMotion.getPosePointCount(sfm, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                        <return name="posePointCount" type="int" desc="The parameter value."/>
                    </function>
                    <function name="getPosePointDisplacement">
                        <trait>hidden</trait>
                        <desc>Returns the selected minimum point displacement for pose estimation. See setPosePointDisplacement for details.</desc>
                        <sample for="lua">posePointDisplacement = Image.StructureFromMotion.getPosePointDisplacement(sfm, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                        <return name="posePointDisplacement" type="float" desc="The parameter value."/>
                    </function>
                    <function name="getReprojectionDistance">
                        <trait>hidden</trait>
                        <desc>WARNING: THIS MIGHT SAY TOO MUCH ABOUT UNDERLYING METHOD.

Returns the selected maximum reprojection distance for 3D points. See setReprojectionDistance for details.</desc>
                        <sample for="lua">reprojectionDistance = Image.StructureFromMotion.getReprojectionDistance(sfm, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                        <return name="reprojectionDistance" type="float" desc="The parameter value."/>
                    </function>
                    <function name="getTriangulationDistance">
                        <trait>hidden</trait>
                        <desc>WARNING: THIS MIGHT SAY TOO MUCH ABOUT UNDERLYING METHOD.

Returns the selected maximum triangulation distance for 3D points. See setTriangulationDistance for details.</desc>
                        <sample for="lua">triangulationDistance = Image.StructureFromMotion.getTriangulationDistance(sfm, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index for which to retrieve the parameter. If unset the parameter that each new camera defaults to is returned."/>
                        <return name="triangulationDistance" type="float" desc="The parameter value."/>
                    </function>
                    <function name="getPoseMode">
                        <trait>hidden</trait>
                        <desc>Retrieve the used pose mode. The pose mode selects how camera poses are estimated. ROBUST or NORMAL corresponds to 2 or 4 degrees of freedom for camera placement.</desc>
                        <sample for="lua">mode = Image.StructureFromMotion.getPoseMode(sfm, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset the parameter that each new camera defaults to is returned."/>
                        <return name="mode" type="enum" ref="PoseMode" desc="The mode used."/>
                    </function>
                    <function name="getTriangulationMode">
                        <trait>hidden</trait>
                        <desc>Retrieve the used triangulation mode. Selects how 3D points are triangulated.</desc>
                        <sample for="lua">mode = Image.StructureFromMotion.getTriangulationMode(sfm, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset the parameter that each new camera defaults to is returned."/>
                        <return name="mode" type="enum" ref="TriangulationMode" desc="The mode used."/>
                    </function>
                    <function name="getMultiLayerMode">
                        <trait>hidden</trait>
                        <desc>Retrieve the used multilayer mode mode.</desc>
                        <sample for="lua">mode = Image.StructureFromMotion.getMultiLayerMode(sfm, cameraId)</sample>
                        <param name="sfm" type="handle" alias="Image.StructureFromMotion" desc="The sfm object to use."/>
                        <param name="cameraId" type="int" multiplicity="?" desc="The camera index to set the parameter for. If unset the parameter that each new camera defaults to is returned."/>
                        <return name="mode" type="enum" ref="Image.StructureFromMotion.MultiLayerMode" desc="The mode used."/>
                    </function>
                </serves>
            </crown>
            <crown name="MultiStereo">
                <trait>released</trait>
                <keywords>reconstruction, epipolar, disparity, triangulation, active stereo, structured light, laser</keywords>
                <links>Calibration</links>
                <desc>Object for creating 3D point clouds using one or more stereo pairs.</desc>
                <enum name="PointcloudIntensity" trait="released">
                    <item name="Constant" desc="The same point intensity values will be assigned to all point cloud points. The default value is 1.0.">CONSTANT</item>
                    <item name="PairID" desc="Different point intensity values will be assigned according to the stereo pair id used to reconstruct the point.">PAIR_ID</item>
                    <item name="Image" desc="The point intensity values will be assigned according to the intensity values of the stereo pair images (per pair, the firstImage - please see setImagePair).">IMAGE</item>
                </enum>
                <crown name="BlockMatching">
                    <trait>released</trait>
                    <keywords>sparse, reconstruction, semiglobal, epipolar, disparity, triangulation, active stereo, structured light, laser</keywords>
                    <links>RandomDot</links>
                    <desc>Block matching stereo object. The block matching multi stereo method is used to generate point clouds from one (regular stereo) or more stereo pairs. It can use a random dot laser that projects laser dots into the scene (recommended, but not necessary if the scene has enough structure). A dense 3D reconstruction can be obtained; all image pixels are tested for a possible match. It is only supported horizontal or vertical stereo, i.e. the cameras must be displaced mainly in the horizontal or vertical directions. A region of interest box must be specified and the objects to be reconstructed should be inside it (only 3D points inside the box will be generated).
Due to the dense nature of the method it is typically necessary to reduce the images resolution before using it. For stereo matching, a pixelwise cost (based on the pixels of the blocks) and a smoothness constraint are used. They are combined and expressed as an energy function that is optimized (semiglobal optimization) to find the best match. Both the pixelwise cost and the smoothness constrains require data from the blocks to compute their values, in addition the smoothness constraint also requires smoothness parameters to control its behavior. After the optimization the best matches are selected and triangulated to obtain the 3D points.</desc>
                    <serves>
                        <function name="create">
                            <trait>released</trait>
                            <desc>Creates a new instance of a multistereo block matching object.</desc>
                            <sample for="lua">local ms = Image.MultiStereo.BlockMatching.create()</sample>
                            <return name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The new instance."/>
                        </function>
                        <function name="addCameraPair">
                            <trait>released</trait>
                            <desc>Using two input camera models containing both intrinsic and extrinsic parameters this function calculates the look up tables for fast rectification and new rectified camera models. The output is a stereo pair id. To retrieve the newly calculated camera models the function getCameraModels can be used. Returns nil if the camera models are incompatible.</desc>
                            <sample for="lua">local pairID = Image.MultiStereo.BlockMatching.addCameraPair(ms, firstCameraModel, secondCameraModel)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="firstCameraModel" type="object" alias="Image.Calibration.CameraModel" desc="Input camera model object containing the camera calibration of the first camera."/>
                            <param name="secondCameraModel" type="object" alias="Image.Calibration.CameraModel" desc="Input camera model object containing the camera calibration of the second camera."/>
                            <return name="pairID" type="int" multiplicity="?" desc="The corresponding id for the stereo pair. Returns nil if the camera models are incompatible."/>
                        </function>
                        <function name="getCameraModels">
                            <trait>released</trait>
                            <desc>Retrieves the rectified camera models corresponding to the camera pair with id 'pairID'. Returns nil if the pairID is not valid.</desc>
                            <sample for="lua">local firstCameraModelRectified, secondCameraModelRectified = Image.MultiStereo.BlockMatching.getCameraModels(ms, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="pairID" type="int" desc="The id for the stereo pair."/>
                            <return name="firstCameraModelRectified" type="object" multiplicity="?" alias="Image.Calibration.CameraModel" desc="Rectified camera model object corresponding to the firstCameraModel (see addCameraPair)."/>
                            <return name="secondCameraModelRectified" type="object" multiplicity="?" alias="Image.Calibration.CameraModel" desc="Rectified camera model object corresponding to the secondCameraModel (see addCameraPair)."/>
                        </function>
                        <function name="setImagePair">
                            <trait>released</trait>
                            <desc>Updates the input images corresponding to the camera pair with id 'pairID'. It also stereo rectifies the input images using the look up tables computed using the function addCamerasPair. To retrieve the rectified images of a specific stereo pair the function getRectifiedImages can be used. Returns false if the stereo images are incompatible and if they are incompatible with the camera models.</desc>
                            <sample for="lua">local success = Image.MultiStereo.BlockMatching.setImagePair(ms, firstImage, secondImage, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="firstImage" type="object" alias="Image" desc="Input image corresponding to the first image of the stereo pair"/>
                            <param name="secondImage" type="object" alias="Image" desc="Input image corresponding to the second image of the stereo pair."/>
                            <param name="pairID" type="int" desc="The stereo pair id."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="getRectifiedImages">
                            <trait>released</trait>
                            <desc>Retrieves the rectified images corresponding to the camera pair with id 'pairID'. These are typically used for visual inspection that the rectification was correct. Returns nil if the pairID is not valid.</desc>
                            <sample for="lua">local firstImageRectified, secondImageRectified = Image.MultiStereo.BlockMatching.getRectifiedImages(ms, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="pairID" type="int" desc="The stereo pair id."/>
                            <return name="firstImageRectified" type="object" multiplicity="?" alias="Image" desc="Rectified image corresponding to the firstImage (see setImagePair)."/>
                            <return name="secondImageRectified" type="object" multiplicity="?" alias="Image" desc="Rectified image corresponding to the secondImage (see setImagePair)."/>
                        </function>
                        <function name="calculate">
                            <trait>released</trait>
                            <desc>Calculates the point cloud. The stereo camera models (addCameraPair), images (setImagePair) and roi (setRoiBox) must be set before using this function or else the method will return nil</desc>
                            <sample for="lua">local pointCloud = Image.MultiStereo.BlockMatching.calculate(ms, pointcloudIntensity, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="pointcloudIntensity" type="enum" multiplicity="?" ref="PointcloudIntensity" desc="How to attribute the intensity of the point cloud points."/>
                            <param name="pairID" type="int" multiplicity="?" desc="The stereo pair id. If omitted the point clouds of all stereo pairs are calculated."/>
                            <return name="pointCloud" type="object" multiplicity="?" alias="PointCloud" desc="The estimated point cloud."/>
                        </function>
                        <function name="setMultiStereoParameters">
                            <trait>hidden</trait>
                            <desc>Set the multistereo parameters. The input parameters control how the rectification is performed and the roi box to be used. The roi box will be updated and internally the minimum and maximum disparity values are recalculated. Please note that the rectification parameters will not change the current rectified images and corresponding camera models. Typically, if the rectification parameters need be set the change should be performed immediately after the Multistereo object is created and kept unchanged. When the functions addCameraPair and setImagePair are used the appropriate rectified images and rectified camera models will be calculated. Returns false if the roiBox is not set correctly (please refer to setRoiBox).</desc>
                            <sample for="lua">success = Image.MultiStereo.BlockMatching.setMultiStereoParameters(ms, rectificationAlpha, rectificationFlags, roiBox)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="rectificationAlpha" type="float" desc="Rectification parameter. -1 for auto, otherwise between 0 and 1 for setting the zoom level."/>
                            <param name="rectificationFlags" type="bool" desc="Rectification parameter. If false minimize the rectified images black borders, else equal principal points for the cameras will be used."/>
                            <param name="roiBox" type="object" alias="Shape3D" desc="The 3D roi box. The box is a 3D shape object. Please see the setRoiBox function for more details."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setRelativeTransform">
                            <trait>released</trait>
                            <desc>A relative transformation is concatenated to the camera poses of a stereo pair (2 cameras). In matrix format the transformation is: newCameraWorldMatrix = originalCameraWorldMatrix * cameraRelativeTransformMatrix. One example application that can benefit from using a relative transformation is when the cameras are rigidly attached to a robot. The robot can provide the relative transformation between the original and the current pose and this value can be used as the cameraRelativeTransform parameter without the need to recalibrate the stereo pair. Please note: for the changes to take effect this function must be called after the addCameraPair function or else the new pairs will have the default values. Returns false if the pairID is not valid or the transformation is not rigid.</desc>
                            <sample for="lua">local success = Image.MultiStereo.BlockMatching.setRelativeTransform(ms, camerasRelativeTransform, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="camerasRelativeTransform" type="object" alias="Transform" desc="The relative transformation applied to the camera pair. By default the relative transformation matrix is the identity matrix."/>
                            <param name="pairID" type="int" multiplicity="?" desc="The stereo pair id. If omitted the same relative transformation will be used by all stereo pairs."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="proposeRoiBox">
                            <trait>released</trait>
                            <desc>Returns a suggestion for a region of interest bounding box. The box will be axis aligned and placed in the world zero plane. The returned box might need tuning to get optimal results. Typically the stereo cameras should be placed at least 50 cm from the calibration pattern plane, looking towards the pattern. If the cameras are not oriented towards the same objects or the distance to the ground plane is less than 30 cm it will not be possible to propose a box in this case nil will be returned.</desc>
                            <sample for="lua">local roiBox = Image.MultiStereo.BlockMatching.proposeRoiBox(ms)</sample>
                            <param name="ms" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="pairID" type="int" multiplicity="?" desc="Optional pair id. If omitted pair 0 will be used."/>
                            <param name="height" type="float" multiplicity="?" desc="Optional box height. If omitted a box from the base plane to 30 cm from the lowest camera will be created."/>
                            <param name="padding" type="float" multiplicity="?" desc="Optional box padding. This will make the box slightly wider and longer, control height with the height parameter."/>
                            <return name="roiBox" type="object" multiplicity="?" alias="Shape3D" desc="The 3D roi box."/>
                        </function>
                        <function name="setRoiBox">
                            <trait>released</trait>
                            <desc>Set the region of interest (a 3D box shape). The reconstructed objects should be contained in the box. It is mandatory that the roi box is specified. The roi is used for two purposes, first: to compute the minimum and maximum disparities that will be used by the stereo matching methods and second: so that only 3D points inside the roi are computed. The roi specification has a great impact on the speed and accuracy of the 3D reconstruction, for example if the roi is larger than it should be the disparity range will increase and with it the stereo matching ambiguity (more possible matches). The roi is specified in the world coordinate system. It is not allowed that the camera positions are inside the roi, in this case the method will return false. It will also return false if the cameras are not oriented towards the roi, i.e. the cameras frustum do not overlap the roi. If the box transformation is the identity, it will be aligned with the world coordinate system axis (obtained using the calibration pattern) and centered at the origin. Typically, a translation in the z direction is applied in order for the roi box base plane to be slightly below the ground plane. The proposed approach to set the roi for a pallet is: first measure the width, length and height of the pallet, slightly larger values should be used to create the roi box object. Rotate the roi (e.g. a rotation around the z axis) to align its axes with the pallet axes and finally translate for the final adjustment. The last rotation and translation are specified using a transform object. Alternatively, you can use the proposeRoiBox method to obtain an initial roi box. In the case that two roi boxes are needed two Multistereo objects must be created. For the corresponding two point clouds to be aligned, the extrinsic calibration must be performed equally for both Multistereo instances, i.e. using the same calibration pattern with a fixed position.</desc>
                            <sample for="lua">success = Image.MultiStereo.BlockMatching.setRoiBox(ms, roiBox)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="roiBox" type="object" alias="Shape3D" desc="The 3D roi box. The box is a 3D shape object."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setP1">
                            <trait>hidden</trait>
                            <desc>Set the block matching P1 parameter. It is a parameter of the smoothness constraint that is a term of an energy function. In the energy function P1 is a constant penalty term that is added if the block pixels disparity is no more than one pixel. It works in combination with the P2 parameter that is also a constant penalty. It is required that P2 is greater or equal than P1. Curved surfaces might be better reconstructed if the value of P1 is low. Please note: for the changes to take effect this function must be called after the addCameraPair function or else the new pairs will have the default values. Returns false if the pairID is not valid or P1 is greater than P2.</desc>
                            <sample for="lua">local success = Image.MultiStereo.BlockMatching.setP1(ms, p1, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="p1" type="int" desc="The block matching P1 parameter. Typically it used the value P1 = 8 * blockSize * blockSize, with default block size of 5 pixels. It is required that P2 is greater or equal than P1."/>
                            <param name="pairID" type="int" multiplicity="?" desc="The stereo pair id. If omitted set the value for all pairs."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setP2">
                            <trait>hidden</trait>
                            <desc>Set the block matching P2 parameter. It is a parameter of the smoothness constraint that is a term of an energy function. In the energy function P2 is a constant penalty term that is added if the block pixels disparity is more than one pixel. It works in combination with the P1 parameter that is also a constant penalty. It is required that P2 is greater or equal than P1. Its function is to try to preserve discontinuities. Please note: for the changes to take effect this function must be called after the addCameraPair function or else the new pairs will have the default values. Returns false if the pairID is not valid or P1 is greater than P2.</desc>
                            <sample for="lua">success = Image.MultiStereo.BlockMatching.setP2(ms, p2, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="p2" type="int" desc="The block matching P2 parameter. Typically it used the value P2 = 32 * blockSize * blockSize, with default block size of 5 pixels. It is required that P2 is greater or equal than P1."/>
                            <param name="pairID" type="int" multiplicity="?" desc="The stereo pair id. If omitted set the value for all pairs."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setUniquenessRatio">
                            <trait>hidden</trait>
                            <desc>Set the block matching uniqueness ratio parameter. This parameter sets a margin in percentage by which the best (minimum) computed cost function value should be better than the second best for it to be considered a valid match. Please note: for the changes to take effect this function must be called after the addCameraPair function or else the new pairs will have the default values. Returns false if the pairID is not valid or the value is not in the correct range.</desc>
                            <sample for="lua">local success = Image.MultiStereo.BlockMatching.setUniquenessRatio(ms, uniquenessRatio, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="uniquenessRatio" type="int" desc="The block matching uniquenessRatio parameter. The default value is 15%. Typically a value between 5%-15% is used."/>
                            <param name="pairID" type="int" multiplicity="?" desc="The stereo pair id. If omitted set the value for all pairs."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setSpeckleWindowSize">
                            <trait>hidden</trait>
                            <desc>Set the block matching speckle window size parameter. Please note: for the changes to take effect this function must be called after the addCameraPair function or else the new pairs will have the default values. Returns false if the pairID is not valid or the value is not in the correct range.</desc>
                            <sample for="lua">success = Image.MultiStereo.BlockMatching.setSpeckleWindowSize(ms, speckleWindowSize, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="speckleWindowSize" type="int" desc="The block matching speckleWindowSize parameter. The default value is 100, typically a value between 50-200 is used. If set to 0 speckle filtering is disabled."/>
                            <param name="pairID" type="int" multiplicity="?" desc="The stereo pair id. If omitted set the value for all pairs."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setSpeckleRange">
                            <trait>hidden</trait>
                            <desc>Set the block matching speckle range parameter. Please note: for the changes to take effect this function must be called after the addCameraPair function or else the new pairs will have the default values. Returns false if the pairID is not valid or the value is not in the correct range.</desc>
                            <sample for="lua">local success = Image.MultiStereo.BlockMatching.setSpeckleRange(ms, speckleRange, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="speckleRange" type="int" desc="The block matching speckleRange parameter. The default value is 2, typically 1 or 2 is used."/>
                            <param name="pairID" type="int" multiplicity="?" desc="The stereo pair id. If omitted set the value for all pairs."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setBlockSize">
                            <trait>hidden</trait>
                            <desc>Set the block matching block size parameter. The matching cost function uses block regions instead of single pixels to find the best stereo matches. Please note: for the changes to take effect this function must be called after the addCameraPair function or else the new pairs will have the default values. Returns false if the pairID is not valid or the value is not in the correct range.</desc>
                            <sample for="lua">local success = Image.MultiStereo.BlockMatching.setBlockSize(ms, blockSize, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="blockSize" type="int" desc="The block matching blockSize parameter. The default value is 5 pixels. It must be a odd number larger or equal than one. Typically a value between 3-11 is used."/>
                            <param name="pairID" type="int" multiplicity="?" desc="The stereo pair id. If omitted set the value for all pairs."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setDispMaxDiff">
                            <trait>hidden</trait>
                            <desc>Set the block matching maximum allowed disparity difference parameter. The difference is measured in pixels between the disparity of the rectified images (rectified firstImage - secondImage). Please note: for the changes to take effect this function must be called after the addCameraPair function or else the new pairs will have the default values. Returns false if the pairID is not valid or the value is not in the correct range.</desc>
                            <sample for="lua">local success = Image.MultiStereo.BlockMatching.setDispMaxDiff(ms, dispMaxDiff, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="dispMaxDiff" type="int" desc="The block matching parameter maximum allowed disparity (in pixels). By default it is disabled (if a negative number is used). To enable it set it to a positive number. Typically, it is set to the maximum number of pixels that the disparity value is allowed to have."/>
                            <param name="pairID" type="int" multiplicity="?" desc="The stereo pair id. If omitted set the value for all pairs."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setPreFilterCap">
                            <trait>hidden</trait>
                            <desc>Set the block matching prefilter cap parameter. Please note: for the changes to take effect this function must be called after the addCameraPair function or else the new pairs will have the default values. Returns false if the pairID is not valid or the value is not in the correct range.</desc>
                            <sample for="lua">local success = Image.MultiStereo.BlockMatching.setPreFilterCap(ms, preFilterCap, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="preFilterCap" type="int" desc="The block matching preFilterCap parameter."/>
                            <param name="pairID" type="int" multiplicity="?" desc="The stereo pair id. If omitted set the value for all pairs."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="getMultiStereoParameters">
                            <trait>hidden</trait>
                            <desc>Get the multi stereo parameters. Refer to the corresponding set function for more details.</desc>
                            <sample for="lua">local rectificationAlpha, rectificationFlags, roiBox = Image.MultiStereo.BlockMatching.getMultiStereoParameters(ms)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <return name="rectificationAlpha" type="float" desc="Rectification parameter."/>
                            <return name="rectificationFlags" type="bool" desc="Rectification parameter."/>
                            <return name="roiBox" type="object" alias="Shape3D" desc="The roi 3D box. The box is a 3D shape object."/>
                        </function>
                        <function name="getRoiBox">
                            <trait>hidden</trait>
                            <desc>Get the region of interest (a 3D box shape). Refer to the corresponding set function for more details.</desc>
                            <sample for="lua">local roiBox = Image.MultiStereo.BlockMatching.getRoiBox(ms)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <return name="roiBox" type="object" alias="Shape3D" desc="The roi 3D box. The box is a 3D shape object."/>
                        </function>
                        <function name="getRelativeTransform">
                            <trait>released</trait>
                            <desc>Get the relative transformation of the stereo pair cameras. Refer to the corresponding set function for more details. Returns nil if the pairID is not valid.</desc>
                            <sample for="lua">local camerasRelativeTransform = Image.MultiStereo.BlockMatching.getRelativeTransform(ms, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="pairID" type="int" desc="The stereo pair id."/>
                            <return name="camerasRelativeTransform" type="object" multiplicity="?" alias="Transform" desc="The relative transformation applied to the camera pair. By default the relative transformation matrix is the identity matrix."/>
                        </function>
                        <function name="getP1">
                            <trait>hidden</trait>
                            <desc>Get the block matching P1 parameter. Refer to the corresponding set function for more details. Returns nil if the pairID is not valid.</desc>
                            <sample for="lua">local p1 = Image.MultiStereo.BlockMatching.getP1(ms, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="pairID" type="int" desc="The stereo pair id."/>
                            <return name="p1" type="int" multiplicity="?" desc="The block matching P1 parameter."/>
                        </function>
                        <function name="getP2">
                            <trait>hidden</trait>
                            <desc>Get the block matching P2 parameter. Refer to the corresponding set function for more details. Returns nil if the pairID is not valid.</desc>
                            <sample for="lua">local p2 = Image.MultiStereo.BlockMatching.getP2(ms, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="pairID" type="int" desc="The stereo pair id."/>
                            <return name="p2" type="int" multiplicity="?" desc="The block matching P2 parameter."/>
                        </function>
                        <function name="getUniquenessRatio">
                            <trait>hidden</trait>
                            <desc>Get the block matching uniqueness ratio parameter. Refer to the corresponding set function for more details. Returns nil if the pairID is not valid.</desc>
                            <sample for="lua">local uniquenessRatio = Image.MultiStereo.BlockMatching.getUniquenessRatio(ms, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="pairID" type="int" desc="The stereo pair id."/>
                            <return name="uniquenessRatio" type="int" multiplicity="?" desc="The block matching uniqueness ratio parameter."/>
                        </function>
                        <function name="getSpeckleWindowSize">
                            <trait>hidden</trait>
                            <desc>Get the block matching speckle window size parameter. Returns nil if the pairID is not valid.</desc>
                            <sample for="lua">local speckleWindowSize = Image.MultiStereo.BlockMatching.getSpeckleWindowSize(ms, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="pairID" type="int" desc="The stereo pair id."/>
                            <return name="speckleWindowSize" type="int" multiplicity="?" desc="The block matching speckle window size parameter."/>
                        </function>
                        <function name="getSpeckleRange">
                            <trait>hidden</trait>
                            <desc>Get the block matching speckle range parameter. Returns nil if the pairID is not valid.</desc>
                            <sample for="lua">local speckleRange = Image.MultiStereo.BlockMatching.getSpeckleRange(ms, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="pairID" type="int" desc="The stereo pair id."/>
                            <return name="speckleRange" type="int" multiplicity="?" desc="The block matching speckle range parameter."/>
                        </function>
                        <function name="getBlockSize">
                            <trait>hidden</trait>
                            <desc>Get the block matching block size parameter. Refer to the corresponding set function for more details. Returns nil if the pairID is not valid.</desc>
                            <sample for="lua">local blockSize = Image.MultiStereo.BlockMatching.getBlockSize(ms, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="pairID" type="int" desc="The stereo pair id."/>
                            <return name="blockSize" type="int" multiplicity="?" desc="The block matching block size parameter."/>
                        </function>
                        <function name="getDispMaxDiff">
                            <trait>hidden</trait>
                            <desc>Get the block matching parameter maximum allowed disparity (in pixels). Refer to the corresponding set function for more details. Returns nil if the pairID is not valid.</desc>
                            <sample for="lua">local dispMaxDiff = Image.MultiStereo.BlockMatching.getDispMaxDiff(ms, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="pairID" type="int" desc="The stereo pair id."/>
                            <return name="dispMaxDiff" type="int" multiplicity="?" desc="The block matching parameter maximum allowed disparity (in pixels)."/>
                        </function>
                        <function name="getPreFilterCap">
                            <trait>hidden</trait>
                            <desc>Get the block matching pre-filter cap parameter. Refer to the corresponding set function for more details. Returns nil if the pairID is not valid.</desc>
                            <sample for="lua">local preFilterCap = Image.MultiStereo.BlockMatching.getPreFilterCap(ms, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.BlockMatching" desc="The MultiStereo instance to use."/>
                            <param name="pairID" type="int" desc="The stereo pair id."/>
                            <return name="preFilterCap" type="int" multiplicity="?" desc="The block matching pre-filter cap parameter."/>
                        </function>
                    </serves>
                </crown>
                <crown name="RandomDot">
                    <trait>released</trait>
                    <keywords>sparse, reconstruction, epipolar, disparity, triangulation, active stereo, structured light, laser</keywords>
                    <links>BlockMatching</links>
                    <desc>Random dot stereo object. The random dot multi stereo method is used to generate point clouds from one (regular stereo) or more stereo pairs. It uses a random dot laser that projects laser dots into the scene. Only the 3D points at the centers of the laser dots are reconstructed. It is only supported horizontal or vertical stereo, i.e. the cameras must be displaced mainly in the horizontal or vertical directions. A region of interest box must be specified and the objects to be reconstructed should be inside it (only 3D points inside the box will be generated). For stereo matching, epipolar constraints are used i.e. for horizontal stereo corresponding points in the rectified images must have the same rows and for vertical stereo the same columns.
If a poor calibration was performed, the epipolar tolerance (the pixel distance from the epipolar line) needs to be increased in order to obtain a complete 3D scene reconstruction. The tolerance increase will impact the quality of the reconstruction (the matching ambiguity is higher) and how fast the results can be computed (more possible matches to be tested). The centers of the dots are calculated in the rectified images, resulting in a subpixel vector of 2D points. This operation might have some localization error, for this reason the effective epipolar tolerance is the specified epipolar tolerance plus the laser dot radius. For the possible matches that pass the initial epipolar constraint another geometrical constraint is applied and an initial matching score is calculated. This constraint relies on the neighboring points (10 closest neighbors) to the point currently being tested. The idea is that the angles and distances between a possible match point in the first image and its neighbors is similar to its counterpart in the second image. The matching score will be higher if more angles and distances are similar between the two images. Next, a regularization step is applied to improve the matching score and finally the best matches are selected and triangulated to obtain the 3D points.</desc>
                    <serves>
                        <function name="create">
                            <trait>released</trait>
                            <desc>Creates a new instance of a multistereo randomDot object.</desc>
                            <sample for="lua">local ms = Image.MultiStereo.RandomDot.create()</sample>
                            <return name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The new instance."/>
                        </function>
                        <function name="addCameraPair">
                            <trait>released</trait>
                            <desc>Using two input camera models containing both intrinsic and extrinsic parameters this function calculates the look up tables for fast rectification and new rectified camera models. The output is a stereo pair id. To retrieve the newly calculated camera models the function getCameraModels can be used. Returns nil if the camera models are incompatible.</desc>
                            <sample for="lua">local pairID = Image.MultiStereo.RandomDot.addCameraPair(ms, firstCameraModel, secondCameraModel)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="firstCameraModel" type="object" alias="Image.Calibration.CameraModel" desc="Input camera model object containing the camera calibration of the first camera."/>
                            <param name="secondCameraModel" type="object" alias="Image.Calibration.CameraModel" desc="Input camera model object containing the camera calibration of the second camera."/>
                            <return name="pairID" type="int" multiplicity="?" desc="The corresponding id for the stereo pair."/>
                        </function>
                        <function name="getCameraModels">
                            <trait>released</trait>
                            <desc>Retrieves the rectified camera models corresponding to the camera pair with id 'pairID'. Returns nil if the pairID is not valid.</desc>
                            <sample for="lua">local firstCameraModelRectified, secondCameraModelRectified = Image.MultiStereo.RandomDot.getCameraModels(ms, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="pairID" type="int" desc="The stereo pair id."/>
                            <return name="firstCameraModelRectified" type="object" multiplicity="?" alias="Image.Calibration.CameraModel" desc="Rectified camera model object corresponding to the firstCameraModel (see addCameraPair)."/>
                            <return name="secondCameraModelRectified" type="object" multiplicity="?" alias="Image.Calibration.CameraModel" desc="Rectified camera model object corresponding to the secondCameraModelRectified (see addCameraPair)."/>
                        </function>
                        <function name="setImagePair">
                            <trait>released</trait>
                            <desc>Updates the input images corresponding to the camera pair with id 'pairID'. It also stereo rectifies the input images using the look up tables computed using the function addCamerasPair. To retrieve the rectified images of a specific stereo pair the function getRectifiedImages can be used. Returns false if the stereo images are incompatible and if they are incompatible with the camera models.</desc>
                            <sample for="lua">local success = Image.MultiStereo.RandomDot.setImagePair(ms, firstImage, secondImage, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="firstImage" type="object" alias="Image" desc="Input image corresponding to the first image of the stereo pair."/>
                            <param name="secondImage" type="object" alias="Image" desc="Input image corresponding to the second image of the stereo pair."/>
                            <param name="pairID" type="int" desc="The stereo pair id."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="getRectifiedImages">
                            <trait>released</trait>
                            <desc>Retrieves the rectified images corresponding to the camera pair with id 'pairID'. These are typically used for visual inspection that the rectification was correct. Returns nil if the pairID is not valid.</desc>
                            <sample for="lua">local firstImageRectified, secondImageRectified = Image.MultiStereo.RandomDot.getRectifiedImages(ms, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="pairID" type="int" desc="The stereo pair id."/>
                            <return name="firstImageRectified" type="object" multiplicity="?" alias="Image" desc="Rectified image corresponding to the firstImage (see setImagePair)."/>
                            <return name="secondImageRectified" type="object" multiplicity="?" alias="Image" desc="Rectified image corresponding to the secondImage (see setImagePair)."/>
                        </function>
                        <function name="calculate">
                            <trait>released</trait>
                            <desc>Calculates the point cloud. The stereo camera models (addCameraPair), images (setImagePair) and roi (setRoiBox) must be set before using this function or else the method will return nil.</desc>
                            <sample for="lua">local pointCloud = Image.MultiStereo.RandomDot.calculate(ms, pointcloudIntensity, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="pointcloudIntensity" type="enum" multiplicity="?" ref="PointcloudIntensity" desc="How to attribute the intensity of the point cloud points."/>
                            <param name="pairID" type="int" multiplicity="?" desc="The stereo pair id. If omitted the point clouds of all stereo pairs are calculated."/>
                            <return name="pointCloud" type="object" multiplicity="?" alias="PointCloud" desc="The estimated point cloud."/>
                        </function>
                        <function name="setMultiStereoParameters">
                            <trait>hidden</trait>
                            <desc>Set the multistereo parameters. The input parameters control how the rectification is performed and the roi box to be used. The roi box will be updated and internally the minimum and maximum disparity values are recalculated. Please note that the rectification parameters will not change the current rectified images and corresponding camera models. Typically, if the rectification parameters need be set the change should be performed immediately after the Multistereo object is created and kept unchanged. When the functions addCameraPair and setImagePair are used the appropriate rectified images and rectified camera models will be calculated. Returns false if the roiBox is not set correctly (please refer to setRoiBox).</desc>
                            <sample for="lua">local success = Image.MultiStereo.RandomDot.setMultiStereoParameters(ms, rectificationAlpha, rectificationFlags, roiBox)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="rectificationAlpha" type="float" desc="Rectification parameter. -1 for auto, otherwise between 0 and 1 for setting the zoom level."/>
                            <param name="rectificationFlags" type="bool" desc="Rectification parameter. If false minimize the rectified images black borders, else equal principal points for the cameras will be used."/>
                            <param name="roiBox" type="object" alias="Shape3D" desc="The 3D roi box. The box is a 3D shape object. Please see the setRoiBox function for more details."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="proposeRoiBox">
                            <trait>released</trait>
                            <desc>Returns a suggestion for a region of interest bounding box. The box will be axis aligned and placed in the world zero plane. The returned box might need tuning to get optimal results. Typically the stereo cameras should be placed at least 50 cm from the calibration pattern plane, looking towards the pattern. If the cameras are not oriented towards the same objects or the distance to the ground plane is less than 30 cm it will not be possible to propose a box in this case nil will be returned.</desc>
                            <sample for="lua">local roiBox = Image.MultiStereo.RandomDot.proposeRoiBox(ms)</sample>
                            <param name="ms" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="pairId" type="int" multiplicity="?" desc="Optional pair id. If omitted pair 0 will be used."/>
                            <param name="height" type="float" multiplicity="?" desc="Optional box height. If omitted a box from the base plane to 30 cm from the lowest camera will be created."/>
                            <param name="padding" type="float" multiplicity="?" desc="Optional box padding. This will make the box slightly wider and longer, control height with the height parameter."/>
                            <return name="roiBox" type="object" multiplicity="?" alias="Shape3D" desc="The 3D roi box."/>
                        </function>
                        <function name="setRoiBox">
                            <trait>released</trait>
                            <desc>Set the region of interest (a 3D box shape). The reconstructed objects should be contained in the box. It is mandatory that the roi box is specified. The roi is used for two purposes, first: to compute the minimum and maximum disparities that will be used by the stereo matching methods and second: so that only 3D points inside the roi are computed. The roi specification has a great impact on the speed and accuracy of the 3D reconstruction, for example if the roi is larger than it should be the disparity range will increase and with it the stereo matching ambiguity (more possible matches). The roi is specified in the world coordinate system. It is not allowed that the camera positions are inside the roi, in this case the method will return false. It will also return false if the cameras are not oriented towards the roi, i.e. the cameras frustum do not overlap the roi. If the box transformation is the identity, it will be aligned with the world coordinate system axis (obtained using the calibration pattern) and centered at the origin. Typically, a translation in the z direction is applied in order for the roi box base plane to be slightly below the ground plane. The proposed approach to set the roi for a pallet is: first measure the width, length and height of the pallet, slightly larger values should be used to create the roi box object. Rotate the roi (e.g. a rotation around the z axis) to align its axes with the pallet axes and finally translate for the final adjustment. The last rotation and translation are specified using a transform object. Alternatively, you can use the proposeRoiBox method to obtain an initial roi box. In the case that two roi boxes are needed two Multistereo objects must be created. For the corresponding two point clouds to be aligned, the extrinsic calibration must be performed equally for both Multistereo instances, i.e. using the same calibration pattern with a fixed position.</desc>
                            <sample for="lua">local success = Image.MultiStereo.RandomDot.setRoiBox(ms, roiBox)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="roiBox" type="object" alias="Shape3D" desc="The 3D roi box. The box is a 3D shape object."/>
                            <return name="success" type="bool" desc="Returns true if successful. The box is a 3D shape object."/>
                        </function>
                        <function name="setRelativeTransform">
                            <trait>released</trait>
                            <desc>A relative transformation is concatenated to the camera poses of a stereo pair (both cameras). In matrix format the transformation is: newCameraWorldMatrix = originalCameraWorldMatrix * cameraRelativeTransformMatrix. One example application that can benefit from using a relative transformation is when the cameras are rigidly attached to a robot. The robot can provide the relative transformation between the original and the current pose and this value can be used as the cameraRelativeTransform parameter without the need to recalibrate the stereo pair. Please note: for the changes to take effect this function must be called after the addCameraPair function or else the new pairs will have the default values. Returns false if the pairID is not valid or the transformation is not rigid.</desc>
                            <sample for="lua"> success = Image.MultiStereo.RandomDot.setRelativeTransform(ms, camerasRelativeTransform, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="camerasRelativeTransform" type="object" alias="Transform" desc="The relative transformation applied to the camera pair. By default the relative transformation matrix is the identity matrix."/>
                            <param name="pairID" type="int" multiplicity="?" desc="The stereo pair id. If omitted the same relative transformation will be used by all stereo pairs."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setPatternProperties">
                            <trait>released</trait>
                            <desc>Set the random dot laser pattern properties. The pattern is composed of approximately circular laser dots that have a specific radius and are placed randomly in relation to each other with an approximate similar distance between them. With this function it is possible to specify these properties, i.e. the dots radius and distance. Their values are in pixels and can be obtained by examining the rectified images. Typically, some tuning is necessary to optimize the result. Please note: for the changes to take effect this function must be called after the addCameraPair function or else the new pairs will have the default values. Returns false if the pairID is not valid or the values are not in the correct range.</desc>
                            <sample for="lua">local success = Image.MultiStereo.RandomDot.setPatternProperties(ms, dotRadius, dotDistance, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="dotRadius" type="int" desc="The laser dots radius, in pixels. The default value is 5 pixels."/>
                            <param name="dotDistance" type="int" desc="The distance between the laser dots, in pixels. The default value is 10 pixels."/>
                            <param name="pairID" type="int" multiplicity="?" desc="The stereo pair id. If omitted set the values in all pairs."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setEpipolarlineTolerance">
                            <trait>released</trait>
                            <desc>Set the epipolar line tolerance. The stereo matching algorithm uses rectified images, computed using epipolar geometry. These geometrical constraints guarantee that a possible match of a point in the first image corresponds to a line in the second image. Using rectified images with horizontal stereo the rows of the points to be matched should be the same and in vertical stereo the columns should be the same. If a poor calibration was performed, the epipolar tolerance (the pixel distance from the epipolar line) needs to be increased in order to obtain a complete 3D scene reconstruction. The tolerance increase will impact the quality of the reconstruction (the matching ambiguity is higher) and how fast the results can be computed (more possible matches to be tested). Please note: for the changes to take effect this function must be called after the addCameraPair function or else the new pairs will have the default values. Returns false if the pairID is not valid or the value is not in the correct range.</desc>
                            <sample for="lua">success = Image.MultiStereo.RandomDot.setEpipolarlineTolerance(ms, epipolarlineTolerance, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="epipolarlineTolerance" type="int" desc="The epipolar line tolerance, in pixels. The default value is 5 pixels."/>
                            <param name="pairID" type="int" multiplicity="?" desc="The stereo pair id. If omitted set the value for all pairs."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setRegularizationNeighborhood3D">
                            <trait>hidden</trait>
                            <desc>Set the regularization 3D neighborhood parameters. The regularization tries to improve iteratively the results of the stereo matches. For each point tested in the first image the best 20 possible matches of the second image are stored in a vector. For each point of the first image the 10 closest neighbors are also computed. The idea behind the regularization is given a point in the first image if its neighbors have possible matches with similar values than the elements of the current match vector then they should increase their score. In this case the reconstructed 3D positions are compared, if the distances (per coordinate) between a neighbor 3D position and the current possible match position are less or equal than the 3D neighborhoods (neighborhood, neighborhoodY, neighborhoodZ) values than the score should increase. After the regularization for each point the match with highest score in the possible match vector is selected. To note that the neighborhood values should be at least twice as large as the physical maximal distances between the laser dots. Please note: for the changes to take effect this function must be called after the addCameraPair function or else the new pairs will have the default values. Returns false if the pairID is not valid or the values are not in the correct range.</desc>
                            <sample for="lua">local success = Image.MultiStereo.RandomDot.setRegularizationNeighborhood3D(ms, neighborhoodX, neighborhoodY, neighborhoodZ, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="neighborhoodX" type="float" desc="The 3D X coordinate neighborhood used by the regularization, in millimeters. The default value is 50 millimeters."/>
                            <param name="neighborhoodY" type="float" desc="The 3D Y coordinate neighborhood used by the regularization, in millimeters. The default value is 50 millimeters."/>
                            <param name="neighborhoodZ" type="float" desc="The 3D Z coordinate neighborhood used by the regularization, in millimeters. The default value is 50 millimeters."/>
                            <param name="pairID" type="int" multiplicity="?" desc="The stereo pair id. If omitted set the value for all pairs."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setRegularizationNeighborhoodDisparity">
                            <trait>hidden</trait>
                            <desc>Set the regularization disparity neighborhood parameter. The regularization tries to improve iteratively the results of the stereo matches. For each point tested in the first image the best 20 possible matches of the second image are stored in a vector. For each point of the first image the 10 closest neighbors are also computed. The idea behind the regularization is given a point in the first image if its neighbors have possible matches with similar values than the elements of the current match vector then they should increase their score. In this case the disparities are compared, if the disparity absolute difference between a neighbor and the current possible match is less or equal than the neighborhood disparity value than the score should increase. After the regularization for each point the match with highest score in the possible match vector is selected. Please note: for the changes to take effect this function must be called after the addCameraPair function or else the new pairs will have the default values. Returns false if the pairID is not valid or the value is not in the correct range.</desc>
                            <sample for="lua">local success = Image.MultiStereo.RandomDot.setRegularizationNeighborhoodDisparity(ms, neighborhoodDisparity, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="neighborhoodDisparity" type="int" desc="The maximum disparity difference allowed in the neighborhood used by the regularization, in pixels. The default value is 20 pixels."/>
                            <param name="pairID" type="int" multiplicity="?" desc="The stereo pair id. If omitted set the value for all pairs."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setRegularizationIterations">
                            <trait>hidden</trait>
                            <desc>Set the regularization number of iterations. Please note: for the changes to take effect this function must be called after the addCameraPair function or else the new pairs will have the default values. Returns false if the pairID is not valid or the value is not in the correct range.</desc>
                            <sample for="lua">local success = Image.MultiStereo.RandomDot.setRegularizationIterations(ms, iterationsCount, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="iterationsCount" type="int" desc="The regularization number of iterations. By default 3 iterations are used."/>
                            <param name="pairID" type="int" multiplicity="?" desc="The stereo pair id. If omitted set the value for all pairs."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setPercentileThreshold">
                            <trait>hidden</trait>
                            <desc>Set the percentile threshold. After the regularization every match has a score, used to sort the matches. The percentage threshold (100% no matches are excluded) enables the selection of the best matches. Please note: for the changes to take effect this function must be called after the addCameraPair function or else the new pairs will have the default values. Please note: for the changes to take effect this function must be called after the addCameraPair function or else the new pairs will have the default values. Returns false if the pairID is not valid or the value is not in the correct range.</desc>
                            <sample for="lua">local success = Image.MultiStereo.RandomDot.setPercentileThreshold(ms, threshold, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="threshold" type="int" desc="The percentile threshold. The default value is 100% (no matches excluded)."/>
                            <param name="pairID" type="int" multiplicity="?" desc="The stereo pair id. If omitted set the value for all pairs."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setMatchingToleranceAngle">
                            <trait>hidden</trait>
                            <desc>Set the matching angle tolerance. A matching angle is specified by the angle between two vectors. The first vector is defined by the point where the match is being tested (PM) and by the epipolar line direction. The second vector is defined by PM and one of its neighbor points. This procedure is performed to both images and all the points to be matched. Per point a maximum of 10 neighbors (the closest neighbors) is used meaning that 10 angles can be obtained. If a possible match is found the angle sets obtained in the first image must have a reasonable alignment with the angles of second image, controlled by the tolerance (|firstAngle - secondAngle| &lt; tolerance). The number of corresponding angles found (maximum 10) is used in the calculation of the initial matching score. Please note: for the changes to take effect this function must be called after the addCameraPair function or else the new pairs will have the default values. Please note: for the changes to take effect this function must be called after the addCameraPair function or else the new pairs will have the default values. Returns false if the pairID is not valid or the value is not in the correct range.</desc>
                            <sample for="lua">local success = Image.MultiStereo.RandomDot.setMatchingToleranceAngle(ms, tolerance, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="threshold" type="float" desc="The matching angle tolerance. The default value is 0.3 radians."/>
                            <param name="pairID" type="int" multiplicity="?" desc="The stereo pair id. If omitted set the value for all pairs."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="setMatchingToleranceDistanceRatio">
                            <trait>hidden</trait>
                            <desc>Set the matching distance ratio tolerance. The matching distance is calculated between the point where the match is being tested and one of its neighbors. Per point a maximum of 10 neighbors (the closest neighbors) is used meaning that 10 distances can be obtained. This procedure is performed to both images and all the points to be matched. If a possible match is found the distances sets obtained in the first image must have similar distances to the distances of the second image, controlled by the tolerance (maxDistance = max(firstDistance1, secondDistance); minDistance = min(firstDistance, secondDistance); minDistance/maxDistance &gt;= tolerance). The number of corresponding distances found (maximum 10) is used in the calculation of the initial matching score. Please note: for the changes to take effect this function must be called after the addCameraPair function or else the new pairs will have the default values. Please note: for the changes to take effect this function must be called after the addCameraPair function or else the new pairs will have the default values. Returns false if the pairID is not valid or the value is not in the correct range.</desc>
                            <sample for="lua">local success = Image.MultiStereo.RandomDot.setMatchingToleranceDistanceRatio(ms, tolerance, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="threshold" type="float" desc="The matching distance ratio tolerance. The default value is 0.8. It must be larger than zero and smaller or equal than 1.0."/>
                            <param name="pairID" type="int" multiplicity="?" desc="The stereo pair id. If omitted set the value for all pairs."/>
                            <return name="success" type="bool" desc="Returns true if successful."/>
                        </function>
                        <function name="getMultiStereoParameters">
                            <trait>hidden</trait>
                            <desc>Get the multi stereo parameters. Refer to the corresponding set function for more details.</desc>
                            <sample for="lua">local rectificationAlpha, rectificationFlags, roiBox = Image.MultiStereo.RandomDot.getMultiStereoParameters(ms)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <return name="rectificationAlpha" type="float" desc="Rectification parameter."/>
                            <return name="rectificationFlags" type="bool" desc="Rectification parameter."/>
                            <return name="roiBox" type="object" alias="Shape3D" desc="The roi 3D box. The box is a 3D shape object."/>
                        </function>
                        <function name="getRoiBox">
                            <trait>hidden</trait>
                            <desc>Get the region of interest (a 3D box shape). Refer to the corresponding set function for more details.</desc>
                            <sample for="lua">local roiBox = Image.MultiStereo.RandomDot.getRoiBox(ms)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <return name="roiBox" type="object" alias="Shape3D" desc="The roi 3D box. The box is a 3D shape object."/>
                        </function>
                        <function name="getRelativeTransform">
                            <trait>released</trait>
                            <desc>Get the relative transformation of the stereo pair cameras. Refer to the corresponding set function for more details. Returns nil if the pairID is not valid.</desc>
                            <sample for="lua">local camerasRelativeTransform = Image.MultiStereo.RandomDot.getRelativeTransform(ms, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="pairID" type="int" desc="The stereo pair id."/>
                            <return name="camerasRelativeTransform" type="object" multiplicity="?" alias="Transform" desc="The relative transformation applied to the camera pair. By default the relative transformation matrix is the identity matrix."/>
                        </function>
                        <function name="getPatternProperties">
                            <trait>released</trait>
                            <desc>Get the random dot laser pattern properties. Refer to the corresponding set function for more details. Returns nil if the pairID is not valid.</desc>
                            <sample for="lua">local dotRadius, dotDistance = Image.MultiStereo.RandomDot.getPatternProperties(ms, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="pairID" type="int" desc="The stereo pair id."/>
                            <return name="dotRadius" type="int" multiplicity="?" desc="The laser dots radius, in pixels."/>
                            <return name="dotDistance" type="int" multiplicity="?" desc="The distance between the laser dots, in pixels."/>
                        </function>
                        <function name="getEpipolarlineTolerance">
                            <trait>released</trait>
                            <desc>Get the epipolar line tolerance. Refer to the corresponding set function for more details. Returns nil if the pairID is not valid.</desc>
                            <sample for="lua">local epipolarlineTolerance = Image.MultiStereo.RandomDot.getEpipolarlineTolerance(ms, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="pairID" type="int" desc="The stereo pair id."/>
                            <return name="epipolarlineTolerance" type="int" multiplicity="?" desc="The epipolar line tolerance, in pixels."/>
                        </function>
                        <function name="getRegularizationNeighborhood3D">
                            <trait>hidden</trait>
                            <desc>Get the regularization 3D neighborhood parameters. Refer to the corresponding set function for more details. Returns nil if the pairID is not valid.</desc>
                            <sample for="lua">local neighborhoodX, neighborhoodY, neighborhoodZ = Image.MultiStereo.RandomDot.getRegularizationNeighborhood3D(ms, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="pairID" type="int" desc="The stereo pair id."/>
                            <return name="neighborhoodX" type="float" multiplicity="?" desc="The 3D X coordinate neighborhood used by the regularization, in millimeters."/>
                            <return name="neighborhoodY" type="float" multiplicity="?" desc="The 3D Y coordinate neighborhood used by the regularization, in millimeters."/>
                            <return name="neighborhoodZ" type="float" multiplicity="?" desc="The 3D Z coordinate neighborhood used by the regularization, in millimeters."/>
                        </function>
                        <function name="getRegularizationNeighborhoodDisparity">
                            <trait>hidden</trait>
                            <desc>Get the regularization disparity neighborhood parameter. Refer to the corresponding set function for more details. Returns nil if the pairID is not valid.</desc>
                            <sample for="lua">local neighborhoodDisparity = Image.MultiStereo.RandomDot.getRegularizationNeighborhoodDisparity(ms, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="pairID" type="int" desc="The stereo pair id."/>
                            <return name="neighborhoodDisparity" type="int" multiplicity="?" desc="The maximum disparity difference allowed in the neighborhood used by the regularization, in pixels."/>
                        </function>
                        <function name="getRegularizationIterations">
                            <trait>hidden</trait>
                            <desc>Get the regularization number of iterations. Refer to the corresponding set function for more details. Returns nil if the pairID is not valid.</desc>
                            <sample for="lua">local iterationsCount = Image.MultiStereo.RandomDot.getRegularizationIterations(ms, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="pairID" type="int" desc="The stereo pair id."/>
                            <return name="iterationsCount" type="int" multiplicity="?" desc="The regularization number of iterations."/>
                        </function>
                        <function name="getPercentileThreshold">
                            <trait>hidden</trait>
                            <desc>Get the percentile threshold. Refer to the corresponding set function for more details. Returns nil if the pairID is not valid.</desc>
                            <sample for="lua">local threshold = Image.MultiStereo.RandomDot.getPercentileThreshold(ms, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="pairID" type="int" desc="The stereo pair id."/>
                            <return name="threshold" type="int" multiplicity="?" desc="The percentile threshold."/>
                        </function>
                        <function name="getMatchingToleranceAngle">
                            <trait>hidden</trait>
                            <desc>Get the matching angle tolerance. Refer to the corresponding set function for more details. Returns nil if the pairID is not valid.</desc>
                            <sample for="lua">local tolerance = Image.MultiStereo.RandomDot.getMatchingToleranceAngle(ms, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="pairID" type="int" desc="The stereo pair id."/>
                            <return name="tolerance" type="float" multiplicity="?" desc="The matching angle tolerance."/>
                        </function>
                        <function name="getMatchingToleranceDistanceRatio">
                            <trait>hidden</trait>
                            <desc>Get the matching distance ratio tolerance. Refer to the corresponding set function for more details. Returns nil if the pairID is not valid.</desc>
                            <sample for="lua">local tolerance = Image.MultiStereo.RandomDot.getMatchingToleranceDistanceRatio(ms, pairID)</sample>
                            <param name="handle" type="handle" alias="Image.MultiStereo.RandomDot" desc="The MultiStereo instance to use."/>
                            <param name="pairID" type="int" desc="The stereo pair id."/>
                            <return name="tolerance" type="float" multiplicity="?" desc="The matching distance ratio tolerance."/>
                        </function>
                    </serves>
                </crown>
            </crown>
            <crown name="SheetOfLight">
                <trait>released</trait>
                <desc>Sheet of light is a technique for reconstructing 3D from a 2D image sensor combined with a planar sheet of light. Typically this sheet of light is formed by a laser projector that projects a line, but it can also be other types of light sources such as LED line lights. Devices that uses this technology include the SICK Ranger, Ruler and Trispector series of devices.
Usually the data these devices produce is represented in the form of height maps. This crown contains calibration and alignment support for these devices and the output data they produce.</desc>
                <enum name="CoordinateSystem" trait="released">
                    <item name="pixel" desc="Raw sensor coordinates.">PIXEL</item>
                    <item name="calibrated" desc="Calibrated XZ coordinates.">CALIBRATED</item>
                    <item name="aligned" desc="Aligned XYZ coordinates.">ALIGNED</item>
                </enum>
                <enum name="PolynomialDegree" trait="hidden">
                    <item name="off" desc="Disable polynomial.">OFF</item>
                    <item name="second degree" desc="Use a second degree polynomial.">SECOND_DEGREE</item>
                    <item name="third degree" desc="Use a third degree polynomial.">THIRD_DEGREE</item>
                </enum>
                <crown name="Model">
                    <trait>released</trait>
                    <links>Image.SheetOfLight.Calibration, Image.SheetOfLight.Alignment, Image.SheetOfLight.Runtime</links>
                    <desc>The model object contains all the calculated calibration and alignment parameters needed to correct for lens distortion, transform to world units, remove skewing and transform to a reference coordinate system. It can also be saved, loaded, serialized or deserialized using the standard Object functions.</desc>
                    <enum name="SkewMode" trait="released">
                        <item name="XZ in light plane" desc="The XZ values were in the sheet of light plane during the calibration.">XZ_IN_LIGHT_PLANE</item>
                        <item name="Z not in light plane" desc="The z values were orthogonal to the translation direction during the calibration.">Z_NOT_IN_LIGHT_PLANE</item>
                        <item name="XZ not in light plane" desc="The xz values were orthogonal to the translation direction during the calibration.">XZ_NOT_IN_LIGHT_PLANE</item>
                    </enum>
                    <enum name="State" trait="released">
                        <item name="uncalibrated" desc="A raw Image.SheetOfLight.Model with default initialization.">UNCALIBRATED</item>
                        <item name="calibrated" desc="A calibrated Image.SheetOfLight.Model.">CALIBRATED</item>
                        <item name="calibrated and aligned 2D" desc="A calibrated and aligned Image.SheetOfLight.Model. Alignment only in the XZ-plane.">CALIBRATED_ALIGNED_2D</item>
                        <item name="calibrated and aligned 3D" desc="A calibrated and aligned Image.SheetOfLight.Model. Alignment in full XYZ.">CALIBRATED_ALIGNED_3D</item>
                        <item name="aligned 2D" desc="An aligned Image.SheetOfLight.Model. Alignment only in the XZ-plane. Not calibrated.">ALIGNED_2D</item>
                        <item name="aligned 3D" desc="An aligned Image.SheetOfLight.Model. Alignment in full XYZ. Not calibrated.">ALIGNED_3D</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <desc>Construct an empty calibration model for Sheet of Light devices.</desc>
                            <sample for="lua">model = Image.SheetOfLight.Model.create()</sample>
                            <return name="model" type="object" alias="Image.SheetOfLight.Model" desc="The new object"/>
                        </function>
                        <function name="setK">
                            <keywords>prescaler</keywords>
                            <links>Image.SheetOfLight.Model.getK</links>
                            <desc>Set camera matrix. The matrix must be on the form [f 0 Cu; 0 f Cv; 0 0 1]. f is the focal length and Cu,Cv is the distortion center. k^-1 is used to prescale and translate the coordinates.</desc>
                            <sample for="lua">success = Image.SheetOfLight.Model.setK(model, k)</sample>
                            <param name="model" type="object" alias="Image.SheetOfLight.Model" desc="The SheetOfLight.Model."/>
                            <param name="k" type="const object" alias="Transform" desc="The camera matrix transform (2D) to set."/>
                            <return name="success" type="bool" desc="True if the parameters could be set"/>
                        </function>
                        <function name="setLensCorrection">
                            <trait>hidden</trait>
                            <keywords>distortion, correction, calibration</keywords>
                            <links>Image.SheetOfLight.Model.getLensCorrection</links>
                            <desc>Specify the lens distortion coefficients. The lens model used is the Brown-Conrady lens model. The values provided will be used as a starting point for the optimization and can potentially increase the likelihood of convergence. Typically they can all be set to 0 for default behavior with no lens distortion correction. These values are optimized during calibration.</desc>
                            <sample for="lua">success = Image.SheetOfLight.Model.setLensCorrection(model, r0, r1, r2, t0, t1)</sample>
                            <param name="model" type="object" alias="Image.SheetOfLight.Model" desc="The SheetOfLight.Model."/>
                            <param name="r0" type="float" multiplicity="?" desc="The first radial distortion coefficient. If unset the value will be unchanged."/>
                            <param name="r1" type="float" multiplicity="?" desc="The second radial distortion coefficient. If unset the value will be unchanged."/>
                            <param name="r2" type="float" multiplicity="?" desc="The third radial distortion coefficient. If unset the value will be unchanged."/>
                            <param name="t0" type="float" multiplicity="?" desc="The first tangential distortion coefficient. If unset the value will be unchanged."/>
                            <param name="t1" type="float" multiplicity="?" desc="The second tangential distortion coefficient. If unset the value will be unchanged."/>
                            <return name="success" type="bool" desc="True if the parameters could be set"/>
                        </function>
                        <function name="setScheimpflugCorrection">
                            <trait>hidden</trait>
                            <keywords>tilt shift, prism distortion, calibration, correction</keywords>
                            <links>Image.SheetOfLight.Model.getScheimpflugCorrection</links>
                            <desc>Specify the Scheimpflug lens correction parameters. Typically they can all be set to 0 for default behavior with no correction active. These are normally estimated when calibrating if the option to use Scheimpflug correction is turned on.</desc>
                            <sample for="lua">success = Image.SheetOfLight.Model.setScheimpflugCorrection(model, s0, s1)</sample>
                            <param name="model" type="object" alias="Image.SheetOfLight.Model" desc="The SheetOfLight.Model."/>
                            <param name="s0" type="float" desc="The amount of Scheimpflug perspective as a function of the u position on the sensor. If unset the value will be unchanged."/>
                            <param name="s1" type="float" desc="The amount of Scheimpflug perspective as a function of the v position on the sensor. If unset the value will be unchanged."/>
                            <return name="success" type="bool" desc="True if the parameters could be set"/>
                        </function>
                        <function name="setSheetCurveCorrection">
                            <trait>hidden</trait>
                            <links>Image.SheetOfLight.Model.getSheetCurveCorrection</links>
                            <desc>Specify the light sheet curve model parameters of the sheet of light calibration model.</desc>
                            <sample for="lua">success = Image.SheetOfLight.Model.setSheetCurveCorrection(model, xo,zp,p0,p1,p2,p3)</sample>
                            <param name="model" type="object" alias="Image.SheetOfLight.Model" desc="The SheetOfLight.Model."/>
                            <param name="xo" type="float" desc="Prespective scaling parameter. Origin in x direction of scaling. x'=(x-xo)*(zp*z+1)"/>
                            <param name="zp" type="float" desc="Prespective scaling parameter. x'=(x-xo)*(zp*z+1)"/>
                            <param name="p0" type="float" desc="Light curve compensation parameter. Constant term."/>
                            <param name="p1" type="float" desc="Light curve compensation parameter. Linear term."/>
                            <param name="p2" type="float" desc="Light curve compensation parameter. Quadratic term."/>
                            <param name="p3" type="float" desc="Light curve compensation parameter. Cubic term."/>
                            <return name="success" type="bool" desc="True if the parameters could be set"/>
                        </function>
                        <function name="setHomography">
                            <keywords>perspective, calibration, correction</keywords>
                            <links>Image.SheetOfLight.Model.getHomography</links>
                            <desc>Explicitly set the homography transform from normalized image coordinates to world coordinates in the XZ-plane. Typically this is calculated during calibration, to set it manually is for advanced use only.</desc>
                            <sample for="lua">success = Image.SheetOfLight.Model.setHomography(model, homography)</sample>
                            <param name="model" type="object" alias="Image.SheetOfLight.Model" desc="The SheetOfLight.Model."/>
                            <param name="homography" type="const object" alias="Transform" desc="The homography transform to set."/>
                            <return name="success" type="bool" desc="True if the parameter could be set"/>
                        </function>
                        <function name="mirror">
                            <keywords>perspective, calibration, correction, flip</keywords>
                            <links>Image.SheetOfLight.Model.setHomography</links>
                            <desc>Create a mirrored version of the input model by mirroring along the world X- and/or Z-axis.
An optional point can be provided to mirror around an arbitrary point in 2D world coordinates. If no point is provided mirroring is performed around the world origin.</desc>
                            <sample for="lua">mirrored = Image.SheetOfLight.Model.mirror(model, xAxis, zAxis)</sample>
                            <param name="model" type="const object" alias="Image.SheetOfLight.Model" desc="The SheetOfLight.Model."/>
                            <param name="xAxis" type="bool" desc="Set to true to mirror the X-axis."/>
                            <param name="zAxis" type="bool" desc="Set to true to mirror the Z-axis."/>
                            <param name="center" type="const object" multiplicity="?" alias="Point" desc="The point (2D) to mirror around. This point is unchanged. Default is (0, 0)."/>
                            <return name="mirrored" type="object" multiplicity="?" alias="Image.SheetOfLight.Model" desc="The mirrored version of the input model. Nil on failure."/>
                        </function>
                        <function name="setSkew">
                            <keywords>alignment, correction, shear, tilt</keywords>
                            <links>Image.SheetOfLight.Model.getSkew</links>
                            <desc>Set the sheet of light plane parameters in relation to the direction of movement. This is typically calculated during alignment, to set it manually is advanced use only.</desc>
                            <sample for="lua">success = Image.SheetOfLight.Model.setSkew(model, nx, ny, nz)</sample>
                            <param name="model" type="object" alias="Image.SheetOfLight.Model" desc="The SheetOfLight.Model."/>
                            <param name="nx" type="float" desc="The x-component of the normal of the sheet of light that produced the data."/>
                            <param name="ny" type="float" desc="The y-component of the normal of the sheet of light that produced the data."/>
                            <param name="nz" type="float" desc="The z-component of the normal of the sheet of light that produced the data."/>
                            <return name="success" type="bool" desc="True if the parameter could be set"/>
                        </function>
                        <function name="setSkewMode">
                            <keywords>alignment, correction, shear, tilt</keywords>
                            <links>Image.SheetOfLight.Model.getSkewMode</links>
                            <desc>Set if the coordinates axes X and/or Z was in the sheet of light plane during the calibration.
This affects how correction is applied. If the calibration was done in the sheet of light plane the X and Z values may have to be rescaled depending on the skew parameters.
For details see the extended developer documentation.</desc>
                            <sample for="lua">success = Image.SheetOfLight.Model.setSkewMode(model, skewMode)</sample>
                            <param name="model" type="object" alias="Image.SheetOfLight.Model" desc="The SheetOfLight.Model."/>
                            <param name="skewMode" type="enum" ref="Image.SheetOfLight.Model.SkewMode" desc="The mode to use. Default is XZ_IN_LIGHT_PLANE."/>
                            <return name="success" type="bool" desc="True if the parameter could be set"/>
                        </function>
                        <function name="setPose">
                            <keywords>alignment, pose, position</keywords>
                            <desc>Set the pose (position) of the setup relative to a global coordinate system. The pose specified here aligns the result to the world. The pose is typically estimated during alignment, but can be modified manually.</desc>
                            <sample for="lua">success = Image.SheetOfLight.Model.setPose(model, pose)</sample>
                            <param name="model" type="object" alias="Image.SheetOfLight.Model" desc="The SheetOfLight.Model."/>
                            <param name="pose" type="const object" alias="Transform" desc="The world pose for alignment (3D transform)."/>
                            <return name="success" type="bool" desc="True if the parameter could be set"/>
                        </function>
                        <function name="getK">
                            <keywords>prescaler</keywords>
                            <links>Image.SheetOfLight.Model.setK</links>
                            <desc>Return the camera matrix K. K^-1 is used to scale image sensor points to normalized image coordinates.</desc>
                            <sample for="lua">k = Image.SheetOfLight.Model.getK(model)</sample>
                            <param name="model" type="object" alias="Image.SheetOfLight.Model" desc="The SheetOfLight.Model."/>
                            <return name="k" type="object" alias="Transform" desc="The camera 2D transform."/>
                        </function>
                        <function name="getLensCorrection">
                            <keywords>distortion, correction, calibration</keywords>
                            <links>Image.SheetOfLight.Model.setLensCorrection</links>
                            <desc>Retrieve the lens model parameters of the sheet of light calibration object. The lens model used is the Brown-Conrady lens model.</desc>
                            <sample for="lua">r0, r1, r2, t0, t1 = Image.SheetOfLight.Model.getLensCorrection(model)</sample>
                            <param name="model" type="object" alias="Image.SheetOfLight.Model" desc="The SheetOfLight.Model."/>
                            <return name="r0" type="float" desc="The first radial distortion coefficient."/>
                            <return name="r1" type="float" desc="The second radial distortion coefficient."/>
                            <return name="r2" type="float" desc="The third radial distortion coefficient."/>
                            <return name="t0" type="float" desc="The first tangential distortion coefficient."/>
                            <return name="t1" type="float" desc="The second tangential distortion coefficient."/>
                        </function>
                        <function name="getScheimpflugCorrection">
                            <keywords>tilt shift, prism distortion</keywords>
                            <links>Image.SheetOfLight.Model.setScheimpflugCorrection</links>
                            <desc>Retrieve the Scheimpflug model parameters of the sheet of light calibration object.</desc>
                            <sample for="lua">s0, s1 = Image.SheetOfLight.Model.getScheimpflugCorrection(model)</sample>
                            <param name="model" type="object" alias="Image.SheetOfLight.Model" desc="The SheetOfLight.Model."/>
                            <return name="s0" type="float" desc="The amount of Scheimpflug perspective as a function of the u position on the sensor."/>
                            <return name="s1" type="float" desc="The amount of Scheimpflug perspective as a function of the v position on the sensor."/>
                        </function>
                        <function name="getSheetCurveCorrection">
                            <trait>hidden</trait>
                            <links>Image.SheetOfLight.Model.setSheetCurveCorrection</links>
                            <desc>Retrieve the light sheet curve model parameters of the sheet of light calibration model.</desc>
                            <sample for="lua">xo, zp, p0, p1, p2, p3 = Image.SheetOfLight.Model.getSheetCurveCorrection(model)</sample>
                            <param name="model" type="object" alias="Image.SheetOfLight.Model" desc="The SheetOfLight.Model."/>
                            <return name="xo" type="float" desc="Prespective scaling parameter. Origin in x direction of scaling. x'=(x-xo)*(zp*z+1)"/>
                            <return name="zp" type="float" desc="Prespective scaling parameter. x'=(x-xo)*(zp*z+1)"/>
                            <return name="p0" type="float" desc="Light curve compensation parameter. Constant term."/>
                            <return name="p1" type="float" desc="Light curve compensation parameter. Linear term."/>
                            <return name="p2" type="float" desc="Light curve compensation parameter. Quadratic term."/>
                            <return name="p3" type="float" desc="Light curve compensation parameter. Cubic term."/>
                        </function>
                        <function name="getHomography">
                            <keywords>perspective, calibration, correction</keywords>
                            <links>Image.SheetOfLight.Model.setHomography</links>
                            <desc>Return the homography transform from normalized image coordinates to world coordinates in the XZ-plane.</desc>
                            <sample for="lua">homography = Image.SheetOfLight.Model.getHomography(model)</sample>
                            <param name="model" type="object" alias="Image.SheetOfLight.Model" desc="The SheetOfLight.Model."/>
                            <return name="homography" type="object" alias="Transform" desc="The homography transform."/>
                        </function>
                        <function name="getSkew">
                            <keywords>alignment, correction, shear, tilt</keywords>
                            <links>Image.SheetOfLight.Model.setSkew</links>
                            <desc>Return the sheet of light plane normal in the unaligned coordinate system of the calibrated setup.</desc>
                            <sample for="lua">nx, ny, nz = Image.SheetOfLight.Model.getSkew(model)</sample>
                            <param name="model" type="object" alias="Image.SheetOfLight.Model" desc="The SheetOfLight.Model."/>
                            <return name="nx" type="float" desc="The x-component of the normal in world units."/>
                            <return name="ny" type="float" desc="The y-component of the normal in world units."/>
                            <return name="nz" type="float" desc="The z-component of the normal in world units."/>
                        </function>
                        <function name="getSkewMode">
                            <keywords>alignment, correction, shear, tilt</keywords>
                            <links>Image.SheetOfLight.Model.setSkewMode</links>
                            <desc>Return the current skew mode of the model.</desc>
                            <sample for="lua">skewMode = Image.SheetOfLight.Model.getSkewMode(model)</sample>
                            <param name="model" type="object" alias="Image.SheetOfLight.Model" desc="The SheetOfLight.Model."/>
                            <return name="skewMode" type="enum" ref="Image.SheetOfLight.Model.SkewMode" desc="The selected skew mode."/>
                        </function>
                        <function name="getPose">
                            <keywords>alignment, pose, position</keywords>
                            <desc>Return the pose that aligns the local camera coordinate system to a global coordinate system.</desc>
                            <sample for="lua">pose = Image.SheetOfLight.Model.getPose(model)</sample>
                            <param name="model" type="object" alias="Image.SheetOfLight.Model" desc="The SheetOfLight.Model."/>
                            <return name="pose" type="object" alias="Transform" desc="The world pose for alignment."/>
                        </function>
                        <function name="getCalibratedRegion">
                            <keywords>region, valid, feedback, info</keywords>
                            <desc>Return a set of objects that can help in understanding where a calibration is valid and what type of errors to expect.
The first returned object is an axis aligned bounding box for all calibration points used to calculate the calibration.
The images after indicate the number of points and the expected errors within subregions of this bounding box.</desc>
                            <sample for="lua">xAverage, zAverage = Image.SheetOfLight.Model.getCalibratedRegion(model)</sample>
                            <param name="model" type="object" alias="Image.SheetOfLight.Model" desc="The SheetOfLight.Model."/>
                            <return name="region" type="object" multiplicity="?" alias="Shape" desc="A rectangle shape indicating the bound of the calibrated area on the sensor."/>
                            <return name="count" type="object" multiplicity="?" alias="Image" desc="An image representing the amount of points in each part of the region."/>
                            <return name="xAverage" type="object" multiplicity="?" alias="Image" desc="An image representing average residual x error in each part of the region."/>
                            <return name="zAverage" type="object" multiplicity="?" alias="Image" desc="An image representing average residual z error in each part of the region."/>
                            <return name="xMaximum" type="object" multiplicity="?" alias="Image" desc="An image representing largest residual x error in each part of the region."/>
                            <return name="zMaximum" type="object" multiplicity="?" alias="Image" desc="An image representing largest residual z error in each part of the region."/>
                        </function>
                        <function name="toString">
                            <desc>Prints a textual representation of the sheet of light calibration model.</desc>
                            <sample for="lua">str = Image.SheetOfLight.Model.toString(model)</sample>
                            <param name="model" type="object" alias="Image.SheetOfLight.Model" desc="The SheetOfLight.Model."/>
                            <return name="str" type="string" desc="Textual description of the Sheet of Light model handle."/>
                        </function>
                        <function name="getState">
                            <desc>Returns the calibration state enum. This indicates if calibration and/or alignment have been performed correctly.</desc>
                            <sample for="lua">state = Image.SheetOfLight.Model.getState(model)</sample>
                            <param name="model" type="object" alias="Image.SheetOfLight.Model" desc="The SheetOfLight.Model."/>
                            <return name="state" type="enum" ref="Image.SheetOfLight.Model.State" desc="The state of the model."/>
                        </function>
                    </serves>
                </crown>
                <crown name="Calibration">
                    <trait>released</trait>
                    <links>Image.SheetOfLight.Model, Image.SheetOfLight.Alignment, Image.SheetOfLight.Runtime</links>
                    <desc>This crown handles the process of calculating the world mapping from raw sensor coordinates. In the most common setting it maps pixels to millimeters. It only operates inside the XZ-plane of the sensor and the Y coordinates are completely left out of the process. The result is a Image.SheetOfLight.Model.
To align the Y coordinates or relate positions between devices see the Image.SheetOfLight.Alignment crown.

A minimal use case example is the following:

local calibrator = Image.SheetOfLight.Calibration.create()
local success = calibrator:addPoints(sensorPoints, referencePoints)
local calibratedModel = calibrator:estimate(model, Point.create(2560, 832))</desc>
                    <serves>
                        <function name="create">
                            <desc>Construct a calibration object capable of computing a calibration for Sheet of Light devices.</desc>
                            <sample for="lua">cal = Image.SheetOfLight.Calibration.create()</sample>
                            <return name="cal" type="handle" alias="Image.SheetOfLight.Calibration" desc="The new handle"/>
                        </function>
                        <function name="setLensParametersEnabled">
                            <keywords>distortion, correction, calibration</keywords>
                            <links>Image.SheetOfLight.Calibration.setScheimpflugEnabled, Image.SheetOfLight.Model.setLensCorrection, Image.SheetOfLight.Model.getLensCorrection</links>
                            <desc>Set which parameters of the lens distortion model to optimize. Turning on many parameters puts greater requirements on the density of the provided points.
A good starting point is to use the default with only one radial distortion parameter. If the calibration error is large consider adding another radial component. Always start with few parameters and increase if required.
For devices with a Scheimpflug adapter its also worth considering turning on the Scheimpflug parameters using the Image.SheetOfLight.Calibration.setScheimpflugEnabled function.
A good configuration for Scheimpflug devices is two radial coefficients and two Scheimpflug coefficients.
For more details on the model implementation look up the Brown-Conrady distortion model.</desc>
                            <sample for="lua"> Image.SheetOfLight.Calibration.setLensParametersEnabled(cal, r0, r1, r2, t0, t1)</sample>
                            <param name="cal" type="handle" alias="Image.SheetOfLight.Calibration" desc="The calibration handle."/>
                            <param name="r0" type="bool" multiplicity="?" desc="The first radial distortion coefficient. Default is true."/>
                            <param name="r1" type="bool" multiplicity="?" desc="The second radial distortion coefficient. Default is false."/>
                            <param name="r2" type="bool" multiplicity="?" desc="The third radial distortion coefficient. Default is false."/>
                            <param name="t0" type="bool" multiplicity="?" desc="The first tangential distortion coefficient. Default is false."/>
                            <param name="t1" type="bool" multiplicity="?" desc="The second tangential distortion coefficient. Default is false."/>
                        </function>
                        <function name="setScheimpflugEnabled">
                            <keywords>tilt shift, prism distortion, calibration, correction</keywords>
                            <links>Image.SheetOfLight.Calibration.setLensParametersEnabled</links>
                            <desc>The Scheimpflug principle involves tilting the lens axis in relation to the imager. This causes the focus plane in the world to tilt. For sheet of light devices this gives a clear advantage as it makes it possible to keep the whole light sheet in focus at the same time by adapting the Scheimpflug angle to the triangulation angle.
For devices that have a Scheimpflug adapter the normal lens distortion model might not always suffice. To enable explicit Scheimpflug distortion optimization toggle the parameters on using this function.
In the most typical case s0 and s1 should be toggled together. That is either both s0 and s1 are on or they are both off. It's however possible to toggle them separately if there is a specific reason to do so.</desc>
                            <sample for="lua"> Image.SheetOfLight.Calibration.setScheimpflugEnabled(cal, scaleU, scaleV)</sample>
                            <param name="cal" type="handle" alias="Image.SheetOfLight.Calibration" desc="The calibration handle."/>
                            <param name="s0" type="bool" desc="The Scheimpflug perspective as a function of the u position on the sensor. Default is false."/>
                            <param name="s1" type="bool" desc="The Scheimpflug perspective as a function of the v position on the sensor. Default is false."/>
                        </function>
                        <function name="setSheetCurveEnabled">
                            <trait>hidden</trait>
                            <keywords></keywords>
                            <links></links>
                            <desc>Set if compensation for curving of the light plane should be made. Second or third degree polynomial can be selected.</desc>
                            <sample for="lua"> Image.SheetOfLight.Calibration.setSheetCurveEnabled(cal, "SECOND_DEGREE")</sample>
                            <param name="cal" type="handle" alias="Image.SheetOfLight.Calibration" desc="The calibration handle."/>
                            <param name="degree" type="enum" ref="Image.SheetOfLight.PolynomialDegree" desc="Use to select the polynomial degree to estimate. Default if OFF."/>
                        </function>
                        <function name="addPoints">
                            <keywords>calibration, sensor points, world points</keywords>
                            <links>Image.SheetOfLight.Calibration.clearPoints, Image.SheetOfLight.Calibration.getSetCount, Image.SheetOfLight.Calibration.getPointCount</links>
                            <desc>Incrementally add points for calibration of the triangulation plane. Each set should must consist of at least 4 points. The recommended number of points is 8 or more.
To perform a calibration one set is enough, but more can be incrementally added to increase robustness and accuracy in a large fields of view. Between each set there can be an unknown translation and rotation within the calibration plane.</desc>
                            <sample for="lua">success = Image.SheetOfLight.Calibration.addPoints(cal, uncalibratedPoints, referencePoints)</sample>
                            <param name="cal" type="handle" alias="Image.SheetOfLight.Calibration" desc="The calibration handle."/>
                            <param name="uncalibratedPoints" type="const object" multiplicity="+" alias="Point" desc="A list of uncalibrated points in sensor U, V coordinates."/>
                            <param name="referencePoints" type="const object" multiplicity="+" alias="Point" desc="A list of calibrated world positions (X, Z) corresponding to where U and V should be after calibration."/>
                            <return name="success" type="bool" desc="True on success."/>
                        </function>
                        <function name="clearPoints">
                            <keywords>calibration, sensor points, world points</keywords>
                            <links>Image.SheetOfLight.Calibration.addPoints, Image.SheetOfLight.Calibration.getSetCount, Image.SheetOfLight.Calibration.getPointCount</links>
                            <desc>Remove all points previously added to XZ calibration.</desc>
                            <sample for="lua">success = Image.SheetOfLight.Calibration.clearPoints(cal)</sample>
                            <param name="cal" type="handle" alias="Image.SheetOfLight.Calibration" desc="The calibration handle."/>
                        </function>
                        <function name="getSetCount">
                            <keywords>calibration, sensor points, world points</keywords>
                            <links>Image.SheetOfLight.Calibration.addPoints, Image.SheetOfLight.Calibration.clearPoints, Image.SheetOfLight.Calibration.getPointCount</links>
                            <desc>Retrieve the number of point sets currently added. This number increases with each successful call to addPoints and is reset by clearPoints.</desc>
                            <sample for="lua">count = Image.SheetOfLight.Calibration.getSetCount(cal)</sample>
                            <param name="cal" type="handle" alias="Image.SheetOfLight.Calibration" desc="The calibration handle."/>
                            <return name="count" type="int" desc="The number of sets."/>
                        </function>
                        <function name="getPointCount">
                            <keywords>calibration, sensor points, world points</keywords>
                            <links>Image.SheetOfLight.Calibration.addPoints, Image.SheetOfLight.Calibration.clearPoints, Image.SheetOfLight.Calibration.getSetCount</links>
                            <desc>Retrieve the number of points currently added. This number increases for each successful call to addPoints and is reset by clearPoints. Pass an index to get the number of points within one set or leave set empty to return the total sum.</desc>
                            <sample for="lua">count = Image.SheetOfLight.Calibration.getPointCount(cal, set)</sample>
                            <param name="cal" type="handle" alias="Image.SheetOfLight.Calibration" desc="The calibration handle."/>
                            <param name="set" type="int" multiplicity="?" desc="The point set index. If unset the total number of points is returned."/>
                            <return name="count" type="int" desc="The number of points."/>
                        </function>
                        <function name="estimate">
                            <keywords>calibration, calibrate, calculate, apply, perform</keywords>
                            <links>Image.SheetOfLight.Calibration.addPoints, Image.SheetOfLight.Calibration.setLensParametersEnabled, Image.SheetOfLight.Calibration.setScheimpflugEnabled, Image.SheetOfLight.Calibration.getResiduals</links>
                            <desc>Perform a calibration of the world XZ-plane. This calibration method is enough to fully calibrate a system with a reverse ordinary geometry (where the sheet of light is orthogonal to the movement direction).
2D Point correspondences should be collected and added using the addPoints call prior to calling this function.
The sensor size is used to regularize the optimization and to stop it from reaching an incorrect solution. This should be set according to the sensor size of the device in pixels.</desc>
                            <sample for="lua">model, meanError, maxError = Image.SheetOfLight.Calibration.estimate(cal, model, sensorSize)</sample>
                            <param name="cal" type="handle" alias="Image.SheetOfLight.Calibration" desc="The calibration handle."/>
                            <param name="model" type="const object" alias="Image.SheetOfLight.Model" desc="The calibration model to update."/>
                            <param name="sensorSize" type="const object" alias="Point" desc="The dimensions of the imager."/>
                            <return name="model" type="object" multiplicity="?" alias="Image.SheetOfLight.Model" desc="The updated model. nil on failure."/>
                            <return name="meanError" type="float" multiplicity="?" desc="The average calibration error in world units per point. nil on failure."/>
                            <return name="maxError" type="float" multiplicity="?" desc="The maximum calibration error in world units per point. nil on failure."/>
                        </function>
                        <function name="getResiduals">
                            <keywords>error, offset, distance</keywords>
                            <links>Image.SheetOfLight.Calibration.estimate, Image.SheetOfLight.Calibration.addPoints, Image.SheetOfLight.Calibration.getPoints</links>
                            <desc>Retrieve the residuals for the last estimate call. Can either return the residuals of a specific input point set or a list of all points in the order they were added. The returned list of points contain the displacement vectors in 2D world coordinate between the reference points and the final calibrated points.</desc>
                            <sample for="lua">residuals = Image.SheetOfLight.Calibration.getResiduals(cal, set)</sample>
                            <param name="cal" type="handle" alias="Image.SheetOfLight.Calibration" desc="The calibration handle."/>
                            <param name="set" type="int" multiplicity="[?*]" desc="The point set index or vector with indices, zero-based indexing. Defaults to all if unset."/>
                            <return name="residuals" type="object" multiplicity="*" alias="Point" desc="The residual error per point in the selected set."/>
                        </function>
                        <function name="getPoints">
                            <keywords>positions</keywords>
                            <links>Image.SheetOfLight.Calibration.estimate, Image.SheetOfLight.Calibration.addPoints, Image.SheetOfLight.Calibration.getResiduals</links>
                            <desc>Retrieve the points used in the last estimate call. Can either return the points of a specific input point set or a list of all points in the order they were added.</desc>
                            <sample for="lua">uncalibratedPoints, referencePoints = Image.SheetOfLight.Calibration.getPoints(cal, set, optimized)</sample>
                            <param name="cal" type="handle" alias="Image.SheetOfLight.Calibration" desc="The calibration handle."/>
                            <param name="set" type="int" multiplicity="[?*]" desc="The point set index or vector with indices, zero-based indexing. Defaults to all if unset."/>
                            <param name="optimized" type="bool" multiplicity="?" desc="If estimate was called successfully this option allows retrieving the recalculated world coordinates. Set to false to get the input data. Default is false."/>
                            <return name="uncalibratedPoints" type="object" multiplicity="*" alias="Point" desc="A list of uncalibrated points in sensor U, V coordinates."/>
                            <return name="referencePoints" type="object" multiplicity="*" alias="Point" desc="A list of calibrated world coordinates."/>
                        </function>
                        <function name="getPose">
                            <keywords>position, offset, translation, rotation</keywords>
                            <links>Image.SheetOfLight.Calibration.estimate, Image.SheetOfLight.Calibration.addPoints, Image.SheetOfLight.Calibration.getPoints, Image.SheetOfLight.Calibration.getResiduals</links>
                            <desc>Retrieve the relative transforms found when performing the estimate call. Can either return the transforms of a specific input point set or a list of all transforms in the order they were added.
The transforms are in the direction from the first set to the following sets. The first set always represent origin and the transform encodes the offset and relative rotation to this position.</desc>
                            <sample for="lua">transforms = Image.SheetOfLight.Calibration.getPose(cal, set)</sample>
                            <param name="cal" type="handle" alias="Image.SheetOfLight.Calibration" desc="The calibration handle."/>
                            <param name="set" type="int" multiplicity="[?*]" desc="The point set index or vector with indices, zero-based indexing. Defaults to all if unset."/>
                            <return name="transforms" type="object" multiplicity="[?*]" alias="Transform" desc="A list of calibrated world poses."/>
                        </function>
                        <function name="toString">
                            <desc>Returns a textual representation of the calibration object.</desc>
                            <sample for="lua">str = Image.SheetOfLight.Calibration.toString(cal)</sample>
                            <param name="cal" type="handle" alias="Image.SheetOfLight.Calibration" desc="The calibration handle."/>
                            <return name="str" type="string" desc="Textual description of the Sheet of Light calibration handle."/>
                        </function>
                    </serves>
                </crown>
                <crown name="Alignment">
                    <trait>released</trait>
                    <links>Image.SheetOfLight.Calibration, Image.SheetOfLight.Model, Image.SheetOfLight.Runtime</links>
                    <desc>Alignment is the process of transforming measurements from a Sheet of Light device into another coordinate frame. The result is a Image.SheetOfLight.Model.
This crown supports different alignment use cases and is intended to be used after a successful calibration has been performed using Image.SheetOfLight.Calibration, or when using a precalibrated device.
This process can be as simple as a 2D or 3D translation and rotation or more involved due to skewing.

A minimal use case example is the following:

local align = Image.SheetOfLight.Alignment.create()
local alignedModel = align:estimate3D(calibratedModel, inputPoints, referencePoints, true/false)</desc>
                    <serves>
                        <function name="create">
                            <desc>Construct an alignment object for Sheet of Light devices.</desc>
                            <sample for="lua">cal = Image.SheetOfLight.Alignment.create()</sample>
                            <return name="cal" type="handle" alias="Image.SheetOfLight.Alignment" desc="The new handle"/>
                        </function>
                        <function name="estimate3D">
                            <keywords>alignment, align, calculate, apply, perform</keywords>
                            <links>Image.SheetOfLight.Alignment.estimate2D, Image.SheetOfLight.Alignment.getResiduals, Image.SheetOfLight.Calibration.estimate</links>
                            <desc>Perform a calibration for geometries other than reverse ordinary, or for alignment of several cameras in full 3D.
The input to this function should be two sets of corresponding 3D points. The input points can either be precalibrated points that are unaligned or true uncalibrated points. The referencePoints should be the final 3D position of each uncalibrated point in the global coordinate system.
Set xzCalibrated to true if the points have previously been calibrated to the xzPlane. This is the case for precalibrated devices or for data extracted from rectified heightmaps for example.
The y-axis of the input image can optionally be scaled and offset according to external encoder information. If the yOrigin or yScale is unset the input points remain unchanged.
If the calibration target used cannot resolve both the rotation and the sheet of light orientation (DotWedge for example) the optimizeRotation flag should be set to false. This requires that the target itself is aligned to the direction of scanning.</desc>
                            <sample for="lua">xyzCloud = Image.SheetOfLight.Alignment.estimate3D(cal, model, inputPoints, referencePoints)</sample>
                            <param name="cal" type="handle" alias="Image.SheetOfLight.Alignment" desc="The calibration handle."/>
                            <param name="model" type="const object" alias="Image.SheetOfLight.Model" desc="The calibration model to update."/>
                            <param name="inputPoints" type="const object" multiplicity="+" alias="Point" desc="A list of uncalibrated points in sensor U, Y, V or distorted X, Y, Z coordinates."/>
                            <param name="referencePoints" type="const object" multiplicity="+" alias="Point" desc="A list of calibrated world positions X, Y, Z corresponding to the inputPoints list."/>
                            <param name="xzCalibrated" type="bool" desc="Decide if the input inputPoints are precalibrated to the XZ-plane (mm) or if they are in raw UV coordinates (px). Set to true if they are precalibrated."/>
                            <param name="yOrigin" type="float" multiplicity="?" desc="An optional offset to be applied to the Y coordinate in inputPoints before calibration is calculated. If unset assumed to be zero."/>
                            <param name="yScale" type="float" multiplicity="?" desc="An optional scale to be applied to the Y coordinate in inputPoints before calibration is calculated. If unset assumed to be one."/>
                            <param name="optimizeRotation" type="bool" multiplicity="?" desc="Set to false to disable rotation estimation. Default is true."/>
                            <return name="model" type="object" multiplicity="?" alias="Image.SheetOfLight.Model" desc="The aligned model. Nil on failure."/>
                            <return name="meanError" type="float" multiplicity="?" desc="The average alignment error in world units per point. Nil on failure."/>
                            <return name="maxError" type="float" multiplicity="?" desc="The maximum alignment error in world units per point. Nil on failure."/>
                        </function>
                        <function name="estimate2D">
                            <keywords>alignment, align, calculate, apply, perform</keywords>
                            <links>Image.SheetOfLight.Alignment.estimate3D, Image.SheetOfLight.Calibration.estimate</links>
                            <desc>Perform an in-plane (2D) alignment of a camera to a reference. The estimated transform is a 2D rotation and translation from the camera to the reference. Thus, the input should be in calibrated coordinates.
The input to this function should be a set of corresponding 2D line segments and/or 2D points. At least two corresponding pairs is required.
Note that the direction of the line segments ("end point 2" - "end point 1") matters, an aligned input line segment should point in the same direction as the corresponding reference line segment.
Make sure that the transform between the input lines/points to the reference is a pure rotation plus translation, not any mirroring.</desc>
                            <sample for="lua">model = Image.SheetOfLight.Alignment.estimate2D(cal, model, inputLines, inputPoints, referenceLines, referencePoints)</sample>
                            <param name="cal" type="handle" alias="Image.SheetOfLight.Alignment" desc="The calibration handle."/>
                            <param name="model" type="const object" alias="Image.SheetOfLight.Model" desc="The calibration model to update."/>
                            <param name="inputLines" type="const object" multiplicity="+" alias="Shape" desc="A list of line segments in world X, Z in the camera, corresponding to referenceLines."/>
                            <param name="inputPoints" type="const object" multiplicity="+" alias="Point" desc="A list of points in world X, Z in the camera, corresponding to referencePoints."/>
                            <param name="referenceLines" type="const object" multiplicity="+" alias="Shape" desc="A list of line segments in world X, Z in camera 1."/>
                            <param name="referencePoints" type="const object" multiplicity="+" alias="Point" desc="A list of points in world X, Z in camera 1."/>
                            <return name="model" type="object" multiplicity="?" alias="Image.SheetOfLight.Model" desc="The aligned model. Nil on failure."/>
                            <return name="meanError" type="float" multiplicity="?" desc="The average alignment error in world units per feature. Nil on failure."/>
                            <return name="maxError" type="float" multiplicity="?" desc="The maximum alignment error in world units per feature. Nil on failure."/>
                        </function>
                        <function name="estimateMulti2D">
                            <trait>hidden</trait>
                            <desc>Perform a alignment of several cameras which have the same sheet of light plane using multiple of measurements. The estimated transform is a 2D rotation and translation from camera 2 to camera 1.
The input to this function should be corresponding pairs of 2D line segments and 2D points (same number of line segments and points), from the two cameras. Thus, the line segment + point n in camera 1 corresponds to line segment + point in camera 2.
Note that the direction of the line segments ("end point 2" - "end point 1") matters, a aligned line segment in camera 1 should point in the same direction as the corresponding line segment in camera 2.
Make sure that the transform between the input lines/points to the reference is a pure rotation plus translation, not any mirroring.
A reference line segment and point pair can be used (optional), one pair for each camera (two). The first line segment and point pair from camera 1 is exactly transformed to the first reference line segment and point pair, the first line segment and point pair from camera 2 is optimized to fit to the second reference line segment and point pair.</desc>
                            <sample for="lua">model = Image.SheetOfLight.Alignment.estimateMulti2D(cal, model, linesCamera1, pointsCamera1, linesCamera2, pointsCamera2, referenceLines, referencePoints)</sample>
                            <param name="cal" type="handle" alias="Image.SheetOfLight.Alignment" desc="The calibration handle."/>
                            <param name="model" type="const object" multiplicity="+" alias="Image.SheetOfLight.Model" desc="The calibration model to update."/>
                            <param name="linesCamera1" type="const object" multiplicity="+" alias="Shape" desc="A list of line segments in world X, Z in camera 1."/>
                            <param name="pointsCamera1" type="const object" multiplicity="+" alias="Point" desc="A list of points in world X, Z in camera 1."/>
                            <param name="linesCamera2" type="const object" multiplicity="+" alias="Shape" desc="A list of line segments in world X, Z in camera 2, corresponding to linesCamera1."/>
                            <param name="pointsCamera2" type="const object" multiplicity="+" alias="Point" desc="A list of points in world X, Z in camera 2, corresponding to pointsCamera1."/>
                            <param name="referenceLines" type="const object" multiplicity="*" alias="Shape" desc="Reference lines. One for each camera, corresponding to first line in linesCamera1 and linesCamera2."/>
                            <param name="referencePoints" type="const object" multiplicity="*" alias="Point" desc="Reference points. One for each camera, corresponding to first point in pointsCamera1 and pointsCamera2"/>
                            <return name="model" type="object" multiplicity="*" alias="Image.SheetOfLight.Model" desc="The updated models. Nil on failure."/>
                            <return name="meanError" type="float" multiplicity="?" desc="The average alignment error in world units per feature. Nil on failure."/>
                            <return name="maxError" type="float" multiplicity="?" desc="The maximum alignment error in world units per feature. Nil on failure."/>
                        </function>
                        <function name="estimateMulti2D180">
                            <trait>hidden</trait>
                            <desc>Special case of estimateMulti2D for the case of a above/below camera configuration (thickness measuring). If a flat surface with known thickness (gives corresponding line segments) with a marker on each side (gives corresponding points) is used, but the position of the marker is not very exact, this function should be used instead.
Note that the alignment target must be rotated 180 degrees between each image, and a even number of images must be used (the number of line segments and points is even).
Perform a alignment of several cameras which have the same sheet of light plane using multiple of measurements. The estimated transform is a 2D rotation and translation from camera 2 to camera 1.
The input to this function should be corresponding pairs of 2D line segments and 2D points (same number of line segments and points), from the two cameras. Thus, the line segment + point n in camera 1 corresponds to line segment + point in camera 2.
Note that the direction of the line segments ("end point 2" - "end point 1") matters, a aligned line segment in camera 1 should point in the same direction as the corresponding line segment in camera 2.
Make sure that the transform between the input lines/points to the reference is a pure rotation plus translation, not any mirroring.
A reference line segment and point pair can be used (optional), one pair for each camera (two). The first line segment and point pair from camera 1 is exactly transformed to the first reference line segment and point pair, the first line segment and point pair from camera 2 is optimized to fit to the second reference line segment and point pair.</desc>
                            <sample for="lua">model = Image.SheetOfLight.Alignment.estimateMulti2D180(cal, model, linesCamera1, pointsCamera1, linesCamera2, pointsCamera2, thickness)</sample>
                            <param name="cal" type="handle" alias="Image.SheetOfLight.Alignment" desc="The calibration handle."/>
                            <param name="model" type="const object" multiplicity="+" alias="Image.SheetOfLight.Model" desc="The calibration model to update."/>
                            <param name="linesCamera1" type="const object" multiplicity="+" alias="Shape" desc="A list of line segments in world X, Z in camera 1."/>
                            <param name="pointsCamera1" type="const object" multiplicity="+" alias="Point" desc="A list of points in world X, Z in camera 1."/>
                            <param name="linesCamera2" type="const object" multiplicity="+" alias="Shape" desc="A list of line segments in world X, Z in camera 2, corresponding to linesCamera1."/>
                            <param name="pointsCamera2" type="const object" multiplicity="+" alias="Point" desc="A list of points in world X, Z in camera 2, corresponding to pointsCamera1."/>
                            <param name="thickness" type="float" desc="Thickness of alignment target."/>
                            <return name="model" type="object" multiplicity="*" alias="Image.SheetOfLight.Model" desc="The updated models. Nil on failure."/>
                            <return name="meanError" type="float" multiplicity="?" desc="The average alignment error in world units per feature. Nil on failure."/>
                            <return name="maxError" type="float" multiplicity="?" desc="The maximum alignment error in world units per feature. Nil on failure."/>
                        </function>
                        <function name="getResiduals">
                            <keywords>error, offset, distance</keywords>
                            <links>Image.SheetOfLight.Alignment.estimate3D</links>
                            <desc>Retrieve the residuals for the last Image.SheetOfLight.Alignment.estimate3D call. The returned list of points contain the displacement vectors in world coordinate between the reference points and the final aligned points.</desc>
                            <sample for="lua">residuals = Image.SheetOfLight.Alignment.getResiduals(cal)</sample>
                            <param name="cal" type="handle" alias="Image.SheetOfLight.Alignment" desc="The calibration handle."/>
                            <return name="residuals" type="object" multiplicity="*" alias="Point" desc="The residual error per point in the selected set."/>
                        </function>
                        <function name="toString">
                            <desc>Retrieve a textual representation of the alignment object.</desc>
                            <sample for="lua">str = Image.SheetOfLight.Alignment.toString(cal)</sample>
                            <param name="cal" type="handle" alias="Image.SheetOfLight.Alignment" desc="The calibration handle."/>
                            <return name="str" type="string" desc="Textual description of the Sheet of Light calibration handle."/>
                        </function>
                    </serves>
                </crown>
                <crown name="Runtime">
                    <trait>released</trait>
                    <links>Image.SheetOfLight.Calibration, Image.SheetOfLight.Alignment, Image.SheetOfLight.Model</links>
                    <desc>This crown manages all apply functionality of Image.SheetOfLight.Model objects.

A minimal use case might be the following:

local model = Object.load('path_to_model')
local runtime = Image.SheetOfLight.Runtime.create()
runtime:setModel(model)
local X, Z = runtime:applyCalibration(heightmap)
local R = runtime:rectifyCalibrated({X, Z, intensity})</desc>
                    <enum name="rectificationMode" trait="released">
                        <item name="mean" desc="Resolve point ambiguities by averaging all observations.">MEAN</item>
                        <item name="topmost" desc="Resolve point ambiguities by picking the upper point, i.e, prioritize points with higher z coordinate.">TOPMOST</item>
                        <item name="bottommost" desc="Resolve point ambiguities by picking the lower point,i.e, prioritize points with a lower z coordinate.">BOTTOMMOST</item>
                        <item name="darkest" desc="Resolve point ambiguities by picking the darker point,i.e, prioritize points with lower intensity.">DARKEST</item>
                        <item name="brightest" desc="Resolve point ambiguities by picking the brighter point,i.e, prioritize points with higher intensity.">BRIGHTEST</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <desc>Construct a calibration object capable of calibrating and aligning Sheet of Light devices.</desc>
                            <sample for="lua">runtime = Image.SheetOfLight.Runtime.create()</sample>
                            <return name="runtime" type="handle" alias="Image.SheetOfLight.Runtime" desc="The new handle"/>
                        </function>
                        <function name="setModel">
                            <keywords>update, load, save, serialize, deserialize</keywords>
                            <links>Image.SheetOfLight.Runtime.getModel, Image.SheetOfLight.Model, Image.SheetOfLight.Calibration, Image.SheetOfLight.Alignment</links>
                            <desc>Update the internal runtime model.</desc>
                            <sample for="lua">local success = Image.SheetOfLight.Runtime.setModel(runtime, model)</sample>
                            <param name="runtime" type="handle" alias="Image.SheetOfLight.Runtime" desc="The sheet of light runtime manager."/>
                            <param name="model" type="const object" alias="Image.SheetOfLight.Model" desc="A calibrated sheet of light model."/>
                            <return name="success" type="bool" desc="True if the model could be set"/>
                        </function>
                        <function name="getModel">
                            <keywords>save, load, save, serialize, deserialize</keywords>
                            <links>Image.SheetOfLight.Runtime.setModel, Image.SheetOfLight.Model, Image.SheetOfLight.Calibration, Image.SheetOfLight.Alignment</links>
                            <desc>Retrieve the internal runtime model.</desc>
                            <sample for="lua">local model = Image.SheetOfLight.Runtime.getModel()</sample>
                            <param name="runtime" type="handle" alias="Image.SheetOfLight.Runtime" desc="The sheet of light runtime manager."/>
                            <return name="model" type="object" alias="Image.SheetOfLight.Model" desc="The internal sheet of light model."/>
                        </function>
                        <function name="setInPlaneAlignment">
                            <keywords></keywords>
                            <links>Image.SheetOfLight.Runtime.applyAlignment, Image.SheetOfLight.Runtime.applyCalibration, Image.SheetOfLight.Runtime.mapPoints, Image.SheetOfLight.Runtime.mapProfiles</links>
                            <desc>Select if the XZ part of alignment should be performed in the calibration step or in the alignment step. This includes any rotation around the movement axis and scaling effects due to light sheet tilt.
For some applications it may be advantageous to compensate for in plane rotation and scaling due to skew without having to add the complexity of a full 3D alignment. For these cases set this parameter to true.
The default behavior is to perform the full alignment in the alignment step.
This setting affects the applyCalibration, applyAlignment, mapPoints and mapProfiles functions. Avoid toggling this between function calls.</desc>
                            <sample for="lua">local success = Image.SheetOfLight.Runtime.setInPlaneAlignment(runtime, false)</sample>
                            <param name="runtime" type="handle" alias="Image.SheetOfLight.Runtime" desc="The sheet of light runtime manager."/>
                            <param name="enable" type="bool" desc="Select if in plane alignment should be enabled. Default is false."/>
                            <return name="success" type="bool" desc="True if the parameter could be set"/>
                        </function>
                        <function name="setRectificationThreading">
                            <trait>hidden</trait>
                            <keywords></keywords>
                            <links>Image.SheetOfLight.Runtime.applyAlignment, Image.SheetOfLight.Runtime.applyCalibration, Image.SheetOfLight.Runtime.mapPoints, Image.SheetOfLight.Runtime.mapProfiles</links>
                            <desc>Select if threading should be allowed in cases where aliasing might occur. Threading has been implemented in order to avoid most aliasing artifacts, but may occur for complex transformations after alignment.
Normally the potential artifacts are small and insignificant and the performance boost of using threading is significant. By default threading is enabled.
Currently functions affected by this option are Image.SheetOfLight.Runtime.rectifyAligned and Image.SheetOfLight.Runtime.rectifyAlignedInplace.</desc>
                            <sample for="lua">Image.SheetOfLight.Runtime.setRectificationThreading(runtime, true)</sample>
                            <param name="runtime" type="handle" alias="Image.SheetOfLight.Runtime" desc="The sheet of light runtime manager."/>
                            <param name="enable" type="bool" desc="Select threading should be enabled for the mentioned cases."/>
                        </function>
                        <function name="applyCalibration">
                            <keywords>calibrate, apply, perform, transform</keywords>
                            <links>Image.SheetOfLight.Calibration.estimate, Image.SheetOfLight.Runtime.applyAlignment, Image.SheetOfLight.Runtime.getCalibrationBounds, Image.SheetOfLight.Runtime.mapPoints, Image.SheetOfLight.Runtime.mapProfiles</links>
                            <desc>Apply a calibration model to a raw input image. The result will be two separate images containing X and Z values respectively.
Using this conversion function does not handle skewing due to a non-orthogonal sheet of light or alignment to a global coordinate system.</desc>
                            <sample for="lua">x, z = Image.SheetOfLight.Runtime.applyCalibration(runtime, heightmap)</sample>
                            <param name="runtime" type="handle" alias="Image.SheetOfLight.Runtime" desc="The sheet of light runtime manager."/>
                            <param name="heightmap" type="const object" alias="Image" desc="The input image containing the depth information."/>
                            <param name="xtarget" type="object" multiplicity="?" alias="Image" desc="An image that will be used as target for X-coordinates. If unset a target image is created."/>
                            <param name="ztarget" type="object" multiplicity="?" alias="Image" desc="An image that will be used as target for Z-coordinates. If unset a target image is created."/>
                            <return name="x" type="object" multiplicity="?" alias="Image" desc="An image containing calibrated X-coordinates."/>
                            <return name="z" type="object" multiplicity="?" alias="Image" desc="An image containing calibrated Z-coordinates."/>
                        </function>
                        <function name="getCalibrationBounds">
                            <keywords>min, max</keywords>
                            <links>Image.SheetOfLight.Runtime.applyCalibration, Image.SheetOfLight.Runtime.mapPoints</links>
                            <desc>Retrieve the x and z bounds of a calibration image returned by applyCalibration. If a calibration model has not been set zeros are returned.</desc>
                            <sample for="lua">minX, maxX, minZ, maxZ = Image.SheetOfLight.Runtime.getCalibrationBounds(runtime)</sample>
                            <param name="runtime" type="handle" alias="Image.SheetOfLight.Runtime" desc="The sheet of light runtime manager."/>
                            <return name="minX" type="float" desc="The minimum possible value of the X output from applyCalibration."/>
                            <return name="maxX" type="float" desc="The maximum possible value of the X output from applyCalibration."/>
                            <return name="minZ" type="float" desc="The minimum possible value of the Z output from applyCalibration."/>
                            <return name="maxZ" type="float" desc="The maximum possible value of the Z output from applyCalibration."/>
                        </function>
                        <function name="applyAlignment">
                            <keywords>align, apply, perform, transform, skew</keywords>
                            <links>Image.SheetOfLight.Alignment.estimate2D, Image.SheetOfLight.Alignment.estimate3D, Image.SheetOfLight.Runtime.applyCalibration, Image.SheetOfLight.Runtime.mapPoints, Image.SheetOfLight.Runtime.mapProfiles</links>
                            <desc>Apply a calibration model to a set of calibrated images.
By using this conversion function it's possible to compensate for both skew and/or alignment to a global coordinate system.
The function can be used either with a single rectified heightmap zin or three separate coordinate sources xin, yin and zin.
The xin parameter is optional. If set it must have the same dimensions and type as zin. This image specifies unique x positions for each z-coordinate in zin.
The yin parameter can be used in three different ways.
1) If zero length the pixel origin and size of the input Z image will be used to create a vector of y coordinates.
2) If of length 2 it will be interpreted as {originY, pixelSizeY} for the inputs.
3) Finally it's possible to specify one value per row of xin and zin. This is typically used when there is encoder information for each row of the raw images.</desc>
                            <sample for="lua">x, y, z = Image.SheetOfLight.Runtime.applyAlignment(runtime, zin, xin, yin)</sample>
                            <param name="runtime" type="handle" alias="Image.SheetOfLight.Runtime" desc="The sheet of light runtime manager."/>
                            <param name="zin" type="object" alias="Image" desc="An image containing calibrated Z-coordinates."/>
                            <param name="xin" type="object" multiplicity="?" alias="Image" desc="An image containing calibrated X-coordinates."/>
                            <param name="yin" type="float" multiplicity="*" desc="A vector containing Y-coordinates."/>
                            <param name="xtarget" type="object" multiplicity="?" alias="Image" desc="An image that will be used as target for X-coordinates. If unset a target image is created."/>
                            <param name="ytarget" type="object" multiplicity="?" alias="Image" desc="An image that will be used as target for Y-coordinates. If unset a target image is created."/>
                            <param name="ztarget" type="object" multiplicity="?" alias="Image" desc="An image that will be used as target for Z-coordinates. If unset a target image is created."/>
                            <return name="x" type="object" multiplicity="?" alias="Image" desc="An image containing calibrated and aligned X-coordinates."/>
                            <return name="y" type="object" multiplicity="?" alias="Image" desc="An image containing calibrated and aligned Y-coordinates."/>
                            <return name="z" type="object" multiplicity="?" alias="Image" desc="An image containing calibrated and aligned Z-coordinates."/>
                        </function>
                        <function name="rectifyCalibrated">
                            <keywords>splat, convert, project, heightmap</keywords>
                            <links>PointCloud.toImage, Image.SheetOfLight.Runtime.rectifyCalibratedInplace</links>
                            <desc>Create a range image from a set of coordinate images. The image is formed by projection onto the z-zero plane with normal (0, 0, 1).
The x and y axes of the pointcloud are aligned with the x and y axes of the resulting image.
The employed method is sometimes referred to as splatting, i.e., each point in the pointcloud is splatted onto the plane, writing its z-distance to a splat area.
For this implementation the splat area is dynamically adjusted depending on the world coordinates. Pixels which are not hit by any splats are marked as missing data.
If such holes appear in the generated image try setting the splat size to a value larger than 1.5 to make the pixel sizes larger or use methods to fill missing data in the resulting image(s).
If the splat size is set too large the image may loose detail. In this case try a splat size between 0 and 1.5.
The output image is of type UINT16 and the size and scale of the image is calculated based on the input parameters.
Rectification mode MEAN is only available for zero or a single intensity image. When more than one intensity image is provided using MEAN will block and return an error.

Image world coordinate system handling:
The world coordinate settings, e.g., origin in x, z and pixel sizes are set based on the input parameters to the function.
The Y-axis is copied from the z input image.

Missing data handling:
Pixels in the output range image will be zero (missing data) if no point in the pointcloud had effect over that pixel. Missing data can be reduced by increasing the splat size or by post processing.</desc>
                            <sample for="lua">local heightmap = Image.SheetOfLight.Runtime.rectifyCalibrated(runtime, {x, z, i}, 2200)</sample>
                            <param name="runtime" type="handle" alias="Image.SheetOfLight.Runtime" desc="The sheet of light runtime manager."/>
                            <param name="xzi" type="const object" multiplicity="+" alias="Image" desc="The input X, Z coordinate images and optional intensity image(s)."/>
                            <param name="width" type="int" multiplicity="?" desc="The width of the rectified output image. Defaults to the width of input images."/>
                            <param name="mode" type="enum" multiplicity="?" ref="Image.SheetOfLight.Runtime.rectificationMode" desc="If several points in the pointcloud splat onto the same pixel, the ambiguity must be handled in some way. Default is TOPMOST."/>
                            <param name="minX" type="float" multiplicity="?" desc="Optional minimum X position to represent in the output image. Defaults to minX from Image.SheetOfLight.Runtime.getCalibrationBounds."/>
                            <param name="maxX" type="float" multiplicity="?" desc="Optional maximum X position to represent in the output image. Defaults to maxX from Image.SheetOfLight.Runtime.getCalibrationBounds."/>
                            <param name="splatSize" type="float" multiplicity="?" desc="Increase to reduce holes, decrease to reduce clotting. Default is 1.5."/>
                            <return name="heightmap" type="object" multiplicity="?" alias="Image" desc="Output range image of UINT16 type. Nil on failure."/>
                            <return name="intensity" type="object" multiplicity="[?*]" alias="Image" desc="Output intensity image(s) of the same type as the corresponding input images(s). Nil on failure or if no intensity input was provided."/>
                        </function>
                        <function name="rectifyCalibratedInplace">
                            <keywords>splat, convert, project, heightmap</keywords>
                            <links>PointCloud.toImage, Image.SheetOfLight.Runtime.rectifyCalibrated</links>
                            <desc>Inplace version of Image.SheetOfLight.Runtime.rectifyCalibrated.
This function takes target images and places content into them. Make sure to create target images with an appropriate coordinate system before calling this function.
It may be convenient to call rectifyCalibrated the first time to allocate the target image and after that use this function for performance reasons. Note that if several intensity images are used they must be "splitted", {heightmap, intensity[1], intensity[2],...}</desc>
                            <sample for="lua">local heightmap, intensity = Image.SheetOfLight.Runtime.rectifyCalibratedInplace(runtime, {x, z, i}, {heightmap, intensity})</sample>
                            <param name="runtime" type="handle" alias="Image.SheetOfLight.Runtime" desc="The sheet of light runtime manager."/>
                            <param name="xzi" type="const object" multiplicity="+" alias="Image" desc="The input X, Z coordinate images and optional intensity image(s)."/>
                            <param name="ziref" type="object" multiplicity="[1+]" alias="Image" desc="Target image(s) for rectification."/>
                            <param name="mode" type="enum" multiplicity="?" ref="Image.SheetOfLight.Runtime.rectificationMode" desc="If several points in the pointcloud splat onto the same pixel, the ambiguity must be handled in some way. Default is TOPMOST."/>
                            <param name="splatSize" type="float" multiplicity="?" desc="Increase to reduce holes, decrease to reduce clotting. Default is 1.5."/>
                            <param name="resetOutput" type="bool" multiplicity="?" desc="Select if the target image should be emptied before placing the new content. Default is true."/>
                            <return name="heightmap" type="object" multiplicity="?" alias="Image" desc="Output range image of UINT16 type. Nil on failure."/>
                            <return name="intensity" type="object" multiplicity="[?*]" alias="Image" desc="Output intensity image(s) of the same type as the corresponding input images(s). Nil on failure or if no intensity input was provided."/>
                        </function>
                        <function name="rectifyAligned">
                            <keywords>splat, convert, project, heightmap</keywords>
                            <links>PointCloud.toImage, Image.SheetOfLight.Runtime.rectifyAlignedInplace</links>
                            <desc>Create a range image from a set of coordinate images. The image is formed by projection onto the z-zero plane with normal (0, 0, 1). The x and y axes of the pointcloud are aligned with the x and y axes of the resulting image. The employed method is sometimes referred to as splatting, i.e., each point in the pointcloud is splatted onto the plane, writing its z-distance to a splat area given in pixels. Pixels which are not hit by any splats are marked as missing data. If such holes appear in the generated image try increasing the splat sizes, make the pixel sizes larger or use methods to fill missing data.
The output image is of type UINT16 and the size of the image is calculated based on the input parameters.
Rectification mode MEAN is only available for zero or a single intensity image. When more than one intensity image is provided using MEAN will block and return an error.

Image world coordinate system handling:
The world coordinate settings, e.g., origin in x,y,z and pixel sizes are set based on the input parameters to the function.

Missing data handling:
Pixels in the output range image will be zero (missing data) if no point in the pointcloud had effect over that pixel. Missing data can be reduced by increasing the splat size or by post processing.</desc>
                            <sample for="lua">heightmap = Image.SheetOfLight.Runtime.rectifyAligned(runtime, {x, y, z, i}, box, {0.5, 0.5, 0.02})</sample>
                            <param name="runtime" type="handle" alias="Image.SheetOfLight.Runtime" desc="The sheet of light runtime manager."/>
                            <param name="xyzi" type="const object" multiplicity="+" alias="Image" desc="The input X, Y, Z coordinate images and optional intensity image(s)."/>
                            <param name="box" type="const object" alias="Shape3D" desc="An axis-aligned box. All coordinates within this box are used for creating the image. Can for example be the bounding box of the pointcloud to include all points. The coordinate system origin of the resulting image is defined by the box."/>
                            <param name="pixelSizes" type="float" multiplicity="+" desc="Vector defining the pixel sizes of the output image {x, y, z}. At least one value must be set and will then affect the x and y resolution. The z-resolution will be automatically estimated if unset."/>
                            <param name="splatSizes" type="int" multiplicity="*" desc="Optional vector of splat kernel sizes in the x and y dimensions. To select a splat size of 5 use {5}, for anisotropic splatting use for example {3, 5}. Default is {3}. It must be a odd number larger or equal than one and maximum is 31."/>
                            <param name="mode" type="enum" multiplicity="?" ref="Image.SheetOfLight.Runtime.rectificationMode" desc="If several points in the pointcloud splat onto the same pixel, it must be chosen if the TOPMOST or BOTTOMMOST value is written to the result pixel. Default is TOPMOST."/>
                            <return name="heightmap" type="object" multiplicity="?" alias="Image" desc="Output range image of UINT16 type. Nil on failure."/>
                            <return name="intensity" type="object" multiplicity="[?*]" alias="Image" desc="Output intensity image(s) of the same type as the corresponding input images(s). Nil on failure or if no intensity input was provided."/>
                        </function>
                        <function name="rectifyAlignedInplace">
                            <keywords>splat, convert, project, heightmap</keywords>
                            <links>PointCloud.toImage, Image.SheetOfLight.Runtime.rectifyAligned</links>
                            <desc>Inplace version of Image.SheetOfLight.Runtime.rectifyAligned.
This function takes target images and places content into them. Make sure to create target images with an appropriate coordinate system before calling this function.
It may be convenient to call rectifyAligned the first time to allocate the target image and after that use this function for performance reasons. Note that if several intensity images are used they must be "splitted", {heightmap, intensity[1], intensity[2],...}</desc>
                            <sample for="lua">local heightmap, intensity = Image.SheetOfLight.Runtime.rectifyAlignedInplace(runtime, {x, y, z, i}, {heightmap, intensity})</sample>
                            <param name="runtime" type="handle" alias="Image.SheetOfLight.Runtime" desc="The sheet of light runtime manager."/>
                            <param name="xyzi" type="const object" multiplicity="+" alias="Image" desc="The input X, Y, Z coordinate images and optional intensity image(s)."/>
                            <param name="ziref" type="object" multiplicity="[1+]" alias="Image" desc="Target image(s) for rectification."/>
                            <param name="splatSizes" type="int" multiplicity="*" desc="Optional vector of splat kernel sizes in the x and y dimensions. To select a splat size of 5 use {5}, for anisotropic splatting use for example {3, 5}. Default is {3}. It must be a odd number larger or equal than one and maximum is 31."/>
                            <param name="mode" type="enum" multiplicity="?" ref="Image.SheetOfLight.Runtime.rectificationMode" desc="If several points in the pointcloud splat onto the same pixel, it must be chosen if the TOPMOST or BOTTOMMOST value is written to the result pixel. Default is TOPMOST."/>
                            <param name="resetOutput" type="bool" multiplicity="?" desc="Select if the target image should be emptied before placing the new content. Default is true."/>
                            <return name="heightmap" type="object" multiplicity="?" alias="Image" desc="Output range image of UINT16 type. Nil on failure."/>
                            <return name="intensity" type="object" multiplicity="[?*]" alias="Image" desc="Output intensity image(s) of the same type as the corresponding input images(s). Nil on failure or if no intensity input was provided."/>
                        </function>
                        <function name="mapPoints">
                            <keywords>calibrate, align, apply, transform</keywords>
                            <links>Image.SheetOfLight.Runtime.mapProfiles, Image.SheetOfLight.Runtime.mapRectangle, Image.SheetOfLight.Runtime.mapBox, Image.SheetOfLight.Runtime.applyCalibration, Image.SheetOfLight.Runtime.applyAlignment</links>
                            <desc>Apply a calibration model to a to a set of points.</desc>
                            <sample for="lua">local outputPoints = Image.SheetOfLight.Runtime.mapPoints(runtime, inputPoints, "PIXEL", "CALIBRATED")</sample>
                            <param name="runtime" type="handle" alias="Image.SheetOfLight.Runtime" desc="The sheet of light runtime manager."/>
                            <param name="inputPoints" type="const object" multiplicity="[1+]" alias="Point" desc="A list of points."/>
                            <param name="from" type="enum" ref="Image.SheetOfLight.CoordinateSystem" desc="The source coordinate system in which the inputPoints are."/>
                            <param name="to" type="enum" ref="Image.SheetOfLight.CoordinateSystem" desc="The target coordinate system to which the inputPoints should be transformed."/>
                            <param name="yOrigin" type="float" multiplicity="?" desc="An optional offset to be applied to the Y coordinate in PIXEL coordinates. Unused if points are 2D or if the PIXEL coordinate system is not used."/>
                            <param name="yScale" type="float" multiplicity="?" desc="An optional scale to be applied to the Y coordinate in PIXEL coordinates. Unused if points are 2D or if the PIXEL coordinate system is not used."/>
                            <return name="outputPoints" type="object" multiplicity="[?*]" alias="Point" desc="The list of points after transformation has been applied."/>
                        </function>
                        <function name="mapProfiles">
                            <keywords>calibrate, align, apply, transform</keywords>
                            <links>Image.SheetOfLight.Runtime.mapPoints, Image.SheetOfLight.Runtime.mapRectangle, Image.SheetOfLight.Runtime.mapBox, Image.SheetOfLight.Runtime.applyCalibration, Image.SheetOfLight.Runtime.applyAlignment</links>
                            <desc>Apply a calibration model to a to a single or a set of profiles.</desc>
                            <sample for="lua">local outputProfiles = Image.SheetOfLight.Runtime.mapProfiles(runtime, inputProfiles, "PIXEL", "CALIBRATED")</sample>
                            <param name="runtime" type="handle" alias="Image.SheetOfLight.Runtime" desc="The sheet of light runtime manager."/>
                            <param name="inputProfiles" type="const object" multiplicity="[1+]" alias="Profile" desc="A single or list of profiles."/>
                            <param name="from" type="enum" ref="Image.SheetOfLight.CoordinateSystem" desc="The source coordinate system in which the inputProfiles are."/>
                            <param name="to" type="enum" ref="Image.SheetOfLight.CoordinateSystem" desc="The target coordinate system to which the inputProfiles should be transformed."/>
                            <return name="outputProfiles" type="object" multiplicity="[1+]" alias="Profile" desc="The single or list of profiles after transformation has been applied."/>
                        </function>
                        <function name="mapRectangle">
                            <keywords>calibrate, align, apply, transform</keywords>
                            <links>Image.SheetOfLight.Runtime.mapPoints, Image.SheetOfLight.Runtime.mapProfiles, Image.SheetOfLight.Runtime.applyCalibration, Image.SheetOfLight.Runtime.applyAlignment</links>
                            <desc>Apply a calibration model to a to a Shape Rectangle.
This function can either return a Shape Polyline or a Shape Rectangle depending the polyline bool input.
Due to lens distortion a rectangle is typically not preserved through transformations. Because of this the rectangle is internally represented as a polyline with one additional vertex in between each rectangle vertex.
To return the full Polyline shape set the polyline input to true. To instead get the minimum axis aligned bounding box set it to false.</desc>
                            <sample for="lua">local outputPoints = Image.SheetOfLight.Runtime.mapRectangle(runtime, inputPoints, "PIXEL", "CALIBRATED")</sample>
                            <param name="runtime" type="handle" alias="Image.SheetOfLight.Runtime" desc="The sheet of light runtime manager."/>
                            <param name="rectangle" type="const object" alias="Shape" desc="A Shape of Rectangle type."/>
                            <param name="from" type="enum" ref="Image.SheetOfLight.CoordinateSystem" desc="The source coordinate system in which the rectangle is defined."/>
                            <param name="to" type="enum" ref="Image.SheetOfLight.CoordinateSystem" desc="The target coordinate system to which the rectangle should be transformed."/>
                            <param name="polyline" type="bool" multiplicity="?" desc="An optional bool that toggles the output type."/>
                            <return name="outputShape" type="object" multiplicity="?" alias="Shape" desc="The returned shape after transformations have been applied."/>
                        </function>
                        <function name="mapBox">
                            <keywords>calibrate, align, apply, transform</keywords>
                            <links>Image.SheetOfLight.Runtime.mapPoints, Image.SheetOfLight.Runtime.mapProfiles, Image.SheetOfLight.Runtime.applyCalibration, Image.SheetOfLight.Runtime.applyAlignment</links>
                            <desc>Apply a calibration model to a to a Shape3D Box.
This function returns a new axis aligned Shape3D Box in the target coordinate system.
Due to lens distortion a rectangle is typically not preserved through transformations. Because of this the corners of the box are internally represented by one additional vertex in between each vertex.
The output is the axis aligned bounding box of the resulting vertices.</desc>
                            <sample for="lua">local outputBox = Image.SheetOfLight.Runtime.mapBox(runtime, inputPoints, "PIXEL", "CALIBRATED")</sample>
                            <param name="runtime" type="handle" alias="Image.SheetOfLight.Runtime" desc="The sheet of light runtime manager."/>
                            <param name="box" type="const object" alias="Shape3D" desc="A Shape3D of Box type."/>
                            <param name="from" type="enum" ref="Image.SheetOfLight.CoordinateSystem" desc="The source coordinate system in which the box is defined."/>
                            <param name="to" type="enum" ref="Image.SheetOfLight.CoordinateSystem" desc="The target coordinate system to which the box should be transformed."/>
                            <param name="yOrigin" type="float" multiplicity="?" desc="An optional offset to be applied to the Y coordinate in PIXEL coordinates. Unused if the PIXEL coordinate system is not used."/>
                            <param name="yScale" type="float" multiplicity="?" desc="An optional scale to be applied to the Y coordinate in PIXEL coordinates. Unused if the PIXEL coordinate system is not used."/>
                            <return name="outputBox" type="object" multiplicity="?" alias="Shape" desc="The returned box after transformations have been applied."/>
                        </function>
                        <function name="calculateSensorLUT">
                            <links>Image.SheetOfLight.Runtime.applySensorLUT</links>
                            <desc>Computes a look up table for converting sensor view images to calibrated images. This function takes a short while to run so avoid running it for every image.
The runtime of the Image.SheetOfLight.Runtime.applySensorLUT is mostly affected by the number of samples in the lut. These can be tuned by the use of the input parameters width and height, which specifies the size of the calibrated image returned by applySensorLUT.
If not provided the width of the sensorImage will be used. If the height is unset it will be computed to give approximately the same resolution vertically as horizontally.

Use the two input regions to select an area of interest for the LUT. Both or either can be used.
If both are provided the world region decides the bounds of the output LUT. In this case the sensor region decides what parts of the input image that are used, it may increase the amount of black pixels.
If only a sensor region is provided the minimal bounding box of this region in world coordinates is used as the LUT bounds.
Supplying no region is the same as a sensor region over the full sensor. Generally this means that there will be black bars around the output images due to perspective and lens distortion.</desc>
                            <sample for="lua">local success = Image.SheetOfLight.Runtime.calculateSensorLUT(sensorImage)</sample>
                            <param name="runtime" type="handle" alias="Image.SheetOfLight.Runtime" desc="The sheet of light runtime manager."/>
                            <param name="sensorImage" type="const object" alias="Image" desc="A sensor image."/>
                            <param name="width" type="int" multiplicity="?" desc="The number of horizontal samples in the output image. If left empty the output image will have the same width as the input image."/>
                            <param name="height" type="int" multiplicity="?" desc="The number of vertical samples in the output image. If left empty the number of samples will be calculated to give approximately square pixels in the output."/>
                            <param name="regionSensor" type="const object" multiplicity="?" alias="Shape" desc="A shape of type rectangle that selects the region on the sensor to include in the output. If left empty the whole input image is used."/>
                            <param name="regionWorld" type="const object" multiplicity="?" alias="Shape" desc="A shape of type rectangle that selects the region in the world to include in the output. If left empty all points from the sensor are kept."/>
                            <return name="success" type="bool" desc="True if the look up table was successfully built."/>
                        </function>
                        <function name="applySensorLUT">
                            <links>Image.SheetOfLight.Runtime.calculateSensorLUT</links>
                            <desc>Applies a precomputed sensor look up table to create a calibrated sensor view.
For details about configuration see Image.SheetOfLight.Runtime.calculateSensorLUT.</desc>
                            <sample for="lua">local calibratedImage = Image.SheetOfLight.Runtime.applySensorLUT(sensorImage)</sample>
                            <param name="runtime" type="handle" alias="Image.SheetOfLight.Runtime" desc="The sheet of light runtime manager."/>
                            <param name="sensorImage" type="const object" alias="Image" desc="A sensor image."/>
                            <return name="calibratedImage" type="object" multiplicity="?" alias="Image" desc="A calibrated view of the sensorImage. Nil on failure."/>
                        </function>
                        <function name="toString">
                            <desc>Retrieve a textual representation of the runtime object.</desc>
                            <sample for="lua">str = Image.SheetOfLight.Runtime.toString(runtime)</sample>
                            <param name="runtime" type="handle" alias="Image.SheetOfLight.Runtime" desc="The sheet of light runtime manager."/>
                            <return name="str" type="string" desc="Textual description of the runtime handle."/>
                        </function>
                        <function name="getState">
                            <desc>Returns the calibration state enum. This indicates if calibration and/or alignment have been performed correctly.</desc>
                            <sample for="lua">state = Image.SheetOfLight.Runtime.getState(runtime)</sample>
                            <param name="runtime" type="handle" alias="Image.SheetOfLight.Runtime" desc="The sheet of light runtime manager."/>
                            <return name="state" type="enum" ref="Image.SheetOfLight.Model.State" desc="The state of the loaded model."/>
                        </function>
                    </serves>
                </crown>
            </crown>
            <crown name="CodeReader">
                <trait>released</trait>
                <desc>A code reader engine to decode 1D, 2D and Postal codes with optional preceding segmentation as well as single code reader. Generally, two different approaches exist.
The first option, which is also the most common one, is to use the code reader engine. To read a code, the corresponding single code reader has to be created, parametrized (if necessary)
and handed to the engine (setDecoder). When starting the decoding, first an (optional) image segmentation is processed to determine “interesting” regions within the image.
Secondly, the code reader is started using the information acquired during the segmentation process (in case of an inactive segmentation, a full image decoding will be used instead).
By using this approach, the user is not only able to use the included segmentation but also to set (and read) multiple code types within the image at once.
In most cases, the code is printed on an object or label fully or partly visible in the input image. In this case a preceding segmentation is also helpful to keep calculation times low.
The code reader engine is started with Image.CodeReader.decode().

The second approach is to use the single code reader itself. In this case the user does not have the possibility to use the segmentation from the code reader engine but needs to hand over
the code’s coordinates by his self (or to use the full image decoding). In case the code almost fills the complete input image or the code region is well known in advance, the second approach
is likely to be the faster one. The single code reader e.g. the Datamatrix code reder is started using Image.CodeReader.DataMatrix.decode().

Note that some of the settings exist for the code reader as well as for the engine. When using the engine, its parameters are prioritized over the code reader parameters and possible
conflicting code reader settings will be ignored.</desc>
                <enum name="DecoderSettingMode">
                    <item desc="Replace the old decoders by the new ones. 'Replace' also accepted.">REPLACE</item>
                    <item desc="Append the new decoders to the existing ones. 'Append' also accepted.">APPEND</item>
                    <item desc="Remove all the decoders. 'Remove' also accepted.">REMOVE</item>
                </enum>
                <enum name="DecoderType">
                    <item>BARCODE</item>
                    <item>POSTAL</item>
                    <item>PDF417</item>
                    <item>DMX</item>
                    <item>QR</item>
                    <item>MAXICODE</item>
                    <item>DOTCODE</item>
                    <item>AZTEC</item>
                </enum>
                <enum name="DiagnosisOutputType">
                    <item>NONE</item>
                    <item>XMLTREE</item>
                    <item>LOGGER</item>
                </enum>
                <enum name="DecoderLogLevel">
                    <item>OFF</item>
                    <item>SEVERE</item>
                    <item>WARNING</item>
                    <item>INFO</item>
                    <item>FINE</item>
                    <item>FINER</item>
                    <item>FINEST</item>
                </enum>
                <enum name="CodeBackground">
                    <item desc="'White' also accepted.">WHITE</item>
                    <item desc="'Black' also accepted.">BLACK</item>
                    <item desc="'Both' also accepted.">BOTH</item>
                </enum>
                <enum name="CodeSize">
                    <item desc="'Small' also accepted.">SMALL</item>
                    <item desc="'Middle' also accepted.">MIDDLE</item>
                    <item desc="'Big' also accepted.">BIG</item>
                    <item desc="'VeryBig' also accepted.">VERYBIG</item>
                </enum>
                <enum name="ScanningMode">
                    <item desc="'Full' also accepted.">FULL</item>
                    <item desc="'Partial' also accepted.">PARTIAL</item>
                    <item desc="'Intelligent' also accepted. This is the default value.">INTELLIGENT</item>
                </enum>
                <enum name="HistoSpreadingMode">
                    <item desc="'Disabled' also accepted.">DISABLED</item>
                    <item desc="'HistoMean' also accepted.">HISTOMEAN</item>
                    <item desc="'HistoValues' also accepted.">HISTOVALUES</item>
                </enum>
                <enum name="CodeAppearance">
                    <item desc="'Normal' still accepted.">NORMAL</item>
                    <item desc="'Mirrored' still accepted.">MIRRORED</item>
                    <item desc="'Both' still accepted.">BOTH</item>
                </enum>
                <enum name="AutoSetupResult">
                    <item desc="Method not yet implemented. 'NotImplemented' still accepted.">NOTIMPLEMENTED</item>
                    <item desc="Missing image or something similar. 'InvalidParam' still accepted.">INVALIDPARAM</item>
                    <item desc="Missing or non-computable additional data. 'InvalidAdditionalData' still accepted.">INVALIDADDITIONALDATA</item>
                    <item desc="Operation cancelled. 'Cancel' still accepted.">CANCEL</item>
                    <item desc="Operation successfully finished">OK</item>
                    <item desc="Error during operation. 'Error' still accepted.">ERROR</item>
                    <item desc="Unknown error or problem. 'Unknown' still accepted.">UNKNOWN</item>
                </enum>
                <enum name="CodeResultsSettingIndex">
                    <desc>The possible indices into the functions \"setCodeResultsSetting\" and \"getCodeResultsSetting\" that set and get the additional code result handling parameters</desc>
                    <item desc="Placeholder only if a wrong index name is used">NONE</item>
                    <item desc="Index setting the small region ratio threshold when removing an Undecodables">RATIOSMALLREGION</item>
                    <item desc="Index setting the common region ratio threshold when removing an Undecodables">RATIOBOTHREGIONS</item>
                </enum>
                <enum name="DecodeAdditionalResultOption">
                    <desc>Describes the additionally desired results of the function \"decodeExperimental\"</desc>
                    <item desc="Placeholder if nothing special is desired">NONE</item>
                    <item desc="Retrieve a clone of the internally used image together with its FPGA data">RETRIEVECLONEDIMAGE</item>
                    <item desc="Retrieve a detailed time list of the several decoding steps">RETRIEVEDETAILEDTIMELIST</item>
                </enum>
                <serves>
                    <event name="OnNewResult">
                        <desc>The event which is thrown for every (new) result read in decode or decodeBlock.</desc>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The code reader instance"/>
                        <param name="result" type="const object" multiplicity="1" alias="Image.CodeReader.Result" desc="the code result"/>
                    </event>
                    <function name="create">
                        <desc>Creates a new code reader instance</desc>
                        <sample for="lua">deco = Image.CodeReader.create()</sample>
                        <return name="handle" type="handle" alias="Image.CodeReader" desc="The handle for the new decoder instance"/>
                    </function>
                    <function name="getVersion">
                        <desc>Gets the decoder version used for the current implementation.</desc>
                        <sample for="lua">version = Image.CodeReader.getVersion()</sample>
                        <return name="version" type="string" desc="The current version as a string of form MM.mm.ss.bb"/>
                    </function>
                    <function name="setImage">
                        <trait>hidden</trait>
                        <desc>Sets the image on which the decoder works.</desc>
                        <sample for="lua">Image.CodeReader.setImage(deco, image)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="image" type="const object" alias="Image" desc="The image the decoder works on"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="setRegion">
                        <desc>Sets the region of interest where the decoder should search. If no region is given the whole image is searched.</desc>
                        <sample for="lua">Image.CodeReader.setRegion(deco,region)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="region" type="const object" multiplicity="?" alias="Shape.Composite" desc="The region of interest the decoder shall use. It can be nil also - in this case the entire image is used."/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="setDecoder">
                        <desc>Sets the single decoders. If no decoder is given, all the single decoders are set to NULL.</desc>
                        <sample for="lua">local success, error = Image.CodeReader.setDecoder(deco,"APPEND",dmxDecoder,barcodeDecoder)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="settingMode" type="enum" ref="DecoderSettingMode" desc="The mode how the decoders are to be handled"/>
                        <param name="decoder1" type="object" multiplicity="?" desc="The (optional) first decoder to be set"/>
                        <param name="decoder2" type="object" multiplicity="?" desc="The (optional) second decoder to be set"/>
                        <param name="decoder3" type="object" multiplicity="?" desc="The (optional) third decoder to be set"/>
                        <param name="decoder4" type="object" multiplicity="?" desc="The (optional) fourth decoder to be set"/>
                        <param name="decoder5" type="object" multiplicity="?" desc="The (optional) fifth decoder to be set"/>
                        <param name="decoder6" type="object" multiplicity="?" desc="The (optional) sixth decoder to be set"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful (all the arguments are decoders or Remove was chosen)"/>
                        <return name="error" type="int" desc="An error value encoding those object indices that are not decoders in Append or Replace mode"/>
                    </function>
                    <function name="getDecoder">
                        <desc>Gets the appropriate decoder already installed.</desc>
                        <sample for="lua">local dmxHandle = Image.CodeReader.getDecoder(deco, "DMX")</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="decoderType" type="enum" ref="DecoderType" desc="The desired decoder type (name)"/>
                        <return name="decoder" type="handle" multiplicity="?" desc="The desired decoder if installed. Otherwise no return value."/>
                    </function>
                    <function name="setHistoSpreadingMode">
                        <desc>Sets the histogram spreading mode value. If enabled additional histogram spreading is used.</desc>
                        <sample for="lua">local success = Image.CodeReader.setHistoSpreadingMode(deco,"HistoMean")</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="histoSpreadingMode" type="enum" ref="HistoSpreadingMode" desc="The desired value."/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getHistoSpreadingMode">
                        <desc>Retrieves the histoSpreadingMode value.</desc>
                        <sample for="lua">local histoSpreadingMode = Image.CodeReader.getHistoSpreadingMode(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="histoSpreadingMode" type="enum" ref="HistoSpreadingMode" desc="The value set."/>
                    </function>
                    <function name="setLocalHistoSpreadingActive">
                        <desc>Spreads the contrast individually for each code region. Only applicable for barcodes. Does not affect segmentation,
therefore for best reading results at low contrast codes also activate global contrast spreading with setHistoSpreadingMode.</desc>
                        <sample for="lua">local success = Image.CodeReader.setLocalHistoSpreadingActive(deco,true)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="localHistoSpreadingActive" type="bool" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getLocalHistoSpreadingActive">
                        <desc>Returns if local contrast spreading is enabled.</desc>
                        <sample for="lua">local active = Image.CodeReader.getLocalHistoSpreadingActive(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="localHistoSpreadingActive" type="bool" desc="The value currently set"/>
                    </function>
                    <function name="setCodeContrast1D">
                        <desc>Sets the code contrast 1D in percent of the pixel range (0..255), i.e. between 0 and 100. Default value is 20.</desc>
                        <sample for="lua">local success = Image.CodeReader.setCodeContrast1D(deco,25)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="codeContrast1d" type="int" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getCodeContrast1D">
                        <desc>Retrieves the code contrast 1D in percent of the pixel range (0..255), i.e. between 0 and 100. Default value is 20.</desc>
                        <sample for="lua">local contrast1Dpercent = Image.CodeReader.getCodeContrast1D(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="codeContrast1d" type="int" desc="The value currently set"/>
                    </function>
                    <function name="setCodeBackground1D">
                        <trait>deprecated</trait>
                        <desc>Sets the background mode for 1D</desc>
                        <sample for="lua">local success = Image.CodeReader.setCodeBackground1D(deco,"White")</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="codeBk1d" type="enum" ref="CodeBackground" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getCodeBackground1D">
                        <trait>deprecated</trait>
                        <desc>Retrieves the background mode for 1D</desc>
                        <sample for="lua">local codeBackground1D = Image.CodeReader.getCodeBackground1D(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="codeBk1d" type="enum" ref="CodeBackground" desc="The value currently set"/>
                    </function>
                    <function name="setCodeSize1D">
                        <trait>deprecated</trait>
                        <desc>Sets the approximate code size for 1D. Default value is "SMALL". This function is deprecated and has no longer any impact on the decoder settings.</desc>
                        <sample for="lua">local success = Image.CodeReader.setCodeSize1D(deco,"MIDDLE")</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="codeSize1d" type="enum" ref="CodeSize" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getCodeSize1D">
                        <trait>deprecated</trait>
                        <desc>Retrieves the approximate code size for 1D. Default value is "SMALL". This function is deprecated.</desc>
                        <sample for="lua">local codeSize1d = Image.CodeReader.getCodeSize1D(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="codeSize1d" type="enum" ref="CodeSize" desc="The value currently set."/>
                    </function>
                    <function name="setJoinSplitBars">
                        <desc>Sets the joinSplitBars1d flag. Default value is 'true'.</desc>
                        <sample for="lua">local success = Image.CodeReader.setJoinSplitBars(deco,true)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="joinSplitBars1d" type="bool" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getJoinSplitBars">
                        <desc>Retrieves the joinSplitBars1d flag. Default value is 'true'.</desc>
                        <sample for="lua">local joinSplitBars = Image.CodeReader.getJoinSplitBars(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="joinSplitBars1d" type="bool" desc="The value currently set"/>
                    </function>
                    <function name="setTireReading">
                        <desc>Sets the tire reading flag for barcode reading</desc>
                        <sample for="lua">local success = Image.CodeReader.setTireReading(deco,true)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="lowScoreActive1d" type="bool" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getTireReading">
                        <desc>Retrieves the tire reading flag</desc>
                        <sample for="lua">local active = Image.CodeReader.getTireReading(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="lowScoreActive1d" type="bool" desc="The value currently set"/>
                    </function>
                    <function name="setTinyStackedCodeActive">
                        <desc>Makes segmentation more sensitive for codes with small heights and closely stacked codes. Default value is 'false'.</desc>
                        <sample for="lua">local success = Image.CodeReader.setTinyStackedCodeActive(deco,true)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="tinyStackedCodeActive" type="bool" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getTinyStackedCodeActive">
                        <desc>Returns if segmentation refinement for tiny and stacked codes is active.</desc>
                        <sample for="lua">local active = Image.CodeReader.getTinyStackedCodeActive(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="tinyStackedCodeActive" type="bool" desc="The value currently set"/>
                    </function>
                    <function name="setSuperResolutionActive">
                        <desc>Optimization for reading 1D codes with a resolution smaller than 1.4 pixels per module. Default value is 'false'.</desc>
                        <sample for="lua">local success = Image.CodeReader.setSuperResolutionActive(deco,true)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="superResolutionActive" type="bool" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getSuperResolutionActive">
                        <desc>Returns if SuperResolution algorithm is enabled. Its default value is 'false'.</desc>
                        <sample for="lua">local active = Image.CodeReader.getSuperResolutionActive(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="superResolutionActive" type="bool" desc="The value currently set"/>
                    </function>
                    <function name="setAbortOnReachedMr">
                        <trait>deprecated</trait>
                        <desc>Sets a flag whether to abort if the number of multireads has been reached (1D only)</desc>
                        <sample for="lua">local success = Image.CodeReader.setAbortOnReachedMr(deco,true)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="abortOnReachedMr1d" type="bool" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getAbortOnReachedMr">
                        <trait>deprecated</trait>
                        <desc>Retrieves the flag whether to abort if the number of multireads has been reached (1D only)</desc>
                        <sample for="lua">local abortOnReachedMr = Image.CodeReader.getAbortOnReachedMr(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="abortOnReachedMr" type="bool" desc="The value currently set"/>
                    </function>
                    <function name="setIso15416Verifier">
                        <trait>deprecated</trait>
                        <desc>Sets the Iso 15416 verifier flag for all the 1D decoders. Deprecated -- use the function of the Image.CodeReader.Barcode crown instead.</desc>
                        <sample for="lua">local success = Image.CodeReader.setIso15416Verifier(deco, false)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="iso15416Verifier" type="bool" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getIso15416Verifier">
                        <trait>deprecated</trait>
                        <desc>Retrieves the Iso 15416 verifier flag for all the 1D decoders. Deprecated -- use the function of the Image.CodeReader.Barcode crown instead.</desc>
                        <sample for="lua">local iso15416Verifier = Image.CodeReader.getIso15416Verifier(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="iso15416Verifier" type="bool" desc="The value currently set"/>
                    </function>
                    <function name="setBadBarcodeQuality">
                        <desc>Sets the bad code quality flag for the 1D decoder(s).</desc>
                        <sample for="lua">local success = Image.CodeReader.setBadBarcodeQuality(deco,true)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="badBarcodeQuality" type="bool" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getBadBarcodeQuality">
                        <desc>Retrieves the bad code quality flag for the 1D decoder(s).</desc>
                        <sample for="lua">local badBarcodeQuality = Image.CodeReader.getBadBarcodeQuality(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="badBarcodeQuality" type="bool" desc="The value currently set"/>
                    </function>
                    <function name="setBlurredCodes">
                        <desc>Sets the blurred codes flag for the 1D decoder(s).</desc>
                        <sample for="lua">success = Image.CodeReader.setBlurredCodes(deco,true)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="blurredCodes" type="bool" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getBlurredCodes">
                        <desc>Retrieves the blurred codes flag for the 1D decoder(s).</desc>
                        <sample for="lua">local blurredcodes = Image.CodeReader.getBlurredCodes(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="blurredCodes" type="bool" desc="The value currently set"/>
                    </function>
                    <function name="setFilterTrayStructure">
                        <desc>Enables or disables wood texture (tray structure) filtering.</desc>
                        <sample for="lua">local success = Image.CodeReader.setFilterTrayStructure(deco,true)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="filterTrayStructure" type="bool" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getFilterTrayStructure">
                        <desc>Retrieves the activation state of wood texture (tray structure) filtering.</desc>
                        <sample for="lua">local filtertraystructure = Image.CodeReader.getFilterTrayStructure(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="filterTrayStructure" type="bool" desc="The value currently set"/>
                    </function>
                    <function name="setMisreadOptimizationAtBorder">
                        <desc>Enables or disables reduction of misreads due to codes located at the image border. Default value is false.</desc>
                        <sample for="lua">local success = Image.CodeReader.setMisreadOptimizationAtBorder(deco,true)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="misreadOptimizationAtBorder" type="bool" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getMisreadOptimizationAtBorder">
                        <desc>Retrieves the activation state of misread reduction due to codes located at the image border. Default value is false.</desc>
                        <sample for="lua">local opti = Image.CodeReader.getMisreadOptimizationAtBorder(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="misreadOptimizationAtBorder" type="bool" desc="The value currently set"/>
                    </function>
                    <function name="setLogisticSegmentation">
                        <desc>Enables or disables logistics false-positive filtering. Default value is false.</desc>
                        <sample for="lua">local success = Image.CodeReader.setLogisticSegmentation(deco,true)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="logisticSegmentation" type="bool" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getLogisticSegmentation">
                        <desc>Retrieves the activation state of logistics false-positive filtering. Default value is false.</desc>
                        <sample for="lua">local logisticSegmentation = Image.CodeReader.getLogisticSegmentation(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="logisticSegmentation" type="bool" desc="The value currently set"/>
                    </function>
                    <function name="setDecode2DBefore1D">
                        <trait>hidden</trait>
                        <desc>Enables or disables the code reading order 2D before 1D. Default value is false.</desc>
                        <sample for="lua">local success = Image.CodeReader.setDecode2DBefore1D(deco,true)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="decode2Dbefore1D" type="bool" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getDecode2DBefore1D">
                        <desc>Retrieves the activation state code reading 2D before 1D. Default value is false.</desc>
                        <sample for="lua">local decode2Dbefore1D = Image.CodeReader.getDecode2DBefore1D(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="decode2Dbefore1D" type="bool" desc="The value currently set"/>
                    </function>
                    <function name="setOptimizationWideBars1D">
                        <desc>Enables or disables reading very big 1D-codes with wide bars. Default value is false.</desc>
                        <sample for="lua">local success = Image.CodeReader.setOptimizationWideBars1D(deco,true)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="optimizationWideBars1D" type="bool" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getOptimizationWideBars1D">
                        <desc>Retrieves the activation state of wide bar optimization (1D-codes). Default value is false.</desc>
                        <sample for="lua">local optiWideBars1D = Image.CodeReader.getOptimizationWideBars1D(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="optimizationWideBars1D" type="bool" desc="The value currently set"/>
                    </function>
                    <function name="setBrightBackground">
                        <desc>Optimization for codes on metal tray sorters. Ignores image parts (tiles)
with a grey value average above the given threshold. Metal trays typically have a much higher
average greyvalue than the code. Default is activation false and 255 for the threshold value.</desc>
                        <sample for="lua">local success = Image.CodeReader.setBrightBackground(deco, true, 251)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="brightBackgroundActive" type="bool" desc="The desired activation status"/>
                        <param name="brightBackgroundThreshold" type="int" multiplicity="?" constraint="0-255" desc="The desired threshold value (optional). Must be between 0 and 255."/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getBrightBackground">
                        <desc>Retrieves the state of bright background activation status and threshold. Default value is false and 255.</desc>
                        <sample for="lua">local active, threshold = Image.CodeReader.getBrightBackground(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="brightBackgroundActive" type="bool" desc="The activation status currently set"/>
                        <return name="brightBackgroundThreshold" type="int" desc="The threshold value currently set"/>
                    </function>
                    <function name="setScanningMode">
                        <desc>Sets the scanning mode for 1D codes. Default value is 'INTELLIGENT'.</desc>
                        <sample for="lua">local success = Image.CodeReader.setScanningMode(deco,"FULL")</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="scanningMode" type="enum" ref="ScanningMode" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getScanningMode">
                        <desc>Retrieves the scanning mode for all the 1D decoders. Default value is 'INTELLIGENT'.</desc>
                        <sample for="lua">local scanningmode = Image.CodeReader.getScanningMode(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="scanningMode" type="enum" ref="ScanningMode" desc="The value currently set"/>
                    </function>
                    <function name="setScanningDensity">
                        <desc>Sets the scanning density for the 1D decoder(s).</desc>
                        <sample for="lua">local success = Image.CodeReader.setScanningDensity(deco,10)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="scanningDensity" type="int" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getScanningDensity">
                        <desc>Retrieves the scanning density for all the 1D decoders</desc>
                        <sample for="lua">local scanningdensity = Image.CodeReader.getScanningDensity(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="scanningDensity" type="int" desc="The value currently set"/>
                    </function>
                    <function name="setCodeSizeFilter">
                        <desc>Filters out codes that are outside of the specified dimensions. The dimensions can be
defined in setAcceptedCodeHeightMax, setAcceptedCodeHeightMin, setAcceptedCodeWidthMax
and setAcceptedCodeWidthMin.</desc>
                        <sample for="lua">local success = Image.CodeReader.setCodeSizeFilter(deco,true)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="codeSizeFilter" type="bool" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getCodeSizeFilter">
                        <desc>Retrieves the code size filter flag for all the 1D decoders</desc>
                        <sample for="lua">local codesizefilter = Image.CodeReader.getCodeSizeFilter(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="codeSizeFilter" type="bool" desc="The value currently set"/>
                    </function>
                    <function name="setAcceptedCodeWidthMin">
                        <desc>Sets the minimal accepted code width assuming the CodeSizeFilter flag is activated.</desc>
                        <sample for="lua">local success = Image.CodeReader.setAcceptedCodeWidthMin(deco,22)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="acceptedCodeWidthMin" type="int" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getAcceptedCodeWidthMin">
                        <desc>Retrieves the minimal accepted code width</desc>
                        <sample for="lua">local acceptedCodeWidthMin = Image.CodeReader.getAcceptedCodeWidthMin(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="acceptedCodeWidthMin" type="int" desc="The value currently set"/>
                    </function>
                    <function name="setAcceptedCodeWidthMax">
                        <desc>Sets the maximal accepted code width assuming the CodeSizeFilter flag is activated.</desc>
                        <sample for="lua">local success = Image.CodeReader.setAcceptedCodeWidthMax(deco,112)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="acceptedCodeWidthMax" type="int" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getAcceptedCodeWidthMax">
                        <desc>Retrieves the minimal accepted code width</desc>
                        <sample for="lua">local acceptedCodeWidthMax = Image.CodeReader.getAcceptedCodeWidthMax(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="acceptedCodeWidthMax" type="int" desc="The value currently set"/>
                    </function>
                    <function name="setAcceptedCodeHeightMin">
                        <desc>Sets the minimal accepted code height assuming the CodeSizeFilter flag is activated.</desc>
                        <sample for="lua">local success = Image.CodeReader.setAcceptedCodeHeightMin(deco,8)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="acceptedCodeHeightMin" type="int" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getAcceptedCodeHeightMin">
                        <desc>Retrieves the minimal accepted code height</desc>
                        <sample for="lua">local acceptedCodeHeightMin = Image.CodeReader.getAcceptedCodeHeightMin(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="acceptedCodeHeightMin" type="int" desc="The value currently set"/>
                    </function>
                    <function name="setAcceptedCodeHeightMax">
                        <desc>Sets the maximal accepted code height assuming the CodeSizeFilter flag is activated.</desc>
                        <sample for="lua">local success = Image.CodeReader.setAcceptedCodeHeightMax(deco,20)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="acceptedCodeHeightMax" type="int" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getAcceptedCodeHeightMax">
                        <desc>Retrieves the minimal accepted code height</desc>
                        <sample for="lua">local acceptedCodeHeightMax = Image.CodeReader.getAcceptedCodeHeightMax(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="acceptedCodeHeightMax" type="int" desc="The value currently set"/>
                    </function>
                    <function name="setCodeContrast2D">
                        <desc>Sets the codeContrast2d value in percent of the pixel range (0..255), i.e. between 0 and 100. Default value is 20.</desc>
                        <sample for="lua">local success = Image.CodeReader.setCodeContrast2D(deco,50)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="codeContrast2d" type="int" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getCodeContrast2D">
                        <desc>Gets the codeContrast2d value in percent of the pixel range (0..255), i.e. between 0 and 100. Default value is 20.</desc>
                        <sample for="lua">local contrast2Dpercent = Image.CodeReader.getCodeContrast2D(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="codeContrast2d" type="int" desc="The value currently set"/>
                    </function>
                    <function name="setCodeBackground2D">
                        <trait>deprecated</trait>
                        <desc>Sets the codeBk2d value</desc>
                        <sample for="lua">local success = Image.CodeReader.setCodeBackground2D(deco,"Both")</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="codeBk2d" type="enum" ref="CodeBackground" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getCodeBackground2D">
                        <trait>deprecated</trait>
                        <desc>Gets the codeBk2d value</desc>
                        <sample for="lua">local codeBackground2D = Image.CodeReader.getCodeBackground2D(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="codeBk2d" type="enum" ref="CodeBackground" desc="The value currently set"/>
                    </function>
                    <function name="setCodeAppearance2D">
                        <trait>deprecated</trait>
                        <desc>Sets the codeAppearance2d value</desc>
                        <sample for="lua">local success = Image.CodeReader.setCodeAppearance2D(deco,"Mirrored")</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="codeAppearance2d" type="enum" ref="CodeAppearance" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getCodeAppearance2D">
                        <trait>deprecated</trait>
                        <desc>Retrieves the codeAppearance2d value</desc>
                        <sample for="lua">local codeAppearance2D = Image.CodeReader.getCodeAppearance2D(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="codeAppearance2d" type="enum" ref="CodeAppearance" desc="The value currently set"/>
                    </function>
                    <function name="setCodeSize2D">
                        <desc>Sets the codeSize2d value. Default value is "SMALL".</desc>
                        <sample for="lua">local success = Image.CodeReader.setCodeSize2D(deco,"Big")</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="codeSize2d" type="enum" ref="CodeSize" desc="The desired value"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getCodeSize2D">
                        <desc>Gets the codeSize2d value. Default value is "SMALL".</desc>
                        <sample for="lua">local codeSize2D = Image.CodeReader.getCodeSize2D(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="codeSize2d" type="enum" ref="CodeSize" desc="The desired value"/>
                    </function>
                    <function name="setNumThreads">
                        <desc>Sets the number of threads internally used.</desc>
                        <sample for="lua">local success = Image.CodeReader.setNumThreads(deco,2)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="numThreads" type="int" desc="The desired number of used threads"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="setDiagOutputType">
                        <trait>hidden</trait>
                        <desc>Sets the diagnose type of the output object. Default is 'NONE' (no change).</desc>
                        <sample for="lua">local success = Image.CodeReader.setDiagOutputType(deco,"XMLTREE")</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="diagOutputType" type="enum" ref="DiagnosisOutputType" desc="The desired diagnosis output type"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getDiagOutputType">
                        <trait>hidden</trait>
                        <desc>Gets the diagnosis output type of the output object. Default is 'NONE'.</desc>
                        <sample for="lua">local level = Image.CodeReader.getDiagOutputType(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="diagOutputType" type="enum" ref="DiagnosisOutputType" desc="The diagnosis output type currently set"/>
                    </function>
                    <function name="setDiagLevel">
                        <trait>hidden</trait>
                        <desc>Sets the diagnosis level of the output object</desc>
                        <sample for="lua">local success = Image.CodeReader.setDiagLevel(deco,2)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="diagLevel" type="int" desc="The desired level of diagnosis"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getDiagLevel">
                        <trait>hidden</trait>
                        <desc>Gets the diagnosis level of the output object</desc>
                        <sample for="lua">local level = Image.CodeReader.getDiagLevel(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="diagLevel" type="int" desc="The level of diagnosis currently set"/>
                    </function>
                    <function name="setLogLevel">
                        <trait>hidden</trait>
                        <desc>Sets the logger level of the output object if logger output is active. Default value is 'OFF'.</desc>
                        <sample for="lua">local success = Image.CodeReader.setLogLevel(deco,"FINEST")</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="logLevel" type="enum" ref="DecoderLogLevel" desc="The desired logging level"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getLogLevel">
                        <trait>hidden</trait>
                        <desc>Retrieves the logger level of the output object if logger output is active. Default value is 'OFF'.</desc>
                        <sample for="lua">local level = Image.CodeReader.getLogLevel(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="logLevel" type="enum" ref="DecoderLogLevel" desc="The level of diagnosis currently set"/>
                    </function>
                    <function name="setCodeResultsSetting">
                        <trait>hidden</trait>
                        <desc>Sets an additonal Result Setting value.</desc>
                        <sample for="lua">local success = Image.CodeReader.setCodeResultsSetting(deco, "RATIOSMALLREGION", 0.25)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="settingIndex" type="enum" ref="CodeResultsSettingIndex" desc="The index for which the value of interest is to be set"/>
                        <param name="settingValue" type="auto" desc="The desired value belonging to the given index."/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getCodeResultsSetting">
                        <trait>hidden</trait>
                        <desc>Retrieves an additonal Result Setting value.</desc>
                        <sample for="lua">local settingValue = Image.CodeReader.getCodeResultsSetting(deco, "RATIOSMALLREGION")</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="settingIndex" type="enum" ref="CodeResultsSettingIndex" desc="The index for which the value of interest is to be retrieved"/>
                        <return name="settingValue" type="auto" desc="The value the user is interested in."/>
                    </function>
                    <function name="register">
                        <trait>released</trait>
                        <desc>This function is used to register for new results . The event name is specified as parameter.</desc>
                        <sample for="lua">local success = Image.CodeReader.register(deco, "OnNewResult", HandleNewResult)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The code reade instance to be used"/>
                        <param name="eventname" type="string" desc="The event to register to."/>
                        <param name="callback" type="string" alias="function" desc="name of function to call upon the event. It expects one argument of type (constant) Image.CodeReader.Result"/>
                        <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                    </function>
                    <function name="deregister">
                        <trait>released</trait>
                        <desc>This function is used to deregister from any registered event of the handle.</desc>
                        <sample for="lua">local success = Image.CodeReader.deregister(deco, "OnNewResult", HandleNewResult)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to deregister from"/>
                        <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                        <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                    </function>
                    <function name="decode">
                        <desc>Decodes the image and returns the decoded result and/or provides the results in the appropriate OnNewResult event.</desc>
                        <sample for="lua">local codes = Image.CodeReader.decode(deco, image)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="image" type="const object" alias="Image" desc="The image the decoder works on"/>
                        <return name="codes" type="const object" multiplicity="+" alias="Image.CodeReader.Result" desc="The complete result list, a list of ImageDecoderResult-s"/>
                        <return name="durationMs" type="int" desc="The overall time in ms for the current decoding process"/>
                    </function>
                    <function name="decodeExperimental">
                        <trait>hidden</trait>
                        <desc>Decodes the image and returns the decoded result and/or provides the results in the appropriate OnNewResult event.</desc>
                        <sample for="lua">local codes, duration, clonedImage = Image.CodeReader.decodeExperimental(deco, image, true)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="image" type="const object" alias="Image" desc="The image the decoder works on"/>
                        <param name="additionalResultOptions" type="enum" multiplicity="*" ref="DecodeAdditionalResultOption" desc="A set of additional options that describes the additionally desired results."/>
                        <return name="codes" type="const object" multiplicity="+" alias="Image.CodeReader.Result" desc="The complete result list, a list of ImageDecoderResult-s"/>
                        <return name="durationMs" type="int" desc="The overall time in ms for the current decoding process"/>
                        <return name="additionalResults" type="auto" multiplicity="*" desc="The additional results in a vector, e.g. the clone of the internally used image together with its FPGA data or/and the detailed duration times."/>
                    </function>
                    <function name="setTimeout">
                        <desc>Sets a timeout in milliseconds for aborting the code reader. Can be used only when a single image is given to the code reader.
A value of 0 or a negative value disables the timeout.</desc>
                        <sample for="lua">local success = Image.CodeReader.setTimeout(reader, timeout)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="timeout" type="int" desc="The timeout value in milliseconds"/>
                        <return name="success" type="bool" desc="A flag whether setting was successful"/>
                    </function>
                    <function name="getDiagnosis">
                        <trait>hidden</trait>
                        <desc>Gets the diagnosis object after decoding. The object is released and so the function shall be called only once.</desc>
                        <sample for="lua">local diag = Image.CodeReader.getDiagnosis(deco)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <return name="diagnosis" type="binary" desc="The released diagnosis object."/>
                    </function>
                    <function name="autoSetup">
                        <trait>hidden</trait>
                        <desc>Runs an automatic setup on the image</desc>
                        <sample for="lua">local result = Image.CodeReader.autoSetup(deco, image)</sample>
                        <param name="handle" type="handle" alias="Image.CodeReader" desc="The instance to use"/>
                        <param name="image" type="const object" alias="Image" desc="The image the decoder works on"/>
                        <return name="autosetupresult" type="enum" ref="AutoSetupResult" desc="One of the possible results of the autoseup."/>
                    </function>
                </serves>
                <crown name="Barcode">
                    <trait>released</trait>
                    <desc>The general Barcode decoder with several symbologies.</desc>
                    <enum name="SymbologySettingMode">
                        <item desc="Replace the old symbologies by the new ones. 'Replace' also accepted.">REPLACE</item>
                        <item desc="Append the new symbologies to the existing ones. 'Append' also accepted.">APPEND</item>
                        <item desc="Remove all the symbologies. 'Remove' also accepted.">REMOVE</item>
                    </enum>
                    <enum name="SymbologyDecoderTypeEnum">
                        <item>CODABAR</item>
                        <item>CODE128</item>
                        <item>PROF1D</item>
                        <item>CODE39</item>
                        <item>CODE93</item>
                        <item>GS1</item>
                        <item>INTERLEAVED25</item>
                        <item>PHARMA</item>
                        <item>EANUPC</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <desc>Creates a new decoder instance</desc>
                            <sample for="lua">deco = Image.CodeReader.Barcode.create()</sample>
                            <return name="handle" type="handle" alias="Image.CodeReader.Barcode" desc="The handle for the new barcode decoder instance"/>
                        </function>
                        <function name="setIso15416Verifier">
                            <desc>Enables or disables code verification derived from ISO 15416 for barcodes. Default value is 'false'.</desc>
                            <sample for="lua">local success = Image.CodeReader.Barcode.setIso15416Verifier(deco, false)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Barcode" desc="The instance to use"/>
                            <param name="iso15416Verifier" type="bool" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getIso15416Verifier">
                            <desc>Retrieves the Iso 15416 verifier flag for all the 1D decoders. Default value is 'false'.</desc>
                            <sample for="lua">local iso15416Verifier = Image.CodeReader.Barcode.getIso15416Verifier(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Barcode" desc="The instance to use"/>
                            <return name="iso15416Verifier" type="bool" desc="The value currently set"/>
                        </function>
                        <function name="setNorcaVerifier">
                            <desc>Activates NoReadCauseAnalysis (Norca) for all 1D codes. Norca examines no reads and sets flags in the Image.CodeReader.Result feature vector.
Default value is 'false', i.e. Norca is off.</desc>
                            <sample for="lua">local success = Image.CodeReader.Barcode.setNorcaVerifier(deco,true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Barcode" desc="The instance to use"/>
                            <param name="norcaVerifier" type="bool" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getNorcaVerifier">
                            <desc>Returns if Norca is active for 1D codes.</desc>
                            <sample for="lua">local norcaVerifier = Image.CodeReader.Barcode.getNorcaVerifier(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Barcode" desc="The instance to use"/>
                            <return name="norcaVerifier" type="bool" desc="The value currently set"/>
                        </function>
                        <function name="setSymbology">
                            <desc>Sets the single symbologies. If no symbology is given, all the single symbologies are set to NULL.</desc>
                            <sample for="lua">local success, error = Image.CodeReader.Barcode.setSymbology(deco,"APPEND",code128,code93)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Barcode" desc="The instance to use"/>
                            <param name="settingMode" type="enum" ref="SymbologySettingMode" desc="The mode how to handle the optional symbology handles"/>
                            <param name="symbology1" type="object" multiplicity="?" desc="The (optional) first symbology to be set"/>
                            <param name="symbology2" type="object" multiplicity="?" desc="The (optional) second symbology to be set"/>
                            <param name="symbology3" type="object" multiplicity="?" desc="The (optional) third symbology to be set"/>
                            <param name="symbology4" type="object" multiplicity="?" desc="The (optional) fourth symbology to be set"/>
                            <param name="symbology5" type="object" multiplicity="?" desc="The (optional) fifth symbology to be set"/>
                            <param name="symbology6" type="object" multiplicity="?" desc="The (optional) sixth symbology to be set"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful (all the arguments are symbologies or Remove was chosen)"/>
                            <return name="error" type="int" desc="An error value encoding those object indices that are not symbologies in Append or Replace mode"/>
                        </function>
                        <function name="getSymbology">
                            <desc>Gets a single symbology decoder if the same has been installed (appended).</desc>
                            <sample for="lua">local symCode128 = Image.CodeReader.Barcode.getSymbology(deco,"CODE128")</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Barcode" desc="The instance to use"/>
                            <param name="symbologyDecoderType" type="enum" ref="SymbologyDecoderTypeEnum" desc="The type of the symbology according to the above enumeration"/>
                            <return name="symbologyDecoder" type="handle" multiplicity="?" desc="The desired symbology (decoder) if it has been installed. Otherwise no return value."/>
                        </function>
                        <function name="setImage">
                            <trait>hidden</trait>
                            <desc>Sets the image on which the decoder works.</desc>
                            <sample for="lua">success = Image.CodeReader.Barcode.setImage(deco, image)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Barcode" desc="The instance to use"/>
                            <param name="image" type="const object" alias="Image" desc="The image the decoder works on"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="setRegion">
                            <trait>hidden</trait>
                            <desc>Sets the region of interest where the 1D decoder should search. If no region is given the whole image is searched.</desc>
                            <sample for="lua">success = Image.CodeReader.Barcode.setRegion(deco,region)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Barcode" desc="The instance to use"/>
                            <param name="region" type="const object" multiplicity="?" alias="Shape.Composite" desc="The region of interest the decoder shall use or nil if no region shall be used"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="setDiagLevel">
                            <trait>hidden</trait>
                            <desc>Sets the diagnosis level of the diagnosis object</desc>
                            <sample for="lua">local success = Image.CodeReader.Barcode.setDiagLevel(deco,2)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Barcode" desc="The instance to use"/>
                            <param name="diagLevel" type="int" desc="The desired level of diagnosis"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful or not"/>
                        </function>
                        <function name="getDiagLevel">
                            <trait>hidden</trait>
                            <desc>Gets the diagnosis level of the output object</desc>
                            <sample for="lua">local level = Image.CodeReader.Barcode.getDiagLevel(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Barcode" desc="The instance to use"/>
                            <return name="diagLevel" type="int" desc="The level of diagnosis currently used"/>
                        </function>
                        <function name="decode">
                            <trait>hidden</trait>
                            <desc>Decodes the code contained in the (region of the) image and returns the decoded result</desc>
                            <sample for="lua">codes = Image.CodeReader.Barcode.decode(deco, image)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Barcode" desc="The instance to use"/>
                            <param name="image" type="const object" alias="Image" desc="The image the decoder works on"/>
                            <return name="codes" type="const object" multiplicity="+" alias="Image.CodeReader.Result" desc="The complete datamatrix result list, a list of ImageDecoderResult-s"/>
                            <return name="durationMs" type="int" desc="The overall time in ms for the current decoding process"/>
                        </function>
                        <function name="getDiagnosis">
                            <trait>hidden</trait>
                            <desc>Gets the diagnosis object after decoding. The object is released and so the function shall be called only once.</desc>
                            <sample for="lua">local diag = Image.CodeReader.Barcode.getDiagnosis(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Barcode" desc="The instance to use"/>
                            <return name="diagnosis" type="binary" desc="The released diagnosis object."/>
                        </function>
                    </serves>
                    <crown name="Codabar">
                        <trait>released</trait>
                        <desc>The Codabar codabar.</desc>
                        <enum name="CheckDigitTest">
                            <item desc="'None' still accepted.">NONE</item>
                            <item desc="'Mod10' still accepted.">MOD10</item>
                            <item>7DR</item>
                            <item desc="'Mod16' still accepted.">MOD16</item>
                        </enum>
                        <serves>
                            <function name="create">
<desc>Creates a new Codabar codabar instance</desc>
<sample for="lua">codabar = Image.CodeReader.Barcode.Codabar.create()</sample>
<return name="handle" type="handle" alias="Image.CodeReader.Barcode.Codabar" desc="The handle for the new Codabar codabar instance"/>
                            </function>
                            <function name="setActive">
<desc>Activates or deactivates the Codabar symbology. Default value is true.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Codabar.setActive(sym,false)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Codabar" desc="The instance to use"/>
<param name="active" type="bool" desc="The desired activation statuc."/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getActive">
<desc>Retrieves the Codabar symbology activation status. Default value is true.</desc>
<sample for="lua">local active = Image.CodeReader.Barcode.Codabar.getActive(sym)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Codabar" desc="The instance to use"/>
<return name="active" type="bool" desc="The current activation status."/>
                            </function>
                            <function name="setMultiRead">
<desc>Sets the multireads for Codabar</desc>
<sample for="lua">success = Image.CodeReader.Barcode.Codabar.setMultiRead(codabar,3)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Codabar" desc="The instance to use"/>
<param name="multiRead" type="int" desc="The desired value (0..100)"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getMultiRead">
<desc>Retrieves the multireads for codabar</desc>
<sample for="lua">CodabarMultiRead = Image.CodeReader.Barcode.Codabar.getMultiRead(codabar)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Codabar" desc="The instance to use"/>
<return name="multiRead" type="int" desc="The value currently set (0..100)"/>
                            </function>
                            <function name="setIdenticalStaSto">
<desc>Codabar codes where the start and stop symbol is not indentical are discarded.</desc>
<sample for="lua">success = Image.CodeReader.Barcode.Codabar.setIdenticalStaSto(codabar,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Codabar" desc="The instance to use"/>
<param name="identicalStaSto" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getIdenticalStaSto">
<desc>Retrieves the flag for identical start-stop pattern in Codabar</desc>
<sample for="lua">IdenticalStaSto = Image.CodeReader.Barcode.Codabar.getIdenticalStaSto(codabar)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Codabar" desc="The instance to use"/>
<return name="identicalStaSto" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setTransmitStaSto">
<desc>Sets the flag for transmit start-stop pattern in Codabar</desc>
<sample for="lua">success = Image.CodeReader.Barcode.Codabar.setTransmitStaSto(codabar,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Codabar" desc="The instance to use"/>
<param name="transmitStaSto" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getTransmitStaSto">
<desc>Retrieves the flag for transmit start-stop pattern in Codabar</desc>
<sample for="lua">TransmitStaSto = Image.CodeReader.Barcode.Codabar.getTransmitStaSto(codabar)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Codabar" desc="The instance to use"/>
<return name="transmitStaSto" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setCheckDigitTest">
<desc>Sets the mode for the check digit test</desc>
<sample for="lua">success = Image.CodeReader.Barcode.Codabar.setCheckDigitTest(codabar,"Mod10")</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Codabar" desc="The instance to use"/>
<param name="checkDigitTest" type="enum" ref="CheckDigitTest" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getCheckDigitTest">
<desc>Retrieves the mode for the check digit test</desc>
<sample for="lua">CheckDigitTest = Image.CodeReader.Barcode.Codabar.getCheckDigitTest(codabar)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Codabar" desc="The instance to use"/>
<return name="checkDigitTest" type="enum" ref="CheckDigitTest" desc="The value currently set"/>
                            </function>
                            <function name="setTransmitCheckDigit">
<desc>Sets the Codabar TransmitCheckDigit flag. Default value is true.</desc>
<sample for="lua">success = Image.CodeReader.Barcode.Codabar.setTransmitCheckDigit(codabar,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Codabar" desc="The instance to use"/>
<param name="transmitCheckDigit" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getTransmitCheckDigit">
<desc>Retrieves the Codabar TransmitCheckDigit flag. Default value is true.</desc>
<sample for="lua">TransmitCheckDigit = Image.CodeReader.Barcode.Codabar.getTransmitCheckDigit(codabar)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Codabar" desc="The instance to use"/>
<return name="transmitCheckDigit" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setCodeLengths">
<desc>Sets the several code lengths</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Codabar.setCodeLengths(codabar,"10,11")</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Codabar" desc="The instance to use"/>
<param name="codeLengths" type="string" desc="The desired values or ranges separated by commas"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getCodeLengths">
<desc>Gets the several code fixed lengths</desc>
<sample for="lua">local codeLengths = Image.CodeReader.Barcode.Codabar.getCodeLengths(codabar)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Codabar" desc="The instance to use"/>
<return name="codeLengths" type="string" desc="The desired values or ranges separated by commas"/>
                            </function>
                            <function name="setNorcaVerifier">
<trait>deprecated</trait>
<desc>Sets the Norca flag. Deprecated and is relevant only in the Image.CodeReader.Barcode crown.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Codabar.setNorcaVerifier(codabar,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Codabar" desc="The instance to use"/>
<param name="norcaVerifier" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getNorcaVerifier">
<trait>deprecated</trait>
<desc>Gets the Norca flag</desc>
<sample for="lua">local norcaVerifier = Image.CodeReader.Barcode.Codabar.getNorcaVerifier(codabar)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Codabar" desc="The instance to use"/>
<return name="norcaVerifier" type="bool" desc="The value set"/>
                            </function>
                        </serves>
                    </crown>
                    <crown name="Code39">
                        <trait>released</trait>
                        <desc>The Code39 symbology.</desc>
                        <enum name="CheckDigitTest">
                            <item desc="'None' also accepted.">NONE</item>
                            <item desc="'Mod10' also accepted.">MOD10</item>
                            <item desc="'Mod43' also accepted.">MOD43</item>
                        </enum>
                        <serves>
                            <function name="create">
<desc>Creates a new Code39 symbology instance</desc>
<sample for="lua">symbology = Image.CodeReader.Barcode.Code39.create()</sample>
<return name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The handle for the new Code39 symbology instance"/>
                            </function>
                            <function name="setActive">
<desc>Activates or deactivates the Code39 symbology. Default value is true.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code39.setActive(sym,false)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The instance to use"/>
<param name="active" type="bool" desc="The desired activation statuc."/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getActive">
<desc>Retrieves the Code39 symbology activation status. Default value is true.</desc>
<sample for="lua">local active = Image.CodeReader.Barcode.Code39.getActive(sym)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The instance to use"/>
<return name="active" type="bool" desc="The current activation status."/>
                            </function>
                            <function name="setMultiRead">
<desc>Sets the multireads for Code39</desc>
<sample for="lua">success = Image.CodeReader.Barcode.Code39.setMultiRead(code39,3)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The instance to use"/>
<param name="multiRead" type="int" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getMultiRead">
<desc>Retrieves the multireads for Code39</desc>
<sample for="lua">MultiRead = Image.CodeReader.Barcode.Code39.getMultiRead(code39)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The instance to use"/>
<return name="multiRead" type="int" desc="The value currently set"/>
                            </function>
                            <function name="setTransmitStaSto">
<desc>Sets the flag transmitting the start stop in code39</desc>
<sample for="lua">success = Image.CodeReader.Barcode.Code39.setTransmitStaSto(code39,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The instance to use"/>
<param name="transmitStaSto" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getTransmitStaSto">
<desc>Retrieves the flag transmitting the start stop for codee39</desc>
<sample for="lua">TransmitStaSto = Image.CodeReader.Barcode.Code39.getTransmitStaSto(code39)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The instance to use"/>
<return name="transmitStaSto" type="bool" desc="The desired value"/>
                            </function>
                            <function name="setFullAscii">
<desc>Sets the flag for full ascii</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code39.setFullAscii(code39,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The instance to use"/>
<param name="fullAscii" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getFullAscii">
<desc>Retrieves the flag for full ascii</desc>
<sample for="lua">local fullAscii = Image.CodeReader.Barcode.Code39.getFullAscii(code39)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The instance to use"/>
<return name="fullAscii" type="bool" desc="The desired value"/>
                            </function>
                            <function name="setCheckDigitTest">
<desc>Sets the check digit test mode</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code39.setCheckDigitTest(code39,"Mod43")</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The instance to use"/>
<param name="checkDigitTest" type="enum" ref="CheckDigitTest" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getCheckDigitTest">
<desc>Gets the check digit test mode</desc>
<sample for="lua">local checkDigitTest = Image.CodeReader.Barcode.Code39.getCheckDigitTest(code39)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The instance to use"/>
<return name="checkDigitTest" type="enum" ref="CheckDigitTest" desc="The value currently set"/>
                            </function>
                            <function name="setTransmitCheckDigit">
<desc>Sets the Code39 TransmitCheckDigit flag. Default value is true.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code39.setTransmitCheckDigit(code39,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The instance to use"/>
<param name="transmitCheckDigit" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getTransmitCheckDigit">
<desc>Retrieves the Code39 TransmitCheckDigit flag. Default value is true.</desc>
<sample for="lua">local transmitCheckDigit = Image.CodeReader.Barcode.Code39.getTransmitCheckDigit(code39)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The instance to use"/>
<return name="transmitCheckDigit" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setStartCharValidation">
<desc>Activates a validation that helps reading when start symbol is defective or missing or when other bars precede the start symbol. Default value is false.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code39.setStartCharValidation(code39, true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The instance to use"/>
<param name="startCharValidation" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getStartCharValidation">
<desc>Retrieves whether start character validation is activated or not.</desc>
<sample for="lua">local flag = Image.CodeReader.Barcode.Code39.getStartCharValidation(code39)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The instance to use"/>
<return name="startCharValidation" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setStopCharValidation">
<desc>Activates a validation that helps reading defective stop symbols or when further bars follow the stop symbol. Default value is false.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code39.setStopCharValidation(code39, true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The instance to use"/>
<param name="stopCharValidation" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getStopCharValidation">
<desc>Retrieves whether stop character validation is activated or not.</desc>
<sample for="lua">local flag = Image.CodeReader.Barcode.Code39.getStopCharValidation(code39)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The instance to use"/>
<return name="stopCharValidation" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setC32Conversion">
<desc>Sets the Code39 C32 conversion flag</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code39.setC32Conversion(code39,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The instance to use"/>
<param name="c32Conversion" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getC32Conversion">
<desc>Gets the Code39 C32 conversion flag</desc>
<sample for="lua">local c32Conversion = Image.CodeReader.Barcode.Code39.getC32Conversion(code39)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The instance to use"/>
<return name="c32Conversion" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setRawConversion">
<trait>hidden</trait>
<desc>Sets the Code39 Raw Conversion flag. Default value is true.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code39.setRawConversion(code39,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The instance to use"/>
<param name="rawConversion" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getRawConversion">
<trait>hidden</trait>
<desc>Retrieves the Code39 Raw Conversion flag. Default value is true.</desc>
<sample for="lua">local rawConversion = Image.CodeReader.Barcode.Code39.getRawConversion(code39)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The instance to use"/>
<return name="rawConversion" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setCodeLengths">
<desc>Sets the code lengths</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code39.setCodeLengths(code39,"10,11-12")</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The instance to use"/>
<param name="codeLengths" type="string" desc="The desired values and ranges separated by commas"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getCodeLengths">
<desc>Retrieves the code lengths</desc>
<sample for="lua">local codeLengths = Image.CodeReader.Barcode.Code39.getCodeLengths(code39)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The instance to use"/>
<return name="codeLengths" type="string" desc="The values and ranges separated by commas"/>
                            </function>
                            <function name="setNorcaVerifier">
<trait>deprecated</trait>
<desc>Sets the Norca flag. Deprecated and is relevant only in the Image.CodeReader.Barcode crown.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code39.setNorcaVerifier(code39,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The instance to use"/>
<param name="norcaVerifier" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getNorcaVerifier">
<trait>deprecated</trait>
<desc>Gets the Norca flag</desc>
<sample for="lua">local norcaVerifier = Image.CodeReader.Barcode.Code39.getNorcaVerifier(code39)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code39" desc="The instance to use"/>
<return name="norcaVerifier" type="bool" desc="The value set"/>
                            </function>
                        </serves>
                    </crown>
                    <crown name="UPC">
                        <trait>released</trait>
                        <desc>The UPC symbology.</desc>
                        <enum name="AddonMode">
                            <item desc="'None' still accepted.">NONE</item>
                            <item desc="'Active' still accepted.">ACTIVE</item>
                            <item desc="'Required' still accepted.">REQUIRED</item>
                        </enum>
                        <enum name="AddonLength">
                            <item desc="'Digits2' still accepted.">DIGITS2</item>
                            <item desc="'Digits5' still accepted.">DIGITS5</item>
                            <item desc="'Digits2Or5' still accepted.">DIGITS2OR5</item>
                        </enum>
                        <serves>
                            <function name="create">
<desc>Creates a new UPC symbology instance</desc>
<sample for="lua">symbology = Image.CodeReader.Barcode.UPC.create()</sample>
<return name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The handle for the new Upc symbology instance"/>
                            </function>
                            <function name="setActive">
<desc>Activates or deactivates the EAN/UPC symbology. Default value is true.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.UPC.setActive(sym,false)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<param name="active" type="bool" desc="The desired activation statuc."/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getActive">
<desc>Retrieves the EAN/UPC symbology activation status. Default value is true.</desc>
<sample for="lua">local active = Image.CodeReader.Barcode.UPC.getActive(sym)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<return name="active" type="bool" desc="The current activation status."/>
                            </function>
                            <function name="setMultiRead">
<desc>Sets the multireads for UPC</desc>
<sample for="lua">success = Image.CodeReader.Barcode.UPC.setMultiRead(upc,3)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<param name="multiRead" type="int" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getMultiRead">
<desc>Gets the multireads for UPC</desc>
<sample for="lua">MultiRead = Image.CodeReader.Barcode.UPC.getMultiRead(upc)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<return name="multiRead" type="int" desc="The value currently set"/>
                            </function>
                            <function name="setAddOn">
<desc>Sets the UPC Addon mode</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.UPC.setAddOn(upc,"Active")</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<param name="addOn" type="enum" ref="AddonMode" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getAddOn">
<desc>Retrieves the UPC Addon mode</desc>
<sample for="lua">local addOn = Image.CodeReader.Barcode.UPC.getAddOn(upc)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<return name="addOn" type="enum" ref="AddonMode" desc="The value currently set"/>
                            </function>
                            <function name="setAddOnLength">
<desc>Sets the UPC addon length</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.UPC.setAddOnLength(upc,"Digits2Or5")</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<param name="addOnLength" type="enum" ref="AddonLength" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getAddOnLength">
<desc>Retrieves the UPC addon length</desc>
<sample for="lua">local addOnLength = Image.CodeReader.Barcode.UPC.getAddOnLength(upc)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<return name="addOnLength" type="enum" ref="AddonLength" desc="The value currently set"/>
                            </function>
                            <function name="setTransmitCheckDigit">
<desc>Sets the UPC TransmitCheckDigit flag. Default value is true.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.UPC.setTransmitCheckDigit(upc,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<param name="transmitCheckDigit" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getTransmitCheckDigit">
<desc>Retrieves the UPC TransmitCheckDigit flag. Default value is true.</desc>
<sample for="lua">local transmitCheckDigit = Image.CodeReader.Barcode.UPC.getTransmitCheckDigit(upc)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<return name="transmitCheckDigit" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setExtendedSegmentation">
<desc>Sets the UPC ExtendedSegmentation flag. Default value is 'false'.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.UPC.setExtendedSegmentation(upc,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<param name="extendedSegmentation" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getExtendedSegmentation">
<desc>Retrieves the UPC ExtendedSegmentation flag. Default value is 'false'.</desc>
<sample for="lua">local extendedSegmentation = Image.CodeReader.Barcode.UPC.getExtendedSegmentation(upc)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<return name="extendedSegmentation" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setStartCharacterCorrection">
<desc>Enables the UPC start character correction. Default value is false.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.UPC.setStartCharacterCorrection(upc,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<param name="startCharacterCorrection" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getStartCharacterCorrection">
<desc>Retrieves the UPC start character correction status. Default value is true.</desc>
<sample for="lua">local startCharacterCorrection = Image.CodeReader.Barcode.UPC.getStartCharacterCorrection(upc)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<return name="startCharacterCorrection" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setStopCharacterCorrection">
<desc>Enables or disables the UPC stop character correction. Default value is true.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.UPC.setStopCharacterCorrection(upc,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<param name="stopCharacterCorrection" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getStopCharacterCorrection">
<desc>Retrieves the UPC stop character correction status. Default value is true.</desc>
<sample for="lua">local stopCharacterCorrection = Image.CodeReader.Barcode.UPC.getStopCharacterCorrection(upc)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<return name="stopCharacterCorrection" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setA">
<desc>Sets the UPC A flag. Default value is 'true'.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.UPC.setA(upc,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<param name="upcA" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getA">
<desc>Retrieves the UPC A flag. Default value is 'true'.</desc>
<sample for="lua">local upcA = Image.CodeReader.Barcode.UPC.getA(upc)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<return name="upcA" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setE">
<desc>Sets the UPC E flag. Default value is 'true'.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.UPC.setE(upc,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<param name="upcE" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getE">
<desc>Retrieves the UPC E flag. Default value is 'true'.</desc>
<sample for="lua">local upcE = Image.CodeReader.Barcode.UPC.getE(upc)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<return name="upcE" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setEExt">
<desc>Sets the UPC E-extended flag. Default value is 'false'.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.UPC.setEExt(upc,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<param name="upcEExt" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getEExt">
<desc>Retrieves the UPC E-extended flag. Default value is 'false'.</desc>
<sample for="lua">local upcEExt = Image.CodeReader.Barcode.UPC.getEExt(upc)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<return name="upcEExt" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setUPCEInsertNumberSystem">
<desc>Inserts the number system digit at the beginning of the content. Default value is 'false'.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.UPC.setUPCEInsertNumberSystem(upc,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<param name="upceInsertNumberSystem" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getUPCEInsertNumberSystem">
<desc>Retrieves the UPC UPCEInsertNumberSystem flag. Default value is 'false'.</desc>
<sample for="lua">local upceInsertNumberSystem = Image.CodeReader.Barcode.UPC.getUPCEInsertNumberSystem(upc)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<return name="upceInsertNumberSystem" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setEAN8">
<desc>Sets the UPC EAN8 flag</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.UPC.setEAN8(upc,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<param name="ean8" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getEAN8">
<desc>Retrieves the UPC EAN8 flag</desc>
<sample for="lua">ean8 = Image.CodeReader.Barcode.UPC.getEAN8(upc)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<return name="ean8" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setEAN13">
<desc>Sets the UPC EAN13 flag</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.UPC.setEAN13(upc,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<param name="ean13" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getEAN13">
<desc>Retrieves the UPC EAN13 flag</desc>
<sample for="lua">local ean13 = Image.CodeReader.Barcode.UPC.getEAN13(upc)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<return name="ean13" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setConversion">
<trait>deprecated</trait>
<desc>Sets the Raw Conversion flag. Default value is true. Use setRawConversion instead.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.UPC.setConversion(upc,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<param name="conversion" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getConversion">
<trait>deprecated</trait>
<desc>Retrieves the UPC Conversion flag. Default value is true. Use getRawConversion instead.</desc>
<sample for="lua">local conversion = Image.CodeReader.Barcode.UPC.getConversion(upc)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<return name="conversion" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setRawConversion">
<desc>Sets the Raw Conversion flag. Default value is 'true'.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.UPC.setRawConversion(upc,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<param name="rawConversion" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getRawConversion">
<desc>Retrieves the UPC Raw Conversion flag. Default value is 'true'.</desc>
<sample for="lua">local rawConversion = Image.CodeReader.Barcode.UPC.getRawConversion(upc)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<return name="rawConversion" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setNorcaVerifier">
<trait>deprecated</trait>
<desc>Sets the Norca flag. Deprecated and is relevant only in the Image.CodeReader.Barcode crown.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.UPC.setNorcaVerifier(upc,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<param name="norcaVerifier" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getNorcaVerifier">
<trait>deprecated</trait>
<desc>Gets the Norca flag</desc>
<sample for="lua">local norcaVerifier = Image.CodeReader.Barcode.UPC.getNorcaVerifier(upc)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.UPC" desc="The instance to use"/>
<return name="norcaVerifier" type="bool" desc="The value set"/>
                            </function>
                        </serves>
                    </crown>
                    <crown name="Interleaved25">
                        <trait>released</trait>
                        <desc>The IL25 symbology.</desc>
                        <enum name="CheckDigitTest">
                            <item desc="'None' still accepted.">NONE</item>
                            <item desc="'Mod10' still accepted.">MOD10</item>
                            <item>1R18</item>
                            <item>W49M10</item>
                            <item>W12CSM10</item>
                            <item desc="'Mod11' still accepted.">MOD11</item>
                        </enum>
                        <serves>
                            <function name="create">
<desc>Creates a new IL25 symbology instance</desc>
<sample for="lua">symbology = Image.CodeReader.Barcode.Interleaved25.create()</sample>
<return name="handle" type="handle" alias="Image.CodeReader.Barcode.Interleaved25" desc="The handle for the new Interleaved 2/5 symbology instance"/>
                            </function>
                            <function name="setActive">
<desc>Activates or deactivates the Interleaved 2/5 symbology. Default value is true.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Interleaved25.setActive(sym,false)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Interleaved25" desc="The instance to use"/>
<param name="active" type="bool" desc="The desired activation statuc."/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getActive">
<desc>Retrieves the Interleaved 2/5 symbology activation status. Default value is true.</desc>
<sample for="lua">local active = Image.CodeReader.Barcode.Interleaved25.getActive(sym)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Interleaved25" desc="The instance to use"/>
<return name="active" type="bool" desc="The current activation status."/>
                            </function>
                            <function name="setMultiRead">
<desc>Sets the multireads for Interleaved</desc>
<sample for="lua">success = Image.CodeReader.Barcode.Interleaved25.setMultiRead(il25,3)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Interleaved25" desc="The instance to use"/>
<param name="multiRead" type="int" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getMultiRead">
<desc>Retrieves the multireads for Interleaved</desc>
<sample for="lua">MultiRead = Image.CodeReader.Barcode.Interleaved25.getMultiRead(il25)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Interleaved25" desc="The instance to use"/>
<return name="multiRead" type="int" desc="The value currently set"/>
                            </function>
                            <function name="setCheckDigitTest">
<desc>Sets the check digit tests as a string</desc>
<sample for="lua">success = Image.CodeReader.Barcode.Interleaved25.setCheckDigitTest(il25,"Mod10,W12CSM10,W12CSM10,Mod11")</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Interleaved25" desc="The instance to use"/>
<param name="checkDigitTest" type="string" desc="A string listing the desired check digit tests corresponding to the appropriate fixed code lengths"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getCheckDigitTest">
<desc>Retrieves the check digit tests as a string</desc>
<sample for="lua">CheckDigitTest = Image.CodeReader.Barcode.Interleaved25.getCheckDigitTest(il25)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Interleaved25" desc="The instance to use"/>
<return name="checkDigitTest" type="string" desc="A string listing the check digit tests corresponding to the appropriate fixed code lengths"/>
                            </function>
                            <function name="setTransmitCheckDigit">
<desc>Sets the Interleaved 2/5 TransmitCheckDigit flag. Default value is true.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Interleaved25.setTransmitCheckDigit(il25,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Interleaved25" desc="The instance to use"/>
<param name="transmitCheckDigit" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getTransmitCheckDigit">
<desc>Retrieves the Interleaved 2/5 TransmitCheckDigit flag. Default value is true.</desc>
<sample for="lua">local transmitCheckDigit = Image.CodeReader.Barcode.Interleaved25.getTransmitCheckDigit(il25)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Interleaved25" desc="The instance to use"/>
<return name="transmitCheckDigit" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setStartCharValidation">
<desc>Sets the flag for the start character validation. Default value is false.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Interleaved25.setStartCharValidation(il25, true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Interleaved25" desc="The instance to use"/>
<param name="startCharValidation" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getStartCharValidation">
<desc>Retrieves the flag for the start character validation. Default value is false.</desc>
<sample for="lua">local flag = Image.CodeReader.Barcode.Interleaved25.getStartCharValidation(il25)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Interleaved25" desc="The instance to use"/>
<return name="startCharValidation" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setStopCharValidation">
<desc>Sets the flag for the stop character validation. Default value is false.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Interleaved25.setStopCharValidation(il25, true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Interleaved25" desc="The instance to use"/>
<param name="stopCharValidation" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getStopCharValidation">
<desc>Retrieves the flag for the stop character validation. Default value is false.</desc>
<sample for="lua">local flag = Image.CodeReader.Barcode.Interleaved25.getStopCharValidation(il25)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Interleaved25" desc="The instance to use"/>
<return name="stopCharValidation" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setSingleErrorCorrection">
<desc>Sets the flag for single error correction. Default value is false.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Interleaved25.setSingleErrorCorrection(il25, true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Interleaved25" desc="The instance to use"/>
<param name="singleErrorCorrection" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getSingleErrorCorrection">
<desc>Retrieves the flag for single error correction. Default value is false.</desc>
<sample for="lua">local flag = Image.CodeReader.Barcode.Interleaved25.getSingleErrorCorrection(il25)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Interleaved25" desc="The instance to use"/>
<return name="singleErrorCorrection" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setQuietZoneValidation">
<trait>deprecated</trait>
<desc>Sets the flag for the quiet zone validation. Default value is false.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Interleaved25.setQuietZoneValidation(il25, true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Interleaved25" desc="The instance to use"/>
<param name="quietZoneValidation" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getQuietZoneValidation">
<trait>deprecated</trait>
<desc>Retrieves the flag for the quiet zone validation. Default value is false.</desc>
<sample for="lua">local flag = Image.CodeReader.Barcode.Interleaved25.getQuietZoneValidation(il25)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Interleaved25" desc="The instance to use"/>
<return name="quietZoneValidation" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setClassRestrict">
<desc>Sets a restriction for the width difference of the wide and the narrow module. (minimumDesiredWidthDifference * 100)/ narrowElementWidth = classRestrictionValue.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Interleaved25.setClassRestrict(il25,50)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Interleaved25" desc="The instance to use"/>
<param name="classRestrict" type="int" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getClassRestrict">
<desc>Retrieves the class restriction</desc>
<sample for="lua">local classRestrict = Image.CodeReader.Barcode.Interleaved25.getClassRestrict(il25)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Interleaved25" desc="The instance to use"/>
<return name="classRestrict" type="int" desc="The value currently set"/>
                            </function>
                            <function name="setCodeLengths">
<desc>Sets the code lengths</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Interleaved25.setCodeLengths(il25,"10-15")</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Interleaved25" desc="The instance to use"/>
<param name="codeLengths" type="string" desc="The desired values and ranges separated by commas"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getCodeLengths">
<desc>Retrieves the code lengths</desc>
<sample for="lua">local codeLengths = Image.CodeReader.Barcode.Interleaved25.getCodeLengths(il25)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Interleaved25" desc="The instance to use"/>
<return name="codeLengths" type="string" desc="The fixed length values and ranges separated by commas"/>
                            </function>
                            <function name="setNorcaVerifier">
<trait>deprecated</trait>
<desc>Sets the Norca flag. Deprecated and is relevant only in the Image.CodeReader.Barcode crown.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Interleaved25.setNorcaVerifier(il25,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Interleaved25" desc="The instance to use"/>
<param name="norcaVerifier" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getNorcaVerifier">
<trait>deprecated</trait>
<desc>Gets the Norca flag</desc>
<sample for="lua">local norcaVerifier = Image.CodeReader.Barcode.Interleaved25.getNorcaVerifier(il25)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Interleaved25" desc="The instance to use"/>
<return name="norcaVerifier" type="bool" desc="The value set"/>
                            </function>
                        </serves>
                    </crown>
                    <crown name="Code93">
                        <trait>released</trait>
                        <desc>The Code93 symbology.</desc>
                        <serves>
                            <function name="create">
<desc>Creates a new Code93 symbology instance</desc>
<sample for="lua">symbology = Image.CodeReader.Barcode.Code93.create()</sample>
<return name="handle" type="handle" alias="Image.CodeReader.Barcode.Code93" desc="The handle for the new Code93 symbology instance"/>
                            </function>
                            <function name="setActive">
<desc>Activates or deactivates the Code93 symbology. Default value is true.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code93.setActive(sym,false)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code93" desc="The instance to use"/>
<param name="active" type="bool" desc="The desired activation statuc."/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getActive">
<desc>Retrieves the Code93 symbology activation status. Default value is true.</desc>
<sample for="lua">local active = Image.CodeReader.Barcode.Code93.getActive(sym)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code93" desc="The instance to use"/>
<return name="active" type="bool" desc="The current activation status."/>
                            </function>
                            <function name="setMultiRead">
<desc>Sets the multireads for Code93</desc>
<sample for="lua">success = Image.CodeReader.Barcode.Code93.setMultiRead(code93,3)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code93" desc="The instance to use"/>
<param name="multiRead" type="int" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getMultiRead">
<desc>Retrieves the multireads for Code93</desc>
<sample for="lua">MultiRead = Image.CodeReader.Barcode.Code93.getMultiRead(code93)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code93" desc="The instance to use"/>
<return name="multiRead" type="int" desc="The value currently set"/>
                            </function>
                            <function name="setCodeLengths">
<desc>Sets the code lengths</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code93.setCodeLengths(code93,"9,10")</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code93" desc="The instance to use"/>
<param name="codeLengths" type="string" desc="The desired values and ranges separated by commas"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getCodeLengths">
<desc>Retrievs the code lengths</desc>
<sample for="lua">local codeLengths = Image.CodeReader.Barcode.Code93.getCodeLengths(code93)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code93" desc="The instance to use"/>
<return name="codeLengths" type="string" desc="The fixed code length values and ranges separated by commas"/>
                            </function>
                            <function name="setConversion">
<trait>deprecated</trait>
<desc>Sets the Code93 Raw Conversion flag. Default value is true. Use setRawConversion instead.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code93.setConversion(code93,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code93" desc="The instance to use"/>
<param name="conversion" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getConversion">
<trait>deprecated</trait>
<desc>Retrieves the Code93 Raw Conversion flag. Default value is true. Use getRawConversion instead.</desc>
<sample for="lua">local conversion = Image.CodeReader.Barcode.Code93.getConversion(code93)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code93" desc="The instance to use"/>
<return name="conversion" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setRawConversion">
<desc>Sets the Code93 Raw Conversion flag. Default value is 'true'.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code93.setRawConversion(code93,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code93" desc="The instance to use"/>
<param name="rawConversion" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getRawConversion">
<desc>Retrieves the Code93 Raw Conversion flag. Default value is 'true'.</desc>
<sample for="lua">local conversion = Image.CodeReader.Barcode.Code93.getRawConversion(code93)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code93" desc="The instance to use"/>
<return name="rawConversion" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setNorcaVerifier">
<trait>deprecated</trait>
<desc>Sets the Norca flag. Deprecated and is relevant only in the Image.CodeReader.Barcode crown.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code93.setNorcaVerifier(code93,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code93" desc="The instance to use"/>
<param name="norcaVerifier" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getNorcaVerifier">
<trait>deprecated</trait>
<desc>Gets the Norca flag</desc>
<sample for="lua">local norcaVerifier = Image.CodeReader.Barcode.Code93.getNorcaVerifier(code93)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code93" desc="The instance to use"/>
<return name="norcaVerifier" type="bool" desc="The value set"/>
                            </function>
                        </serves>
                    </crown>
                    <crown name="Code128">
                        <trait>released</trait>
                        <desc>The Code128 symbology.</desc>
                        <enum name="CheckDigitTest">
                            <item desc="'None' still accepted.">NONE</item>
                            <item desc="'Ground96' still accepted.">GROUND96</item>
                            <item>SSCC18</item>
                            <item>W8M11</item>
                            <item desc="'1DBarcode' still accepted.">BARCODE1D</item>
                        </enum>
                        <serves>
                            <function name="create">
<desc>Creates a new Code128 symbology instance</desc>
<sample for="lua">symbology = Image.CodeReader.Barcode.Code128.create()</sample>
<return name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The handle for the new Code128 symbology instance"/>
                            </function>
                            <function name="setActive">
<desc>Activates or deactivates the Code128 symbology. Default value is true.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code128.setActive(sym,false)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<param name="active" type="bool" desc="The desired activation statuc."/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getActive">
<desc>Retrieves the Code128 symbology activation status. Default value is true.</desc>
<sample for="lua">local active = Image.CodeReader.Barcode.Code128.getActive(sym)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<return name="active" type="bool" desc="The current activation status."/>
                            </function>
                            <function name="setMultiRead">
<desc>Sets the number of multireads for Code128</desc>
<sample for="lua">success = Image.CodeReader.Barcode.Code128.setMultiRead(code128,3)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<param name="multiRead" type="int" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getMultiRead">
<desc>Retrieves the number of multireads for Code128</desc>
<sample for="lua">MultiRead = Image.CodeReader.Barcode.Code128.getMultiRead(code128)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<return name="multiRead" type="int" desc="The desired value"/>
                            </function>
                            <function name="setC128">
<desc>Sets the Code128 flag. Default value is true.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code128.setC128(code128,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<param name="code128" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getC128">
<desc>Gets the Code128 flag. Default value is true.</desc>
<sample for="lua">local code128 = Image.CodeReader.Barcode.Code128.getC128(code128)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<return name="code128" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setEAN128">
<desc>Sets the EAN128 flag. Default value is false.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code128.setEAN128(code128,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<param name="ean128" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getEAN128">
<desc>Returns the EAN128 flag. Default value is false.</desc>
<sample for="lua">local ean128 = Image.CodeReader.Barcode.Code128.getEAN128(code128)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<return name="ean128" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setCode">
<trait>deprecated</trait>
<desc>Sets the Code128 flag. Replaced by setC128 now.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code128.setCode(code128,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<param name="code128" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getCode">
<trait>deprecated</trait>
<desc>Gets the Code128 flag. Replaced by getC128 now.</desc>
<sample for="lua">local code128 = Image.CodeReader.Barcode.Code128.getCode(code128)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<return name="code128" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setGs1">
<trait>deprecated</trait>
<desc>Sets the Gs1 flag. Replaced by setEAN128 now.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code128.setGs1(code128,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<param name="gs1" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getGs1">
<trait>deprecated</trait>
<desc>Returns the Gs1 flag. Replaced by getEAN128 now.</desc>
<sample for="lua">local gs1 = Image.CodeReader.Barcode.Code128.getGs1(code128)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<return name="gs1" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setConversion">
<trait>deprecated</trait>
<desc>Sets the Code128 Raw Conversion flag. Use setRawConversion instead.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code128.setConversion(code128,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<param name="conversion" type="bool" desc="The desired value. Default value is true."/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getConversion">
<trait>deprecated</trait>
<desc>Returns the Code128 Raw Conversion flag. Use getRawConversion instead.</desc>
<sample for="lua">local conversion = Image.CodeReader.Barcode.Code128.getConversion(code128)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<return name="conversion" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setRawConversion">
<desc>Sets the Code128 Raw Conversion flag.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code128.setRawConversion(code128,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<param name="rawConversion" type="bool" desc="The desired value. Default value is true."/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getRawConversion">
<desc>Returns the Code128 Raw Conversion flag.</desc>
<sample for="lua">local rawConversion = Image.CodeReader.Barcode.Code128.getRawConversion(code128)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<return name="rawConversion" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setCodeLengths">
<desc>Sets Code128 code lengths</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code128.setCodeLengths(code128,"15,16")</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<param name="codeLengths" type="string" desc="The desired values and ranges separated by commas"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getCodeLengths">
<desc>Retrieves Code128 code lengths</desc>
<sample for="lua">local codeLengths = Image.CodeReader.Barcode.Code128.getCodeLengths(code128)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<return name="codeLengths" type="string" desc="The fixed code length values and ranges separated by commas"/>
                            </function>
                            <function name="setCheckDigitTest">
<desc>Sets the check digit tests as a string</desc>
<sample for="lua">success = Image.CodeReader.Barcode.Code128.setCheckDigitTest(code128,"Ground96,SSCC18")</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<param name="checkDigitTest" type="string" desc="A string listing the desired check digit tests corresponding to the appropriate fixed code lengths"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getCheckDigitTest">
<desc>Retrieves the check digit tests as a string</desc>
<sample for="lua">CheckDigitTest = Image.CodeReader.Barcode.Code128.getCheckDigitTest(code128)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<return name="checkDigitTest" type="string" desc="A string listing the check digit tests corresponding to the appropriate fixed code lengths"/>
                            </function>
                            <function name="setFnc1FirstPos">
<desc>Sets up to three ASCII symbols that replace an FNC1 symbol at the first position of a GS1-128 code.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code128.setFnc1FirstPos(code128,"93,67,49")</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<param name="fnc1FirstPos" type="string" desc="The desired values (as a string of comma-separated numbers)"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getFnc1FirstPos">
<desc>Retrieves the 3 values of the first FNC1 as a string of comma separated values.</desc>
<sample for="lua">local fnc1FirstPos = Image.CodeReader.Barcode.Code128.getFnc1FirstPos(code128)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<return name="fnc1FirstPos" type="string" desc="The values currently set (as a string of comma-separated numbers)"/>
                            </function>
                            <function name="setFnc1InterPos">
<desc>Sets up to three ASCII symbols that replace an FNC1 symbol at an intermediate position of a GS1-128 code.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code128.setFnc1InterPos(code128,"29,0,0")</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<param name="fnc1InterPos" type="string" desc="The desired values (as a string of comma-separated numbers)"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getFnc1InterPos">
<desc>Retrieves the values of the intermediate FNC1 as a string</desc>
<sample for="lua">local fnc1InterPos = Image.CodeReader.Barcode.Code128.getFnc1InterPos(code128)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<return name="fnc1InterPos" type="string" desc="The values currently set (as a string of comma-separated numbers)"/>
                            </function>
                            <function name="setStartCharValidation">
<desc>Sets the flag for the start character validation. Default value is false.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code128.setStartCharValidation(code128, true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<param name="startCharValidation" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getStartCharValidation">
<desc>Retrieves the flag for the start character validation. Default value is false.</desc>
<sample for="lua">local flag = Image.CodeReader.Barcode.Code128.getStartCharValidation(code128)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<return name="startCharValidation" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setStopCharValidation">
<desc>Sets the flag for the stop character validation. Default value is false.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code128.setStopCharValidation(code128, true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<param name="stopCharValidation" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getStopCharValidation">
<desc>Retrieves the flag for the stop character validation. Default value is false.</desc>
<sample for="lua">local flag = Image.CodeReader.Barcode.Code128.getStopCharValidation(code128)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<return name="stopCharValidation" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setSingleErrorCorrection">
<desc>Sets the flag for the single error correction. Default value is true.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code128.setSingleErrorCorrection(code128, false)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<param name="singleErrorCorrection" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getSingleErrorCorrection">
<desc>Retrieves the flag for the single error correction. Default value is true.</desc>
<sample for="lua">local flag = Image.CodeReader.Barcode.Code128.getSingleErrorCorrection(code128)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<return name="singleErrorCorrection" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setNorcaVerifier">
<trait>deprecated</trait>
<desc>Sets the Norca flag. Deprecated and is relevant only in the Image.CodeReader.Barcode crown.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Code128.setNorcaVerifier(code128,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<param name="norcaVerifier" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getNorcaVerifier">
<trait>deprecated</trait>
<desc>Gets the Norca flag</desc>
<sample for="lua">local norcaVerifier = Image.CodeReader.Barcode.Code128.getNorcaVerifier(code128)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Code128" desc="The instance to use"/>
<return name="norcaVerifier" type="bool" desc="The value set"/>
                            </function>
                        </serves>
                    </crown>
                    <crown name="ProfileCode">
                        <trait>released</trait>
                        <desc>The Profile (programmable) Code symbology.</desc>
                        <serves>
                            <function name="create">
<desc>Creates a new Profile Code symbology instance</desc>
<sample for="lua">symbology = Image.CodeReader.Barcode.ProfileCode.create()</sample>
<return name="handle" type="handle" alias="Image.CodeReader.Barcode.ProfileCode" desc="The handle for the new ProfileCode symbology instance"/>
                            </function>
                            <function name="setActive">
<desc>Activates or deactivates the Profile Code symbology. Default value is true.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.ProfileCode.setActive(sym,false)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.ProfileCode" desc="The instance to use"/>
<param name="active" type="bool" desc="The desired activation statuc."/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getActive">
<desc>Retrieves the Profile Code symbology activation status. Default value is true.</desc>
<sample for="lua">local active = Image.CodeReader.Barcode.ProfileCode.getActive(sym)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.ProfileCode" desc="The instance to use"/>
<return name="active" type="bool" desc="The current activation status."/>
                            </function>
                            <function name="setC128">
<desc>Sets the Code128 flag</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.ProfileCode.setC128(profilecode,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.ProfileCode" desc="The instance to use"/>
<param name="code128" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getC128">
<desc>Gets the Code128 flag</desc>
<sample for="lua">local code128 = Image.CodeReader.Barcode.ProfileCode.getC128(profilecode)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.ProfileCode" desc="The instance to use"/>
<return name="code128" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setEAN128">
<desc>Sets the EAN128 flag</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.ProfileCode.setEAN128(profilecode,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.ProfileCode" desc="The instance to use"/>
<param name="ean128" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getEAN128">
<desc>Returns the EAN128 flag</desc>
<sample for="lua">local ean128 = Image.CodeReader.Barcode.ProfileCode.getEAN128(profilecode)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.ProfileCode" desc="The instance to use"/>
<return name="ean128" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setFnc1FirstPos">
<desc>Sets the 3 values of the first FNC1 as a string</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.ProfileCode.setFnc1FirstPos(profilecode,"93,67,49")</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.ProfileCode" desc="The instance to use"/>
<param name="fnc1FirstPos" type="string" desc="The desired values (as a string of comma-separated numbers)"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getFnc1FirstPos">
<desc>Retrieves the 3 values of the first FNC1 as a string</desc>
<sample for="lua">local fnc1FirstPos = Image.CodeReader.Barcode.ProfileCode.getFnc1FirstPos(profilecode)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.ProfileCode" desc="The instance to use"/>
<return name="fnc1FirstPos" type="string" desc="The values currently set (as a string of comma-separated numbers)"/>
                            </function>
                            <function name="setFnc1InterPos">
<desc>Sets the values of the intermediate FNC1 as a string</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.ProfileCode.setFnc1InterPos(profilecode,"29,0,0")</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.ProfileCode" desc="The instance to use"/>
<param name="fnc1InterPos" type="string" desc="The desired values (as a string of comma-separated numbers)"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getFnc1InterPos">
<desc>Retrieves the values of the intermediate FNC1 as a string</desc>
<sample for="lua">local fnc1InterPos = Image.CodeReader.Barcode.ProfileCode.getFnc1InterPos(profilecode)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.ProfileCode" desc="The instance to use"/>
<return name="fnc1InterPos" type="string" desc="The values currently set (as a string of comma-separated numbers)"/>
                            </function>
                            <function name="setStartCharValidation">
<desc>Sets the flag for the start character validation. Default value is false.</desc>
<sample for="lua">local success Image.CodeReader.Barcode.ProfileCode.setStartCharValidation(profilecode, true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.ProfileCode" desc="The instance to use"/>
<param name="startCharValidation" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getStartCharValidation">
<desc>Retrieves the flag for the start character validation. Default value is false.</desc>
<sample for="lua">local flag = Image.CodeReader.Barcode.ProfileCode.getStartCharValidation(profilecode)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.ProfileCode" desc="The instance to use"/>
<return name="startCharValidation" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setStopCharValidation">
<desc>Sets the flag for the stop character validation. Default value is false.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.ProfileCode.setStopCharValidation(profilecode, true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.ProfileCode" desc="The instance to use"/>
<param name="stopCharValidation" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getStopCharValidation">
<desc>Retrieves the flag for the stop character validation. Default value is false.</desc>
<sample for="lua">local flag = Image.CodeReader.Barcode.ProfileCode.getStopCharValidation(profilecode)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.ProfileCode" desc="The instance to use"/>
<return name="stopCharValidation" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setSingleErrorCorrection">
<desc>Sets the flag for the single error correction. Default value is true.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.ProfileCode.setSingleErrorCorrection(profilecode, false)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.ProfileCode" desc="The instance to use"/>
<param name="singleErrorCorrection" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getSingleErrorCorrection">
<desc>Retrieves the flag for the single error correction. Default value is true.</desc>
<sample for="lua">local flag = Image.CodeReader.Barcode.ProfileCode.getSingleErrorCorrection(profilecode)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.ProfileCode" desc="The instance to use"/>
<return name="singleErrorCorrection" type="bool" desc="The value currently set"/>
                            </function>
                        </serves>
                    </crown>
                    <crown name="GS1DataBar">
                        <trait>released</trait>
                        <desc>The GS1 DataBar symbology.</desc>
                        <enum name="Databar2DComponent">
                            <item desc="'None' still accepted.">NONE</item>
                            <item desc="'Active' still accepted.">ACTIVE</item>
                            <item desc="'Required' still accepted.">REQUIRED</item>
                        </enum>
                        <serves>
                            <function name="create">
<desc>Creates a new GS1 DataBar symbology instance</desc>
<sample for="lua">symbology = Image.CodeReader.Barcode.GS1DataBar.create()</sample>
<return name="handle" type="handle" alias="Image.CodeReader.Barcode.GS1DataBar" desc="The handle for the new GS1DataBar symbology instance"/>
                            </function>
                            <function name="setActive">
<desc>Activates or deactivates the GS1 Databar symbology. Default value is true.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.GS1DataBar.setActive(sym,false)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.GS1DataBar" desc="The instance to use"/>
<param name="active" type="bool" desc="The desired activation statuc."/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getActive">
<desc>Retrieves the GS1 Databar symbology activation status. Default value is true.</desc>
<sample for="lua">local active = Image.CodeReader.Barcode.GS1DataBar.getActive(sym)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.GS1DataBar" desc="The instance to use"/>
<return name="active" type="bool" desc="The current activation status."/>
                            </function>
                            <function name="setDatabar14">
<desc>Sets the Databar14 flag</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.GS1DataBar.setDatabar14(gs1,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.GS1DataBar" desc="The instance to use"/>
<param name="databar14" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getDatabar14">
<desc>Gets the Databar14 flag</desc>
<sample for="lua">local databar14 = Image.CodeReader.Barcode.GS1DataBar.getDatabar14(gs1)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.GS1DataBar" desc="The instance to use"/>
<return name="databar14" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setDatabarExpanded">
<desc>Sets the Databar Expanded flag</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.GS1DataBar.setDatabarExpanded(gs1,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.GS1DataBar" desc="The instance to use"/>
<param name="databarExpanded" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getDatabarExpanded">
<desc>Gets the Databar Expanded flag</desc>
<sample for="lua">local databarExpanded = Image.CodeReader.Barcode.GS1DataBar.getDatabarExpanded(gs1)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.GS1DataBar" desc="The instance to use"/>
<return name="databarExpanded" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setDatabarLimited">
<desc>Sets the Databar limited flag</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.GS1DataBar.setDatabarLimited(gs1,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.GS1DataBar" desc="The instance to use"/>
<param name="databarLimited" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getDatabarLimited">
<desc>Gets the Databar limited flag</desc>
<sample for="lua">local databarLimited = Image.CodeReader.Barcode.GS1DataBar.getDatabarLimited(gs1)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.GS1DataBar" desc="The instance to use"/>
<return name="databarLimited" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setStackedCodes">
<desc>Sets the stacked codes flag</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.GS1DataBar.setStackedCodes(gs1,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.GS1DataBar" desc="The instance to use"/>
<param name="stackedCodes" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getStackedCodes">
<desc>Gets the stacked codes flag</desc>
<sample for="lua">local stackedCodes = Image.CodeReader.Barcode.GS1DataBar.getStackedCodes(gs1)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.GS1DataBar" desc="The instance to use"/>
<return name="stackedCodes" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setMultiRead">
<desc>Sets the number of multi reads for GS1</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.GS1DataBar.setMultiRead(gs1,3)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.GS1DataBar" desc="The instance to use"/>
<param name="multiRead" type="int" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getMultiRead">
<desc>Retrieves the number of multi reads for GS1</desc>
<sample for="lua">local multiRead = Image.CodeReader.Barcode.GS1DataBar.getMultiRead(gs1)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.GS1DataBar" desc="The instance to use"/>
<return name="multiRead" type="int" desc="The value currently set"/>
                            </function>
                            <function name="setComponent2D">
<desc>Sets the GS1 2D component mode</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.GS1DataBar.setComponent2D(gs1,"Required")</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.GS1DataBar" desc="The instance to use"/>
<param name="component2d" type="enum" ref="Databar2DComponent" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getComponent2D">
<desc>Gets the GS1 2D component mode</desc>
<sample for="lua">local component2d = Image.CodeReader.Barcode.GS1DataBar.getComponent2D(gs1)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.GS1DataBar" desc="The instance to use"/>
<return name="component2d" type="enum" ref="Databar2DComponent" desc="The value currently set"/>
                            </function>
                            <function name="setNorcaVerifier">
<trait>deprecated</trait>
<desc>Sets the Norca flag. Deprecated and is relevant only in the Image.CodeReader.Barcode crown.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.GS1DataBar.setNorcaVerifier(gs1,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.GS1DataBar" desc="The instance to use"/>
<param name="norcaVerifier" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getNorcaVerifier">
<trait>deprecated</trait>
<desc>Gets the Norca flag</desc>
<sample for="lua">local norcaVerifier = Image.CodeReader.Barcode.GS1DataBar.getNorcaVerifier(gs1)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.GS1DataBar" desc="The instance to use"/>
<return name="norcaVerifier" type="bool" desc="The value set"/>
                            </function>
                        </serves>
                    </crown>
                    <crown name="Pharmacode">
                        <trait>released</trait>
                        <desc>The Pharma symbology.</desc>
                        <enum name="ModuleWidthMode">
                            <item desc="'Auto' still accepted.">AUTO</item>
                            <item desc="'UserDefined' still accepted.">USERDEFINED</item>
                        </enum>
                        <serves>
                            <function name="create">
<desc>Creates a new Pharma symbology instance</desc>
<sample for="lua">symbology = Image.CodeReader.Barcode.Pharmacode.create()</sample>
<return name="handle" type="handle" alias="Image.CodeReader.Barcode.Pharmacode" desc="The handle for the new Pharma symbology instance"/>
                            </function>
                            <function name="setActive">
<desc>Activates or deactivates the Pharma Code symbology. Default value is true.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Pharmacode.setActive(sym,false)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Pharmacode" desc="The instance to use"/>
<param name="active" type="bool" desc="The desired activation statuc."/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getActive">
<desc>Retrieves the Pharma Code symbology activation status. Default value is true.</desc>
<sample for="lua">local active = Image.CodeReader.Barcode.Pharmacode.getActive(sym)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Pharmacode" desc="The instance to use"/>
<return name="active" type="bool" desc="The current activation status."/>
                            </function>
                            <function name="setMultiRead">
<desc>Sets the number of multi reads for Pharma. Default value is 3.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Pharmacode.setMultiRead(pharma,3)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Pharmacode" desc="The instance to use"/>
<param name="multiRead" type="int" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getMultiRead">
<desc>Retrieves the number of multi reads for Pharma. Default value is 3.</desc>
<sample for="lua">local multiRead = Image.CodeReader.Barcode.Pharmacode.getMultiRead(pharma)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Pharmacode" desc="The instance to use"/>
<return name="multiRead" type="int" desc="The value currently used"/>
                            </function>
                            <function name="setModuleWidthMode">
<desc>Sets the module width mode</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Pharmacode.setModuleWidthMode(pharma,"UserDefined")</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Pharmacode" desc="The instance to use"/>
<param name="moduleWidthMode" type="enum" ref="ModuleWidthMode" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getModuleWidthMode">
<desc>Gets the module width mode</desc>
<sample for="lua">local moduleWidthMode = Image.CodeReader.Barcode.Pharmacode.getModuleWidthMode(pharma)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Pharmacode" desc="The instance to use"/>
<return name="moduleWidthMode" type="enum" ref="ModuleWidthMode" desc="The value currently used"/>
                            </function>
                            <function name="setModuleWidth">
<desc>Sets the module width</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Pharmacode.setModuleWidth(pharma,8)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Pharmacode" desc="The instance to use"/>
<param name="moduleWidth" type="float" desc="All modules thinner than half the parameter value are interpreted as thin, all others as wide. Unit: Pixels"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getModuleWidth">
<desc>Gets the module width</desc>
<sample for="lua">local moduleWidth = Image.CodeReader.Barcode.Pharmacode.getModuleWidth(pharma)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Pharmacode" desc="The instance to use"/>
<return name="moduleWidth" type="float" desc="All modules thinner than half the returned value are interpreted as thin, all others as wide. Unit: Pixels"/>
                            </function>
                            <function name="setReverse">
<desc>Sets the reverse flag</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Pharmacode.setReverse(pharma,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Pharmacode" desc="The instance to use"/>
<param name="reverse" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getReverse">
<desc>Gets the reverse flag</desc>
<sample for="lua">local reverse = Image.CodeReader.Barcode.Pharmacode.getReverse(pharma)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Pharmacode" desc="The instance to use"/>
<return name="reverse" type="bool" desc="The desired value"/>
                            </function>
                            <function name="setDecimalOutput">
<desc>Sets the decimal output flag</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Pharmacode.setDecimalOutput(pharma,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Pharmacode" desc="The instance to use"/>
<param name="decimalOutput" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getDecimalOutput">
<desc>Gets the decimal output flag</desc>
<sample for="lua">local decimalOutput = Image.CodeReader.Barcode.Pharmacode.setDecimalOutput(pharma)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Pharmacode" desc="The instance to use"/>
<return name="decimalOutput" type="bool" desc="The value currently set"/>
                            </function>
                            <function name="setCodeLength">
<desc>Sets the (fixed) code length</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Pharmacode.setCodeLength(pharma,5)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Pharmacode" desc="The instance to use"/>
<param name="codeLength" type="int" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getCodeLength">
<desc>Gets the (fixed) code length</desc>
<sample for="lua">local codeLength = Image.CodeReader.Barcode.Pharmacode.getCodeLength(pharma)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Pharmacode" desc="The instance to use"/>
<return name="codeLength" type="int" desc="The value currently set"/>
                            </function>
                            <function name="setNorcaVerifier">
<trait>deprecated</trait>
<desc>Sets the Norca flag. Deprecated and is relevant only in the Image.CodeReader.Barcode crown.</desc>
<sample for="lua">local success = Image.CodeReader.Barcode.Pharmacode.setNorcaVerifier(pharma,true)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Pharmacode" desc="The instance to use"/>
<param name="norcaVerifier" type="bool" desc="The desired value"/>
<return name="success" type="bool" desc="A flag whether setting was successful"/>
                            </function>
                            <function name="getNorcaVerifier">
<trait>deprecated</trait>
<desc>Gets the Norca flag</desc>
<sample for="lua">local norcaVerifier = Image.CodeReader.Barcode.Pharmacode.getNorcaVerifier(pharma)</sample>
<param name="handle" type="handle" alias="Image.CodeReader.Barcode.Pharmacode" desc="The instance to use"/>
<return name="norcaVerifier" type="bool" desc="The value set"/>
                            </function>
                        </serves>
                    </crown>
                </crown>
                <crown name="Postal">
                    <trait>released</trait>
                    <desc>The general Postal Code Reader.</desc>
                    <enum name="BlobSelectionMode">
                        <item>AUTO</item>
                        <item>DPIBASED</item>
                        <item>MODULESIZEBASED</item>
                    </enum>
                    <enum name="PostalCodeType">
                        <desc>An enumeration of the different postal code types.</desc>
                        <item>POSTNET</item>
                        <item>PLANET</item>
                        <item>USPS4SCB</item>
                        <item>POSTAUSTRALIA</item>
                        <item>RM4SCC</item>
                        <item>KIX</item>
                        <item>POSTSINGAPORE</item>
                        <item>POSTSWEDEN</item>
                        <item>CUSTOM4STATE</item>
                        <item>CUSTOM2STATE</item>
                        <item>MAILMARK</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <desc>Creates a new decoder instance</desc>
                            <sample for="lua">deco = Image.CodeReader.Postal.create()</sample>
                            <return name="handle" type="handle" alias="Image.CodeReader.Postal" desc="The handle for the new postal decoder instance"/>
                        </function>
                        <function name="setActive">
                            <desc>Activates or deactivates the Postal decoder. Default value is 'true'.
In order to run the Postal decoder one of the subdecoders must also be activated.
If the overall status is set to 'false' then the Postal Decoder will not do anything even
if any subdecoder is activated.</desc>
                            <sample for="lua">local success = Image.CodeReader.Postal.setActive(deco,false)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Postal" desc="The instance to use"/>
                            <param name="active" type="bool" desc="The desired activation statuc."/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getActive">
                            <desc>Retrieves the Postal decoder activation status.
Note that the activation status also depends on the activation status of the particular subdecoders.
If none of them has been activated the overall activation status will be 'false' even if 'setActive' was called with 'true'.</desc>
                            <sample for="lua">local active = Image.CodeReader.Postal.getActive(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Postal" desc="The instance to use"/>
                            <return name="active" type="bool" desc="The current activation status."/>
                        </function>
                        <function name="setPostalCodeActive">
                            <desc>Activates or deactivates the Postnet decoder. Default value is false.</desc>
                            <sample for="lua">local success = Image.CodeReader.Postal.setPostalCodeActive(deco, "KIX", true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Postal" desc="The instance to use"/>
                            <param name="codeType" type="enum" ref="PostalCodeType" desc="The particular decoder name."/>
                            <param name="postalCodeActive" type="bool" desc="The desired particular decoder activation status."/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getPostalCodeActive">
                            <desc>Retrieves the Postnet decoder activation status. Default value is false.</desc>
                            <sample for="lua">local postalCodeActive = Image.CodeReader.Postal.getPostalCodeActive(deco, "KIX")</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Postal" desc="The instance to use"/>
                            <param name="codeType" type="enum" ref="PostalCodeType" desc="The particular decoder name."/>
                            <return name="postalCodeActive" type="bool" desc="The current particular decoder activation status."/>
                        </function>
                        <function name="setBlobSelectionMode">
                            <desc>Sets the blob selection mode to be used in blob detection. Default value is 'AUTO'.</desc>
                            <sample for="lua">local success = Image.CodeReader.Postal.setBlobSelectionMode(deco, "DPIBASED")</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Postal" desc="The instance to use"/>
                            <param name="blobSelectionMode" type="enum" ref="BlobSelectionMode" desc="The desired blob selection mode."/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getBlobSelectionMode">
                            <desc>Retrieves the current blob selection mode. Default value is 'AUTO'.</desc>
                            <sample for="lua">local mode = Image.CodeReader.Postal.getBlobSelectionMode(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Postal" desc="The instance to use"/>
                            <return name="blobSelectionMode" type="enum" ref="BlobSelectionMode" desc="The current blob selection mode."/>
                        </function>
                        <function name="setDPI">
                            <desc>Sets the DPI value used when blob selection mode is 'DPIBASED'. Default value is 0.</desc>
                            <sample for="lua">local success = Image.CodeReader.Postal.setDPI(deco, 200)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Postal" desc="The instance to use"/>
                            <param name="dpi" type="int" desc="The desired DPI value."/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getDPI">
                            <desc>Retrieves the DPI value used when blob selection mode is 'DPIBASED'. Default value is 0.</desc>
                            <sample for="lua">local dpi = Image.CodeReader.Postal.getDPI(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Postal" desc="The instance to use"/>
                            <return name="dpi" type="int" desc="The current DPI value."/>
                        </function>
                        <function name="setModuleSize">
                            <desc>Sets the module size in pixels used when blob selection mode is 'MODULESIZEBASED'. Default value is -1.</desc>
                            <sample for="lua">local success = Image.CodeReader.Postal.setModuleSize(deco, 4.5)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Postal" desc="The instance to use"/>
                            <param name="moduleSize" type="float" desc="The desired module size value (in pixels)."/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getModuleSize">
                            <desc>Retrieves the ModuleSize value used when blob selection mode is 'ModuleSizeBASED'. Default value is -1.</desc>
                            <sample for="lua">local size = Image.CodeReader.Postal.getModuleSize(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Postal" desc="The instance to use"/>
                            <return name="moduleSize" type="float" desc="The current module size in pixels."/>
                        </function>
                        <function name="setOmniDirectional">
                            <desc>Sets the reading direction mode. Default value is true.</desc>
                            <sample for="lua">local success = Image.CodeReader.Postal.setOmniDirectional(deco, false)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Postal" desc="The instance to use"/>
                            <param name="omniDirectional" type="bool" desc="The desired value."/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getOmniDirectional">
                            <desc>Retrieves the reading direction mode. Default value is true.</desc>
                            <sample for="lua">local omniDirectional = Image.CodeReader.Postal.getOmniDirectional(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Postal" desc="The instance to use"/>
                            <return name="omniDirectional" type="bool" desc="The current omnidirection mode value."/>
                        </function>
                        <function name="setCompressResult">
                            <desc>Sets the 'compress result' flag. Valid and used for Post Sweden only. Default value is false.</desc>
                            <sample for="lua">local success = Image.CodeReader.Postal.setCompressResult(deco, true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Postal" desc="The instance to use"/>
                            <param name="compressResult" type="bool" desc="The desired value."/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getCompressResult">
                            <desc>Retrieves the 'compress result' flag. Valid and used for Post Sweden only. Default value is false.</desc>
                            <sample for="lua">local compressResult = Image.CodeReader.Postal.getCompressResult(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Postal" desc="The instance to use"/>
                            <return name="compressResult" type="bool" desc="The current 'compress result' flag value."/>
                        </function>
                        <function name="setAllowZeroFCC">
                            <desc>Sets the 'allow zero FCC' flag. Valid and used for Post Australia only. Default value is false.</desc>
                            <sample for="lua">local success = Image.CodeReader.Postal.setAllowZeroFCC(deco, true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Postal" desc="The instance to use"/>
                            <param name="allowZeroFcc" type="bool" desc="The desired value."/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getAllowZeroFCC">
                            <desc>Retrieves the 'allow zero FCC' flag. Valid and used for Post Australia only. Default value is false.</desc>
                            <sample for="lua">local allowZeroFcc = Image.CodeReader.Postal.getAllowZeroFCC(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Postal" desc="The instance to use"/>
                            <return name="allowZeroFcc" type="bool" desc="The current 'allow zero FCC' flag value."/>
                        </function>
                        <function name="setCustomerFormat">
                            <desc>Sets the customer format flag. Valid and used for Post Australia only and only in SICK devices. Default value is false.</desc>
                            <sample for="lua">local success = Image.CodeReader.Postal.setCustomerFormat(deco, true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Postal" desc="The instance to use"/>
                            <param name="customerFormat" type="bool" desc="The desired value."/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getCustomerFormat">
                            <desc>Retrieves the customer format flag. Valid and used for Post Australia only and only in SICK devices. Default value is false.</desc>
                            <sample for="lua">local allowZeroFcc = Image.CodeReader.Postal.getCustomerFormat(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Postal" desc="The instance to use"/>
                            <return name="customerFormat" type="bool" desc="The current customer format flag value."/>
                        </function>
                        <function name="setCodeLengths">
                            <desc>Sets the several code lengths</desc>
                            <sample for="lua">local success = Image.CodeReader.Postal.setCodeLengths(deco,"8,10")</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Postal" desc="The instance to use"/>
                            <param name="codeLengths" type="string" desc="The desired values or ranges separated by commas"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getCodeLengths">
                            <desc>Retrieves the several code fixed lengths</desc>
                            <sample for="lua">local codeLengths = Image.CodeReader.Postal.getCodeLengths(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Postal" desc="The instance to use"/>
                            <return name="codeLengths" type="string" desc="The desired values or ranges separated by commas"/>
                        </function>
                    </serves>
                </crown>
                <crown name="PDF417">
                    <trait>released</trait>
                    <desc>The Pdf417Decoder.</desc>
                    <enum name="AggressivityLevel">
                        <desc>AggressivityLevel that allows different retries.</desc>
                        <item desc="'Fast' also accepted.">FAST</item>
                        <item desc="'Balanced' also accepted.">BALANCED</item>
                        <item desc="'Aggressive' also accepted.">AGGRESSIVE</item>
                        <item desc="'VeryAggressive' also accepted.">VERYAGGRESSIVE</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <desc>Creates a new decoder instance</desc>
                            <sample for="lua">deco = Image.CodeReader.PDF417.create()</sample>
                            <return name="handle" type="handle" alias="Image.CodeReader.PDF417" desc="The handle for the new Pdf417 decoder instance"/>
                        </function>
                        <function name="setActive">
                            <desc>Activates or deactivates the PDF417 decoder. Default value is true.</desc>
                            <sample for="lua">local success = Image.CodeReader.PDF417.setActive(deco,false)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.PDF417" desc="The instance to use"/>
                            <param name="active" type="bool" desc="The desired activation statuc."/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getActive">
                            <desc>Retrieves the PDF417 decoder activation status. Default value is true.</desc>
                            <sample for="lua">local active = Image.CodeReader.PDF417.getActive(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.PDF417" desc="The instance to use"/>
                            <return name="active" type="bool" desc="The current activation status."/>
                        </function>
                        <function name="setOptimizeTruncated">
                            <desc>Sets the truncated code optimization</desc>
                            <sample for="lua">local success = Image.CodeReader.PDF417.setOptimizeTruncated(deco,true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.PDF417" desc="The instance to use"/>
                            <param name="optimizeTruncated" type="bool" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getOptimizeTruncated">
                            <desc>Gets the truncated code optimization flag</desc>
                            <sample for="lua">local optimizeTruncated = Image.CodeReader.PDF417.getOptimizeTruncated(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.PDF417" desc="The instance to use"/>
                            <return name="optimizeTruncated" type="bool" desc="The value currently set"/>
                        </function>
                        <function name="setNorcaVerifier">
                            <desc>Activates NoReadCauseAnalysis (Norca) for PDF417. Norca examines no reads and sets flags in the Image.CodeReader.Result feature vector.
Default value is 'false', i.e. Norca is off.</desc>
                            <sample for="lua">local success = Image.CodeReader.PDF417.setNorcaVerifier(deco,true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.PDF417" desc="The instance to use"/>
                            <param name="norcaVerifier" type="bool" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getNorcaVerifier">
                            <desc>Returns if Norca is active for PDF417.</desc>
                            <sample for="lua">local norcaVerifier = Image.CodeReader.PDF417.getNorcaVerifier(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.PDF417" desc="The instance to use"/>
                            <return name="norcaVerifier" type="bool" desc="The value currently set"/>
                        </function>
                    </serves>
                </crown>
                <crown name="DataMatrix">
                    <trait>released</trait>
                    <desc>The DataMatrix code reader. With the default settings, the code reader engine should read well printed, square Datamatrix codes of arbitrary size and with bright background.
The code reader supports the formats ECC200 (Default) and GS1, as well as rectangular code formats and direct part marked (DPM) codes.
To use this code reader in the engine with a preceding segmentation, the user needs to hand this decoder to the engine (Image.CodeReader.setDecoder).
If no segmentation is required, the user may start the single decoder directly (Image.CodeReader.DataMatrix.decode).</desc>
                    <enum name="CodeFormat">
                        <item>ECC200</item>
                        <item>GS1</item>
                    </enum>
                    <enum name="CodeBackground">
                        <item desc="'White' also accepted.">WHITE</item>
                        <item desc="'Black' also accepted.">BLACK</item>
                        <item desc="'Both' also accepted.">BOTH</item>
                    </enum>
                    <enum name="Direction">
                        <item desc="'Normal' also accepted.">NORMAL</item>
                        <item desc="'Mirrored' also accepted.">MIRRORED</item>
                        <item desc="'Both' also accepted.">BOTH</item>
                    </enum>
                    <enum name="FixedSize">
                        <item>10X10</item>
                        <item>12X12</item>
                        <item>14X14</item>
                        <item>16X16</item>
                        <item>18X18</item>
                        <item>20X20</item>
                        <item>22X22</item>
                        <item>24X24</item>
                        <item>26X26</item>
                        <item>32X32</item>
                        <item>36X36</item>
                        <item>40X40</item>
                        <item>44X44</item>
                        <item>48X48</item>
                        <item>52X52</item>
                        <item>64X64</item>
                        <item>72X72</item>
                        <item>80X80</item>
                        <item>88X88</item>
                        <item>96X96</item>
                        <item>104X104</item>
                        <item>120X120</item>
                        <item>132X132</item>
                        <item>144X144</item>
                        <item>18X8</item>
                        <item>32X8</item>
                        <item>26X12</item>
                        <item>36X12</item>
                        <item>36X16</item>
                        <item>48X16</item>
                        <item>8X48</item>
                        <item>24X32</item>
                        <item>24X40</item>
                        <item>24X48</item>
                        <item>26X32</item>
                        <item>26X40</item>
                        <item>26X48</item>
                        <item>8X64</item>
                        <item>12X64</item>
                        <item>16X64</item>
                        <item>24X64</item>
                        <item>26X64</item>
                        <item>12X48</item>
                    </enum>
                    <enum name="BinarizationAlgorithm">
                        <desc>BinarizationAlgorithm used internally for Grid binarization.</desc>
                        <item>BINALG1</item>
                        <item>BINALG2</item>
                        <item>BINALG3</item>
                        <item>BINALG4</item>
                    </enum>
                    <enum name="AggressivityLevel">
                        <item desc="'Fast' also accepted.">FAST</item>
                        <item desc="'Balanced' also accepted.">BALANCED</item>
                        <item desc="'Aggressive' also accepted.">AGGRESSIVE</item>
                        <item>DPM</item>
                        <item desc="'DPMPlus' also accepted.">DPMPLUS</item>
                    </enum>
                    <enum name="Verifier">
                        <item desc="'None' also accepted.">NONE</item>
                        <item>ISO16022</item>
                        <item>ISO15415</item>
                        <item desc="'AimDpm' also accepted.">AIMDPM</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <desc>Creates a new Datamatrix code reader.</desc>
                            <sample for="lua">deco = Image.CodeReader.DataMatrix.create()</sample>
                            <return name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The handle for the new Datamatrix decoder instance"/>
                        </function>
                        <function name="setImage">
                            <trait>hidden</trait>
                            <desc>Sets the image on which the decoder works.</desc>
                            <sample for="lua">success = Image.CodeReader.DataMatrix.setImage(deco, image)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <param name="image" type="const object" alias="Image" desc="The image the decoder works on"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="setRegion">
                            <desc>Sets the region of interest on which the Datamatrix decoder shall search. If no region is given the whole image is searched. If the code reder engine is used this setting will be ignored.</desc>
                            <sample for="lua">success = Image.CodeReader.DataMatrix.setRegion(deco,region)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <param name="region" type="const object" multiplicity="?" alias="Shape.Composite" desc="The region of interest the decoder shall use or nil if no region shall be used"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="setActive">
                            <desc>Activates or deactivates the DataMatrix decoder. Default value is true.</desc>
                            <sample for="lua">local success = Image.CodeReader.DataMatrix.setActive(deco,false)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <param name="active" type="bool" desc="The desired activation statuc."/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getActive">
                            <desc>Retrieves the DataMatrix decoder activation status. Default value is true.</desc>
                            <sample for="lua">local active = Image.CodeReader.DataMatrix.getActive(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <return name="active" type="bool" desc="The current activation status."/>
                        </function>
                        <function name="setDiagLevel">
                            <trait>hidden</trait>
                            <desc>Sets the diagnosis level of the Datamatrix decoder.</desc>
                            <sample for="lua">local success = Image.CodeReader.DataMatrix.setDiagLevel(deco,2)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <param name="diagLevel" type="int" desc="The desired level of diagnosis"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful or not"/>
                        </function>
                        <function name="getDiagLevel">
                            <trait>hidden</trait>
                            <desc>Gets the diagnosis level of the Datamatrix decoder.</desc>
                            <sample for="lua">local level = Image.CodeReader.DataMatrix.getDiagLevel(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <return name="diagLevel" type="int" desc="The level of diagnosis currently used"/>
                        </function>
                        <function name="decode">
                            <desc>Starts the single Datamatrix code reader without preceding segmentation and returns the decoding result. If a segmentation is needed, use the decode-function from the code reader engine instead.</desc>
                            <sample for="lua">codes = Image.CodeReader.DataMatrix.decode(deco, image)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <param name="image" type="const object" alias="Image" desc="The image the decoder works on"/>
                            <return name="codes" type="const object" multiplicity="+" alias="Image.CodeReader.Result" desc="The complete Datamatrix result list, a list of ImageDecoderResult-s"/>
                            <return name="durationMs" type="int" desc="The overall time in ms for the current decoding process"/>
                        </function>
                        <function name="getDiagnosis">
                            <trait>hidden</trait>
                            <desc>Gets the diagnosis object after decoding. The object is released and so the function can only be called once.</desc>
                            <sample for="lua">local diagnosis = Image.CodeReader.DataMatrix.getDiagnosis(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <return name="diagnosis" type="binary" desc="The released diagnosis object."/>
                        </function>
                        <function name="setCodeFormat">
                            <desc>Sets the Datamatrix code format, which can be ECC200 (Default) or GS1.</desc>
                            <sample for="lua">local success = Image.CodeReader.DataMatrix.setCodeFormat(deco,"ECC200")</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <param name="codeFormat" type="enum" ref="CodeFormat" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getCodeFormat">
                            <desc>Gets the active Datamatrix code format.</desc>
                            <sample for="lua">local codeFormat = Image.CodeReader.DataMatrix.getCodeFormat(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <return name="codeFormat" type="enum" ref="CodeFormat" desc="The value currently set"/>
                        </function>
                        <function name="setCodeBackground">
                            <desc>Sets the code background mode to "White" (Default), "Black" or "Both". E.g. if "White" is set, only dark codes on bright background will be read.</desc>
                            <sample for="lua">local success = Image.CodeReader.DataMatrix.setCodeBackground(deco,"Both")</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <param name="codeBackground" type="enum" ref="CodeBackground" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getCodeBackground">
                            <desc>Retrieves the Datamatrix code background color.</desc>
                            <sample for="lua">local codeBackground = Image.CodeReader.DataMatrix.getCodeBackground(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <return name="codeBackground" type="enum" ref="CodeBackground" desc="The value currently set"/>
                        </function>
                        <function name="setDirection">
                            <desc>Sets the code direction to "Normal", "Mirrored" or "Both" (Default).  E.g. if "Mirrored" is set, only codes that appear mirrored will be read.</desc>
                            <sample for="lua">local success = Image.CodeReader.DataMatrix.setDirection(deco,"Mirrored")</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <param name="direction" type="enum" ref="Direction" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getDirection">
                            <desc>Retrieves the Datamatrix code direction.</desc>
                            <sample for="lua">local direction = Image.CodeReader.DataMatrix.getDirection(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <return name="direction" type="enum" ref="Direction" desc="The value currently set"/>
                        </function>
                        <function name="setMaxErrorCorr">
                            <trait>deprecated</trait>
                            <desc>Sets the maximum number of errors that may occur for correction. Default is 100.</desc>
                            <sample for="lua">local success = Image.CodeReader.DataMatrix.setMaxErrorCorr(deco,99)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <param name="maxErrorCorr" type="int" desc="The desired value. Must be between 0 and 100"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getMaxErrorCorr">
                            <trait>deprecated</trait>
                            <desc>Gets the maximum number of errors that may occur for correction.</desc>
                            <sample for="lua">local maxErrorCorr = Image.CodeReader.DataMatrix.getMaxErrorCorr(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <return name="maxErrorCorr" type="int" desc="The value currently set"/>
                        </function>
                        <function name="setCodeSizes">
                            <trait>hidden</trait>
                            <desc>Sets the allowed code size values</desc>
                            <sample for="lua">local success = Image.CodeReader.DataMatrix.setCodeSizes(deco,"14x14,18x14")</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <param name="codeSizes" type="string" desc="The desired code sizes as string"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getCodeSizes">
                            <trait>hidden</trait>
                            <desc>Gets the allowed code size values</desc>
                            <sample for="lua">local codeSizes = Image.CodeReader.DataMatrix.getCodeSizes(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <return name="codeSizes" type="string" desc="The code sizes currently set (as string)"/>
                        </function>
                        <function name="setFixedCodeSizes">
                            <desc>Sets the allowed code size(s). The argument containing the code sizes needs to be a vector. Note that the Datamatrix code does not support arbitrary code sizes.
For available code sizes type Image.CodeReader.DataMatrix.FixedSizes. If no code size is set, all sizes will be read (Default). In case only invalid code sizes are set, the decoder will return no decoding result.</desc>
                            <sample for="lua">local success = Image.CodeReader.DataMatrix.setFixedCodeSizes(deco,{"14x14","18x14"})</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <param name="fixedCodeSizes" type="enum" multiplicity="+" ref="FixedSize" desc="The desired values as a vector of enums"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getFixedCodeSizes">
                            <desc>Gets the allowed code size vector.</desc>
                            <sample for="lua">local fixedCodeSizes = Image.CodeReader.DataMatrix.getFixedCodeSizes(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <return name="fixedCodeSizes" type="enum" multiplicity="+" ref="FixedSize" desc="The vector of size values currently set"/>
                        </function>
                        <function name="setRectangularFields">
                            <desc>Sets the flag whether rectangular data matrix formats are allowed. If false, only square codes can be read. Default is true.</desc>
                            <sample for="lua">local success = Image.CodeReader.DataMatrix.setRectangularFields(deco,true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <param name="rectFields" type="bool" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getRectangularFields">
                            <desc>Gets the flag whether rectangular data matrix formats are allowed.</desc>
                            <sample for="lua">local rectangularFields = Image.CodeReader.DataMatrix.getRectangularFields(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <return name="rectFields" type="bool" desc="The value currently set"/>
                        </function>
                        <function name="setSurroundedByPatterns">
                            <desc>Sets an additional flag to ignore pattern-like structures. Decreases calculation times if the code is surrounded by patterns. Default is false.</desc>
                            <sample for="lua">local success = Image.CodeReader.DataMatrix.setSurroundedByPatterns(deco,true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <param name="surroundedByPatterns" type="bool" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getSurroundedByPatterns">
                            <desc>Gets the value of the SurroundedByPatterns-flag.</desc>
                            <sample for="lua">local surroundedByPatterns = Image.CodeReader.DataMatrix.getSurroundedByPatterns(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <return name="surroundedByPatterns" type="bool" desc="The value currently set"/>
                        </function>
                        <function name="setSurroundedByText">
                            <desc>Sets an additional flag to ignore text-like structures. Decreases calculation times if the code is surrounded by text. Default is false.</desc>
                            <sample for="lua">local success = Image.CodeReader.DataMatrix.setSurroundedByText(deco,true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <param name="surroundedByText" type="bool" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getSurroundedByText">
                            <desc>Gets the value of the flag that allows DMx code reading also if the code is (tightly) surrounded by text.</desc>
                            <sample for="lua">local surroundedByText = Image.CodeReader.DataMatrix.getSurroundedByText(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <return name="surroundedByText" type="bool" desc="The value currently set"/>
                        </function>
                        <function name="setExcludeCodeAreas">
                            <desc>Sets an additional flag that allows exclusion of regions containing non-Datamatrix codes. Default is false.</desc>
                            <sample for="lua">local success = Image.CodeReader.DataMatrix.setExcludeCodeAreas(deco,true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <param name="excludeCodeAreas" type="bool" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getExcludeCodeAreas">
                            <desc>Gets the value of the flag that allows allows exclusion of regions containing non-Datamatrix codes.</desc>
                            <sample for="lua">local excludecodeareas = Image.CodeReader.DataMatrix.getExcludeCodeAreas(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <return name="excludeCodeAreas" type="bool" desc="The value currently set"/>
                        </function>
                        <function name="setAggressivityLevel">
                            <desc>Sets the Decoding Aggressivity Level of the Datamatrix decoder. With this setting a tradeoff between speed and reading performance can be made.
The modes ordered according to increasing performance / decreasing speed are "FAST", "BALANCED", "AGGRESSIVE" (Default), "DPM" and "DPMPLUS". "DPM" refers to direct part marked, i.e. marking by laser or press.
Note that neither "DPM" nor "DPMPLUS" is used in the crown yet and gets translated to "AGGRESSIVE".</desc>
                            <sample for="lua">local success = Image.CodeReader.DataMatrix.setAggressivityLevel(deco, "AGGRESSIVE")</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <param name="aggressivityLevel" type="enum" ref="AggressivityLevel" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getAggressivityLevel">
                            <desc>Gets the Decoding Aggressivity Level value of the Datamatrix decoder. Default value is "AGGRESSIVE".</desc>
                            <sample for="lua">local decodingmode = Image.CodeReader.DataMatrix.getAggressivityLevel(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <return name="aggressivityLevel" type="enum" ref="AggressivityLevel" desc="The desired value"/>
                        </function>
                        <function name="setDecodingMode">
                            <trait>deprecated</trait>
                            <desc>Sets the Decoding Mode of the Datamatrix decoder. For compatibility only, see and use setAggressivityLevel instead.</desc>
                            <sample for="lua">local success = Image.CodeReader.DataMatrix.setDecodingMode(deco, "AGGRESSIVE")</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <param name="decodingMode" type="enum" ref="AggressivityLevel" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getDecodingMode">
                            <trait>deprecated</trait>
                            <desc>Gets the Decoding Mode value of the Datamatrix decoder. For compatibility only, see and use getAggressivityLevel instead.</desc>
                            <sample for="lua">local decodingmode = Image.CodeReader.DataMatrix.getDecodingMode(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <return name="decodingMode" type="enum" ref="AggressivityLevel" desc="The desired value"/>
                        </function>
                        <function name="setLPatternErrors">
                            <desc>Sets the flag whether defects in the code's L-pattern are allowed. If true, additional calculation time will be needed to restore the L-pattern. Default is true.</desc>
                            <sample for="lua">local success = Image.CodeReader.DataMatrix.setLPatternErrors(deco,true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <param name="lPatternErrors" type="bool" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getLPatternErrors">
                            <desc>Gets the value of the flag whether defects in the code's L-pattern are allowed.</desc>
                            <sample for="lua">local lPatternErrors = Image.CodeReader.DataMatrix.getLPatternErrors(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <return name="lPatternErrors" type="bool" desc="The value currently set"/>
                        </function>
                        <function name="setMinModuleSize">
                            <desc>Sets the minimal module size for the DMx codes. Used only if 2D code size is 'VERYBIG' or the DMx decoder is used stand-alone. Default value is 4.</desc>
                            <sample for="lua">local success = Image.CodeReader.DataMatrix.setMinModuleSize(deco,6)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <param name="minModuleSize" type="int" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getMinModuleSize">
                            <desc>Retrieves the minimal module size for the DMx codes. Used only if 2D code size is 'VERYBIG' or the DMx decoder is used stand-alone. Default value is 4.</desc>
                            <sample for="lua">local minModuleSize = Image.CodeReader.DataMatrix.getMinModuleSize(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <return name="minModuleSize" type="int" desc="The value currently set"/>
                        </function>
                        <function name="setGS1FirstCharReplacement">
                            <desc>Sets the replacement string for the first FNC1 character in a GS1 DataMatrix code. Only if 'CodeFormat' is 'GS1'. Default value is an empty string.</desc>
                            <sample for="lua">local success = Image.CodeReader.DataMatrix.setGS1FirstCharReplacement(deco,"33,34")</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <param name="gs1FirstCharReplacement" type="string" desc="A comma-separated list (string) of not more than 4 character ASCII codes (integers)."/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getGS1FirstCharReplacement">
                            <desc>Retrieves the replacement string for the first FNC1 character in a GS1 DataMatrix code. Only if 'CodeFormat' is 'GS1'. Default value is an empty string.</desc>
                            <sample for="lua">local replacement = Image.CodeReader.DataMatrix.getGS1FirstCharReplacement(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <return name="gs1FirstCharReplacement" type="string" desc="A comma-separated list (string) of not more than 4 character ASCII codes (integers)."/>
                        </function>
                        <function name="setGS1CodeCharReplacement">
                            <desc>Sets the replacement string for the FNC1 code character in a GS1 DataMatrix code. Only if 'CodeFormat' is 'GS1'. Default value is an empty string.</desc>
                            <sample for="lua">local success = Image.CodeReader.DataMatrix.setGS1CodeCharReplacement(deco,"33,34")</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <param name="gs1CodeCharReplacement" type="string" desc="A comma-separated list (string) of not more than 4 character ASCII codes (integers)."/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getGS1CodeCharReplacement">
                            <desc>Retrieves the replacement string for the FNC1 code character in a GS1 DataMatrix code. Only if 'CodeFormat' is 'GS1'. Default value is an empty string.</desc>
                            <sample for="lua">local replacement = Image.CodeReader.DataMatrix.getGS1CodeCharReplacement(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <return name="gs1CodeCharReplacement" type="string" desc="A comma-separated list (string) of not more than 4 character ASCII codes (integers)."/>
                        </function>
                        <function name="setGS1AIMarking">
                            <desc>Surrounds Application Identifiers with brackets. Only if 'CodeFormat' is 'GS1'. Default value is an empty string.</desc>
                            <sample for="lua">local success = Image.CodeReader.DataMatrix.setGS1AIMarking(deco,true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <param name="gs1AIMarking" type="bool" desc="The flag that surrounds Application Identifiers with brackets."/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getGS1AIMarking">
                            <desc>Retrieves the flag that surrounds Application Identifiers with brackets. Only if 'CodeFormat' is 'GS1'. Default value is an empty string.</desc>
                            <sample for="lua">local flag = Image.CodeReader.DataMatrix.getGS1AIMarking(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <return name="gs1AIMarking" type="bool" desc="The flag that surrounds Application Identifiers with brackets."/>
                        </function>
                        <function name="setVerifier">
                            <desc>Sets the value (mode) of the verifier calculation according to the corresponding ISO norm. Allowed values are "None", "ISO16022" (Default), "ISO15415" and "AimDpm",</desc>
                            <sample for="lua">local success = Image.CodeReader.DataMatrix.setVerifier(deco,"ISO16022")</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <param name="verifier" type="enum" ref="Verifier" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getVerifier">
                            <desc>Retrieves the value of the verifier.</desc>
                            <sample for="lua">local verifier = Image.CodeReader.DataMatrix.getVerifier(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <return name="verifier" type="enum" ref="Verifier" desc="The value currently set"/>
                        </function>
                        <function name="setNorcaVerifier">
                            <desc>Activates NoReadCauseAnalysis (Norca) for DataMatrix. Norca examines no reads and sets flags in the Image.CodeReader.Result feature vector.
Default value is 'false', i.e. Norca is off.</desc>
                            <sample for="lua">local success = Image.CodeReader.DataMatrix.setNorcaVerifier(deco,true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <param name="norcaVerifier" type="bool" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getNorcaVerifier">
                            <desc>Returns if Norca is activated for DataMatrix</desc>
                            <sample for="lua">local norcaVerifier = Image.CodeReader.DataMatrix.getNorcaVerifier(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.DataMatrix" desc="The instance to use"/>
                            <return name="norcaVerifier" type="bool" desc="The value currently set"/>
                        </function>
                    </serves>
                </crown>
                <crown name="QR">
                    <trait>released</trait>
                    <desc>The QR decoder.</desc>
                    <enum name="CodeBackground">
                        <item desc="'White' also accepted.">WHITE</item>
                        <item desc="'Black' also accepted.">BLACK</item>
                        <item desc="'Both' also accepted.">BOTH</item>
                    </enum>
                    <enum name="Direction">
                        <item desc="'Normal' also accepted.">NORMAL</item>
                        <item desc="'Mirrored' also accepted.">MIRRORED</item>
                        <item desc="'Both' also accepted.">BOTH</item>
                    </enum>
                    <enum name="AggressivityLevel">
                        <desc>AggressivityLevel that allows different levels of decoding.</desc>
                        <item desc="'Fast' also accepted.">FAST</item>
                        <item desc="'Balanced' also accepted.">BALANCED</item>
                        <item desc="'Aggressive' also accepted.">AGGRESSIVE</item>
                    </enum>
                    <enum name="FixedSize">
                        <item>21X21</item>
                        <item>25X25</item>
                        <item>29X29</item>
                        <item>33X33</item>
                        <item>37X37</item>
                        <item>41X41</item>
                        <item>45X45</item>
                        <item>49X49</item>
                        <item>53X53</item>
                        <item>57X57</item>
                        <item>61X61</item>
                        <item>65X65</item>
                        <item>69X69</item>
                        <item>73X73</item>
                        <item>77X77</item>
                        <item>81X81</item>
                        <item>85X85</item>
                        <item>89X89</item>
                        <item>93X93</item>
                        <item>97X97</item>
                        <item>101X101</item>
                        <item>105X105</item>
                        <item>109X109</item>
                        <item>113X113</item>
                        <item>117X117</item>
                        <item>121X121</item>
                        <item>125X125</item>
                        <item>129X129</item>
                        <item>133X133</item>
                        <item>137X137</item>
                        <item>141X141</item>
                        <item>145X145</item>
                        <item>149X149</item>
                        <item>153X153</item>
                        <item>157X157</item>
                        <item>161X161</item>
                        <item>165X165</item>
                        <item>169X169</item>
                        <item>173X173</item>
                        <item>177X177</item>
                    </enum>
                    <enum name="Model">
                        <item desc="'Both' also accepted.">BOTH</item>
                        <item desc="'Model1' also accepted.">MODEL1</item>
                        <item desc="'Model2' also accepted.">MODEL2</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <desc>Creates a new decoder instance</desc>
                            <sample for="lua">deco = Image.CodeReader.QR.create()</sample>
                            <return name="handle" type="handle" alias="Image.CodeReader.QR" desc="The handle for the new Qr decoder instance"/>
                        </function>
                        <function name="setImage">
                            <trait>hidden</trait>
                            <desc>Sets the image on which the decoder works.</desc>
                            <sample for="lua">success = Image.CodeReader.QR.setImage(deco, image)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <param name="image" type="const object" alias="Image" desc="The image the decoder works on"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="setRegion">
                            <desc>Sets the region of interest where the QR decoder should search. If no region is given the whole image is searched.</desc>
                            <sample for="lua">success = Image.CodeReader.QR.setRegion(deco,region)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <param name="region" type="const object" multiplicity="?" alias="Shape.Composite" desc="The region of interest the decoder shall use or nil if no region shall be used"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="setActive">
                            <desc>Activates or deactivates the QR decoder. Default value is true.</desc>
                            <sample for="lua">local success = Image.CodeReader.QR.setActive(deco,false)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <param name="active" type="bool" desc="The desired activation statuc."/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getActive">
                            <desc>Retrieves the QR decoder activation status. Default value is true.</desc>
                            <sample for="lua">local active = Image.CodeReader.QR.getActive(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <return name="active" type="bool" desc="The current activation status."/>
                        </function>
                        <function name="setDiagLevel">
                            <trait>hidden</trait>
                            <desc>Sets the diagnosis level of the QR diagnosis object</desc>
                            <sample for="lua">local success = Image.CodeReader.QR.setDiagLevel(deco,2)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <param name="diagLevel" type="int" desc="The desired level of diagnosis"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful or not"/>
                        </function>
                        <function name="getDiagLevel">
                            <trait>hidden</trait>
                            <desc>Gets the diagnosis level of the output object</desc>
                            <sample for="lua">local level = Image.CodeReader.QR.getDiagLevel(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <return name="diagLevel" type="int" desc="The level of diagnosis currently used"/>
                        </function>
                        <function name="decode">
                            <desc>Decodes the QR code contained in the (region of the) image and returns the decoded result</desc>
                            <sample for="lua">codes = Image.CodeReader.QR.decode(deco, image)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <param name="image" type="const object" alias="Image" desc="The image the decoder works on"/>
                            <return name="codes" type="const object" multiplicity="+" alias="Image.CodeReader.Result" desc="The complete datamatrix result list, a list of ImageDecoderResult-s"/>
                            <return name="durationMs" type="int" desc="The overall time in ms for the current decoding process"/>
                        </function>
                        <function name="getDiagnosis">
                            <trait>hidden</trait>
                            <desc>Gets the diagnosis object after decoding. The object is released and so the function shall be called only once.</desc>
                            <sample for="lua">local diagnosis = Image.CodeReader.QR.getDiagnosis(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <return name="diagnosis" type="binary" desc="The released diagnosis object."/>
                        </function>
                        <function name="setCodeBackground">
                            <desc>Sets the possible code background color. Default value is "White".</desc>
                            <sample for="lua">local success = Image.CodeReader.QR.setCodeBackground(deco,"Both")</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <param name="codeBackground" type="enum" ref="CodeBackground" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getCodeBackground">
                            <desc>Retrieves the code background color. Default value is "White".</desc>
                            <sample for="lua">local codeBackground = Image.CodeReader.QR.getCodeBackground(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <return name="codeBackground" type="enum" ref="CodeBackground" desc="The value currently set"/>
                        </function>
                        <function name="setDirection">
                            <desc>Sets the code direction. Default value is "Both".</desc>
                            <sample for="lua">local success = Image.CodeReader.QR.setDirection(deco,"Both")</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <param name="direction" type="enum" ref="Direction" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getDirection">
                            <desc>Retrieves the code direction. Default value is "Both".</desc>
                            <sample for="lua">local direction = Image.CodeReader.QR.getDirection(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <return name="direction" type="enum" ref="Direction" desc="The value currently set"/>
                        </function>
                        <function name="setCodeSizes">
                            <trait>hidden</trait>
                            <desc>Sets the allowed code sizes</desc>
                            <sample for="lua">local success = Image.CodeReader.QR.setCodeSizes(deco,"21x21,25x25")</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <param name="codeSizes" type="string" desc="The desired values of form sizexsize or only size separated by commas"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getCodeSizes">
                            <trait>hidden</trait>
                            <desc>Gets the allowed code sizes</desc>
                            <sample for="lua">local codeSizes = Image.CodeReader.QR.getCodeSizes(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <return name="codeSizes" type="string" desc="The current values of form sizexsize or only size separated by commas"/>
                        </function>
                        <function name="setFixedCodeSizes">
                            <desc>Sets the allowed code size vector</desc>
                            <sample for="lua">local success = Image.CodeReader.QR.setFixedCodeSizes(deco,{"21x21","25x25"})</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <param name="fixedCodeSizes" type="enum" multiplicity="+" ref="FixedSize" desc="The desired size values as a vector"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getFixedCodeSizes">
                            <desc>Gets the allowed code size vector</desc>
                            <sample for="lua">local fixedCodeSizes = Image.CodeReader.QR.getFixedCodeSizes(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <return name="fixedCodeSizes" type="enum" multiplicity="+" ref="FixedSize" desc="The vector of current size values"/>
                        </function>
                        <function name="setModel">
                            <desc>Sets the model value</desc>
                            <sample for="lua">local success = Image.CodeReader.QR.setModel(deco,"Model2")</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <param name="model" type="enum" ref="Model" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getModel">
                            <desc>Retrieves the model value</desc>
                            <sample for="lua">local model = Image.CodeReader.QR.getModel(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <return name="model" type="enum" ref="Model" desc="The value currently set"/>
                        </function>
                        <function name="setVerifier">
                            <desc>Enables or disables the verifier. Default value is false.</desc>
                            <sample for="lua">local success = Image.CodeReader.QR.setVerifier(deco,true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <param name="verifier" type="bool" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getVerifier">
                            <desc>Retrieves the verifier activation status. Default value is false.</desc>
                            <sample for="lua">local verifier = Image.CodeReader.QR.getVerifier(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <return name="verifier" type="bool" desc="The value currently set"/>
                        </function>
                        <function name="setAggressivityLevel">
                            <desc>Sets the decoding level of the QR decoder. Default value is 'Aggressive'.</desc>
                            <sample for="lua">local success = Image.CodeReader.QR.setAggressivityLevel(deco,"Fast")</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <param name="aggressivityLevel" type="enum" ref="AggressivityLevel" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getAggressivityLevel">
                            <desc>Retrieves the decoding level of the QR decoder. Default value is 'Aggressive'.</desc>
                            <sample for="lua">local level = Image.CodeReader.QR.getAggressivityLevel(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <return name="aggressivityLevel" type="enum" ref="AggressivityLevel" desc="The value currently set."/>
                        </function>
                        <function name="setIssueUndecodable">
                            <trait>deprecated</trait>
                            <desc>Sets the issueUndecodable value. Deprecated. Use 'setNorcaVerifier' instead.</desc>
                            <sample for="lua">local success = Image.CodeReader.QR.setIssueUndecodable(deco,true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <param name="issueUndecodable" type="bool" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getIssueUndecodable">
                            <trait>deprecated</trait>
                            <desc>Gets the issueUndecodable value. Deprecated. Use 'getNorcaVerifier' instead.</desc>
                            <sample for="lua">local issueUndecodable = Image.CodeReader.QR.getIssueUndecodable(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <return name="issueUndecodable" type="bool" desc="The value currently set"/>
                        </function>
                        <function name="setNorcaVerifier">
                            <desc>Activates NoReadCauseAnalysis (Norca) for QR. Norca examines no reads and sets flags in the Image.CodeReader.Result feature vector.
Default value is 'false', i.e. Norca is off.</desc>
                            <sample for="lua">local success = Image.CodeReader.QR.setNorcaVerifier(deco,true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <param name="norcaVerifier" type="bool" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getNorcaVerifier">
                            <desc>Returns if Norca is activated for QR.</desc>
                            <sample for="lua">local norcaVerifier = Image.CodeReader.QR.getNorcaVerifier(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.QR" desc="The instance to use"/>
                            <return name="norcaVerifier" type="bool" desc="The value currently set"/>
                        </function>
                    </serves>
                </crown>
                <crown name="Maxicode">
                    <trait>released</trait>
                    <desc>The Maxicode decoder.</desc>
                    <enum name="SamplingSpeedOption">
                        <item desc="'Normal' also accepted.">NORMAL</item>
                        <item desc="'SpeedUpIPMethods' also accepted.">SPEEDUPIPMETHODS</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <desc>Creates a new decoder instance</desc>
                            <sample for="lua">deco = Image.CodeReader.Maxicode.create()</sample>
                            <return name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The handle for the new Maxicode decoder instance"/>
                        </function>
                        <function name="setImage">
                            <trait>hidden</trait>
                            <desc>Sets the image on which the decoder works.</desc>
                            <sample for="lua">success = Image.CodeReader.Maxicode.setImage(deco, image)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <param name="image" type="const object" alias="Image" desc="The image the decoder works on"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="setRegion">
                            <desc>Sets the region of interest where the Maxicode decoder should search. If no region is given the whole image is searched.</desc>
                            <sample for="lua">success = Image.CodeReader.Maxicode.setRegion(deco,region)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <param name="region" type="const object" multiplicity="?" alias="Shape.Composite" desc="The region of interest the decoder shall use or nil if no region shall be used"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="setActive">
                            <desc>Activates or deactivates the Maxicode decoder. Default value is true.</desc>
                            <sample for="lua">local success = Image.CodeReader.Maxicode.setActive(deco,false)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <param name="active" type="bool" desc="The desired activation statuc."/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getActive">
                            <desc>Retrieves the Maxicode decoder activation status. Default value is true.</desc>
                            <sample for="lua">local active = Image.CodeReader.Maxicode.getActive(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <return name="active" type="bool" desc="The current activation status."/>
                        </function>
                        <function name="setDiagLevel">
                            <trait>hidden</trait>
                            <desc>Sets the diagnosis level of the Maxicode diagnosis object</desc>
                            <sample for="lua">local success = Image.CodeReader.Maxicode.setDiagLevel(deco,2)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <param name="diagLevel" type="int" desc="The desired level of diagnosis"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful or not"/>
                        </function>
                        <function name="getDiagLevel">
                            <trait>hidden</trait>
                            <desc>Gets the diagnosis level of the output object</desc>
                            <sample for="lua">local level = Image.CodeReader.Maxicode.getDiagLevel(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <return name="diagLevel" type="int" desc="The level of diagnosis currently used"/>
                        </function>
                        <function name="decode">
                            <desc>Decodes the Maxicode code contained in the (region of the) image and returns the decoded result</desc>
                            <sample for="lua">codes = Image.CodeReader.Maxicode.decode(deco, image)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <param name="image" type="const object" alias="Image" desc="The image the decoder works on"/>
                            <return name="codes" type="const object" multiplicity="+" alias="Image.CodeReader.Result" desc="The complete datamatrix result list, a list of ImageDecoderResult-s"/>
                            <return name="durationMs" type="int" desc="The overall time in ms for the current decoding process"/>
                        </function>
                        <function name="getDiagnosis">
                            <trait>hidden</trait>
                            <desc>Gets the diagnosis object after decoding. The object is released and so the function shall be called only once.</desc>
                            <sample for="lua">local diagnosis = Image.CodeReader.Maxicode.getDiagnosis(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <return name="diagnosis" type="binary" desc="The released diagnosis object."/>
                        </function>
                        <function name="setMode2Active">
                            <desc>Activates or deactivates the Mode2: Structured Carrier Message for numerical postal codes. Default value is true.</desc>
                            <sample for="lua">local success = Image.CodeReader.Maxicode.setMode2Active(deco,true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <param name="mode2Active" type="bool" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getMode2Active">
                            <desc>Gets the Mode2 activation status. Default value is true.</desc>
                            <sample for="lua">local mode2Active = Image.CodeReader.Maxicode.getMode2Active(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <return name="mode2Active" type="bool" desc="The value currently set"/>
                        </function>
                        <function name="setMode3Active">
                            <desc>Activates or deactivates the Mode3: Structured Carrier Message for alphanumerical postal codes. Default value is true.</desc>
                            <sample for="lua">local success = Image.CodeReader.Maxicode.setMode3Active(deco,true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <param name="mode3Active" type="bool" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getMode3Active">
                            <desc>Gets the Mode3 activation status. Default value is true.</desc>
                            <sample for="lua">local mode3Active = Image.CodeReader.Maxicode.getMode3Active(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <return name="mode3Active" type="bool" desc="The value currently set"/>
                        </function>
                        <function name="setMode4Active">
                            <desc>Activates or deactivates the Mode4: Unformatted data. Default value is true.</desc>
                            <sample for="lua">local success = Image.CodeReader.Maxicode.setMode4Active(deco,true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <param name="mode4Active" type="bool" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getMode4Active">
                            <desc>Gets the Mode4 activation status. Default value is true.</desc>
                            <sample for="lua">local mode4Active = Image.CodeReader.Maxicode.getMode4Active(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <return name="mode4Active" type="bool" desc="The value currently set"/>
                        </function>
                        <function name="setMode5Active">
                            <desc>Activates or deactivates the Mode5: Unformatted data encoded with full Enhanced Error Correction(EEC). Default value is true.</desc>
                            <sample for="lua">local success = Image.CodeReader.Maxicode.setMode5Active(deco,true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <param name="mode5Active" type="bool" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getMode5Active">
                            <desc>Gets the Mode5 activation status. Default value is true.</desc>
                            <sample for="lua">local mode5Active = Image.CodeReader.Maxicode.getMode5Active(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <return name="mode5Active" type="bool" desc="The value currently set"/>
                        </function>
                        <function name="setMode6Active">
                            <desc>Activates or deactivates the Mode6: Code Reader programming. Default value is true.</desc>
                            <sample for="lua">local success = Image.CodeReader.Maxicode.setMode6Active(deco,true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <param name="mode6Active" type="bool" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getMode6Active">
                            <desc>Gets the Mode6 activation status. Default value is true.</desc>
                            <sample for="lua">local mode6Active = Image.CodeReader.Maxicode.getMode6Active(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <return name="mode6Active" type="bool" desc="The value currently set"/>
                        </function>
                        <function name="setPrimaryMessage">
                            <desc>Activates or deactivates the Primary Message mode, where only the primary message is required to be successfully decoded. Default value is true.</desc>
                            <sample for="lua">local success = Image.CodeReader.Maxicode.setPrimaryMessage(deco,true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <param name="primaryMsg" type="bool" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getPrimaryMessage">
                            <desc>Gets the Primary Message mode activation status. Default value is true.</desc>
                            <sample for="lua">local primaryMessage = Image.CodeReader.Maxicode.getPrimaryMessage(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <return name="primaryMsg" type="bool" desc="The value currently set"/>
                        </function>
                        <function name="setVerifier">
                            <desc>Activates or deactivates the verifier.</desc>
                            <sample for="lua">local success = Image.CodeReader.Maxicode.setVerifier(deco,true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <param name="verifier" type="bool" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getVerifier">
                            <desc>Retrieves the verifier activation status.</desc>
                            <sample for="lua">local verifier = Image.CodeReader.Maxicode.getVerifier(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <return name="verifier" type="bool" desc="The value currently set"/>
                        </function>
                        <function name="setSamplingSpeedOption">
                            <desc>Sets the maxicode sampling speed-up option</desc>
                            <sample for="lua">local success = Image.CodeReader.Maxicode.setSamplingSpeedOption(deco,"Normal")</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <param name="samplingSpeedOption" type="enum" ref="SamplingSpeedOption" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getSamplingSpeedOption">
                            <desc>Gets the maxicode sampling speed-up option</desc>
                            <sample for="lua">local samplingSpeedOption = Image.CodeReader.Maxicode.getSamplingSpeedOption(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <return name="samplingSpeedOption" type="enum" ref="SamplingSpeedOption" desc="The value currently set"/>
                        </function>
                        <function name="setNorcaVerifier">
                            <desc>Activates NoReadCauseAnalysis (Norca) for Maxicode. Norca examines no reads and sets flags in the Image.CodeReader.Result feature vector.
Default value is 'false', i.e. Norca is off.</desc>
                            <sample for="lua">local success = Image.CodeReader.Maxicode.setNorcaVerifier(deco,true)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <param name="norcaVerifier" type="bool" desc="The desired value"/>
                            <return name="success" type="bool" desc="A flag whether setting was successful"/>
                        </function>
                        <function name="getNorcaVerifier">
                            <desc>Returns if Norca is activated.</desc>
                            <sample for="lua">local norcaVerifier = Image.CodeReader.Maxicode.getNorcaVerifier(deco)</sample>
                            <param name="handle" type="handle" alias="Image.CodeReader.Maxicode" desc="The instance to use"/>
                            <return name="norcaVerifier" type="bool" desc="The value currently set"/>
                        </function>
                    </serves>
                </crown>
                <crown name="TimeMeasurement">
                    <trait>hidden</trait>
                    <desc>Contains a single time measurement results that may be required in decodeExperimental.</desc>
                    <serves>
                        <function name="getName">
                            <desc>Returns the name of the particular time measurement.</desc>
                            <sample for="lua">local name = Image.CodeReader.TimeMeasurement.getName(measurement)</sample>
                            <param name="measurement" type="const object" alias="Image.CodeReader.TimeMeasurement" desc="The instance (time measurement) to use"/>
                            <return name="name" type="string" desc="The name of the time measurement"/>
                        </function>
                        <function name="getDescription">
                            <desc>Returns the description of the particular time measurement.</desc>
                            <sample for="lua">local desc = Image.CodeReader.TimeMeasurement.getDescription(measurement)</sample>
                            <param name="measurement" type="const object" alias="Image.CodeReader.TimeMeasurement" desc="The instance (time measurement) to use"/>
                            <return name="description" type="string" desc="The description of the time measurement"/>
                        </function>
                        <function name="getDuration">
                            <desc>Returns the duration in us of the particular time measurement.</desc>
                            <sample for="lua">local time = Image.CodeReader.TimeMeasurement.getDuration(measurement)</sample>
                            <param name="measurement" type="const object" alias="Image.CodeReader.TimeMeasurement" desc="The instance (time measurement) to use"/>
                            <return name="duration" type="int" desc="The duration of the particular time measurement in us"/>
                        </function>
                        <function name="getDuration_ms">
                            <desc>Returns the duration in ms of the particular time measurement.</desc>
                            <sample for="lua">local time = Image.CodeReader.TimeMeasurement.getDurationMs(measurement)</sample>
                            <param name="measurement" type="const object" alias="Image.CodeReader.TimeMeasurement" desc="The instance (time measurement) to use"/>
                            <return name="duration" type="float" desc="The duration of the particular time measurement in ms"/>
                        </function>
                    </serves>
                </crown>
                <crown name="TimeMeasurementList">
                    <trait>hidden</trait>
                    <desc>Contains the time measurement result list that may be required in decodeExperimental.</desc>
                    <serves>
                        <function name="getItems">
                            <desc>Returns a list of single Time Measurement items</desc>
                            <param name="list" type="const object" alias="Image.CodeReader.TimeMeasurementList" desc="The instance (time measurement list) to use"/>
                            <return name="items" type="const object" multiplicity="+" alias="Image.CodeReader.TimeMeasurement" desc="The complete measurement list"/>
                        </function>
                        <function name="getAsStringList">
                            <desc>Returns a list of strings that represent the single time measurement objects</desc>
                            <param name="list" type="const object" alias="Image.CodeReader.TimeMeasurementList" desc="The instance (time measurement list) to use"/>
                            <return name="stringlist" type="string" multiplicity="+" desc="The complete measurement list as a collection of strings"/>
                        </function>
                        <function name="getAsString">
                            <desc>Returns a single string that collects all the single time measurement objects</desc>
                            <param name="list" type="const object" alias="Image.CodeReader.TimeMeasurementList" desc="The instance (time measurement list) to use"/>
                            <return name="stringrepresentation" type="string" desc="The complete measurement list as a single string"/>
                        </function>
                    </serves>
                </crown>
                <crown name="VerifierResult">
                    <trait>released</trait>
                    <desc>Contains the 1D and 2D verifier results related to the result from that it is derived.</desc>
                    <enum name="Dimension">
                        <item desc="The verifier results are related to a Barcode (not to Postal Codes).">CODEDIM1D</item>
                        <item desc="The verifier results are related to some 2D code.">CODEDIM2D</item>
                        <item desc="The verifier results are related to Postal codes. This is not implemented.">CODEDIMPOSTAL</item>
                    </enum>
                    <serves>
                        <function name="getDimension">
                            <desc>Returns the type of the underlying code.</desc>
                            <sample for="lua">local dim = Image.CodeReader.VerifierResult.getDimension(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="dimension" type="enum" ref="Dimension" desc="The type (dimension) of the verifier result"/>
                        </function>
                        <function name="getMinGray">
                            <desc>Returns the minimal gray value of the code in percent. In case of 1D codes this is the so-called minimal reflection value.</desc>
                            <sample for="lua">local value = Image.CodeReader.VerifierResult.getMinGray(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="minGray" type="int" desc="The minimal reflection (gray) value of the code in percent."/>
                        </function>
                        <function name="getMaxGray">
                            <desc>Returns the maximal gray value of the code in percent. In case of 1D codes this is the so-called maximal reflection value.</desc>
                            <sample for="lua">local value = Image.CodeReader.VerifierResult.getMaxGray(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="maxGray" type="int" desc="The maximal reflection (gray) value of the code in percent."/>
                        </function>
                        <function name="getMinReflectionGrade">
                            <desc>Returns the minimal reflection (gray value) grade of the code.</desc>
                            <sample for="lua">local minReflectionGrade = Image.CodeReader.VerifierResult.getMinReflectionGrade(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="minReflectionGrade" type="char" desc="The contrast grade of the code"/>
                        </function>
                        <function name="getContrast">
                            <desc>Returns the symbol contrast of the code.</desc>
                            <sample for="lua">local value = Image.CodeReader.VerifierResult.getContrast(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="contrast" type="int" desc="The symbol contrast of the code."/>
                        </function>
                        <function name="getContrastGrade">
                            <desc>Returns the contrast grade of the code.</desc>
                            <sample for="lua">local contrastGrade = Image.CodeReader.VerifierResult.getContrastGrade(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="contrastgrade" type="char" desc="The contrast grade of the code"/>
                        </function>
                        <function name="getModulation">
                            <desc>Returns the modulation value of the code.</desc>
                            <sample for="lua">local value = Image.CodeReader.VerifierResult.getModulation(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="modulation" type="int" desc="The modulation value of the code."/>
                        </function>
                        <function name="getModulationGrade">
                            <desc>Returns the modulation grade of the code.</desc>
                            <sample for="lua">local grade = Image.CodeReader.VerifierResult.getModulationGrade(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="modulationGrade" type="char" desc="The modulation grade of the code."/>
                        </function>
                        <function name="getSymbolGrade">
                            <desc>Returns the overall symbol grade of the code. Its computation depends on whether the code is 1D or 2D according to the appropriate ISO.</desc>
                            <sample for="lua">local symbolGrade = Image.CodeReader.VerifierResult.getSymbolGrade(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="symbolgrade" type="char" desc="The overall symbol grade of the code."/>
                        </function>
                        <function name="getMinEdgeContrast">
                            <desc>Returns the minimal edge contrast of the code. Relevant for 1D codes.</desc>
                            <sample for="lua">local value = Image.CodeReader.VerifierResult.getMinEdgeContrast(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="minEdgeContrast" type="int" desc="The minimal edge contrast of the code."/>
                        </function>
                        <function name="getMinEdgeContrastGrade">
                            <desc>Returns the minimal edge contrast grade of the code. Relevant for 1D codes.</desc>
                            <sample for="lua">local grade = Image.CodeReader.VerifierResult.getMinEdgeContrastGrade(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="minEdgeContrastGrade" type="char" desc="The minimal edge contrast of the code."/>
                        </function>
                        <function name="getDefect">
                            <desc>Returns the defect value of the code. Relevant for 1D codes.</desc>
                            <sample for="lua">local value = Image.CodeReader.VerifierResult.getDefect(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="defect" type="int" desc="The defect value of the code."/>
                        </function>
                        <function name="getDefectGrade">
                            <desc>Returns the defect grade of the code. Relevant for 1D codes.</desc>
                            <sample for="lua">local grade = Image.CodeReader.VerifierResult.getDefectGrade(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="defectGrade" type="char" desc="The defect grade of the code."/>
                        </function>
                        <function name="getDecodability">
                            <desc>Returns the decodability value of the code. Relevant for 1D codes.</desc>
                            <sample for="lua">local value = Image.CodeReader.VerifierResult.getDecodability(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="decodability" type="int" desc="The decodability value of the code."/>
                        </function>
                        <function name="getDecodabilityGrade">
                            <desc>Returns the decodability grade of the code. Relevant for 1D codes.</desc>
                            <sample for="lua">local grade = Image.CodeReader.VerifierResult.getDecodabilityGrade(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="decodabilityGrade" type="char" desc="The decodability value of the code."/>
                        </function>
                        <function name="getPrintGrowth">
                            <desc>Returns the print growth value. Relevant for 2D codes.</desc>
                            <sample for="lua">local value = Image.CodeReader.VerifierResult.getPrintGrowth(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="printGrowth" type="int" desc="The print growth value of the code."/>
                        </function>
                        <function name="getPrintGrowthGrade">
                            <desc>Returns the print growth grade. Relevant for 2D codes.</desc>
                            <sample for="lua">local grade = Image.CodeReader.VerifierResult.getPrintGrowthGrade(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="printGrowthGrade" type="char" desc="The print growth grade of the code."/>
                        </function>
                        <function name="getAxialNonUniformity">
                            <desc>Returns the axial non-uniformity value of a 2D code in percent.</desc>
                            <sample for="lua">local value = Image.CodeReader.VerifierResult.getAxialNonUniformity(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="axialNonuniformity" type="int" desc="The axial non-uniformity value in percent"/>
                        </function>
                        <function name="getAxialNonUniformityGrade">
                            <desc>Returns the axial non-uniformity grade.</desc>
                            <sample for="lua">local grade = Image.CodeReader.VerifierResult.getAxialNonUniformityGrade(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="axialNonuniformityGrade" type="char" desc="The axial non-uniformity grade."/>
                        </function>
                        <function name="getUnusedErrorCorrection">
                            <desc>Returns the percentage of the unused errors in the code related to the maximal possible number of errors</desc>
                            <sample for="lua">local unsederrpercent = Image.CodeReader.VerifierResult.getUnusedErrorCorrection(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="unusedErrorCorrection" type="int" desc="The percentage of the unused errors in the code related to the maximal possible number of errors"/>
                        </function>
                        <function name="getUnusedErrorCorrectionGrade">
                            <desc>Returns the unused error correction grade of the code</desc>
                            <sample for="lua">local errcorrGrade = Image.CodeReader.VerifierResult.getUnusedErrorCorrectionGrade(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="unusedErrorCorrectionGrade" type="char" desc="The unused error correction grade of the code"/>
                        </function>
                        <function name="getFixedPatternDamage">
                            <desc>Returns the fixed pattern damage in the code.</desc>
                            <sample for="lua">local value = Image.CodeReader.VerifierResult.getFixedPatternDamage(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="fixedPatternDamage" type="int" desc="The fixed pattern damage."/>
                        </function>
                        <function name="getGridNonUniformity">
                            <desc>Returns the grid non-uniformity value in percent.</desc>
                            <sample for="lua">local value = Image.CodeReader.VerifierResult.getGridNonUniformity(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="gridNonuniformity" type="int" desc="The grid non-uniformity value in percent"/>
                        </function>
                        <function name="getGridNonUniformityGrade">
                            <desc>Returns the grid non-uniformity grade.</desc>
                            <sample for="lua">local grade = Image.CodeReader.VerifierResult.getGridNonUniformityGrade(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="gridNonuniformityGrade" type="char" desc="The grid non-uniformity grade."/>
                        </function>
                        <function name="getCellContrastDPM">
                            <trait>hidden</trait>
                            <desc>Returns the AIM DPM cell contrast of the code. Relevant for Datamatrix DPM codes.</desc>
                            <sample for="lua">local value = Image.CodeReader.VerifierResult.getCellContrastDPM(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="cellContrast" type="int" desc="The AIM DPM cell contrast of the code."/>
                        </function>
                        <function name="getMinimumReflectanceDPM">
                            <trait>hidden</trait>
                            <desc>Returns the AIM DPM minimal reflectance. Relevant for Datamatrix DPM codes.</desc>
                            <sample for="lua">local value = Image.CodeReader.VerifierResult.getMinimumReflectanceDPM(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="minimumReflectance" type="int" desc="The AIM DPM minimal reflectance."/>
                        </function>
                        <function name="getCellModulationDPM">
                            <trait>hidden</trait>
                            <desc>Returns the AIM DPM cell contrast of the code. Relevant for Datamatrix DPM codes.</desc>
                            <sample for="lua">local value = Image.CodeReader.VerifierResult.getCellModulationDPM(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="cellModulation" type="int" desc="The AIM DPM cell contrast of the code."/>
                        </function>
                        <function name="getFixedPatternDamageDPM">
                            <trait>hidden</trait>
                            <desc>Returns the AIM DPM fixed pattern damage of the code. Relevant for Datamatrix DPM codes.</desc>
                            <sample for="lua">local value = Image.CodeReader.VerifierResult.getFixedPatternDamageDPM(verifierResult)</sample>
                            <param name="verifierResult" type="const object" alias="Image.CodeReader.VerifierResult" desc="The instance (verifier result) to use"/>
                            <return name="fixedPatternDamage" type="int" desc="The AIM DPM fixed pattern damage of the code."/>
                        </function>
                    </serves>
                </crown>
                <crown name="Result">
                    <trait>released</trait>
                    <desc>Contains the results of a decoder</desc>
                    <enum name="CodeTypeEnum">
                        <item desc="'Codabar' also accepted.">CODABAR</item>
                        <item desc="'Code39' also accepted.">CODE39</item>
                        <item desc="'EAN/UPC' also accepted.">EANUPC</item>
                        <item desc="'Interleaved 2/5' also accepted.">INTERLEAVED25</item>
                        <item desc="'Code93' also accepted.">CODE93</item>
                        <item desc="'Code128' also accepted.">CODE128</item>
                        <item>GS1</item>
                        <item desc="'Pharma' also accepted.">PHARMA</item>
                        <item desc="Postal Code type. 'Postnet' also accepted.">POSTNET</item>
                        <item desc="Postal Code type. 'Planet' also accepted.">PLANET</item>
                        <item desc="Postal Code type.">USPS4SCB</item>
                        <item desc="Postal Code type. 'PostAustralia' also accepted.">POSTAUSTRALIA</item>
                        <item desc="Postal Code type.">RM4SCC</item>
                        <item desc="Postal Code type.">KIX</item>
                        <item desc="Postal Code type. 'PostSingapore' also accepted.">POSTSINGAPORE</item>
                        <item desc="Postal Code type. 'PostSweden' also accepted.">POSTSWEDEN</item>
                        <item desc="Postal Code type. 'Custom2State' also accepted.">CUSTOM2STATE</item>
                        <item desc="Postal Code type. 'Custom4State' also accepted.">CUSTOM4STATE</item>
                        <item desc="Postal Code type. 'Mailmark' also accepted.">MAILMARK</item>
                        <item>PDF417</item>
                        <item desc="'DMx' also accepted.">DMX</item>
                        <item>QR</item>
                        <item desc="'MaxiCode' also accepted.">MAXICODE</item>
                        <item desc="'Dotcode' also accepted.">DOTCODE</item>
                        <item desc="'Aztec' also accepted.">AZTEC</item>
                        <item desc="Describes a undecodable object - its type is contained in TypeExpected. 'Undecodable' also accepted.">UNDECODABLE</item>
                        <item desc="This stands for a virtual code and is actually not a code type. 'VirtualCode' also accepted.">VIRTUALCODE</item>
                        <item desc="No Code in Image - this is actually not a code type">NCII</item>
                    </enum>
                    <enum name="CodeSubTypeEnum">
                        <item desc="'Codabar' also accepted.">CODABAR</item>
                        <item desc="'Code39' also accepted.">CODE39</item>
                        <item desc="'Code32' also accepted.">CODE32</item>
                        <item desc="'EAN/UPC.IDT' also accepted.">EANUPCIDT</item>
                        <item desc="'EAN8.DT' also accepted.">EAN8DT</item>
                        <item desc="'EAN13.DT' also accepted.">EAN13DT</item>
                        <item desc="'UPCe.DT' also accepted.">UPCEDT</item>
                        <item desc="'UPCe.EXP' also accepted.">UPCEEXP</item>
                        <item desc="'UPCa.DT' also accepted.">UPCADT</item>
                        <item desc="'AddOn' also accepted.">ADDON</item>
                        <item desc="'Interleaved 2/5' also accepted.">INTERLEAVED25</item>
                        <item desc="'Code93.Conv' also accepted.">CODE93CONV</item>
                        <item desc="'Code93.Raw' also accepted.">CODE93RAW</item>
                        <item desc="'Code128.Conv' also accepted.">CODE128CONV</item>
                        <item desc="'Code128.Raw' also accepted.">CODE128RAW</item>
                        <item desc="'EAN128.Conv' also accepted.">EAN128CONV</item>
                        <item desc="Profile Code handled as a subtype of Code128. 'Prof1D' also accepted.">PROF1D</item>
                        <item desc="'GS1.14' also accepted.">GS114</item>
                        <item desc="'GS1.Databar' also accepted.">GS1DATABAR</item>
                        <item desc="'GS1.EXP' also accepted.">GS1EXP</item>
                        <item desc="'GS1.Inc.Core' also accepted.">GS1INCCORE</item>
                        <item desc="'GS1.Inc.Mem' also accepted.">GS1INCMEM</item>
                        <item desc="'GS1.Limited' also accepted.">GS1LIMITED</item>
                        <item desc="'Pharma' also accepted.">PHARMA</item>
                        <item desc="Postal Code type. 'Postnet' also accepted.">POSTNET</item>
                        <item desc="Postal Code type. 'Planet' also accepted.">PLANET</item>
                        <item desc="Postal Code type.">USPS4SCB</item>
                        <item desc="Postal Code type. 'PostAustralia' also accepted.">POSTAUSTRALIA</item>
                        <item desc="Postal Code type.">RM4SCC</item>
                        <item desc="Postal Code type.">KIX</item>
                        <item desc="Postal Code type. 'PostSingapore' also accepted.">POSTSINGAPORE</item>
                        <item desc="Postal Code type. 'PostSweden' also accepted.">POSTSWEDEN</item>
                        <item desc="Postal Code type. 'Custom2State' also accepted.">CUSTOM2STATE</item>
                        <item desc="Postal Code type. 'Custom4State' also accepted.">CUSTOM4STATE</item>
                        <item desc="Postal Code type. 'Mailmark' also accepted.">MAILMARK</item>
                        <item>PDF417</item>
                        <item desc="'DMx' also accepted.">DMX</item>
                        <item>QR</item>
                        <item desc="'MaxiCode' also accepted.">MAXICODE</item>
                        <item desc="'Dotcode' also accepted.">DOTCODE</item>
                        <item desc="'Aztec' also accepted.">AZTEC</item>
                        <item desc="'Undecodable' also accepted.">UNDECODABLE</item>
                        <item desc="'VirtualCode' also accepted.">VIRTUALCODE</item>
                        <item>NCII</item>
                    </enum>
                    <enum name="FeatureVectorCodeType">
                        <item>NONE</item>
                        <item>QFV1D</item>
                        <item>QFV2D</item>
                        <item>QFVPOSTAL</item>
                        <item>QFVIMAGE</item>
                    </enum>
                    <enum name="FeatureVectorBits">
                        <item>QFV1D_START_CHARACTER_CORRECTED</item>
                        <item>QFV1D_STOP_CHARACTER_CORRECTED</item>
                        <item>QFV1D_SINGLE_ERROR_CORRECTED</item>
                        <item>QFV1D_BUFFER_DECODING_FAILED</item>
                        <item>QFV1D_CHECKSUM_CHECK_FAILED</item>
                        <item>QFV1D_START_CHARACTER_CHECK_FAILED</item>
                        <item>QFV1D_STOP_CHARACTER_CHECK_FAILED</item>
                        <item>QFV1D_LENGTH_CHECK_FAILED</item>
                        <item>QFV1D_SINGLE_ERROR_CORRECTION_FAILED</item>
                        <item>QFV1D_RESULT_CONVERTION_FAILED</item>
                        <item>QFV1D_INACTIVE_SYMBOLT_TYPE</item>
                        <item>QFV1D_MISSING_SUPPLEMENT</item>
                        <item>QFV1D_MULTI_READS_NOT_REACHED</item>
                        <item>QFV1D_LOW_CONTRAST</item>
                        <item>QFV1D_TORN_PARTIAL_CODE</item>
                        <item>QFV1D_OUT_OF_FOCUS</item>
                        <item>QFV1D_CODE_WASH_OUT</item>
                        <item>QFV1D_SPLIT_BARS_DETECTED</item>
                        <item>QFV1D_FRAGMENT_MERGED</item>
                        <item>QFV1D_QUIET_ZONE_HURT</item>
                        <item>QFV1D_OVERLAP_DETECTED</item>
                        <item>QFV1D_CODE_AT_BORDER</item>
                        <item>QFV1D_GLARE_FEATURE</item>
                        <item>QFV1D_SUPERRES_READ</item>
                        <item>QFV1D_UNKNOWN_FAILURE</item>
                        <item>QFV2D_SCHEME_DECODING_ERROR</item>
                        <item>QFV2D_CHECKSUM_CHECK_FAILED</item>
                        <item>QFV2D_ERROR_CORRECTION_FAILED</item>
                        <item>QFV2D_SYMBOL_SIZE_CHECK_FAILED</item>
                        <item>QFV2D_SYMBOL_DECODING_FAILED</item>
                        <item desc="Code Bitmatrix Sampling was not successful.">QFV2D_BITMATRIXSAMPLING_FAILED</item>
                        <item>QFV2D_INVALIDE_MODE</item>
                        <item>QFV2D_PDF417_LRI_NOT_FOUND</item>
                        <item>QFV2D_PDF417_RRI_NOT_FOUND</item>
                        <item>QFV2D_PARTIAL_RESULT</item>
                        <item>QFV2D_QR_MODEL1_SYMBOL</item>
                        <item>QFV2D_LOW_CONTRAST</item>
                        <item>QFV2D_UNKNOWN_FAILURE</item>
                        <item>QFVPOST_ERROR_CORRECTION_FAILED</item>
                        <item>QFVPOST_INVALID_FCC_VALUE</item>
                        <item>QFVPOST_INVALID_SORTING_CODE</item>
                        <item>QFVPOST_INVALID_CUSTOMER_INFORMATION</item>
                        <item>QFVPOST_SCHEME_DECODING_ERROR</item>
                        <item>QFVPOST_ROUTING_CODE_ERROR</item>
                        <item>QFVPOST_START_STOP_ERROR</item>
                        <item>QFVPOST_CHECKSUM_CHECK_FAILED</item>
                        <item>QFVPOST_SINGLE_BIT_ERROR_CORRECTED</item>
                        <item>QFVPOST_UNKNOWN_TYPE</item>
                        <item>QFVPOST_UNKNOWN_FAILURE</item>
                        <item>QFVIMG_NO_CODE_IN_IMAGE</item>
                        <item>QFVIMG_IMAGE_ABORTED</item>
                        <item>QFVIMG_UNKNOWN_FAILURE</item>
                    </enum>
                    <enum name="ScanDirectionType">
                        <item>NOTAVAILABLE</item>
                        <item>UNKNOWN</item>
                        <item>FORWARD</item>
                        <item>BACKWARD</item>
                    </enum>
                    <enum name="OrientationComputationMode">
                        <item>CLOCKWISE</item>
                        <item>COUNTERCLOCKWISE</item>
                    </enum>
                    <enum name="OrientationComputationMode1">
                        <item>CLOCKWISE</item>
                        <item>COUNTERCLOCKWISE</item>
                        <item>MODE8903COMPATIBLE</item>
                        <item>MODE8903SWIFT</item>
                    </enum>
                    <enum name="OrientationResultMode">
                        <item>RADIAN</item>
                        <item desc="The angle is computed in degrees.">DEGREE</item>
                        <item desc="The angle is computed in degrees without decimals.">DEGREEINT</item>
                        <item desc="The angle is computed in degrees rounded to one decimal.">DEGREEINT10</item>
                    </enum>
                    <enum name="OrientationRangeMode">
                        <item desc="The computed angle is not changed.">NONE</item>
                        <item desc="Normalize the angle to values in the range between 0 and 360 degrees (2pi)">FULLANGLE</item>
                        <item desc="Normalize the angle to values in the range between -180 and 180 degrees (-pi and pi)">HALFANGLE</item>
                    </enum>
                    <serves>
                        <function name="getUniqueIdentifier">
                            <trait>hidden</trait>
                            <desc>Returns the unique identifier of a particular result. For debug purposes.</desc>
                            <sample for="lua">local uid = Image.CodeReader.Result.getUniqueIdentifier(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="uniqueidentifier" type="int" desc="The unique identifier of the result"/>
                        </function>
                        <function name="getType">
                            <desc>Returns the code type of a particular result</desc>
                            <sample for="lua">local type = Image.CodeReader.Result.getType(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="type" type="enum" ref="CodeTypeEnum" desc="The code type of the result"/>
                        </function>
                        <function name="getSubType">
                            <desc>Returns the code subtype of a particular result</desc>
                            <sample for="lua">local subtype = Image.CodeReader.Result.getSubType(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="subtype" type="enum" ref="CodeSubTypeEnum" desc="The code subtype of the result"/>
                        </function>
                        <function name="getTypeExpected">
                            <desc>Returns the expected code type if the result actually is undecodable (Norca)</desc>
                            <sample for="lua">local type = Image.CodeReader.Result.getTypeExpected(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="type" type="enum" ref="CodeTypeEnum" desc="The expected code type of the result"/>
                        </function>
                        <function name="getSubTypeExpected">
                            <desc>Returns the expected code subtype of a result if it actually is undecodable</desc>
                            <sample for="lua">local subtype = Image.CodeReader.Result.getSubTypeExpected(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="subtype" type="enum" ref="CodeSubTypeEnum" desc="The expected code subtype of the result"/>
                        </function>
                        <function name="getContent">
                            <desc>Returns the content of a particular result</desc>
                            <sample for="lua">local content = Image.CodeReader.Result.getContent(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="content" type="binary" desc="The content of the result"/>
                        </function>
                        <function name="getContentLength">
                            <desc>Returns the content of a particular result</desc>
                            <sample for="lua">local length = Image.CodeReader.Result.getContentLength(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="contentlength" type="int" desc="The content length of the result"/>
                        </function>
                        <function name="getContentHexAscii">
                            <desc>Returns the content of a particular result in so-called Hex Ascii mode (each character as a 2-digit hexadecimal number).</desc>
                            <sample for="lua">local contentHexAscii = Image.CodeReader.Result.getContentHexAscii(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="contentHexAscii" type="string" desc="The content of the result in Full Ascii mode."/>
                        </function>
                        <function name="getRegion">
                            <desc>Returns the code region of the result.</desc>
                            <sample for="lua">local region = Image.CodeReader.Result.getRegion(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="region" type="const object" alias="Shape" desc="The region of interest instance where the code was found. This is actually a shape of type Polyline."/>
                        </function>
                        <function name="getRegionCorner">
                            <desc>Returns the n-th corner of the result's code region.</desc>
                            <sample for="lua">local corner = Image.CodeReader.Result.getRegionCorner(codeResult, 2)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <param name="index" type="int" desc="The index of the corner. It is considered modulo 4."/>
                            <return name="corner" type="const object" alias="Point" desc="The region's n-th corner where the code was found."/>
                        </function>
                        <function name="getOrientation">
                            <desc>Returns the angle of the result code region with the x-axis in clock-wise or counter-clockwise direction</desc>
                            <sample for="lua">local angle, middleline = Image.CodeReader.Result.getOrientation(codeResult, "COUNTERCLOCKWISE")</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <param name="computationMode" type="enum" multiplicity="?" ref="OrientationComputationMode" desc="The mode how to compute the code angle. Default value is 'COUNTERCLOCKWISE'."/>
                            <param name="resultMode" type="enum" multiplicity="?" ref="OrientationResultMode" desc="The unit of the code angle. Default value is 'RADIAN'."/>
                            <param name="rangeMode" type="enum" multiplicity="?" ref="OrientationRangeMode" desc="The code angle range normalization mode. Default value is 'NONE'."/>
                            <return name="angle" type="float" desc="The angle between the middle line of the code region and the x-axis."/>
                            <return name="middleline" type="const object" alias="Shape" desc="The middle line of the code region ."/>
                        </function>
                        <function name="getGravityCenter">
                            <desc>Returns the gravity center of the result code region.</desc>
                            <sample for="lua">local center = Image.CodeReader.Result.getGravityCenter(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="gravitycenter" type="const object" alias="Point" desc="The code region gravity center."/>
                        </function>
                        <function name="getAddonRegion">
                            <desc>Returns the region of the addon code for the result. This may be NULL.</desc>
                            <sample for="lua">local region = Image.CodeReader.Result.getAddonRegion(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="addonregion" type="const object" alias="Shape.Composite" desc="The region of interest instance where the addon-code was found. This is actually a shape of type Polyline"/>
                        </function>
                        <function name="getAddonRegionCorner">
                            <desc>Returns the n-th corner of the result's addon code region if such a region exists.</desc>
                            <sample for="lua">local corner = Image.CodeReader.Result.getAddonRegionCorner(codeResult, 2)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <param name="index" type="int" desc="The index of the corner. It is considered modulo 4."/>
                            <return name="corner" type="const object" alias="Point" desc="The region's n-th corner where the addon code was found."/>
                        </function>
                        <function name="getAddonOrientation">
                            <desc>Returns the angle of the result addon code region with the x-axis (if such a region is part of the result).</desc>
                            <sample for="lua">local angle, middleline = Image.CodeReader.Result.getAddonOrientation(codeResult, "CLOCKWISE")</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <param name="computationMode" type="enum" multiplicity="?" ref="OrientationComputationMode" desc="The mode how to compute the addon angle. Default value is 'COUNTERCLOCKWISE'."/>
                            <param name="resultMode" type="enum" multiplicity="?" ref="OrientationResultMode" desc="The unit of the addon angle. Default value is 'RADIAN'."/>
                            <param name="normMode" type="enum" multiplicity="?" ref="OrientationRangeMode" desc="The addon angle range normalization mode. Default value is 'NONE'."/>
                            <return name="angle" type="float" desc="The angle between the middle line of the addon code region and the x-axis."/>
                            <return name="middleline" type="const object" alias="Shape" desc="The middle line of the region of the addon code."/>
                        </function>
                        <function name="getAddonGravityCenter">
                            <desc>Returns the gravity center of the result addon code region (if such a region is part of the result).</desc>
                            <sample for="lua">local center = Image.CodeReader.Result.getAddonGravityCenter(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="gravitycenter" type="const object" alias="Point" desc="The addon code region gravity center."/>
                        </function>
                        <function name="getModuleSizeX">
                            <desc>Returns the horizontal module size of the result</desc>
                            <sample for="lua">local sizeX = Image.CodeReader.Result.getModuleSizeX(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="modulesizex" type="float" desc="The horizontal module size of the code"/>
                        </function>
                        <function name="getModuleSizeY">
                            <desc>Returns a rough estimation of the vertical module size of the result</desc>
                            <sample for="lua">local sizeY = Image.CodeReader.Result.getModuleSizeY(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="modulesizey" type="float" desc="The vertical module size of the code"/>
                        </function>
                        <function name="getModuleAspectRatio">
                            <desc>Returns the ratio of the horizontal and vertical module size</desc>
                            <sample for="lua">local ratioXY = Image.CodeReader.Result.getModuleAspectRatio(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="moduleaspectratio" type="float" desc="The ratio of the horizontal and vertical module size"/>
                        </function>
                        <function name="getSymbolSizeX">
                            <desc>Returns the number of modules in horizontal direction. Valid for 2D codes only -- in case of Barcodes it always returns 0, since there are no modules.</desc>
                            <sample for="lua">local numX = Image.CodeReader.Result.getSymbolSizeX(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="symbolsizex" type="int" desc="The number of modules in horizontal direction"/>
                        </function>
                        <function name="getSymbolSizeY">
                            <desc>Returns the number of modules in vertical direction. Valid for 2D codes only -- in case of Barcodes it always returns 1.</desc>
                            <sample for="lua">local numY = Image.CodeReader.Result.getSymbolSizeY(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="symbolsizey" type="int" desc="The number of modules in vertical direction"/>
                        </function>
                        <function name="getMinGray">
                            <trait>deprecated</trait>
                            <desc>Returns the minimal gray value of the code. This function shall be replaced by 'Image.CodeReader.VerifierResult.getMinGray'.</desc>
                            <sample for="lua">local minGray = Image.CodeReader.Result.getMinGray(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="mingray" type="int" desc="The minimal gray value of the code"/>
                        </function>
                        <function name="getMaxGray">
                            <trait>deprecated</trait>
                            <desc>Returns the maximal gray value of the code. This function shall be replaced by 'Image.CodeReader.VerifierResult.getMaxGray'.</desc>
                            <sample for="lua">local maxGray = Image.CodeReader.Result.getMaxGray(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="maxgray" type="int" desc="The maximal gray value of the code"/>
                        </function>
                        <function name="getContrast">
                            <trait>deprecated</trait>
                            <desc>Returns the contrast value of the code. This function shall be replaced by 'Image.CodeReader.VerifierResult.getContrast'.</desc>
                            <sample for="lua">local contrast = Image.CodeReader.Result.getContrast(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="contrast" type="int" desc="The contrast value of the code"/>
                        </function>
                        <function name="getContrastGrade">
                            <trait>deprecated</trait>
                            <desc>Returns the contrast grade of the code. This function shall be replaced by 'Image.CodeReader.VerifierResult.getContrastGrade'.</desc>
                            <sample for="lua">local contrastGrade = Image.CodeReader.Result.getContrastGrade(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="contrastgrade" type="char" desc="The contrast grade of the code"/>
                        </function>
                        <function name="getMaxNumErrors">
                            <desc>Returns the maximal possible number of detectable and correctable errors in a code. Only if Error Correction is available (e.g. MaxiCode, DataMatrix).</desc>
                            <sample for="lua">local maxnumerr = Image.CodeReader.Result.getMaxNumErrors(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="maxnumerrors" type="int" desc="The maximal possible number of errors"/>
                        </function>
                        <function name="getNumErrors">
                            <desc>Returns the number of detected and corrected errors in the code. Unlike erasures errors are erroneous codewords at unknown locations. Only if Error Correction is available (e.g. MaxiCode, DataMatrix).</desc>
                            <sample for="lua">local numerr = Image.CodeReader.Result.getNumErrors(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="numerrors" type="int" desc="The number of errors in the code"/>
                        </function>
                        <function name="getNumErasures">
                            <desc>Returns the number of corrected erasures in the code. Erasures are erroneous codewords at known locations. Only applicable for PDF417.</desc>
                            <sample for="lua">local numera = Image.CodeReader.Result.getNumErasures(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="numerasures" type="int" desc="The number of erasures in the code"/>
                        </function>
                        <function name="getErrorCorrectionLevel">
                            <desc>Returns the error correction level used in the code (2d only)</desc>
                            <sample for="lua">local errcorrlevel = Image.CodeReader.Result.getErrorCorrectionLevel(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="errorcorrectionlevel" type="string" desc="The error correction level used in the code (2d only)"/>
                        </function>
                        <function name="getNumDataCodewords">
                            <desc>Returns the number data codewords in the code. Only if Error Correction is available (e.g. MaxiCode, DataMatrix).</desc>
                            <sample for="lua">local numdatawords = Image.CodeReader.Result.getNumDataCodewords(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="numdatacodewords" type="int" desc="The number of data codewords in the code"/>
                        </function>
                        <function name="getNumEccCodewords">
                            <desc>Returns the number error correction codewords in the code. Only if Error Correction is available (e.g. MaxiCode, DataMatrix).</desc>
                            <sample for="lua">local numeccwords = Image.CodeReader.Result.getNumEccCodewords(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="numecccodewords" type="int" desc="The number of ecc codewords in the code"/>
                        </function>
                        <function name="getUnusedErrorCorrection">
                            <trait>deprecated</trait>
                            <desc>Returns the percentage of the unused errors in the code related to the maximal possible number of errors.
Use 'Image.CodeReader.VerifierResult.getUnusedErrorCorrection' instead.</desc>
                            <sample for="lua">local unsederrpercent = Image.CodeReader.Result.getUnusedErrorCorrection(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="unusederrorcorrection" type="int" desc="The percentage of the unused errors in the code related to the maximal possible number of errors"/>
                        </function>
                        <function name="getUnusedErrorCorrectionGrade">
                            <trait>deprecated</trait>
                            <desc>Returns the unused error correction grade of the code.
Use 'Image.CodeReader.VerifierResult.getUnusedErrorCorrectionGrade' instead.</desc>
                            <sample for="lua">local errcorrGrade = Image.CodeReader.Result.getUnusedErrorCorrectionGrade(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="unusederrorcorrectiongrade" type="char" desc="The unused error correction grade of the code"/>
                        </function>
                        <function name="getScanRatio">
                            <desc>Returns the percentage of the successful scans and overall scans (1d only). Is based on the 'MultiRead' and 'MultiReadBase'.</desc>
                            <sample for="lua">local ratio = Image.CodeReader.Result.getScanRatio(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="scanratio" type="int" desc="The percentage of the successful and overall scans"/>
                        </function>
                        <function name="getScanRatioGrade">
                            <desc>Returns the grade belonging to the percentage of the successful scans and overall scans (1d only). Is based on the 'MultiRead' and 'MultiReadBase'.</desc>
                            <sample for="lua">local grade = Image.CodeReader.Result.getScanRatioGrade(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="scanratiograde" type="char" desc="The grade belonging to the scan ratio"/>
                        </function>
                        <function name="getPrintGrowth">
                            <trait>deprecated</trait>
                            <desc>Returns the print growth value. This function shall be replaced by 'Image.CodeReader.VerifierResult.getPrintGrowth'.</desc>
                            <sample for="lua">local val = Image.CodeReader.Result.getPrintGrowth(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="printgrowth" type="int" desc="The print growth value"/>
                        </function>
                        <function name="getPrintGrowthGrade">
                            <trait>deprecated</trait>
                            <desc>Returns the print growth grade. This function shall be replaced by 'Image.CodeReader.VerifierResult.getPrintGrowthGrade'.</desc>
                            <sample for="lua">local grade = Image.CodeReader.Result.getPrintGrowthGrade(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="printgrowthgrade" type="char" desc="The print growth grade"/>
                        </function>
                        <function name="getAxialUniformity">
                            <trait>deprecated</trait>
                            <desc>Returns the axial uniformity value. Do no longer use it -- the name is wrong. Use 'getAxialNonUniformity' instead.</desc>
                            <sample for="lua">local value = Image.CodeReader.Result.getAxialUniformity(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="axialuniformity" type="int" desc="The axial uniformity value"/>
                        </function>
                        <function name="getAxialUniformityGrade">
                            <trait>deprecated</trait>
                            <desc>Returns the axial uniformity grade. Do no longer use it -- the name is wrong. Use 'getAxialNonUniformityGrade' instead.</desc>
                            <sample for="lua">local grade = Image.CodeReader.Result.getAxialUniformityGrade(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="axialuniformitygrade" type="char" desc="The axial uniformity grade"/>
                        </function>
                        <function name="getAxialNonUniformity">
                            <trait>deprecated</trait>
                            <desc>Returns the axial non-uniformity value in percent. This function shall be replaced by 'Image.CodeReader.VerifierResult.getAxialNonUniformity'.</desc>
                            <sample for="lua">local value = Image.CodeReader.Result.getAxialNonUniformity(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="axialnonuniformity" type="int" desc="The axial non-uniformity value in percent"/>
                        </function>
                        <function name="getAxialNonUniformityGrade">
                            <trait>deprecated</trait>
                            <desc>Returns the axial non-uniformity grade. This function shall be replaced by 'Image.CodeReader.VerifierResult.getAxialNonUniformityGrade'.</desc>
                            <sample for="lua">local grade = Image.CodeReader.Result.getAxialNonUniformityGrade(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="axialnonuniformitygrade" type="char" desc="The axial non-uniformity grade"/>
                        </function>
                        <function name="getDecodability">
                            <trait>deprecated</trait>
                            <desc>Returns the decodability value. This function shall be replaced by 'Image.CodeReader.VerifierResult.getDecodability'.</desc>
                            <sample for="lua">local value = Image.CodeReader.Result.getDecodability(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="decodability" type="int" desc="The decodability value"/>
                        </function>
                        <function name="getDecodabilityGrade">
                            <trait>deprecated</trait>
                            <desc>Returns the decodability grade. This function shall be replaced by 'Image.CodeReader.VerifierResult.getDecodabilityGrade'.</desc>
                            <sample for="lua">local grade = Image.CodeReader.Result.getDecodabilityGrade(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="decodabilitygrade" type="char" desc="The decodability grade"/>
                        </function>
                        <function name="getSymbolGrade">
                            <trait>deprecated</trait>
                            <desc>Returns the symbol grade of the code. This function shall be replaced by 'Image.CodeReader.VerifierResult.getSymbolGrade'.</desc>
                            <sample for="lua">local symbolGrade = Image.CodeReader.Result.getSymbolGrade(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="symbolgrade" type="char" desc="The symbol grade of the code"/>
                        </function>
                        <function name="getCodeIsComposite">
                            <trait>hidden</trait>
                            <desc>Returns a flag whether the code a composite code.</desc>
                            <sample for="lua">local isComposite = Image.CodeReader.Result.getCodeIsComposite(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="codeiscomposite" type="bool" desc="True if the code is 'composite'."/>
                        </function>
                        <function name="getFeatureVector">
                            <desc>Returns the code analytics (feature vector) of the code</desc>
                            <sample for="lua">local featureVector = Image.CodeReader.Result.getFeatureVector(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="featurevector" type="int" desc="The code analytics feature vector of the code"/>
                        </function>
                        <function name="getScanDirection">
                            <trait>hidden</trait>
                            <desc>Returns the scan direction for this particular result.</desc>
                            <sample for="lua">local sd = Image.CodeReader.Result.getScanDirection(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="scandirection" type="enum" ref="ScanDirectionType" desc="The multi reads of the code"/>
                        </function>
                        <function name="getMultiRead">
                            <desc>Returns the number of (successful) multi reads</desc>
                            <sample for="lua">local mr = Image.CodeReader.Result.getMultiRead(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="multiread" type="int" desc="The multi reads of the code"/>
                        </function>
                        <function name="getScansOnRoi">
                            <trait>deprecated</trait>
                            <desc>Returns the number of scans on the code region. Should no longer be used. It does not reflect the basis for getting quality and ratio values based on 'MultiRead'. Use 'getMultiReadBase' instead.</desc>
                            <sample for="lua">local numsc = Image.CodeReader.Result.getScansOnRoi(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="scansOnRoi" type="int" desc="The number of scans"/>
                        </function>
                        <function name="getCoherentGoodReads">
                            <desc>Returns the code continuity value, consecutive good reads.</desc>
                            <sample for="lua">local cohgr = Image.CodeReader.Result.getCoherentGoodReads(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="coherentgoodreads" type="int" desc="The code continuity value"/>
                        </function>
                        <function name="getRequiredScans">
                            <desc>Returns the number of required scans (scan effort)</desc>
                            <sample for="lua">local reqsc = Image.CodeReader.Result.getRequiredScans(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="requiredscans" type="int" desc="The number of required scans"/>
                        </function>
                        <function name="getUsableScans">
                            <desc>Returns the number of useful scans</desc>
                            <sample for="lua">local featureVector = Image.CodeReader.Result.getUsableScans(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="usablescans" type="int" desc="The number of useful scans"/>
                        </function>
                        <function name="getResultQuality">
                            <desc>Returns an indicator for the quality of a result. Maximum value is 100. Its value depends on the code type.</desc>
                            <sample for="lua">local resultquality = Image.CodeReader.Result.getResultQuality(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="resultquality" type="int" desc="The result quality value"/>
                        </function>
                        <function name="getCodeSecurity">
                            <desc>Returns an indicator for the code security. Its value depends on the code type.
For 2D codes it is 0. For 1D codes it should have a value between 0 and 10.</desc>
                            <sample for="lua">local codesecurity = Image.CodeReader.Result.getCodeSecurity(codeResult)</sample>
                            <param name="result" type="const object" alias="Image.CodeReader.Result" desc="The instance (result) to use"/>
                            <return name="codesecurity" type="int" desc="The result code security"/>
                        </function>
                    </serves>
                </crown>
            </crown>
            <crown name="Provider">
                <trait>released</trait>
                <desc>Provides access to various image providers.</desc>
                <serves/>
                <uses/>
                <crown name="RemoteCamera">
                    <trait>released</trait>
                    <desc>Provides functionality to control and receive images from a remote camera which is connected via Ethernet.
connect has to be called after the camera is set up with setIPAddress, setType and setConfig, in case the camera is not connected yet.</desc>
                    <enum name="CameraType">
                        <item name="GigEVisionCam" desc="2nd generation picoCam/midiCam series,  Ranger3 and other GigE-Vision/GenICam compliant cameras.">GIGE_VISIONCAM</item>
                        <item name="V2D Camera" desc="SICK 2D cameras: Lector series only - InspectorP series is not supported via RemoteCamera-Crown">V2DCAM</item>
                        <item name="I2D Camera" desc="SICK 2D cameras: 1st. generation picoCam and midiCam series">I2DCAM</item>
                        <item name="IDS-uEye Camera" desc="IDS uEye cameras with GigE-interface">IDS_UEYE_CAM</item>
                        <item name="V3SXX0 Camera" desc="SICK 3D-ToF camera: Visionary-T">V3SXX0</item>
                        <item name="V3SXX2 Camera" desc="SICK 3D-Stereo camera: Visionary-S">V3SXX2</item>
                    </enum>
                    <serves>
                        <event name="OnNewImage">
                            <desc>The event which is thrown for every new image.</desc>
                            <param name="handle" type="handle" alias="Image.Provider.RemoteCamera" desc="Instance handle of the RemoteCamera provider."/>
                            <param name="image" type="object" multiplicity="[1+]" alias="Image" desc="The image captured by the sensor."/>
                            <param name="sensorData" type="object" multiplicity="[1+]" alias="SensorData" desc="Supplementary data which belongs to the image"/>
                        </event>
                        <function name="register">
                            <desc>This function is used to register for any event of the image provider. The event name is specified as parameter.</desc>
                            <sample for="lua">Image.Provider.RemoteCamera.register(cam, "OnNewImage", "handleNewImage")</sample>
                            <param name="handle" type="handle" alias="Image.Provider.RemoteCamera" desc="Instance handle of the RemoteCamera provider."/>
                            <param name="eventname" type="string" desc="The event to register to."/>
                            <param name="callback" type="string" alias="function" desc="Function name to call when the event occurs."/>
                            <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                        </function>
                        <function name="deregister">
                            <desc>This function is used to deregister from any registered event of the handle.</desc>
                            <param name="handle" type="handle" alias="Image.Provider.RemoteCamera" desc="The instance handle to use"/>
                            <param name="eventname" type="string" desc="The event to deregister from"/>
                            <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                            <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                        </function>
                        <function name="create">
                            <desc>Creates an instance of the remote camera provider, which provides images from cameras connected via Ethernet</desc>
                            <sample for="">cam = Image.Provider.RemoteCamera.create()</sample>
                            <return name="handle" type="handle" alias="Image.Provider.RemoteCamera" desc="RemoteCamera exists as long as this handle exists."/>
                        </function>
                        <function name="start">
                            <desc>Starts image acquisition.</desc>
                            <sample for="lua">Image.Provider.RemoteCamera.start(cam)</sample>
                            <param name="handle" type="handle" alias="Image.Provider.RemoteCamera" desc="Instance handle of the RemoteCamera provider."/>
                            <param name="burstLength" type="int" multiplicity="?" desc="Number of images to capture. Set to 0 or leave empty for continuous acquisition."/>
                            <return name="success" type="bool" desc="Returns true if acquisition could be started."/>
                        </function>
                        <function name="snapshot">
                            <desc>Trigger a single image acquisition. The camera must be configured in software trigger mode. This mode is not supported for V3SXX0, V3SXX2 and V2D cameras. Snapshot mode is not intended to be used for fast capturing of image sequences. Use hardware trigger mode or continuous acquisition instead.</desc>
                            <sample for="lua">Image.Provider.RemoteCamera.snapshot(cam)</sample>
                            <param name="handle" type="handle" alias="Image.Provider.RemoteCamera" desc="Instance handle of the RemoteCamera provider."/>
                            <return name="success" type="bool" desc="Returns true if acquisition could be triggered."/>
                        </function>
                        <function name="stop">
                            <desc>Stops image acquisition.</desc>
                            <sample for="lua">Image.Provider.RemoteCamera.stop(cam)</sample>
                            <param name="handle" type="handle" alias="Image.Provider.RemoteCamera" desc="Instance handle of the RemoteCamera provider."/>
                            <return name="success" type="bool" desc="Returns true if acquisition could be stopped."/>
                        </function>
                        <function name="setConfig">
                            <desc>Applies the configuration to the remote device. Call connect() to (re)initialize the camera, in case the camera is not connected yet.</desc>
                            <sample for="lua">Image.Provider.RemoteCamera.setConfig(cam, config)</sample>
                            <param name="handle" type="handle" alias="Image.Provider.RemoteCamera" desc="Instance handle of the RemoteCamera provider."/>
                            <param name="configHandle" type="handle" alias="Image.Provider.RemoteCamera.Config" desc="Handle of config instance to apply."/>
                            <return name="success" type="bool" desc="true if new value could be set in configuration"/>
                        </function>
                        <function name="getConfig">
                            <desc>Returns the configuration to the remote device. Can be nil if config is not available (e. g. for V3SXX0)</desc>
                            <sample for="lua">local cfg = Image.Provider.RemoteCamera.getConfig(cam)</sample>
                            <param name="handle" type="handle" alias="Image.Provider.RemoteCamera" desc="Instance handle of the RemoteCamera provider."/>
                            <return name="config" type="handle" multiplicity="?" alias="Image.Provider.RemoteCamera.Config" desc="Handle of config instance."/>
                        </function>
                        <function name="setType">
                            <desc>Applies the type to the remote device. Call connect() to (re)initialize the camera.</desc>
                            <sample for="lua">Image.Provider.RemoteCamera.setType(cam, config)</sample>
                            <param name="handle" type="handle" alias="Image.Provider.RemoteCamera" desc="Instance handle of the RemoteCamera provider."/>
                            <param name="cameraType" type="enum" ref="CameraType" desc="Select the camera type to be used."/>
                        </function>
                        <function name="setIPAddress">
                            <desc>Sets the IP address used to connect to the camera.</desc>
                            <sample for="lua">Image.Provider.RemoteCamera.setIPAddress(cam, "192.168.0.1")</sample>
                            <param name="handle" type="handle" alias="Image.Provider.RemoteCamera" desc="Instance handle of the RemoteCamera provider."/>
                            <param name="ipaddress" type="string" desc="IP address of the camera."/>
                        </function>
                        <function name="setImagePoolSize">
                            <desc>Limits the number of images which can be acquired and used at the same time. Default is 10.</desc>
                            <sample for="lua">Image.Provider.RemoteCamera.setImagePoolSize(cam, 10)</sample>
                            <param name="handle" type="handle" alias="Image.Provider.RemoteCamera" desc="Instance handle of the RemoteCamera provider."/>
                            <param name="size" type="int" desc="Size of the internal image pool."/>
                        </function>
                        <function name="connect">
                            <desc>Connect to the camera. A valid IP address and camera type must be set first.</desc>
                            <sample for="lua">Image.Provider.RemoteCamera.connect(cam)</sample>
                            <param name="handle" type="handle" alias="Image.Provider.RemoteCamera" desc="Instance handle of the RemoteCamera provider."/>
                            <return name="success" type="bool" desc="true if connection could be established."/>
                        </function>
                    </serves>
                    <uses/>
                    <crown name="GigEVisionConfig">
                        <trait>released</trait>
                        <desc>Configuration for GigEVision compliant camera.</desc>
                        <enum name="AccessLevel">
                            <item name="GIGE_PARAM_NA" desc="not available or unknown">GIGE_PARAM_NA</item>
                            <item name="GIGE_PARAM_RO" desc="read only">GIGE_PARAM_RO</item>
                            <item name="GIGE_PARAM_RW" desc="read/write">GIGE_PARAM_RW</item>
                            <item name="GIGE_PARAM_WO" desc="write only">GIGE_PARAM_WO</item>
                        </enum>
                        <enum name="Type">
                            <item name="GIGE_PARAM_TYPE_NA" desc="not available or unknown">GIGE_PARAM_TYPE_NA</item>
                            <item name="GIGE_PARAM_TYPE_STRING" desc="string">GIGE_PARAM_TYPE_STRING</item>
                            <item name="GIGE_PARAM_TYPE_FLOAT" desc="floating point number">GIGE_PARAM_TYPE_FLOAT</item>
                            <item name="GIGE_PARAM_TYPE_INTEGER" desc="integer">GIGE_PARAM_TYPE_INTEGER</item>
                        </enum>
                        <serves>
                            <function name="create">
<desc>Create an empty GigEVisionConfig.</desc>
<sample for="lua">camCfg = Image.Provider.RemoteCamera.GigEVisionConfig.create()</sample>
<return name="config" type="object" alias="Image.Provider.RemoteCamera.GigEVisionConfig" desc="Instance of the GigEVisionConfig."/>
                            </function>
                            <function name="addChunkDataItem">
<desc>Register a chunk data item to be delivered with the image callback.</desc>
<sample for="lua">Image.Provider.RemoteCamera.GigEVisionConfig.addChunkDataItem(camCfg, "ChunkTimestamp")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.GigEVisionConfig" desc="Instance of the GigEVisionConfig."/>
<param name="chunkDataItemName" type="string" desc="The GenICam name of the chunk data item."/>
<return name="state" type="bool" desc="True if new value could be set in configuration."/>
                            </function>
                            <function name="setGainFactor">
<desc>Sets the gain factor. This writes the GigEVision parameter "Gain".</desc>
<sample for="lua">Image.Provider.RemoteCamera.GigEVisionConfig.setGainFactor(camCfg, 10.0)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.GigEVisionConfig" desc="Instance of the GigEVisionConfig."/>
<param name="value" type="float" desc="the gain factor"/>
<return name="state" type="bool" desc="true if new value could be set in configuration."/>
                            </function>
                            <function name="setShutterTime">
<desc>Sets the shutter time of the imager in micro seconds. his writes the GigEVision parameter "ExposureTime" or "ExposureTimeAbs"</desc>
<sample for="lua">Image.Provider.RemoteCamera.GigEVisionConfig.setShutterTimer(camCfg, 200)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.GigEVisionConfig" desc="Instance of the GigEVisionConfig."/>
<param name="value" type="int" desc="the shutter time in micro seconds"/>
<return name="state" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="setFrameRate">
<desc>Sets the acquisition frame rate in frames per second. This writes the GigEVision parameter "AcquisitionFrameRate" or "AcquisitionFrameRateAbs"</desc>
<sample for="lua">Image.Provider.RemoteCamera.GigEVisionConfig.setFrameRate(camCfg, 10.0)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.GigEVisionConfig" desc="Instance of the GigEVisionConfig."/>
<param name="value" type="float" desc="frame rate in frames per second"/>
<return name="state" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="setFieldOfView">
<desc>Sets the field of view of the image. This writes the GigEVision parameters "Width", "Height", "OffsetX" and "OffsetY"</desc>
<sample for="lua">Image.Provider.RemoteCamera.GigEVisionConfig.setFieldOfView(camCfg, 20, 80, 0, 100)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.GigEVisionConfig" desc="Instance of the GigEVisionConfig."/>
<param name="xMin" type="int" desc="Start from left in percent of full width."/>
<param name="xMax" type="int" desc="End from left in percent of full width."/>
<param name="yMin" type="int" desc="Start from top in percent of full height."/>
<param name="yMax" type="int" desc="End from top in percent of full height."/>
<return name="state" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="setParameterString">
<desc>Add a GigEVision parameter of type string to the configuration.</desc>
<sample for="lua">Image.Provider.RemoteCamera.GigEVisionConfig.setParameterString(camCfg, "name", "value")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.GigEVisionConfig" desc="Instance of the GigEVisionConfig."/>
<param name="name" type="string" desc="Name of the GigEVision parameter"/>
<param name="value" type="string" desc="Value to set"/>
<return name="state" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="setParameterInteger">
<desc>Add a GigEVision parameter of type integer to the configuration.</desc>
<sample for="lua">Image.Provider.RemoteCamera.GigEVisionConfig.setParameterInteger(camCfg, "name", 42)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.GigEVisionConfig" desc="Instance of the GigEVisionConfig."/>
<param name="name" type="string" desc="Name of the GigEVision parameter"/>
<param name="value" type="int" desc="Value to set"/>
<return name="state" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="setParameterFloat">
<desc>Add a GigEVision parameter of type float to the configuration.</desc>
<sample for="lua">Image.Provider.RemoteCamera.GigEVisionConfig.setParameterFloat(camCfg, "name", 1.)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.GigEVisionConfig" desc="Instance of the GigEVisionConfig."/>
<param name="name" type="string" desc="Name of the GigEVision parameter"/>
<param name="value" type="float" desc="Value to set"/>
<return name="state" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="setRegister">
<desc>Add a plain GigEVision register value to the configuration. Caution, use at your own risk and be extremely careful!</desc>
<sample for="lua">Image.Provider.RemoteCamera.GigEVisionConfig.setRegister(camCfg, 0x004f5349, "00 aa 3f g4")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.GigEVisionConfig" desc="Instance of the GigEVisionConfig."/>
<param name="address" type="int" desc="Register address to write."/>
<param name="value" type="string" desc="Space delimited hex-string (must represent a multiple of 4 bytes)."/>
<return name="state" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getParameters">
<desc>Get a list of all available GigEVision parameter names.</desc>
<sample for="lua">local parameters = Image.Provider.RemoteCamera.GigEVisionConfig.getParameters(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.GigEVisionConfig" desc="Instance of the GigEVisionConfig."/>
<return name="parameters" type="string" multiplicity="*" desc="Array of all supported values of the requested parameter."/>
                            </function>
                            <function name="getParameterAccessLevel">
<desc>Get the access level of a GigEVision parameter.</desc>
<sample for="lua">local parameters = Image.Provider.RemoteCamera.GigEVisionConfig.getParameterAccessLevel(camCfg, "name")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.GigEVisionConfig" desc="Instance of the GigEVisionConfig."/>
<param name="name" type="string" desc="Name of the GigEVision parameter"/>
<return name="accessLevel" type="enum" multiplicity="?" ref="AccessLevel" desc="Access level of parameter."/>
                            </function>
                            <function name="getParameterType">
<desc>Get the type of a GigEVision parameter.</desc>
<sample for="lua">local parameters = Image.Provider.RemoteCamera.GigEVisionConfig.getParameterType(camCfg, "name")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.GigEVisionConfig" desc="Instance of the GigEVisionConfig."/>
<param name="name" type="string" desc="Name of the GigEVision parameter"/>
<return name="type" type="enum" multiplicity="?" ref="Type" desc="Type of parameter."/>
                            </function>
                            <function name="getParameterString">
<desc>Retrieve a GigEVision parameter of type string.</desc>
<sample for="lua">local value, options = Image.Provider.RemoteCamera.GigEVisionConfig.getParameterString(camCfg, "name")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.GigEVisionConfig" desc="Instance of the GigEVisionConfig."/>
<param name="name" type="string" desc="Name of the GigEVision parameter"/>
<return name="value" type="string" multiplicity="?" desc="Value of the requested parameter."/>
<return name="options" type="string" multiplicity="*" desc="Array of all supported values of the requested parameter."/>
                            </function>
                            <function name="getParameterInteger">
<desc>Retrieve a GigEVision parameter of type integer.</desc>
<sample for="lua">local current, min, max, range = Image.Provider.RemoteCamera.GigEVisionConfig.getParameterInteger(camCfg, "name")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.GigEVisionConfig" desc="Instance of the GigEVisionConfig."/>
<param name="name" type="string" desc="Name of the GigEVision parameter"/>
<return name="current" type="int" multiplicity="?" desc="Value of the GigEVision parameter."/>
<return name="min" type="int" multiplicity="?" desc="Minimum valid value of the GigEVision parameter."/>
<return name="max" type="int" multiplicity="?" desc="Maximum valid value of the GigEVision parameter."/>
<return name="step" type="int" multiplicity="?" desc="Step size of the GigEVision parameter."/>
                            </function>
                            <function name="getParameterFloat">
<desc>Retrieve a GigEVision parameter of type float.</desc>
<sample for="lua">local current, min, max, range = Image.Provider.RemoteCamera.GigEVisionConfig.getParameterFloat(camCfg, "name")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.GigEVisionConfig" desc="Instance of the GigEVisionConfig."/>
<param name="name" type="string" desc="Name of the GigEVision parameter"/>
<return name="current" type="float" multiplicity="?" desc="Value of the GigEVision parameter."/>
<return name="min" type="float" multiplicity="?" desc="Minimum valid value of the GigEVision parameter."/>
<return name="max" type="float" multiplicity="?" desc="Maximum valid value of the GigEVision parameter."/>
<return name="step" type="float" multiplicity="?" desc="Step size of the GigEVision parameter."/>
                            </function>
                        </serves>
                    </crown>
                    <crown name="Config">
                        <trait>released</trait>
                        <desc>Provides functionality to configure a general RemoteCamera. Call Image.Provider.RemoteCamera.setConfig() to set this config.</desc>
                        <serves>
                            <function name="create">
<desc>Creates an instance of a RemoteCameraConfig.</desc>
<sample for="lua">camCfg = Image.Provider.RemoteCamera.Config.create()</sample>
<return name="config" type="object" alias="Image.Provider.RemoteCamera.Config" desc="Instance of the RemoteCameraConfig."/>
                            </function>
                            <function name="setGainFactor">
<desc>Sets the brightness of the resulting image without changing the shutter.
Higher value means more amplification and more noise.</desc>
<sample for="lua">Image.Provider.RemoteCamera.Config.setGainFactor(camCfg, 10.0)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.Config" desc="Instance of the configuration."/>
<param name="value" type="float" desc="the gain factor"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getGainFactor">
<desc>Gets the brightness of the resulting image without changing the shutter. A higher value means more amplification and more noise.</desc>
<sample for="lua">local value, default, min, max = Image.Provider.RemoteCamera.Config.getGainFactor(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="value" type="float" multiplicity="?" desc="Gain factor"/>
<return name="default" type="float" multiplicity="?" desc="Default Gain factor"/>
<return name="min" type="int" multiplicity="?" desc="Minimum gain factor"/>
<return name="max" type="int" multiplicity="?" desc="Maximum gain factor"/>
                            </function>
                            <function name="setShutterTime">
<desc>Sets the shutter time of the imager. Higher value means brighter image.</desc>
<sample for="lua">Image.Provider.RemoteCamera.Config.setShutterTimer(camCfg, 200)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.Config" desc="Instance of the configuration."/>
<param name="value" type="int" desc="the shutter time in microseconds"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getShutterTime">
<desc>Returns the shutter time of the imager.</desc>
<sample for="lua">local value, default, min, max, inc = Image.Provider.RemoteCamera.Config.getShutterTimer(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.Config" desc="Instance of the configuration."/>
<return name="value" type="int" multiplicity="?" desc="the shutter time in microseconds"/>
<return name="default" type="int" multiplicity="?" desc="the default shutter time in microseconds"/>
<return name="min" type="int" multiplicity="?" desc="Minimim shutter time in microseconds"/>
<return name="max" type="int" multiplicity="?" desc="Maximum shutter time in microseconds"/>
<return name="inc" type="int" multiplicity="?" desc="Increment of shutter time in microseconds"/>
                            </function>
                            <function name="setFrameRate">
<desc>Sets the speed used to take images.</desc>
<sample for="lua">Image.Provider.RemoteCamera.Config.setFrameRate(camCfg, 10.0)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.Config" desc="Instance of the configuration."/>
<param name="value" type="float" desc="frame rate in frames per second"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getFrameRate">
<desc>Returns the speed used to take images.</desc>
<sample for="lua">local value, default, min, max, interval = Image.Provider.RemoteCamera.Config.getFrameRate(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.Config" desc="Instance of the configuration."/>
<return name="value" type="float" multiplicity="?" desc="frame rate in frames per second"/>
<return name="default" type="float" multiplicity="?" desc="default frame rate in frames per second"/>
<return name="min" type="float" multiplicity="?" desc="Minimim frame rate in frames per second"/>
<return name="max" type="float" multiplicity="?" desc="Maximum frame rate in frames per second"/>
<return name="inc" type="float" multiplicity="?" desc="Increment of the frame rate frames per second"/>
                            </function>
                            <function name="setFieldOfView">
<desc>Sets the field of view of the resulting image. A limited FOV usually means faster image capturing.</desc>
<sample for="lua">Image.Provider.RemoteCamera.Config.setFieldOfView(camCfg, 20, 80, 0, 100)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.Config" desc="Instance of the configuration."/>
<param name="xMin" type="int" constraint="0-100" desc="left corner in % (default is 0)"/>
<param name="xMax" type="int" constraint="0-100" desc="right corner in % (default is 100)"/>
<param name="yMin" type="int" constraint="0-100" desc="top corner in % (default is 0)"/>
<param name="yMax" type="int" constraint="0-100" desc="bottom corner in % (default is 100)"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getFieldOfView">
<desc>Returns the field of view of the resulting image.</desc>
<sample for="lua">local xmin, xmax, ymin, ymax = Image.Provider.RemoteCamera.Config.setFieldOfView(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.Config" desc="Instance of the configuration."/>
<return name="xMin" type="int" multiplicity="?" desc="Limit from left in % of width."/>
<return name="xMax" type="int" multiplicity="?" desc="Limit from left in % of width."/>
<return name="yMin" type="int" multiplicity="?" desc="Limit from top in % of height."/>
<return name="yMax" type="int" multiplicity="?" desc="Limit from top in % of height."/>
                            </function>
                        </serves>
                    </crown>
                    <crown name="I2DConfig">
                        <trait>released</trait>
                        <enum name="AcquisitionMode">
                            <item name="Fixed Frequency" desc="Capture images in free-running mode">FIXED_FREQUENCY</item>
                            <item name="Software Trigger" desc="Capture images by software trigger">SOFTWARE_TRIGGER</item>
                            <item name="Hardware Trigger" desc="Capture images by hardware trigger">HARDWARE_TRIGGER</item>
                        </enum>
                        <enum name="HardwareTriggerMode">
                            <item name="Hi-Lo" desc="Hardware Trigger. Falling signal edge">HI_LO</item>
                            <item name="Lo-Hi" desc="Hardware Trigger. Rising signal edge">LO_HI</item>
                            <item name="Pre Hi-Lo" desc="Enables the pre-trigger in the memory mode. Falling signal edge">PRE_HI_LO</item>
                            <item name="Pre Lo-Hi" desc="Enables the pre-trigger in the memory mode. Rising signal edge">PRE_LO_HI</item>
                            <item name="Hi-Lo Sync" desc="Freerun sync./hardware trigger. Falling signal edge">HI_LO_SYNC</item>
                            <item name="Lo-Hi Sync" desc="Freerun sync./hardware trigger. Rising signal edge">LO_HI_SYNC</item>
                        </enum>
                        <enum name="ColorMode">
                            <item name="Mono 8bit" desc="Set image format to 8 bit grayscale.">MONO8</item>
                            <item name="RGB 24bit" desc="Set image format to 24 bit color.">COLOR8</item>
                            <item name="RAW 8bit" desc="Capture raw sensor data in 8bit. For color sensors external bayer conversion is requires.">RAW8</item>
                        </enum>
                        <enum name="ColorModel">
                            <item name="Default" desc="">DEFAULT</item>
                            <item name="Adobe RGB D65" desc="Adobe RGB color space with a white point of 6500 kelvins (mid daylight). The Adobe RGB color space is larger than the sRGB color space, but not all devices can render it.">ADOBE_RGB_D65</item>
                            <item name="CIE RGB E" desc="CIE-RGB color space with standard illumination E">CIE_RGB_E</item>
                            <item name="ECI RGB D50" desc="ECI-RGB color space with a white point of 5000 kelvins (warm light)">ECI_RGB_D50</item>
                            <item name="SRGB D50" desc="Standard RGB color space with a white point of 5000 kelvins (warm light)">SRGB_D50</item>
                            <item name="SRGB D65" desc="Standard RGB color space with a white point of 6500 kelvins (mid daylight)">SRGB_D65</item>
                        </enum>
                        <enum name="BinningMode">
                            <item name="No Binning" desc="Do not use binning (default)">NO_BINNING</item>
                            <item name="Binning 2x" desc="Average output over 2 sensor pixels in horizontal or vertical direction">BINNING_2X</item>
                            <item name="Binning 3x" desc="Average output over 3 sensor pixels in horizontal or vertical direction">BINNING_3X</item>
                            <item name="Binning 4x" desc="Average output over 4 sensor pixels in horizontal or vertical direction">BINNING_4X</item>
                            <item name="Binning 5x" desc="Average output over 5 sensor pixels in horizontal or vertical direction">BINNING_5X</item>
                            <item name="Binning 6x" desc="Average output over 6 sensor pixels in horizontal or vertical direction">BINNING_6X</item>
                            <item name="Binning 8x" desc="Average output over 8 sensor pixels in horizontal or vertical direction">BINNING_8X</item>
                            <item name="Binning 16x" desc="Average output over 16 sensor pixels in horizontal or vertical direction">BINNING_16X</item>
                        </enum>
                        <enum name="SubSamplingMode">
                            <item name="No Sub-sampling" desc="Do not use sub-sampling (default)">NO_SUBSAMPLING</item>
                            <item name="Sub-sampling 2x" desc="Sub-sample every 2nd sensor pixels in horizontal or vertical direction">SUBSAMPLING_2X</item>
                            <item name="Sub-sampling 3x" desc="Sub-sample every 3rd sensor pixels in horizontal or vertical direction">SUBSAMPLING_3X</item>
                            <item name="Sub-sampling 4x" desc="Sub-sample every 4th sensor pixels in horizontal or vertical direction">SUBSAMPLING_4X</item>
                            <item name="Sub-sampling 5x" desc="Sub-sample every 5th sensor pixels in horizontal or vertical direction">SUBSAMPLING_5X</item>
                            <item name="Sub-sampling 6x" desc="Sub-sample every 6th sensor pixels in horizontal or vertical direction">SUBSAMPLING_6X</item>
                            <item name="Sub-sampling 8x" desc="Sub-sample every 8th sensor pixels in horizontal or vertical direction">SUBSAMPLING_8X</item>
                            <item name="Sub-sampling 16x" desc="Sub-sample every 16th sensor pixels in horizontal or vertical direction">SUBSAMPLING_16X</item>
                        </enum>
                        <enum name="FlashMode">
                            <item name="Off" desc=" Disables the digital output.">OFF</item>
                            <item name="Active low" desc="Enables the flash strobe. The digital output is set to low level for the flash duration.">ACTIVE_LOW</item>
                            <item name="Active high" desc="Enables the flash strobe. The digital output is set to high level for the flash duration.">ACTIVE_HIGH</item>
                            <item name="Constant low" desc=" Statically sets the digital output to low level.">CONSTANT_LOW</item>
                            <item name="Constant high" desc="Statically sets the digital output to high level.">CONSTANT_HIGH</item>
                            <item name="Freerun auto active low" desc="Enables the auto flash in fixed frequency mode. The digital output is set to low level for the flash duration.">FREERUN_AUTO_ACTIVE_LOW</item>
                            <item name="Freerun auto active high" desc="Enables the auto flash in fixed frequency mode. The digital output is set to high level for the flash duration.">FREERUN_AUTO_ACTIVE_HIGH</item>
                        </enum>
                        <serves>
                            <function name="create">
<desc>Creates an instance of a I2DConfig.</desc>
<sample for="lua">camCfg = Image.Provider.RemoteCamera.I2DConfig.create()</sample>
<return name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the I2DConfig."/>
                            </function>
                            <function name="setFlashMode">
<desc>Configure the flash output mode of the camera.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setFlashMode(camCfg, "ACTIVE_LOW")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="mode" type="enum" ref="FlashMode" desc="The flash mode."/>
<return name="success" type="bool" desc="true if new value could be set in configuration."/>
                            </function>
                            <function name="getFlashMode">
<desc>Get the flash output configuration of the camera.</desc>
<sample for="lua">local value, supported = Image.Provider.RemoteCamera.I2DConfig.getFlashMode(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="mode" type="enum" multiplicity="?" ref="FlashMode" desc="The current flash mode."/>
<return name="modes" type="enum" multiplicity="*" ref="FlashMode" desc="List of all supported flash modes."/>
                            </function>
                            <function name="setFlashDuration">
<desc>Set the flash duration in microseconds. If 0 is passed, the flash output will be active until the end of the exposure time.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setFlashDuration(camCfg, 100)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="value" type="int" desc="Flash duration in microseconds."/>
<return name="success" type="bool" desc="true if new value could be set in configuration."/>
                            </function>
                            <function name="getFlashDuration">
<desc>Get the flash duration in microseconds.</desc>
<sample for="lua">local value, min, max, inc = Image.Provider.RemoteCamera.I2DConfig.getFlashDuration(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="value" type="int" multiplicity="?" desc="Current flash duration in microseconds."/>
<return name="min" type="int" multiplicity="?" desc="Minimum flash duration in microseconds."/>
<return name="max" type="int" multiplicity="?" desc="Maximum flash duration in microseconds."/>
<return name="increment" type="int" multiplicity="?" desc="Increment of the flash duration in microseconds."/>
                            </function>
                            <function name="setFlashDelay">
<desc>Set the flash delay in microseconds.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setFlashDelay(camCfg, 100)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="value" type="int" desc="Flash delay in microseconds."/>
<return name="success" type="bool" desc="true if new value could be set in configuration."/>
                            </function>
                            <function name="getFlashDelay">
<desc>Get the flash delay in microseconds.</desc>
<sample for="lua">local value, min, max, inc = Image.Provider.RemoteCamera.I2DConfig.getFlashDelay(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="value" type="int" multiplicity="?" desc="Current flash delay in microseconds."/>
<return name="min" type="int" multiplicity="?" desc="Minimum flash delay in microseconds."/>
<return name="max" type="int" multiplicity="?" desc="Maximum flash delay in microseconds."/>
<return name="increment" type="int" multiplicity="?" desc="Increment of the flash delay in microseconds."/>
                            </function>
                            <function name="setGainFactor">
<desc>Sets the brightness of the resulting image without changing the shutter. A higher value means more amplification and more noise.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setGainFactor(camCfg, 10.0)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="value" type="float" desc="Gain factor"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getGainFactor">
<desc>Gets the brightness of the resulting image without changing the shutter. A higher value means more amplification and more noise.</desc>
<sample for="lua">local value, default, min, max = Image.Provider.RemoteCamera.I2DConfig.getGainFactor(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="value" type="float" multiplicity="?" desc="Gain factor"/>
<return name="default" type="float" multiplicity="?" desc="Default Gain factor"/>
<return name="min" type="int" multiplicity="?" desc="Minimum gain factor"/>
<return name="max" type="int" multiplicity="?" desc="Maximum gain factor"/>
                            </function>
                            <function name="setShutterTime">
<desc>Sets the shutter time of the imager in microseconds. Higher value yields brighter image.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setShutterTime(camCfg, 2000)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="value" type="int" desc="Shutter time in microseconds"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getShutterTime">
<desc>Returns the shutter time of the imager.</desc>
<sample for="lua">local value, default, min, max, inc = Image.Provider.RemoteCamera.I2DConfig.getShutterTime(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="value" type="int" multiplicity="?" desc="the shutter time in microseconds"/>
<return name="default" type="int" multiplicity="?" desc="the default shutter time in microseconds"/>
<return name="min" type="int" multiplicity="?" desc="Minimim shutter time in microseconds"/>
<return name="max" type="int" multiplicity="?" desc="Maximum shutter time in microseconds"/>
<return name="inc" type="int" multiplicity="?" desc="Increment of shutter time in microseconds"/>
                            </function>
                            <function name="setPacketInterval">
<desc>The packet interval value determines the interval between the transfer of two successive packets, improving the data transfer of one or several cameras on slow networks. The usual value for the packet interval in Gigabit Ethernet networks is around 20 microseconds.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setPacketInterval(camCfg, 20)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="value" type="int" desc="Shutter packet interval in microseconds"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getPacketInterval">
<desc>Returns the packet interval value for the camera.</desc>
<sample for="lua">local value, default, min, max, inc = Image.Provider.RemoteCamera.I2DConfig.getPacketInterval(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="value" type="int" multiplicity="?" desc="The current packet interval value in microseconds"/>
<return name="default" type="int" multiplicity="?" desc="The default spacket interval value in microseconds"/>
<return name="min" type="int" multiplicity="?" desc="Minimim packet interval value in microseconds"/>
<return name="max" type="int" multiplicity="?" desc="Maximum packet interval value in microseconds"/>
<return name="inc" type="int" multiplicity="?" desc="Increment of packet interval value in microseconds"/>
                            </function>
                            <function name="setFrameRate">
<desc>Sets the desired rate for capturing images in frames per second in fixed frequency (FIXED_FREQUENCY) mode.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setFrameRate(camCfg, 10.0)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="value" type="float" desc="Frame rate in frames per second"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getFrameRate">
<desc>Returns the speed used to take images.</desc>
<sample for="lua">local value, default, min, max = Image.Provider.RemoteCamera.I2DConfig.getFrameRate(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.Config" desc="Instance of the configuration."/>
<return name="value" type="float" desc="frame rate in frames per second"/>
<return name="default" type="float" multiplicity="?" desc="default frame rate in frames per second"/>
<return name="min" type="float" multiplicity="?" desc="Minimum frame rate in frames per second"/>
<return name="max" type="float" multiplicity="?" desc="Maximum frame rate in frames per second"/>
<return name="interval" type="float" multiplicity="?" desc="Increment of the frame rate in frames per second"/>
                            </function>
                            <function name="setFieldOfView">
<desc>Sets the field of view of the resulting image. A limited FOV usually means faster image capturing.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setFieldOfView(camCfg, 20, 80, 0, 100)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="xMin" type="int" constraint="0-100" desc="left corner in % (default is 0)"/>
<param name="xMax" type="int" constraint="0-100" desc="right corner in % (default is 100)"/>
<param name="yMin" type="int" constraint="0-100" desc="top corner in % (default is 0)"/>
<param name="yMax" type="int" constraint="0-100" desc="bottom corner in % (default is 100)"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getFieldOfView">
<desc>Returns the field of view of the resulting image.</desc>
<sample for="lua">local xmin, xmax, ymin, ymax = Image.Provider.RemoteCamera.I2DConfig.getFieldOfView(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="xMin" type="int" multiplicity="?" desc="Limit from left in % of width."/>
<return name="xMax" type="int" multiplicity="?" desc="Limit from left in % of width."/>
<return name="yMin" type="int" multiplicity="?" desc="Limit from top in % of height."/>
<return name="yMax" type="int" multiplicity="?" desc="Limit from top in % of height."/>
                            </function>
                            <function name="setAcquisitionMode">
<desc>Selects the acquisition mode for the camera.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setAcquisitionMode(camCfg, "FIXED_FREQUENCY")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="mode" type="enum" ref="AcquisitionMode" desc="Acquisition mode"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getAcquisitionMode">
<desc>Get the acquisition mode for the camera.</desc>
<sample for="lua">local value, supported = Image.Provider.RemoteCamera.I2DConfig.getAcquisitionMode(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="mode" type="enum" multiplicity="?" ref="AcquisitionMode" desc="Acquisition mode"/>
<return name="modes" type="enum" multiplicity="*" ref="AcquisitionMode" desc="List of all supported Acquisition modes."/>
                            </function>
                            <function name="setHardwareTriggerMode">
<desc>Selects the trigger mode when acquisition mode is set to hardware trigger (HARDWARE_TRIGGER). See the manual of the camera which modes are supported.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setHardwareTriggerMode(camCfg, "HI_LO")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="mode" type="enum" ref="HardwareTriggerMode" desc="Hardware trigger mode"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getHardwareTriggerMode">
<desc>Get the trigger mode when acquisition mode is set to hardware trigger (HARDWARE_TRIGGER). See the manual of the camera which modes are supported.</desc>
<sample for="lua">local value, default, supported = Image.Provider.RemoteCamera.I2DConfig.getHardwareTriggerMode(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="mode" type="enum" multiplicity="?" ref="HardwareTriggerMode" desc="Hardware trigger mode"/>
<return name="default" type="enum" multiplicity="?" ref="HardwareTriggerMode" desc="Derfault hardware trigger mode"/>
<return name="modes" type="enum" multiplicity="*" ref="HardwareTriggerMode" desc="List of all supported hardware trigger modes."/>
                            </function>
                            <function name="setColorMode">
<desc>Selects the color mode to use for capturing images.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setColorMode(camCfg, "MONO8")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="mode" type="enum" ref="ColorMode" desc="Color mode"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getColorMode">
<desc>Get the color mode to use for capturing images.</desc>
<sample for="lua">local value, default, supported = Image.Provider.RemoteCamera.I2DConfig.getColorMode(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="mode" type="enum" multiplicity="?" ref="ColorMode" desc="Color mode"/>
<return name="default" type="enum" multiplicity="?" ref="ColorMode" desc="Default Color mode"/>
<return name="modes" type="enum" multiplicity="*" ref="ColorMode" desc="List of all supported Color modes"/>
                            </function>
                            <function name="setAutoGainEnabled">
<desc>Enables driver auto gain adjustment (resp. white level adjustment for HDR cameras).</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setAutoGainEnabled(camCfg, true)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="state" type="bool" desc="State of setting (true = on, false = off)"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getAutoGainEnabled">
<desc>Get driver auto gain adjustment (resp. white level adjustment for HDR cameras).</desc>
<sample for="lua">local value = Image.Provider.RemoteCamera.I2DConfig.getAutoGainEnabled(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="state" type="bool" multiplicity="?" desc="State of setting (true = on, false = off)"/>
                            </function>
                            <function name="setAutoSensorGainEnabled">
<desc>Enables internal sensor auto gain adjustment (resp. white level adjustment for HDR cameras).</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setAutoSensorGainEnabled(camCfg, true)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="state" type="bool" desc="State of setting (true = on, false = off)"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getAutoSensorGainEnabled">
<desc>Get internal sensor auto gain adjustment (resp. white level adjustment for HDR cameras).</desc>
<sample for="lua">local value = Image.Provider.RemoteCamera.I2DConfig.getAutoSensorGainEnabled(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="state" type="bool" multiplicity="?" desc="State of setting (true = on, false = off)"/>
                            </function>
                            <function name="setAutoShutterEnabled">
<desc>Enables driver auto shutter function.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setAutoShutterEnabled(camCfg, true)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="state" type="bool" desc="State of setting (true = on, false = off)"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getAutoShutterEnabled">
<desc>Get driver auto shutter function.</desc>
<sample for="lua">local value = Image.Provider.RemoteCamera.I2DSuEyeConfig.getAutoShutterEnabled(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="state" type="bool" multiplicity="?" desc="State of setting (true = on, false = off)"/>
                            </function>
                            <function name="setAutoSensorShutterEnabled">
<desc>Enables internal sensor auto shutter function.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setAutoSensorShutterEnabled(camCfg, true)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="state" type="bool" desc="State of setting (true = on, false = off)"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getAutoSensorShutterEnabled">
<desc>Get internal sensor auto shutter function.</desc>
<sample for="lua">local value = Image.Provider.RemoteCamera.I2DConfig.getAutoSensorShutterEnabled(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="state" type="bool" multiplicity="?" desc="State of setting (true = on, false = off)"/>
                            </function>
                            <function name="setAutoSensorGainShutterEnabled">
<desc>Enables auto shutter and gain adjustment function for XS camera models.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setAutoSensorGainShutterEnabled(camCfg, true)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="state" type="bool" desc="State of setting (true = on, false = off)"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getAutoSensorGainShutterEnabled">
<desc>Get auto shutter and gain adjustment function for XS camera models.</desc>
<sample for="lua">local value = Image.Provider.RemoteCamera.I2DConfig.getAutoSensorGainShutterEnabled(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="state" type="bool" multiplicity="?" desc="State of setting (true = on, false = off)"/>
                            </function>
                            <function name="setAutoWhitebalanceEnabled">
<desc>Enables driver auto whitebalance function.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setAutoWhitebalanceEnabled(camCfg, true)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="state" type="bool" desc="State of setting (true = on, false = off)"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getAutoWhitebalanceEnabled">
<desc>Get driver auto whitebalance function.</desc>
<sample for="lua">local value = Image.Provider.RemoteCamera.I2DConfig.getAutoWhitebalanceEnabled(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="state" type="bool" multiplicity="?" desc="State of setting (true = on, false = off)"/>
                            </function>
                            <function name="setAutoSensorWhitebalanceEnabled">
<desc>Enables internal sensor auto whitebalance function.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setAutoSensorWhitebalanceEnabled(camCfg, true)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="state" type="bool" desc="State of setting (true = on, false = off)"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getAutoSensorWhitebalanceEnabled">
<desc>Get internal sensor auto whitebalance function.</desc>
<sample for="lua">local value = Image.Provider.RemoteCamera.I2DConfig.getAutoSensorWhitebalanceEnabled(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="state" type="bool" multiplicity="?" desc="State of setting (true = on, false = off)"/>
                            </function>
                            <function name="setAutoFramerateEnabled">
<desc>Enables driver auto framerate function.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setAutoFramerateEnabled(camCfg, true)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="state" type="bool" desc="State of setting (true = on, false = off)"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getAutoFramerateEnabled">
<desc>Get driver auto framerate function.</desc>
<sample for="lua">local value = Image.Provider.RemoteCamera.I2DConfig.getAutoFramerateEnabled(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="state" type="bool" multiplicity="?" desc="State of setting (true = on, false = off)"/>
                            </function>
                            <function name="setAutoSensorFramerateEnabled">
<desc>Enables internal sensor auto framerate function.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setAutoSensorFramerateEnabled(camCfg, true)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="state" type="bool" desc="State of setting (true = on, false = off)"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getAutoSensorFramerateEnabled">
<desc>Get internal sensor auto framerate function.</desc>
<sample for="lua">local value = Image.Provider.RemoteCamera.I2DConfig.getAutoSensorFramerateEnabled(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="state" type="bool" multiplicity="?" desc="State of setting (true = on, false = off)"/>
                            </function>
                            <function name="setColorModel">
<desc>Selects the color model for the camera.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setColorModel(camCfg, "SRGB_D50")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="mode" type="enum" ref="ColorModel" desc="Color model"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getColorModel">
<desc>Get the color model for the camera.</desc>
<sample for="lua">local value = Image.Provider.RemoteCamera.I2DConfig.getColorModel(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="model" type="enum" multiplicity="?" ref="ColorModel" desc="Color model"/>
<return name="default" type="enum" multiplicity="?" ref="ColorModel" desc="Default Color model"/>
<return name="models" type="enum" multiplicity="*" ref="ColorModel" desc="List of all supported Color models"/>
                            </function>
                            <function name="setColorTemperature">
<desc>Sets the color temperature.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setColorTemperature(camCfg, 6500)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="temperature" type="int" desc="Color temperature in Kelvin"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getColorTemperature">
<desc>Gets the color temperature.</desc>
<sample for="lua">local value, default, min, max, inc = Image.Provider.RemoteCamera.I2DConfig.getColorTemperature(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="temperature" type="int" multiplicity="?" desc="Color temperature in Kelvin"/>
<return name="default" type="int" multiplicity="?" desc="default Color temperature in Kelvin"/>
<return name="min" type="int" multiplicity="?" desc="minimum Color temperature in Kelvin"/>
<return name="max" type="int" multiplicity="?" desc="maximum Color temperature in Kelvin"/>
<return name="inc" type="int" multiplicity="?" desc="Color temperature increment in Kelvin"/>
                            </function>
                            <function name="setPixelClock">
<desc>Sets the pixel clock in MHz. For the range of supported values please refer to the camera manual. If the pixel clock is not valid a warning is displayed</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setPixelClock(camCfg, 72)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="clock" type="int" desc="Pixel clock value in MHz."/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getPixelClock">
<desc>Gets the pixel clock in MHz. For the range of supported values please refer to the camera manual.</desc>
<sample for="lua">local value, default, min, max, inc = Image.Provider.RemoteCamera.I2DConfig.getPixelClock(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="clock" type="int" multiplicity="?" desc="Pixel clock value in MHz."/>
<return name="default" type="int" multiplicity="?" desc="Default target pixel clock increment in MHz."/>
<return name="min" type="int" multiplicity="?" desc="Minimum pixel clock value in MHz."/>
<return name="max" type="int" multiplicity="?" desc="Maximum pixel clock value in MHz."/>
<return name="inc" type="int" multiplicity="?" desc="Pixel clock increment in MHz."/>
                            </function>
                            <function name="setUseAutoBlacklevel">
<desc>Enables auto blacklevel correction.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setUseAutoBlacklevel(camCfg, true)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="state" type="bool" desc="State of setting (true = on, false = off)"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getUseAutoBlacklevel">
<desc>Get auto blacklevel correction.</desc>
<sample for="lua">local value, default = Image.Provider.RemoteCamera.I2DConfig.getUseAutoBlacklevel(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="state" type="bool" multiplicity="?" desc="State of setting (true = on, false = off)"/>
<return name="default" type="bool" multiplicity="?" desc="State of setting (true = on, false = off)"/>
                            </function>
                            <function name="setBlacklevelOffset">
<desc>Sets the blacklevel offset when using blacklevel correction.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setBlacklevelOffset(camCfg, 100)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="offset" type="int" desc="Blacklevel offset"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getBlacklevelOffset">
<desc>Gets the blacklevel offset when using blacklevel correction.</desc>
<sample for="lua">local value, default, min, max, inc = Image.Provider.RemoteCamera.I2DConfig.getBlacklevelOffset(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="offset" type="int" multiplicity="?" desc="Blacklevel offset"/>
<return name="default" type="int" multiplicity="?" desc="Default blacklevel offset"/>
<return name="min" type="int" multiplicity="?" desc="Minimum blacklevel offset"/>
<return name="max" type="int" multiplicity="?" desc="Maximum Blacklevel offset"/>
<return name="inc" type="int" multiplicity="?" desc="Blacklevel offset increment"/>
                            </function>
                            <function name="setGammaCorrection">
<desc>Sets digital gamma correction. This mode can not be used in raw mode (RAW8)</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setGammaCorrection(camCfg, 160)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="value" type="int" desc="Gamma correction value (range 1..1000). Is divided by 100 internally to obtain actual gamma correction value."/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getGammaCorrection">
<desc>Gets digital gamma correction. This mode can not be used in raw mode (RAW8)</desc>
<sample for="lua">local value, default = Image.Provider.RemoteCamera.I2DConfig.getGammaCorrection(camCfg)</sample>
<param name="config" type="object" multiplicity="?" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="value" type="int" multiplicity="?" desc="Gamma correction value (range 1..1000). Is divided by 100 internally to obtain actual gamma correction value."/>
<return name="default" type="int" multiplicity="?" desc="Default gamma correction value."/>
                            </function>
                            <function name="setVerticalBinning">
<desc>Sets the vertical binning mode. For the range of supported modes please refer to the camera manual.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setVerticalBinning(camCfg, "NO_BINNING")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="mode" type="enum" ref="BinningMode" desc="Vertical binning mode"/>
<return name="success" type="bool" multiplicity="?" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getVerticalBinning">
<desc>Gets the vertical binning mode. For the range of supported modes please refer to the camera manual.</desc>
<sample for="lua">local value, default, supported = Image.Provider.RemoteCamera.I2DConfig.getVerticalBinning(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="mode" type="enum" multiplicity="?" ref="BinningMode" desc="Vertical binning mode"/>
<return name="default" type="enum" multiplicity="?" ref="BinningMode" desc="Default vertical binning mode"/>
<return name="modes" type="enum" multiplicity="*" ref="BinningMode" desc="Supported vertical binning modes"/>
                            </function>
                            <function name="setHorizontalBinning">
<desc>Sets the horizontal binning mode. For the range of supported modes please refer to the camera manual.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setHorizontalBinning(camCfg, "NO_BINNING")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="mode" type="enum" ref="BinningMode" desc="Horizontal binning mode"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getHorizontalBinning">
<desc>Gets the horizontal binning mode. For the range of supported modes please refer to the camera manual.</desc>
<sample for="lua">local value, default, supported = Image.Provider.RemoteCamera.I2DConfig.getHorizontalBinning(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="mode" type="enum" multiplicity="?" ref="BinningMode" desc="Horizontal binning mode"/>
<return name="default" type="enum" multiplicity="?" ref="BinningMode" desc="Default horizontal binning mode"/>
<return name="modes" type="enum" multiplicity="*" ref="BinningMode" desc="Supported horizontal binning modes"/>
                            </function>
                            <function name="setVerticalSubsampling">
<desc>Sets the vertical subsampling mode. For the range of supported modes please refer to the camera manual.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setVerticalSubsampling(camCfg, "NO_SUBSAMPLING")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="mode" type="enum" ref="SubSamplingMode" desc="Vertical subsampling mode"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getVerticalSubsampling">
<desc>Gets the vertical subsampling mode. For the range of supported modes please refer to the camera manual.</desc>
<sample for="lua">local value, default, supported = Image.Provider.RemoteCamera.I2DConfig.getVerticalSubsampling(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="mode" type="enum" multiplicity="?" ref="SubSamplingMode" desc="Vertical subsampling mode"/>
<return name="default" type="enum" multiplicity="?" ref="SubSamplingMode" desc="Default vertical subsampling mode"/>
<return name="modes" type="enum" multiplicity="*" ref="SubSamplingMode" desc="Supported vertical subsampling modes"/>
                            </function>
                            <function name="setHorizontalSubsampling">
<desc>Sets the horizontal subsampling mode. For the range of supported modes please refer to the camera manual.</desc>
<sample for="lua">Image.Provider.RemoteCamera.I2DConfig.setHorizontalSubsampling(camCfg, "NO_SUBSAMPLING")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="mode" type="enum" ref="SubSamplingMode" desc="Horizontal subsampling mode"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getHorizontalSubsampling">
<desc>Gets the horizontal subsampling mode. For the range of supported modes please refer to the camera manual.</desc>
<sample for="lua">local value, default, supported = Image.Provider.RemoteCamera.I2DConfig.getHorizontalSubsampling(camCfg, "NO_SUBSAMPLING")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="mode" type="enum" multiplicity="?" ref="SubSamplingMode" desc="Horizontal subsampling mode"/>
<return name="default" type="enum" multiplicity="?" ref="SubSamplingMode" desc="Default horizontal subsampling mode"/>
<return name="modes" type="enum" multiplicity="*" ref="SubSamplingMode" desc="Supported horizontal subsampling modes"/>
                            </function>
                        </serves>
                    </crown>
                    <crown name="IDSuEyeConfig">
                        <trait>released</trait>
                        <enum name="AcquisitionMode">
                            <item name="No Acquisition" desc="Do not capture images">NO_ACQUISITION</item>
                            <item name="Fixed Frequency" desc="Capture images in free-running mode">FIXED_FREQUENCY</item>
                            <item name="Software Trigger" desc="Capture images by software trigger">SOFTWARE_TRIGGER</item>
                            <item name="Hardware Trigger" desc="Capture images by hardware trigger">HARDWARE_TRIGGER</item>
                        </enum>
                        <enum name="HardwareTriggerMode">
                            <item name="Hi-Lo" desc="Hardware Trigger. Falling signal edge">HI_LO</item>
                            <item name="Lo-Hi" desc="Hardware Trigger. Rising signal edge">LO_HI</item>
                            <item name="Pre Hi-Lo" desc="Enables the pre-trigger in the memory mode. Falling signal edge">PRE_HI_LO</item>
                            <item name="Pre Lo-Hi" desc="Enables the pre-trigger in the memory mode. Rising signal edge">PRE_LO_HI</item>
                            <item name="Hi-Lo Sync" desc="Freerun sync./hardware trigger. Falling signal edge">HI_LO_SYNC</item>
                            <item name="Lo-Hi Sync" desc="Freerun sync./hardware trigger. Rising signal edge">LO_HI_SYNC</item>
                        </enum>
                        <enum name="ColorMode">
                            <item name="Mono 8bit" desc="Set image format to 8 bit grayscale.">MONO8</item>
                            <item name="RGB 24bit" desc="Set image format to 24 bit color.">COLOR8</item>
                            <item name="RAW 8bit" desc="Capture raw sensor data in 8bit. For color sensors external bayer conversion is requires.">RAW8</item>
                        </enum>
                        <enum name="ColorModel">
                            <item name="Default" desc="">DEFAULT</item>
                            <item name="Adobe RGB D65" desc="Adobe RGB color space with a white point of 6500 kelvins (mid daylight). The Adobe RGB color space is larger than the sRGB color space, but not all devices can render it.">ADOBE_RGB_D65</item>
                            <item name="CIE RGB E" desc="CIE-RGB color space with standard illumination E">CIE_RGB_E</item>
                            <item name="ECI RGB D50" desc="ECI-RGB color space with a white point of 5000 kelvins (warm light)">ECI_RGB_D50</item>
                            <item name="SRGB D50" desc="Standard RGB color space with a white point of 5000 kelvins (warm light)">SRGB_D50</item>
                            <item name="SRGB D65" desc="Standard RGB color space with a white point of 6500 kelvins (mid daylight)">SRGB_D65</item>
                        </enum>
                        <enum name="BinningMode">
                            <item name="No Binning" desc="Do not use binning (default)">NO_BINNING</item>
                            <item name="Binning 2x" desc="Average output over 2 sensor pixels in horizontal or vertical direction">BINNING_2X</item>
                            <item name="Binning 3x" desc="Average output over 3 sensor pixels in horizontal or vertical direction">BINNING_3X</item>
                            <item name="Binning 4x" desc="Average output over 4 sensor pixels in horizontal or vertical direction">BINNING_4X</item>
                            <item name="Binning 5x" desc="Average output over 5 sensor pixels in horizontal or vertical direction">BINNING_5X</item>
                            <item name="Binning 6x" desc="Average output over 6 sensor pixels in horizontal or vertical direction">BINNING_6X</item>
                            <item name="Binning 8x" desc="Average output over 8 sensor pixels in horizontal or vertical direction">BINNING_8X</item>
                            <item name="Binning 16x" desc="Average output over 16 sensor pixels in horizontal or vertical direction">BINNING_16X</item>
                        </enum>
                        <enum name="SubSamplingMode">
                            <item name="No Sub-sampling" desc="Do not use sub-sampling (default)">NO_SUBSAMPLING</item>
                            <item name="Sub-sampling 2x" desc="Sub-sample every 2nd sensor pixels in horizontal or vertical direction">SUBSAMPLING_2X</item>
                            <item name="Sub-sampling 3x" desc="Sub-sample every 3rd sensor pixels in horizontal or vertical direction">SUBSAMPLING_3X</item>
                            <item name="Sub-sampling 4x" desc="Sub-sample every 4th sensor pixels in horizontal or vertical direction">SUBSAMPLING_4X</item>
                            <item name="Sub-sampling 5x" desc="Sub-sample every 5th sensor pixels in horizontal or vertical direction">SUBSAMPLING_5X</item>
                            <item name="Sub-sampling 6x" desc="Sub-sample every 6th sensor pixels in horizontal or vertical direction">SUBSAMPLING_6X</item>
                            <item name="Sub-sampling 8x" desc="Sub-sample every 8th sensor pixels in horizontal or vertical direction">SUBSAMPLING_8X</item>
                            <item name="Sub-sampling 16x" desc="Sub-sample every 16th sensor pixels in horizontal or vertical direction">SUBSAMPLING_16X</item>
                        </enum>
                        <enum name="FlashMode">
                            <item name="Off" desc=" Disables the digital output.">OFF</item>
                            <item name="Active low" desc="Enables the flash strobe. The digital output is set to low level for the flash duration.">ACTIVE_LOW</item>
                            <item name="Active high" desc="Enables the flash strobe. The digital output is set to high level for the flash duration.">ACTIVE_HIGH</item>
                            <item name="Constant low" desc=" Statically sets the digital output to low level.">CONSTANT_LOW</item>
                            <item name="Constant high" desc="Statically sets the digital output to high level.">CONSTANT_HIGH</item>
                            <item name="Freerun auto active low" desc="Enables the auto flash in fixed frequency mode. The digital output is set to low level for the flash duration.">FREERUN_AUTO_ACTIVE_LOW</item>
                            <item name="Freerun auto active high" desc="Enables the auto flash in fixed frequency mode. The digital output is set to high level for the flash duration.">FREERUN_AUTO_ACTIVE_HIGH</item>
                        </enum>
                        <serves>
                            <function name="create">
<desc>Creates an empty instance of an IDSuEyeConfig.</desc>
<sample for="lua">camCfg = Image.Provider.RemoteCamera.IDSuEyeConfig.create()</sample>
<return name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the I2DConfig."/>
                            </function>
                            <function name="setFlashMode">
<desc>Configure the flash output mode of the camera.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setFlashMode(camCfg, "ACTIVE_LOW")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="mode" type="enum" ref="FlashMode" desc="The flash mode."/>
<return name="success" type="bool" desc="true if new value could be set in configuration."/>
                            </function>
                            <function name="getFlashMode">
<desc>Get the flash output configuration of the camera.</desc>
<sample for="lua">local value, supported = Image.Provider.RemoteCamera.IDSuEyeConfig.getFlashMode(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="mode" type="enum" multiplicity="?" ref="FlashMode" desc="The current flash mode."/>
<return name="modes" type="enum" multiplicity="*" ref="FlashMode" desc="List of all supported flash modes."/>
                            </function>
                            <function name="setFlashDuration">
<desc>Set the flash duration in microseconds. If 0 is passed, the flash output will be active until the end of the exposure time.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setFlashDuration(camCfg, 100)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="value" type="int" desc="Flash duration in microseconds."/>
<return name="success" type="bool" desc="true if new value could be set in configuration."/>
                            </function>
                            <function name="getFlashDuration">
<desc>Get the flash duration in microseconds.</desc>
<sample for="lua">local value, min, max, inc = Image.Provider.RemoteCamera.IDSuEyeConfig.getFlashDuration(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="value" type="int" multiplicity="?" desc="Current flash duration in microseconds."/>
<return name="min" type="int" multiplicity="?" desc="Minimum flash duration in microseconds."/>
<return name="max" type="int" multiplicity="?" desc="Maximum flash duration in microseconds."/>
<return name="increment" type="int" multiplicity="?" desc="Increment of the flash duration in microseconds."/>
                            </function>
                            <function name="setFlashDelay">
<desc>Set the flash delay in microseconds.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setFlashDelay(camCfg, 100)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="value" type="int" desc="Flash delay in microseconds."/>
<return name="success" type="bool" desc="true if new value could be set in configuration."/>
                            </function>
                            <function name="getFlashDelay">
<desc>Get the flash delay in microseconds.</desc>
<sample for="lua">local value, min, max, inc = Image.Provider.RemoteCamera.IDSuEyeConfig.getFlashDelay(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="value" type="int" multiplicity="?" desc="Current flash delay in microseconds."/>
<return name="min" type="int" multiplicity="?" desc="Minimum flash delay in microseconds."/>
<return name="max" type="int" multiplicity="?" desc="Maximum flash delay in microseconds."/>
<return name="increment" type="int" multiplicity="?" desc="Increment of the flash delay in microseconds."/>
                            </function>
                            <function name="setGainFactor">
<desc>Sets the brightness of the resulting image without changing the shutter. A higher value means more amplification and more noise.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setGainFactor(camCfg, 10.0)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="value" type="float" desc="Gain factor"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getGainFactor">
<desc>Gets the brightness of the resulting image without changing the shutter. A higher value means more amplification and more noise.</desc>
<sample for="lua">local value, default, min, max = Image.Provider.RemoteCamera.IDSuEyeConfig.getGainFactor(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="value" type="float" multiplicity="?" desc="Gain factor"/>
<return name="default" type="float" multiplicity="?" desc="Default Gain factor"/>
<return name="min" type="int" multiplicity="?" desc="Minimum gain factor"/>
<return name="max" type="int" multiplicity="?" desc="Maximum gain factor"/>
                            </function>
                            <function name="setShutterTime">
<desc>Sets the shutter time of the imager in microseconds. Higher value yields brighter image.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setShutterTimer(camCfg, 2000)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="value" type="int" desc="Shutter time in microseconds"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getShutterTime">
<desc>Returns the shutter time of the imager.</desc>
<sample for="lua">local value, default, min, max, inc = Image.Provider.RemoteCamera.IDSuEyeConfig.getShutterTimer(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.Config" desc="Instance of the configuration."/>
<return name="value" type="int" multiplicity="?" desc="the shutter time in microseconds"/>
<return name="default" type="int" multiplicity="?" desc="the default shutter time in microseconds"/>
<return name="min" type="int" multiplicity="?" desc="Minimim shutter time in microseconds"/>
<return name="max" type="int" multiplicity="?" desc="Maximum shutter time in microseconds"/>
<return name="inc" type="int" multiplicity="?" desc="Increment of shutter time in microseconds"/>
                            </function>
                            <function name="setPacketInterval">
<desc>The packet interval value determines the interval between the transfer of two successive packets, improving the data transfer of one or several cameras on slow networks. The usual value for the packet interval in Gigabit Ethernet networks is around 20 microseconds.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setPacketInterval(camCfg, 20)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<param name="value" type="int" desc="Shutter packet interval in microseconds"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getPacketInterval">
<desc>Returns the packet interval value for the camera.</desc>
<sample for="lua">local value, default, min, max, inc = Image.Provider.RemoteCamera.IDSuEyeConfig.getPacketInterval(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.I2DConfig" desc="Instance of the configuration."/>
<return name="value" type="int" multiplicity="?" desc="The current packet interval value in microseconds"/>
<return name="default" type="int" multiplicity="?" desc="The default spacket interval value in microseconds"/>
<return name="min" type="int" multiplicity="?" desc="Minimim packet interval value in microseconds"/>
<return name="max" type="int" multiplicity="?" desc="Maximum packet interval value in microseconds"/>
<return name="inc" type="int" multiplicity="?" desc="Increment of packet interval value in microseconds"/>
                            </function>
                            <function name="setFrameRate">
<desc>Sets the desired rate for capturing images in frames per second in fixed frequency (FIXED_FREQUENCY) mode.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setFrameRate(camCfg, 10.0)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="value" type="float" desc="Frame rate in frames per second"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getFrameRate">
<desc>Returns the speed used to take images.</desc>
<sample for="lua">local value, default, min, max = Image.Provider.RemoteCamera.IDSuEyeConfig.getFrameRate(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.Config" desc="Instance of the configuration."/>
<return name="value" type="float" multiplicity="?" desc="frame rate in frames per second"/>
<return name="default" type="float" multiplicity="?" desc="default frame rate in frames per second"/>
<return name="min" type="float" multiplicity="?" desc="Minimum frame rate in frames per second"/>
<return name="max" type="float" multiplicity="?" desc="Maximum frame rate in frames per second"/>
<return name="interval" type="float" multiplicity="?" desc="Increment of the frame rate in frames per second"/>
                            </function>
                            <function name="setFieldOfView">
<desc>Sets the field of view of the resulting image. A limited FOV usually means faster image capturing.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setFieldOfView(camCfg, 20, 80, 0, 100)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="xMin" type="int" constraint="0-100" desc="left corner in % (default is 0)"/>
<param name="xMax" type="int" constraint="0-100" desc="right corner in % (default is 100)"/>
<param name="yMin" type="int" constraint="0-100" desc="top corner in % (default is 0)"/>
<param name="yMax" type="int" constraint="0-100" desc="bottom corner in % (default is 100)"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getFieldOfView">
<desc>Gets the field of view of the resulting image. A limited FOV usually means faster image capturing.</desc>
<sample for="lua">local xMin, xMax, yMin, yMax = Image.Provider.RemoteCamera.IDSuEyeConfig.getFieldOfView(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="xMin" type="int" multiplicity="?" desc="Start from left in percent of full width."/>
<return name="xMax" type="int" multiplicity="?" desc="End from left in percent of full width."/>
<return name="yMin" type="int" multiplicity="?" desc="Start from top in percent of full height."/>
<return name="yMax" type="int" multiplicity="?" desc="End from top in percent of full height."/>
                            </function>
                            <function name="setAcquisitionMode">
<desc>Selects the acquisition mode for the camera.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setAcquisitionMode(camCfg, "FIXED_FREQUENCY")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="mode" type="enum" ref="AcquisitionMode" desc="Acquisition mode"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getAcquisitionMode">
<desc>Get the acquisition mode for the camera.</desc>
<sample for="lua">local value, supported = Image.Provider.RemoteCamera.IDSuEyeConfig.getAcquisitionMode(camCfg)</sample>
<param name="config" type="object" multiplicity="?" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="mode" type="enum" multiplicity="?" ref="AcquisitionMode" desc="Acquisition mode"/>
<return name="modes" type="enum" multiplicity="*" ref="AcquisitionMode" desc="List of all supported Acquisition modes."/>
                            </function>
                            <function name="setHardwareTriggerMode">
<desc>Selects the trigger mode when acquisition mode is set to hardware trigger (HARDWARE_TRIGGER). See the manual of the camera which modes are supported.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setHardwareTriggerMode(camCfg, "HI_LO")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="mode" type="enum" ref="HardwareTriggerMode" desc="Hardware trigger mode"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getHardwareTriggerMode">
<desc>Get the trigger mode when acquisition mode is set to hardware trigger (HARDWARE_TRIGGER). See the manual of the camera which modes are supported.</desc>
<sample for="lua">local value, default, supported = Image.Provider.RemoteCamera.IDSuEyeConfig.getHardwareTriggerMode(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="mode" type="enum" multiplicity="?" ref="HardwareTriggerMode" desc="Hardware trigger mode"/>
<return name="default" type="enum" multiplicity="?" ref="HardwareTriggerMode" desc="Derfault hardware trigger mode"/>
<return name="modes" type="enum" multiplicity="*" ref="HardwareTriggerMode" desc="List of all supported hardware trigger modes."/>
                            </function>
                            <function name="setColorMode">
<desc>Selects the color mode to use for capturing images.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setColorMode(camCfg, "MONO8")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="mode" type="enum" ref="ColorMode" desc="Color mode"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getColorMode">
<desc>Get the color mode to use for capturing images.</desc>
<sample for="lua">local value, default, supported = Image.Provider.RemoteCamera.IDSuEyeConfig.getColorMode(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="mode" type="enum" multiplicity="?" ref="ColorMode" desc="Color mode"/>
<return name="default" type="enum" multiplicity="?" ref="ColorMode" desc="Default Color mode"/>
<return name="modes" type="enum" multiplicity="*" ref="ColorMode" desc="List of all supported Color modes"/>
                            </function>
                            <function name="setAutoGainEnabled">
<desc>Enables driver auto gain adjustment (resp. white level adjustment for HDR cameras).</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setAutoGainEnabled(camCfg, true)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="state" type="bool" desc="State of setting (true = on, false = off)"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getAutoGainEnabled">
<desc>Get driver auto gain adjustment (resp. white level adjustment for HDR cameras).</desc>
<sample for="lua">local value = Image.Provider.RemoteCamera.IDSuEyeConfig.getAutoGainEnabled(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="state" type="bool" multiplicity="?" desc="State of setting (true = on, false = off)"/>
                            </function>
                            <function name="setAutoSensorGainEnabled">
<desc>Enables internal sensor auto gain adjustment (resp. white level adjustment for HDR cameras).</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setAutoSensorGainEnabled(camCfg, true)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="state" type="bool" desc="State of setting (true = on, false = off)"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getAutoSensorGainEnabled">
<desc>Get internal sensor auto gain adjustment (resp. white level adjustment for HDR cameras).</desc>
<sample for="lua">local value = Image.Provider.RemoteCamera.IDSuEyeConfig.getAutoSensorGainEnabled(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="state" type="bool" multiplicity="?" desc="State of setting (true = on, false = off)"/>
                            </function>
                            <function name="setAutoShutterEnabled">
<desc>Enables driver auto shutter function.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setAutoShutterEnabled(camCfg, true)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="state" type="bool" desc="State of setting (true = on, false = off)"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getAutoShutterEnabled">
<desc>Get driver auto shutter function.</desc>
<sample for="lua">local value = Image.Provider.RemoteCamera.IDSuEyeConfig.getAutoShutterEnabled(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="state" type="bool" multiplicity="?" desc="State of setting (true = on, false = off)"/>
                            </function>
                            <function name="setAutoSensorShutterEnabled">
<desc>Enables internal sensor auto shutter function.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setAutoSensorShutterEnabled(camCfg, true)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="state" type="bool" desc="State of setting (true = on, false = off)"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getAutoSensorShutterEnabled">
<desc>Get internal sensor auto shutter function.</desc>
<sample for="lua">local value = Image.Provider.RemoteCamera.IDSuEyeConfig.getAutoSensorShutterEnabled(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="state" type="bool" multiplicity="?" desc="State of setting (true = on, false = off)"/>
                            </function>
                            <function name="setAutoSensorGainShutterEnabled">
<desc>Enables auto shutter and gain adjustment function for XS camera models.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setAutoSensorGainShutterEnabled(camCfg, true)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="state" type="bool" desc="State of setting (true = on, false = off)"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getAutoSensorGainShutterEnabled">
<desc>Get auto shutter and gain adjustment function for XS camera models.</desc>
<sample for="lua">local value = Image.Provider.RemoteCamera.IDSuEyeConfig.getAutoSensorGainShutterEnabled(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="state" type="bool" multiplicity="?" desc="State of setting (true = on, false = off)"/>
                            </function>
                            <function name="setAutoWhitebalanceEnabled">
<desc>Enables driver auto whitebalance function.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setAutoWhitebalanceEnabled(camCfg, true)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="state" type="bool" desc="State of setting (true = on, false = off)"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getAutoWhitebalanceEnabled">
<desc>Get driver auto whitebalance function.</desc>
<sample for="lua">local value = Image.Provider.RemoteCamera.IDSuEyeConfig.getAutoWhitebalanceEnabled(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="state" type="bool" multiplicity="?" desc="State of setting (true = on, false = off)"/>
                            </function>
                            <function name="setAutoSensorWhitebalanceEnabled">
<desc>Enables internal sensor auto whitebalance function.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setAutoSensorWhitebalanceEnabled(camCfg, true)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="state" type="bool" desc="State of setting (true = on, false = off)"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getAutoSensorWhitebalanceEnabled">
<desc>Get internal sensor auto whitebalance function.</desc>
<sample for="lua">local value = Image.Provider.RemoteCamera.IDSuEyeConfig.getAutoSensorWhitebalanceEnabled(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="state" type="bool" multiplicity="?" desc="State of setting (true = on, false = off)"/>
                            </function>
                            <function name="setAutoFramerateEnabled">
<desc>Enables driver auto framerate function.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setAutoFramerateEnabled(camCfg, true)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="state" type="bool" desc="State of setting (true = on, false = off)"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getAutoFramerateEnabled">
<desc>Get driver auto framerate function.</desc>
<sample for="lua">local value = Image.Provider.RemoteCamera.IDSuEyeConfig.getAutoFramerateEnabled(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="state" type="bool" multiplicity="?" desc="State of setting (true = on, false = off)"/>
                            </function>
                            <function name="setAutoSensorFramerateEnabled">
<desc>Enables internal sensor auto framerate function.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setAutoSensorFramerateEnabled(camCfg, true)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="state" type="bool" desc="State of setting (true = on, false = off)"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getAutoSensorFramerateEnabled">
<desc>Get internal sensor auto framerate function.</desc>
<sample for="lua">local value = Image.Provider.RemoteCamera.IDSuEyeConfig.getAutoSensorFramerateEnabled(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="state" type="bool" multiplicity="?" desc="State of setting (true = on, false = off)"/>
                            </function>
                            <function name="setColorModel">
<desc>Selects the color model for the camera.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setColorModel(camCfg, "SRGB_D50")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="mode" type="enum" ref="ColorModel" desc="Color model"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getColorModel">
<desc>Get the color model for the camera.</desc>
<sample for="lua">local value = Image.Provider.RemoteCamera.IDSuEyeConfig.getColorModel(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="model" type="enum" multiplicity="?" ref="ColorModel" desc="Color model"/>
<return name="default" type="enum" multiplicity="?" ref="ColorModel" desc="Default Color model"/>
<return name="models" type="enum" multiplicity="*" ref="ColorModel" desc="List of all supported Color models"/>
                            </function>
                            <function name="setColorTemperature">
<desc>Sets the color temperature.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setColorTemperature(camCfg, 6500)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="temperature" type="int" desc="Color temperature in Kelvin"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getColorTemperature">
<desc>Gets the color temperature.</desc>
<sample for="lua">local value, default, min, max, inc = Image.Provider.RemoteCamera.IDSuEyeConfig.getColorTemperature(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="temperature" type="int" multiplicity="?" desc="Color temperature in Kelvin"/>
<return name="default" type="int" multiplicity="?" desc="default Color temperature in Kelvin"/>
<return name="min" type="int" multiplicity="?" desc="minimum Color temperature in Kelvin"/>
<return name="max" type="int" multiplicity="?" desc="maximum Color temperature in Kelvin"/>
<return name="inc" type="int" multiplicity="?" desc="Color temperature increment in Kelvin"/>
                            </function>
                            <function name="setPixelClock">
<desc>Sets the pixel clock in MHz. For the range of supported values please refer to the camera manual.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setPixelClock(camCfg, 72)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="clock" type="int" desc="Target pixel clock value in MHz."/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getPixelClock">
<desc>Gets the pixel clock in MHz. For the range of supported values please refer to the camera manual.</desc>
<sample for="lua">local value, default, min, max, inc = Image.Provider.RemoteCamera.IDSuEyeConfig.getPixelClock(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="clock" type="int" multiplicity="?" desc="Target pixel clock value in MHz."/>
<return name="default" type="int" multiplicity="?" desc="Default target pixel clock increment in MHz."/>
<return name="min" type="int" multiplicity="?" desc="Minimum target pixel clock value in MHz."/>
<return name="max" type="int" multiplicity="?" desc="Maximum target pixel clock value in MHz."/>
<return name="inc" type="int" multiplicity="?" desc="Target pixel clock increment in MHz."/>
                            </function>
                            <function name="setUseAutoBlacklevel">
<desc>Enables auto blacklevel correction.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setUseAutoBlacklevel(camCfg, true)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="state" type="bool" desc="State of setting (true = on, false = off)"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getUseAutoBlacklevel">
<desc>Get auto blacklevel correction.</desc>
<sample for="lua">local value, default = Image.Provider.RemoteCamera.IDSuEyeConfig.getUseAutoBlacklevel(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="state" type="bool" multiplicity="?" desc="State of setting (true = on, false = off)"/>
<return name="default" type="bool" multiplicity="?" desc="State of setting (true = on, false = off)"/>
                            </function>
                            <function name="setBlacklevelOffset">
<desc>Sets the blacklevel offset when using blacklevel correction.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setBlacklevelOffset(camCfg, 100)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="offset" type="int" desc="Blacklevel offset"/>
<return name="success" type="bool" multiplicity="?" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getBlacklevelOffset">
<desc>Gets the blacklevel offset when using blacklevel correction.</desc>
<sample for="lua">local value, default, min, max, inc = Image.Provider.RemoteCamera.IDSuEyeConfig.getBlacklevelOffset(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="offset" type="int" multiplicity="?" desc="Blacklevel offset"/>
<return name="default" type="int" multiplicity="?" desc="Default blacklevel offset"/>
<return name="min" type="int" multiplicity="?" desc="Minimum blacklevel offset"/>
<return name="max" type="int" multiplicity="?" desc="Maximum Blacklevel offset"/>
<return name="inc" type="int" multiplicity="?" desc="Blacklevel offset increment"/>
                            </function>
                            <function name="setGammaCorrection">
<desc>Sets digital gamma correction. This mode can not be used in raw mode (RAW8)</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setGammaCorrection(camCfg, 160)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="value" type="int" desc="Gamma correction value (range 1..1000). Is divided by 100 internally to obtain actual gamma correction value."/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getGammaCorrection">
<desc>Gets digital gamma correction. This mode can not be used in raw mode (RAW8)</desc>
<sample for="lua">local value, default = Image.Provider.RemoteCamera.IDSuEyeConfig.getGammaCorrection(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="value" type="int" multiplicity="?" desc="Gamma correction value (range 1..1000). Is divided by 100 internally to obtain actual gamma correction value."/>
<return name="default" type="int" multiplicity="?" desc="Default gamma correction value."/>
                            </function>
                            <function name="setVerticalBinning">
<desc>Sets the vertical binning mode. For the range of supported modes please refer to the camera manual.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setVerticalBinning(camCfg, "NO_BINNING")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="mode" type="enum" ref="BinningMode" desc="Vertical binning mode"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getVerticalBinning">
<desc>Gets the vertical binning mode. For the range of supported modes please refer to the camera manual.</desc>
<sample for="lua">local value, default, supported = Image.Provider.RemoteCamera.IDSuEyeConfig.getVerticalBinning(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="mode" type="enum" multiplicity="?" ref="BinningMode" desc="Vertical binning mode"/>
<return name="default" type="enum" multiplicity="?" ref="BinningMode" desc="Default vertical binning mode"/>
<return name="modes" type="enum" multiplicity="*" ref="BinningMode" desc="Supported vertical binning modes"/>
                            </function>
                            <function name="setHorizontalBinning">
<desc>Sets the horizontal binning mode. For the range of supported modes please refer to the camera manual.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setHorizontalBinning(camCfg, "NO_BINNING")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="mode" type="enum" ref="BinningMode" desc="Horizontal binning mode"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getHorizontalBinning">
<desc>Gets the horizontal binning mode. For the range of supported modes please refer to the camera manual.</desc>
<sample for="lua">local value, default, supported = Image.Provider.RemoteCamera.IDSuEyeConfig.getHorizontalBinning(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="mode" type="enum" multiplicity="?" ref="BinningMode" desc="Horizontal binning mode"/>
<return name="default" type="enum" multiplicity="?" ref="BinningMode" desc="Default horizontal binning mode"/>
<return name="modes" type="enum" multiplicity="*" ref="BinningMode" desc="Supported horizontal binning modes"/>
                            </function>
                            <function name="setVerticalSubsampling">
<desc>Sets the vertical subsampling mode. For the range of supported modes please refer to the camera manual.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setVerticalSubsampling(camCfg, "NO_SUBSAMPLING")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="mode" type="enum" ref="SubSamplingMode" desc="Vertical subsampling mode"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getVerticalSubsampling">
<desc>Gets the vertical subsampling mode. For the range of supported modes please refer to the camera manual.</desc>
<sample for="lua">local value, default, supported = Image.Provider.RemoteCamera.IDSuEyeConfig.getVerticalSubsampling(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="mode" type="enum" multiplicity="?" ref="SubSamplingMode" desc="Vertical subsampling mode"/>
<return name="default" type="enum" multiplicity="?" ref="SubSamplingMode" desc="Default vertical subsampling mode"/>
<return name="modes" type="enum" multiplicity="*" ref="SubSamplingMode" desc="Supported vertical subsampling modes"/>
                            </function>
                            <function name="setHorizontalSubsampling">
<desc>Sets the horizontal subsampling mode. For the range of supported modes please refer to the camera manual.</desc>
<sample for="lua">Image.Provider.RemoteCamera.IDSuEyeConfig.setHorizontalSubsampling(camCfg, "NO_SUBSAMPLING")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<param name="mode" type="enum" ref="SubSamplingMode" desc="Horizontal subsampling mode"/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="getHorizontalSubsampling">
<desc>Gets the horizontal subsampling mode. For the range of supported modes please refer to the camera manual.</desc>
<sample for="lua">local value, default, supported = Image.Provider.RemoteCamera.IDSuEyeConfig.getHorizontalSubsampling(camCfg, "NO_SUBSAMPLING")</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.IDSuEyeConfig" desc="Instance of the configuration."/>
<return name="mode" type="enum" multiplicity="?" ref="SubSamplingMode" desc="Horizontal subsampling mode"/>
<return name="default" type="enum" multiplicity="?" ref="SubSamplingMode" desc="Default horizontal subsampling mode"/>
<return name="modes" type="enum" multiplicity="*" ref="SubSamplingMode" desc="Supported horizontal subsampling modes"/>
                            </function>
                        </serves>
                    </crown>
                    <crown name="V3SXX0Config">
                        <trait>released</trait>
                        <desc>Provides functionality to configure a Visionary-T camera. Call RemoteCamera.setConfig() to set this config.</desc>
                        <serves>
                            <function name="create">
<desc>Creates an instance of a V3SXX0Config.</desc>
<sample for="lua">camCfg = Image.Provider.RemoteCamera.V3SXX0Config.create()</sample>
<return name="config" type="object" alias="Image.Provider.RemoteCamera.V3SXX0Config" desc="Instance of the V3SXX0Config."/>
                            </function>
                            <function name="getCameraModel">
<desc>Get the current camera model.</desc>
<sample for="lua">cameraModel = Image.Provider.RemoteCamera.V3SXX0Config.getCameraModel(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.V3SXX0Config" desc="Instance of the configuration."/>
<return name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="Camera model instance."/>
                            </function>
                        </serves>
                    </crown>
                    <crown name="V3SXX2Config">
                        <trait>released</trait>
                        <desc>Provides functionality to configure a Visionary-S camera. Call RemoteCamera.setConfig() to set this config.</desc>
                        <serves>
                            <function name="create">
<desc>Creates an instance of a V3SXX2Config.</desc>
<sample for="lua">camCfg = Image.Provider.RemoteCamera.V3SXX2Config.create()</sample>
<return name="config" type="object" alias="Image.Provider.RemoteCamera.V3SXX2Config" desc="Instance of the V3SXX2Config."/>
                            </function>
                            <function name="getCameraModel">
<desc>Get the current camera model.</desc>
<sample for="lua">cameraModel = Image.Provider.RemoteCamera.V3SXX2Config.getCameraModel(camCfg)</sample>
<param name="config" type="object" alias="Image.Provider.RemoteCamera.V3SXX2Config" desc="Instance of the configuration."/>
<return name="cameraModel" type="object" alias="Image.Calibration.CameraModel" desc="Camera model instance."/>
                            </function>
                        </serves>
                    </crown>
                </crown>
                <crown name="Directory">
                    <trait>released</trait>
                    <desc>Image provider which provides images periodically from the filesystem. Images can be in format PNG or BMP.</desc>
                    <serves>
                        <event name="OnNewImage">
                            <desc>The image event which is thrown for every new image.</desc>
                            <param name="handle" type="handle" alias="Image.Provider.Directory" desc="Instance handle of this provider"/>
                            <param name="image" type="object" alias="Image" desc="The loaded image"/>
                            <param name="sensorData" type="object" alias="SensorData" desc="Supplementary data which belongs to the image"/>
                        </event>
                        <function name="create">
                            <desc>Creates an instance of the image directory provider, which provides images asynchronously from file-system.</desc>
                            <sample for="lua">dirProv = Image.Provider.Directory.create()</sample>
                            <return name="handle" type="handle" alias="Image.Provider.Directory" desc="Image provider exists as long as this handle exists."/>
                        </function>
                        <function name="setPath">
                            <desc>Sets the directory and file extension(s) for the image provider from which it reads images.</desc>
                            <sample for="lua">Image.Provider.Directory.setPath(dirProv, ImageInputPath)</sample>
                            <param name="handle" type="handle" alias="Image.Provider.Directory" desc="Instance handle of this provider"/>
                            <param name="path" type="string" desc="Path to the file-system"/>
                            <param name="fileextensions" type="string" multiplicity="?" desc="Supported file extensions (comma separated)."/>
                            <param name="recursive" type="bool" multiplicity="?" desc="An optional flag whether to run through subdriectories also."/>
                        </function>
                        <function name="setCycleTime">
                            <desc>Sets the pause between taking images in milli seconds.</desc>
                            <sample for="lua">Image.Provider.Directory.setCycleTime(handle, 500)</sample>
                            <param name="handle" type="handle" alias="Image.Provider.Directory" desc="Instance handle of this provider"/>
                            <param name="periodMs" type="int" desc="Period in [ms] between images."/>
                        </function>
                        <function name="setAutoDeleteActive">
                            <desc>Sets auto-delete active. This means the image is deleted from the directory after load. Default is false.</desc>
                            <sample for="lua">Image.Provider.Directory.setAutoDeleteActive(dirProv, true)</sample>
                            <param name="handle" type="handle" alias="Image.Provider.Directory" desc="Instance handle of this provider"/>
                            <param name="state" type="bool" desc="If true the image file will be deleted after being loaded."/>
                        </function>
                        <function name="setCyclicModeActive">
                            <desc>Sets cyclic-mode active. Default is true.</desc>
                            <sample for="lua">Image.Provider.Directory.setCyclicModeActive(dirProv, true)</sample>
                            <param name="handle" type="handle" alias="Image.Provider.Directory" desc="Instance handle of this provider"/>
                            <param name="state" type="bool" desc="If false driver stops taking images if end of directory is reached."/>
                        </function>
                        <function name="setImagePoolSizeMB">
                            <desc>Limits the number of mega bytes which can be acquired by capturing images and used at the same time. Default is 20.</desc>
                            <sample for="lua">Image.Provider.Directory.setImagePoolSizeMB(cam, 20)</sample>
                            <param name="handle" type="handle" alias="Image.Provider.Directory" desc="Instance handle of the provider."/>
                            <param name="size" type="int" desc="Size of the internal image pool in mega byte."/>
                        </function>
                        <function name="start">
                            <desc>Starts taking images.</desc>
                            <sample for="lua">local success = Image.Provider.Directory.start(dirProv)</sample>
                            <param name="handle" type="handle" alias="Image.Provider.Directory" desc="Instance handle of this provider"/>
                            <param name="burst" type="int" multiplicity="?" desc="Leave empty or '0' for continuous acquisition. &gt;0:=enable burst-mode with provided number of images."/>
                            <return name="success" type="bool" desc="Returns true if function call was successful, otherwise false"/>
                        </function>
                        <function name="stop">
                            <desc>Stops taking images.</desc>
                            <sample for="lua">local stopped = Image.Provider.Directory.stop(dirProv)</sample>
                            <param name="handle" type="handle" alias="Image.Provider.Directory" desc="Instance handle of this provider"/>
                            <return name="success" type="bool" desc="Returns true if function call was successful, otherwise false"/>
                        </function>
                        <function name="register">
                            <desc>This function is used to register for any event of the image provider. The event name is specified as parameter.</desc>
                            <sample for="lua">Image.Provider.Directory.register(dirProv, "OnNewImage", "handleNewImage")</sample>
                            <param name="handle" type="handle" alias="Image.Provider.Directory" desc="Instance handle of this provider"/>
                            <param name="eventname" type="string" desc="The event to register to"/>
                            <param name="callback" type="string" alias="function" desc="function name to call on the event"/>
                            <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                        </function>
                        <function name="deregister">
                            <desc>This function is used to deregister from any registered event of the handle.</desc>
                            <param name="handle" type="handle" alias="Image.Provider.Directory" desc="The instance handle to use"/>
                            <param name="eventname" type="string" desc="The event to deregister from"/>
                            <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                            <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                        </function>
                    </serves>
                </crown>
            </crown>
            <crown name="OCR">
                <trait>released</trait>
                <crown name="Halcon">
                    <trait>released</trait>
                    <serves>
                        <function name="findTextLineOrientation">
                            <desc>Finds the orientation of a text line in an image. The text line is assumed to be darker than the background</desc>
                            <sample for="lua">local orientationAngleRad = Image.OCR.Halcon.findTextLineOrientation(region, image, charHeightPix, orientationFromRad, orientationToRad)</sample>
                            <param name="region" type="const object" multiplicity="1" alias="Image.PixelRegion" desc="Input region where the text line is located"/>
                            <param name="image" type="const object" multiplicity="1" alias="Image" desc="Input sample"/>
                            <param name="charHeightPix" type="int" multiplicity="1" desc="Character height"/>
                            <param name="orientationFromRad" type="float" multiplicity="1" desc="Start of search interval"/>
                            <param name="orientationToRad" type="float" multiplicity="1" desc="End of search interval"/>
                            <return name="orientationAngleRad" type="float" desc="Orientation of text line in radians"/>
                        </function>
                        <function name="rotateImage">
                            <desc>Rotates an image.</desc>
                            <sample for="lua">local rotatedImage = Image.OCR.Halcon.rotateImage(image, phi)</sample>
                            <param name="image" type="const object" multiplicity="1" alias="Image" desc="Input image"/>
                            <param name="orientationAngleRad" type="float" multiplicity="1" desc="Orientation of text line in radians"/>
                            <return name="rotatedImage" type="object" alias="Image" desc="The rotated image"/>
                        </function>
                    </serves>
                    <crown name="ManualSegmenter">
                        <trait>released</trait>
                        <desc>Segments text in an image based on user input.</desc>
                        <enum name="ManualSegmentationParameters">
                            <item name="char_height" desc="Height of the characters in pixels. Refers to an uppercase character. List of values: integer or float value greater than or equal to 1. Default value: 30px">CHAR_HEIGHT</item>
                            <item name="char_width" desc="Width of the characters in pixels. Refers to an uppercase character. List of values: integer or float value greater than or equal to 1. Default value: 20px">CHAR_WIDTH</item>
                            <item name="stroke_width" desc="Stroke width of the characters in pixels. List of values: integer or float value greater than or equal to 0. Default value: 4.0px">STROKE_WIDTH</item>
                            <item name="base_line_tolerance" desc="Maximum base line deviation of the characters (in percent of 'char_height'). Default value: 0.15">BASE_LINE_TOLERANCE</item>
                            <item name="polarity" desc="'dark_on_light' if the text to be segmented is darker than its background, otherwise 'light_on_dark'. List of values: 'dark_on_light' or 'light_on_dark'. Default value: 'dark_on_light'">POLARITY</item>
                            <item name="uppercase_only" desc="'true' if the text to be segmented contains uppercase characters or numbers only, otherwise 'false'. Default value: 'false'">UPPERCASE_ONLY</item>
                            <item name="is_dotprint" desc="'true' if the text to be segmented is a dotprint, otherwise 'false'. Default value: 'false'">IS_DOTPRINT</item>
                            <item name="is_imprinted" desc="'true' if the text to be segmented suffers of local changes of polarity due to reflections, otherwise 'false'. Default value: 'false'">IS_IMPRINTED</item>
                            <item name="eliminate_horizontal_lines" desc="'true' if there are longer horizontal structures close to the text to be segmented, otherwise 'false'. Default value: 'false'">ELIMINATE_HORIZONTAL_LINES</item>
                            <item name="eliminate_border_blobs" desc="'true' if regions that are touching the border of the image domain should be discarded, otherwise 'false'. Default value: 'false'">ELIMINATE_BORDER_BLOBS</item>
                            <item name="max_line_num" desc="Maximum number of lines to be found. Zero or negative values indicate no limitation. Setting 'max_line_num' to a low value may strongly improve the runtime of findText. Default value: no limitation">MAX_LINE_NUM</item>
                            <item name="return_punctuation" desc="'true' if punctuation marks (e.g., dots or comma) should be added to the segmented characters. Default value: 'true'">RETURN_PUNCTUATION</item>
                            <item name="return_separators" desc="'true' if separators such as a minus or the equality sign should be added to the segmented characters. Default value: 'true'">RETURN_SEPARATORS</item>
                            <item name="add_fragments" desc="'true' if fragments, such as the dot on the 'i', should be added to the segmented characters. Be aware, that this can cause noise to be added to the segmented characters. Default value: 'true'">ADD_FRAGMENTS</item>
                            <item name="fragment_size_min" desc="minimum area of fragment regions that are added if 'add_fragments' is set to 'true'. List of values: integer value greater than or equal to 0. Default value: 1">FRAGMENT_SIZE_MIN</item>
                            <item name="text_line_structure" desc="To simplify the search for specific structures (e.g. dates or serial numbers) within the segmented text, it is possible to define text line structures. For each text line the distances between the characters are calculated, and based on these distances, the text line is divided into text blocks. Short characters such as '.', '_' and '-' are ignored in this process and treated as spaces. The text line structure is a string that contains the number of characters for every character block and spaces between these character blocks. For example, if the text to be found is a date with two characters for month, day, and year the structure would be '2 2 2'. If the year may consist of two or four characters, the structure would be '2 2 2-4', indicating that the last character block consists of two to four characters. It is possible to provide up to five structures to match by appending an index to the parameter name, e.g. 'text_line_structure_0', 'text_line_structure_1', etc.  If 'text_line_structure' is set to an empty string '', the text to be found may have any structure. Please observe, that every text line structure which is found, is saved as in the text result even if they overlap. Default value: ''">TEXT_LINE_STRUCTURE</item>
                        </enum>
                        <serves>
                            <function name="create">
<desc>Creates an instance of a OCR.Halcon.ManualSegmenter.</desc>
<sample for="lua">handle = Image.OCR.Halcon.ManualSegmenter.create()</sample>
<return name="handle" type="handle" alias="Image.OCR.Halcon.ManualSegmenter" desc="Instance handle of the ManualSegmenter."/>
                            </function>
                            <function name="setParameter">
<desc>Sets a parameter used when segmenting the image for text lines.</desc>
<sample for="lua">Image.OCR.Halcon.ManualSegmenter.setParameter(handle, paramName, paramValue)</sample>
<param name="handle" type="handle" alias="Image.OCR.Halcon.ManualSegmenter" desc="Instance handle of the configuration."/>
<param name="paramName" type="enum" multiplicity="1" ref="ManualSegmentationParameters" desc="Name of parameter."/>
<param name="paramValue" type="auto" multiplicity="1" desc="Flexible parameter to set a segmentation parameter. Could be a string, an integer value or a float value."/>
                            </function>
                            <function name="findText">
<desc>Segments an image into text lines and characters.</desc>
<sample for="lua">local textLines = Image.OCR.Halcon.ManualSegmenter.findText(handle, image)</sample>
<param name="handle" type="handle" alias="Image.OCR.Halcon.ManualSegmenter" desc="Instance handle of the configuration."/>
<param name="image" type="const object" multiplicity="1" alias="Image" desc="Input sample"/>
<param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. If supplied, the filter operation is only performed within the bounding box of is region. This can save a lot of computation time if the region is small."/>
<return name="textLines" type="object" multiplicity="?" alias="Image.OCR.Halcon.SegmenterResult" desc="Result with found text lines."/>
                            </function>
                        </serves>
                    </crown>
                    <crown name="AutoSegmenter">
                        <trait>released</trait>
                        <desc>Automatically segments text in an image.</desc>
                        <enum name="AutoSegmentationParameters">
                            <item name="min_contrast" desc="The minimal contrast the characters have to their surrounding background.List of values: integer or float value between 1 and 255 for byte images and between 1 and 65.535 for uint2 images. Default value: 15">MIN_CONTRAST</item>
                            <item name="polarity" desc="'dark_on_light' if the text to be segmented is darker than its background, 'light_on_dark' if the text to be segmented is lighter than its background, and 'both' if both kinds of text are to be segmented. List of values: 'dark_on_light', 'light_on_dark' or 'both'. Default value: 'both'">POLARITY</item>
                            <item name="min_char_height" desc="The minimal height of the characters in pixels. If text of arbitrary height is to be segmented, 'auto' may be passed. Note that 'min_char_height' refers to characters only. The height of punctuation marks or separators is not restricted by 'min_char_height'.List of values: integer or float value greater than or equal to 1. Default value: 'auto'">MIN_CHAR_HEIGHT</item>
                            <item name="max_char_height" desc="The maximal height of the characters in pixels. If text of arbitrary height is to be segmented, 'auto' may be passed. Note that 'max_char_height' refers to characters only. The height of punctuation marks or separators is not restricted by 'max_char_height'.List of values: integer or float value greater than or equal to 1. Default value: 'auto'">MAX_CHAR_HEIGHT</item>
                            <item name="min_char_width" desc="The minimal width of the characters in pixels. If text of arbitrary width is to be segmented, 'auto' may be passed. Note that 'min_char_width' refers to characters only. The width of punctuation marks or separators is not restricted by 'min_char_width'.List of values: integer or float value greater than or equal to 1. Default value: 'auto'">MIN_CHAR_WIDTH</item>
                            <item name="max_char_width" desc="The maximal width of the characters in pixels. If text of arbitrary width is to be segmented, 'auto' may be passed. Note that 'max_char_width' refers to characters only. The width of punctuation marks or separators is not restricted by 'max_char_width'.List of values: integer or float value greater than or equal to 1. Default value: 'auto'">MAX_CHAR_WIDTH</item>
                            <item name="min_stroke_width" desc="The minimal stroke width of the characters in pixels. If the minimal stroke width is to be estimated within the text segmentation process automatically, 'auto' may be passed. Note that 'min_stroke_width' refers to characters only. The stroke width of punctuation marks or separators is not restricted by 'min_stroke_width'.List of values: integer or float value greater than or equal to 1. Default value: 'auto'">MIN_STROKE_WIDTH</item>
                            <item name="max_stroke_width" desc="The maximal stroke width of the characters in pixels. If the maximal stroke width is to be estimated within the text segmentation process automatically, 'auto' may be passed. Note that 'max_stroke_width' refers to characters only. The stroke width of punctuation marks or separators is not restricted by 'max_stroke_width'.List of values: integer or float value greater than or equal to 1. Default value: 'auto'">MAX_STROKE_WIDTH</item>
                            <item name="eliminate_border_blobs" desc="'true' if regions that are touching the border of the image domain should be discarded, otherwise 'false'.List of values: 'true','false'. Default value: 'false'">ELIMINATE_BORDER_BLOBS</item>
                            <item name="return_punctuation" desc="'true' if small punctuation marks that lie close to the base line of the corresponding text line (e.g. dots or commas) are to be returned. 'false' if no such punctuations should be returned.List of values: 'true','false'. Default value: 'true'">RETURN_PUNCTUATION</item>
                            <item name="return_separators" desc="'true' if separators such as a minus or the equality sign should be returned as well. 'false' if no separators should be returned.List of values: 'true','false'. Default value: 'true'">RETURN_SEPARATORS</item>
                            <item name="add_fragments" desc="'true' if fragments, such as the dot on the 'i', should be added to the segmented characters, otherwise 'false'. Be aware, that this can cause noise to be added to the segmented characters.List of values: 'true','false'. Default value: 'true'">ADD_FRAGMENTS</item>
                            <item name="text_line_structure" desc="To simplify the search for specific structures (e.g. dates or serial numbers) within the segmented text, it is possible to define text line structures. For each text line the distances between the characters are calculated, and based on these distances, the text line is divided into text blocks. Short characters such as '.', '_' and '-' are ignored in this process and treated as spaces. Furthermore, it is possible to define user specific separators which are also ignored. See the description of 'text_line_separators' for details. The text line structure is a string that contains the number of characters for every character block and spaces between these character blocks. For example, if the text to be found is a date with two characters for month, day, and year the structure would be '2 2 2'. If the year may consist of two or four characters, the structure would be '2 2 2-4', indicating that the last character block consists of two to four characters. It is possible to provide up to five structures to match by appending an index to the parameter name, e.g. 'text_line_structure_0', 'text_line_structure_1', etc. If 'text_line_structure' is set to an empty string '', the text to be found may have any structure. Please observe, that every text line structure which is found, is saved as in the text result even if they overlap. If the whole text line containing the text line structure is to be returned instead, it is possible to set 'return_whole_line' accordingly. Default value: ''">TEXT_LINE_STRUCTURE</item>
                            <item name="text_line_separators" desc="A string containing the list of characters which are to be ignored in the process of finding text line structures, see 'text_line_structure' for further details. Please note, user specific separators need to be valid characters within the used OCR classifier. For example, if ':' and '\' are to be ignored, ':\\' should be passed. Please observe, that '\' escapes any special symbol to treat it as a literal, and hence '\\' needs to be passed to use '\' as a separator.List of values: '/', ':', ':\\', '\\/:', etc. Default value: ' '">TEXT_LINE_SEPARATORS</item>
                            <item name="return_whole_line" desc="'false' if only the segmented text line structures are to be returned as text lines. 'true' if each whole text line containing a text line structure is to be returned in text lines.List of values: 'true','false'. Default value: 'false'">RETURN_WHOLE_LINE</item>
                            <item name="mlp_classifier" desc="The pre-trained font classifier used within findText for text segmentation. Default value: 'Industrial_Rej.omc'">MLP_CLASSIFIER</item>
                        </enum>
                        <serves>
                            <function name="create">
<desc>Creates an instance of a OCR.Halcon.AutoSegmenter.</desc>
<sample for="lua">handle = Image.OCR.Halcon.AutoSegmenter.create()</sample>
<return name="handle" type="handle" alias="Image.OCR.Halcon.AutoSegmenter" desc="Instance handle of the AutoSegmenter."/>
                            </function>
                            <function name="setParameter">
<desc>Sets a parameter used to help/guide the automatic segmentation of the image into text lines.</desc>
<sample for="lua">Image.OCR.Halcon.AutoSegmenter.setParameter(handle, paramName, paramValue)</sample>
<param name="handle" type="handle" alias="Image.OCR.Halcon.AutoSegmenter" desc="Instance handle of the configuration."/>
<param name="paramName" type="enum" multiplicity="1" ref="AutoSegmentationParameters" desc="Name of parameter."/>
<param name="paramValue" type="auto" multiplicity="1" desc="Flexible parameter to set a segmentation parameter. Could be a string, an integer value or a float value."/>
                            </function>
                            <function name="findText">
<desc>Segments an image into text lines and characters.</desc>
<sample for="lua">local textLines = Image.OCR.Halcon.AutoSegmenter.findText(handle, image)</sample>
<param name="handle" type="handle" alias="Image.OCR.Halcon.AutoSegmenter" desc="Instance handle of the configuration."/>
<param name="image" type="const object" multiplicity="1" alias="Image" desc="Input sample"/>
<param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Optional region of interest. If supplied, the find text operation is only performed within the bounding box of is region. This can save a lot of computation time if the region is small."/>
<return name="textLines" type="object" multiplicity="?" alias="Image.OCR.Halcon.SegmenterResult" desc="Result with found text lines."/>
                            </function>
                        </serves>
                    </crown>
                    <crown name="SegmenterResult">
                        <trait>released</trait>
                        <desc>Segmentation result from either the ManualSegmenter or the AutoSegmenter. Contains all found text lines. Each text line is stored as a vector of PixelRegions.</desc>
                        <serves>
                            <function name="getTextLine">
<desc>Returns the text line with the given index.</desc>
<sample for="lua">textLine = Image.OCR.Halcon.SegmenterResult.getTextLine(result, index)</sample>
<param name="result" type="const object" alias="Image.OCR.Halcon.SegmenterResult" desc="The segmentation result to use."/>
<param name="index" type="int" multiplicity="1" desc="Index of the text line."/>
<return name="textLine" type="object" multiplicity="*" alias="Image.PixelRegion" desc="The text line as a vector of PixelRegions."/>
                            </function>
                            <function name="getNumberOfTextLines">
<desc>Returns the number of found text lines.</desc>
<sample for="lua">numTextLines = Image.OCR.Halcon.SegmenterResult.getNumberOfTextLines(result)</sample>
<param name="result" type="const object" alias="Image.OCR.Halcon.SegmenterResult" desc="The segmentation result to use."/>
<return name="numTextLines" type="int" multiplicity="1" desc="The number of text lines."/>
                            </function>
                        </serves>
                    </crown>
                    <crown name="FontClassifier">
                        <trait>released</trait>
                        <desc>Classifies text in an image using a pre-trained font classifier.</desc>
                        <enum name="PreTrainedFonts">
                            <item name="Document_0-9A-Z_NoRej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z">DOCUMENT_0_9A_Z_NOREJ</item>
                            <item name="Document_0-9A-Z_Rej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z">DOCUMENT_0_9A_Z_REJ</item>
                            <item name="Document_0-9_NoRej.omc" desc="Pre-trained font classifier for symbols: 0-9">DOCUMENT_0_9_NOREJ</item>
                            <item name="Document_0-9_Rej.omc" desc="Pre-trained font classifier for symbols: 0-9">DOCUMENT_0_9_REJ</item>
                            <item name="Document_A-Z+_NoRej.omc" desc="Pre-trained font classifier for symbols: A-Z, special characters. Available special characters: - = + &lt; &gt; . # $ % &amp; ( ) @ * e £ ¥">DOCUMENT_A_ZPLUS_NOREJ</item>
                            <item name="Document_A-Z+_Rej.omc" desc="Pre-trained font classifier for symbols: A-Z, special characters. Available special characters: - = + &lt; &gt; . # $ % &amp; ( ) @ * e £ ¥">DOCUMENT_A_ZPLUS_REJ</item>
                            <item name="Document_NoRej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z, a-z, special characters. Available special characters: - = + &lt; &gt; . # $ % &amp; ( ) @ * e £ ¥">DOCUMENT_NOREJ</item>
                            <item name="Document_Rej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z, a-z, special characters. Available special characters: - = + &lt; &gt; . # $ % &amp; ( ) @ * e £ ¥">DOCUMENT_REJ</item>
                            <item name="DotPrint.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z, special characters. Available special characters: - / . * :">DOTPRINT</item>
                            <item name="DotPrint_0-9+.omc" desc="Pre-trained font classifier for symbols: 0-9, special characters. Available special characters: - / . * :">DOTPRINT_0_9PLUS</item>
                            <item name="DotPrint_0-9+_NoRej.omc" desc="Pre-trained font classifier for symbols: 0-9, special characters. Available special characters: - / . * :">DOTPRINT_0_9PLUS_NOREJ</item>
                            <item name="DotPrint_0-9+_Rej.omc" desc="Pre-trained font classifier for symbols: 0-9, special characters. Available special characters: - / . * :">DOTPRINT_0_9PLUS_REJ</item>
                            <item name="DotPrint_0-9.omc" desc="Pre-trained font classifier for symbols: 0-9">DOTPRINT_0_9</item>
                            <item name="DotPrint_0-9A-Z.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z">DOTPRINT_0_9A_Z</item>
                            <item name="DotPrint_0-9A-Z_NoRej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z">DOTPRINT_0_9A_Z_NOREJ</item>
                            <item name="DotPrint_0-9A-Z_Rej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z">DOTPRINT_0_9A_Z_REJ</item>
                            <item name="DotPrint_0-9_NoRej.omc" desc="Pre-trained font classifier for symbols: 0-9">DOTPRINT_0_9_NOREJ</item>
                            <item name="DotPrint_0-9_Rej.omc" desc="Pre-trained font classifier for symbols: 0-9">DOTPRINT_0_9_REJ</item>
                            <item name="DotPrint_A-Z+.omc" desc="Pre-trained font classifier for symbols: A-Z, special characters. Available special characters: - / . * :">DOTPRINT_A_ZPLUS</item>
                            <item name="DotPrint_A-Z+_NoRej.omc" desc="Pre-trained font classifier for symbols: A-Z, special characters. Available special characters: - / . * :">DOTPRINT_A_ZPLUS_NOREJ</item>
                            <item name="DotPrint_A-Z+_Rej.omc" desc="Pre-trained font classifier for symbols: A-Z, special characters. Available special characters: - / . * :">DOTPRINT_A_ZPLUS_REJ</item>
                            <item name="DotPrint_NoRej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z, special characters. Available special characters: - / . * :">DOTPRINT_NOREJ</item>
                            <item name="DotPrint_Rej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z, special characters. Available special characters: - / . * :">DOTPRINT_REJ</item>
                            <item name="HandWritten_0-9.omc" desc="Pre-trained font classifier for symbols: 0-9">HANDWRITTEN_0_9</item>
                            <item name="HandWritten_0-9_NoRej.omc" desc="Pre-trained font classifier for symbols: 0-9">HANDWRITTEN_0_9_NOREJ</item>
                            <item name="HandWritten_0-9_Rej.omc" desc="Pre-trained font classifier for symbols: 0-9">HANDWRITTEN_0_9_REJ</item>
                            <item name="Industrial_0-9+_NoRej.omc" desc="Pre-trained font classifier for symbols: 0-9, special characters. Available special characters: - / + . $ % * e £ ¥">INDUSTRIAL_0_9PLUS_NOREJ</item>
                            <item name="Industrial_0-9+_Rej.omc" desc="Pre-trained font classifier for symbols: 0-9, special characters. Available special characters: - / + . $ % * e £ ¥">INDUSTRIAL_0_9PLUS_REJ</item>
                            <item name="Industrial_0-9A-Z_NoRej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z">INDUSTRIAL_0_9A_Z_NOREJ</item>
                            <item name="Industrial_0-9A-Z_Rej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z">INDUSTRIAL_0_9A_Z_REJ</item>
                            <item name="Industrial_0-9_NoRej.omc" desc="Pre-trained font classifier for symbols: 0-9">INDUSTRIAL_0_9_NOREJ</item>
                            <item name="Industrial_0-9_Rej.omc" desc="Pre-trained font classifier for symbols: 0-9">INDUSTRIAL_0_9_REJ</item>
                            <item name="Industrial_A-Z+_NoRej.omc" desc="Pre-trained font classifier for symbols: A-Z, special characters. Available special characters: - / + . $ % * e £ ¥">INDUSTRIAL_A_ZPLUS_NOREJ</item>
                            <item name="Industrial_A-Z+_Rej.omc" desc="Pre-trained font classifier for symbols: A-Z, special characters. Available special characters: - / + . $ % * e £ ¥">INDUSTRIAL_A_ZPLUS_REJ</item>
                            <item name="Industrial_NoRej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z, a-z, special characters. Available special characters: - / + . $ % * e £ ¥">INDUSTRIAL_NOREJ</item>
                            <item name="Industrial_Rej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z, a-z, special characters. Available special characters: - / + . $ % * e £ ¥">INDUSTRIAL_REJ</item>
                            <item name="MICR.omc" desc="Pre-trained font classifier.">MICR</item>
                            <item name="OCRA.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z, a-z, special characters. Available special characters: - ? ! / \ { } = + &lt; &gt; . # $ % &amp; ( ) @ * e £ ¥">OCRA</item>
                            <item name="OCRA_0-9.omc" desc="Pre-trained font classifier for symbols: 0-9">OCRA_0_9</item>
                            <item name="OCRA_0-9A-Z.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z">OCRA_0_9A_Z</item>
                            <item name="OCRA_0-9A-Z_NoRej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z">OCRA_0_9A_Z_NOREJ</item>
                            <item name="OCRA_0-9A-Z_Rej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z">OCRA_0_9A_Z_REJ</item>
                            <item name="OCRA_0-9_NoRej.omc" desc="Pre-trained font classifier for symbols: 0-9">OCRA_0_9_NOREJ</item>
                            <item name="OCRA_0-9_Rej.omc" desc="Pre-trained font classifier for symbols: 0-9">OCRA_0_9_REJ</item>
                            <item name="OCRA_A-Z+.omc" desc="Pre-trained font classifier for symbols: A-Z, special characters. Available special characters: - ? ! / \ { } = + &lt; &gt; . # $ % &amp; ( ) @ * e £ ¥">OCRA_A_ZPLUS</item>
                            <item name="OCRA_A-Z+_NoRej.omc" desc="Pre-trained font classifier for symbols: A-Z, special characters. Available special characters: - ? ! / \ { } = + &lt; &gt; . # $ % &amp; ( ) @ * e £ ¥">OCRA_A_ZPLUS_NOREJ</item>
                            <item name="OCRA_A-Z+_Rej.omc" desc="Pre-trained font classifier for symbols: A-Z, special characters. Available special characters: - ? ! / \ { } = + &lt; &gt; . # $ % &amp; ( ) @ * e £ ¥">OCRA_A_ZPLUS_REJ</item>
                            <item name="OCRA_NoRej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z, a-z, special characters. Available special characters: - ? ! / \ { } = + &lt; &gt; . # $ % &amp; ( ) @ * e £ ¥">OCRA_NOREJ</item>
                            <item name="OCRA_Rej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z, a-z, special characters. Available special characters: - ? ! / \ { } = + &lt; &gt; . # $ % &amp; ( ) @ * e £ ¥">OCRA_REJ</item>
                            <item name="OCRB.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z, a-z, special characters. Available special characters: - ? ! / \ { } = + &lt; &gt; . # $ % &amp; ( ) @ * e £ ¥">OCRB</item>
                            <item name="OCRB_0-9.omc" desc="Pre-trained font classifier for symbols: 0-9">OCRB_0_9</item>
                            <item name="OCRB_0-9A-Z.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z">OCRB_0_9A_Z</item>
                            <item name="OCRB_0-9A-Z_NoRej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z">OCRB_0_9A_Z_NOREJ</item>
                            <item name="OCRB_0-9A-Z_Rej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z">OCRB_0_9A_Z_REJ</item>
                            <item name="OCRB_0-9_NoRej.omc" desc="Pre-trained font classifier for symbols: 0-9">OCRB_0_9_NOREJ</item>
                            <item name="OCRB_0-9_Rej.omc" desc="Pre-trained font classifier for symbols: 0-9">OCRB_0_9_REJ</item>
                            <item name="OCRB_A-Z+.omc" desc="Pre-trained font classifier for symbols: A-Z, special characters. Available special characters: - ? ! / \ { } = + &lt; &gt; . # $ % &amp; ( ) @ * e £ ¥">OCRB_A_ZPLUS</item>
                            <item name="OCRB_A-Z+_NoRej.omc" desc="Pre-trained font classifier for symbols: A-Z, special characters. Available special characters: - ? ! / \ { } = + &lt; &gt; . # $ % &amp; ( ) @ * e £ ¥">OCRB_A_ZPLUS_NOREJ</item>
                            <item name="OCRB_A-Z+_Rej.omc" desc="Pre-trained font classifier for symbols: A-Z, special characters. Available special characters: - ? ! / \ { } = + &lt; &gt; . # $ % &amp; ( ) @ * e £ ¥">OCRB_A_ZPLUS_REJ</item>
                            <item name="OCRB_NoRej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z, a-z, special characters. Available special characters: - ? ! / \ { } = + &lt; &gt; . # $ % &amp; ( ) @ * e £ ¥">OCRB_NOREJ</item>
                            <item name="OCRB_passport.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z, + and &lt;">OCRB_PASSPORT</item>
                            <item name="OCRB_passport_NoRej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z, + and &lt;">OCRB_PASSPORT_NOREJ</item>
                            <item name="OCRB_passport_Rej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z, + and &lt;">OCRB_PASSPORT_REJ</item>
                            <item name="OCRB_Rej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z, a-z, special characters. Available special characters: - ? ! / \ { } = + &lt; &gt; . # $ % &amp; ( ) @ * e £ ¥">OCRB_REJ</item>
                            <item name="Pharma.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z, special characters. Available special characters: - / . ( ) :">PHARMA</item>
                            <item name="Pharma_0-9+.omc" desc="Pre-trained font classifier for symbols: 0-9, special characters. Available special characters: - / . ( ) :">PHARMA_0_9PLUS</item>
                            <item name="Pharma_0-9+_NoRej.omc" desc="Pre-trained font classifier for symbols: 0-9, special characters. Available special characters: - / . ( ) :">PHARMA_0_9PLUS_NOREJ</item>
                            <item name="Pharma_0-9+_Rej.omc" desc="Pre-trained font classifier for symbols: 0-9, special characters. Available special characters: - / . ( ) :">PHARMA_0_9PLUS_REJ</item>
                            <item name="Pharma_0-9.omc" desc="Pre-trained font classifier for symbols: 0-9">PHARMA_0_9</item>
                            <item name="Pharma_0-9A-Z.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z">PHARMA_0_9A_Z</item>
                            <item name="Pharma_0-9A-Z_NoRej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z">PHARMA_0_9A_Z_NOREJ</item>
                            <item name="Pharma_0-9A-Z_Rej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z">PHARMA_0_9A_Z_REJ</item>
                            <item name="Pharma_0-9_NoRej.omc" desc="Pre-trained font classifier for symbols: 0-9">PHARMA_0_9_NOREJ</item>
                            <item name="Pharma_0-9_Rej.omc" desc="Pre-trained font classifier for symbols: 0-9">PHARMA_0_9_REJ</item>
                            <item name="Pharma_NoRej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z, special characters. Available special characters: - / . ( ) :">PHARMA_NOREJ</item>
                            <item name="Pharma_Rej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z, special characters. Available special characters: - / . ( ) :">PHARMA_REJ</item>
                            <item name="SEMI.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z, special characters. Available special characters: - .">SEMI</item>
                            <item name="SEMI_NoRej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z, special characters. Available special characters: - .">SEMI_NOREJ</item>
                            <item name="SEMI_Rej.omc" desc="Pre-trained font classifier for symbols: 0-9, A-Z, special characters. Available special characters: - .">SEMI_REJ</item>
                            <item name="Universal_0-9_NoRej.occ" desc="Pre-trained font classifier for symbols: 0-9">UNIVERSAL_0_9_NOREJ</item>
                            <item name="Universal_0-9_Rej.occ" desc="Pre-trained font classifier for symbols: 0-9">UNIVERSAL_0_9_REJ</item>
                            <item name="Universal_0-9+_NoRej.occ" desc="Pre-trained font classifier for symbols: 0-9, special characters. Available special characters: - / = + : &lt; &gt; . # $ % &amp; ( ) @ * e £ ¥">UNIVERSAL_0_9PLUS_NOREJ</item>
                            <item name="Universal_0-9+_Rej.occ" desc="Pre-trained font classifier for symbols: 0-9, special characters. Available special characters: - / = + : &lt; &gt; . # $ % &amp; ( ) @ * e £ ¥">UNIVERSAL_0_9PLUS_REJ</item>
                            <item name="Universal_0-9A-Z_NoRej.occ" desc="Pre-trained font classifier for symbols: 0-9, A-Z">UNIVERSAL_0_9A_Z_NOREJ</item>
                            <item name="Universal_0-9A-Z_Rej.occ" desc="Pre-trained font classifier for symbols: 0-9, A-Z">UNIVERSAL_0_9A_Z_REJ</item>
                            <item name="Universal_0-9A-Z+_NoRej.occ" desc="Pre-trained font classifier for symbols: 0-9, A-Z, special characters. Available special characters: - / = + : &lt; &gt; . # $ % &amp; ( ) @ * e £ ¥">UNIVERSAL_0_9A_ZPLUS_NOREJ</item>
                            <item name="Universal_0-9A-Z+_Rej.occ" desc="Pre-trained font classifier for symbols: 0-9, A-Z, special characters. Available special characters: - / = + : &lt; &gt; . # $ % &amp; ( ) @ * e £ ¥">UNIVERSAL_0_9A_ZPLUS_REJ</item>
                            <item name="Universal_A-Z+_NoRej.occ" desc="Pre-trained font classifier for symbols: A-Z, special characters. Available special characters: - / = + : &lt; &gt; . # $ % &amp; ( ) @ * e £ ¥">UNIVERSAL_A_ZPLUS_NOREJ</item>
                            <item name="Universal_A-Z+_Rej.occ" desc="Pre-trained font classifier for symbols: A-Z, special characters. Available special characters: - / = + : &lt; &gt; . # $ % &amp; ( ) @ * e £ ¥">UNIVERSAL_A_ZPLUS_REJ</item>
                            <item name="Universal_NoRej.occ" desc="Pre-trained font classifier for symbols: 0-9, A-Z, a-z, special characters. Available special characters: - / = + : &lt; &gt; . # $ % &amp; ( ) @ * e £ ¥">UNIVERSAL_NOREJ</item>
                            <item name="Universal_Rej.occ" desc="Pre-trained font classifier for symbols: 0-9, A-Z, a-z, special characters. Available special characters: - / = + : &lt; &gt; . # $ % &amp; ( ) @ * e £ ¥">UNIVERSAL_REJ</item>
                        </enum>
                        <serves>
                            <function name="create">
<desc>Creates an instance of a OCR.Halcon.FontClassifier</desc>
<sample for="lua">handle = Image.OCR.Halcon.FontClassifier.create()</sample>
<return name="handle" type="handle" alias="Image.OCR.Halcon.FontClassifier" desc="Instance handle of the FontClassifier."/>
                            </function>
                            <function name="setFont">
<desc>Set which pre-trained font classifier to used. Font names ending with _Rej have a rejection class. With fonts that provide a rejection class, it is possible to distinguish characters from background clutter. Fonts with a rejection class return the ASCII Code 26, which is SUB (substitute) if no letter was found.</desc>
<sample for="lua">Image.OCR.Halcon.FontClassifier.setFont(handle, mode, fontName)</sample>
<param name="handle" type="handle" alias="Image.OCR.Halcon.FontClassifier" desc="Instance handle of the configuration."/>
<param name="fontName" type="enum" multiplicity="1" ref="PreTrainedFonts" desc="Name of pre-trained font. Default value: 'INDUSTRIAL_REJ'"/>
                            </function>
                            <function name="classifyCharacters">
<desc>Finds characters in one text line. The text line must first be segmented into individual characters and supplied as a vector of pixelregions.</desc>
<sample for="lua">local characters, confidence, regExpScore = Image.OCR.Halcon.FontClassifier.classifyCharacters(handle, textline, image, expression)</sample>
<param name="handle" type="handle" alias="Image.OCR.Halcon.FontClassifier" desc="Instance handle of the configuration."/>
<param name="textline" type="const object" multiplicity="+" alias="Image.PixelRegion" desc="Array of pixel regions each containing a text character"/>
<param name="image" type="const object" multiplicity="1" alias="Image" desc="Image with text"/>
<param name="expression" type="string" multiplicity="?" desc="Regular expression (Perl Compatible Regular Expressions) defining the allowed set of characters"/>
<return name="characters" type="string" multiplicity="1" desc="Classified characters. If the used fonts has a rejection class (name ends with _REJ) the ASCII code \x1A is returned whenever a character can not be classified"/>
<return name="confidence" type="float" multiplicity="+" desc="The confidence for each found character"/>
<return name="regExpScore" type="float" multiplicity="1" desc="The score for how well the found characters match the regular expression. Set to 1.0 if no expression is used."/>
                            </function>
                        </serves>
                    </crown>
                </crown>
            </crown>
            <crown name="Arrangement">
                <trait>hidden</trait>
                <desc>Functions for creating regular arrangements of shapes. Useful for edge fitting, contour analysis etc.</desc>
                <serves>
                    <function name="coverRectangleParallel">
                        <desc>Creates a set of parallel line segments covering the input rectangle</desc>
                        <sample for="lua">lineSegments = Image.Arrangement.coverRectangleParallel(rect, lineCount)</sample>
                        <param name="rect" type="object" alias="Shape" desc="Rectangle to cover with line segments"/>
                        <param name="lineCount" type="int" desc="Number of lines"/>
                        <return name="lineSegments" type="object" multiplicity="*" alias="Shape" desc="List of created line segments"/>
                    </function>
                    <function name="coverPixelRegionParallel">
                        <desc>Creates a set of parallel line segments covering the input pixel region</desc>
                        <sample for="lua">lineSegments = Image.Arrangement.coverPixelRegionParallel(region, directionRad, lineCount)</sample>
                        <param name="region" type="object" alias="Image.PixelRegion" desc="PixelRegion to cover with line segments"/>
                        <param name="directionRad" type="float" desc="Line direction in radians"/>
                        <param name="lineCount" type="int" desc="Number of lines"/>
                        <return name="lineSegments" type="object" multiplicity="*" alias="Shape" desc="List of created line segments"/>
                    </function>
                </serves>
            </crown>
            <crown name="BackgroundModel">
                <trait>released</trait>
                <keywords>foreground, background, segmentation, detection, subtraction, separation, surveillance, presence, mean, average, my, mu, variance, standard deviation, sigma, mixture, gaussian, anomaly</keywords>
                <links>Image.threshold, Image.thresholdPlane, Image.thresholdCompare, Image.add, Image.divide, Image.getMean, Image.PixelRegion.getStatistics</links>
                <desc>Functions for pixelwise modeling the background values and normal variations in an image. A pixelwise statistical model of the background, e.g., average and standard deviation variations in each pixel, is estimated based on a series of training images. Live images can then be compared to the model to find outliers, typically caused by new foreground objects that were not present in the background training images. The following two models are supported:

- Average model: The background model consists of the pixelwise average over all added training images.
- Gaussian model: The background model consists of the pixelwise average and variance over all added training images.

After creation of a BackgroundModel object, the model is built up incrementally by repeatedly adding background images to it using the BackgroundModel.add() function. To compare a new image with the built up model the BackgroundModel.compare() function is used.

To use the BackgroundModel for anomaly detection purposes, it is important that the images are pre-aligned so that the object-of-interest is in the same position in all images. This can for example be achieved using the EdgeMatcher or PointMatcher algorithms.

All pixel types (uint8, uint16, float32, etc) except color RGB are supported.

Image world coordinate system handling:
The pixel variations are modeled in world coordinates using the z-pixelsize and z-origin. This is mainly relevant for range/heightmap/depthmap images.

Missing data handling:
All models automatically handle missing data: Missing data pixels are not used to update the model and will not show up as foreground after a call to Image.BackgroundModel.compare.</desc>
                <enum name="CompareDirection">
                    <item name="BRIGHTER" desc="Compare will return pixels that are brighter than the model.">BRIGHTER</item>
                    <item name="DARKER" desc="Compare will return pixels that are darker than the model.">DARKER</item>
                    <item name="ALL" desc="Compare will return all pixels that deviate from the model.">ALL</item>
                </enum>
                <serves>
                    <function name="createAverage">
                        <desc>Construct an empty background model of Average type. This model is based on calculating the average value in every pixel:

average = (images[1] + images[2] + ...) / #images

Optionally there is a lineMode parameter to calculate the average over the entire columns in the training images, creating a 1-dimensional model. This mode is suited for line-scanning camera devices. The Average model will never forget added images and should be built up using training images with representative of background only.</desc>
                        <sample for="lua">bgm = Image.BackgroundModel.createAverage()</sample>
                        <param name="lineMode" type="bool" multiplicity="?" desc="Select if input images are from a line scan camera or standard area sensor. Default is false."/>
                        <return name="bgm" type="object" alias="Image.BackgroundModel" desc="The created background model."/>
                    </function>
                    <function name="createGaussian">
                        <desc>Construct an empty background model of Gaussian type. This model is based on calculating the average value and variance in every pixel
average = (images[1] + images[2] + ...) / #images
var = ((images[1] - average)^2 + (images[2] - average)^2 + ...) / (#images - 1)

Optionally there is a lineMode parameter to calculate the average and variance over the entire columns in the training images, creating a 1-dimensional model. This mode is suited for line-scanning camera devices. The Average model will never forget added images and should be built up using training images with representative of background only.</desc>
                        <sample for="lua">bgm = Image.BackgroundModel.createGaussian()</sample>
                        <param name="lineMode" type="bool" multiplicity="?" desc="Select if input images are from a line scan camera or standard area sensor. Default is false."/>
                        <return name="bgm" type="object" alias="Image.BackgroundModel" desc="The created background model."/>
                    </function>
                    <function name="createRunningGaussian">
                        <desc>Construct an empty background model of RunningGaussian type. This model is calculating a running average and a running variance in each pixel

average1 = images[1]
var1 = initialSigma, or local estimate in a 3x3 region around each pixel in images[1]

averageN = (1 - learningRate) * averageN-1 + learningRate * image[N]
varN = (1 - learningRate) * varN-1 + learningRate * (image[N] - averageN)^2

The RunningGaussian model is updated incrementally and should generally be allowed to adopt to changing conditions by calling Image.BackgroundModel.add() continuously.

Optionally there is a lineMode parameter to calculate the average and variance over the entire columns in the training images, creating a 1-dimensional model. This mode is suited for line-scanning camera devices.

For missing data input the model points are reset using the last added image if they have not been observed for more than 1/learningRate images and are now observed again.</desc>
                        <sample for="lua">bgm = Image.BackgroundModel.createRunningGaussian(0.01)</sample>
                        <param name="lineMode" type="bool" multiplicity="?" desc="Select if input images are from a line scan camera or standard area sensor. Default is false."/>
                        <param name="learningRate" type="float" multiplicity="?" desc="Selects how fast the model is updated and old images forgotten. Setting the learning rate to 0.1 will make a weighted update of the current model and a new image, using 90% of the current model and 10% with new values from the the image. Default is 0.01."/>
                        <param name="memory" type="int" multiplicity="?" desc="The number of observations as value can be missing data before being reinitialized. Default is 1/learningRate."/>
                        <param name="initialSigma" type="float" multiplicity="?" desc="The initial standard deviation expected in the image. If set to a negative value a small neighborhood in the first image is used to estimate the standard deviation. Default is to use a local estimate around each pixel."/>
                        <return name="bgm" type="object" alias="Image.BackgroundModel" desc="The created background model."/>
                    </function>
                    <function name="setRegionOfInterest">
                        <desc>Optional function to configure a pre-defined region in the input images in which the model is built. Unless set with this function, a model is made for the entire image.
This can be used to improve performance in cases where only a part of the image needs to be modeled. For pixels outside the region of interest the model will remain uninitialized.

The add() and compare() functions also allow a region input per image. An intersection with the region set in this function will then be used.</desc>
                        <sample for="lua">Image.BackgroundModel.setRegionOfInterest(bgm, roi)</sample>
                        <param name="bgm" type="object" alias="Image.BackgroundModel" desc="The background model to update the region for."/>
                        <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="The region in which to compute and evaluate the model. Unless set a model is estimated for all pixels in the entire image."/>
                        <return name="success" type="bool" desc="True if the region could be set."/>
                    </function>
                    <function name="setLearningRate">
                        <desc>Update the learning rate of a RunningGaussian model. This affects how quickly a model pixel will be updated to match new data. Setting the learning rate to 0.1 will make a weighted update of the current model and a new image, using 90% of the current model and 10% with new values from the the image.</desc>
                        <sample for="lua">Image.BackgroundModel.setLearningRate(bgm, learningRate)</sample>
                        <param name="bgm" type="object" alias="Image.BackgroundModel" desc="The background model to update the learning rate for."/>
                        <param name="learningRate" type="float" desc="The new learning rate to use. Default is 0.01."/>
                        <return name="success" type="bool" desc="True if the rate could be set."/>
                    </function>
                    <function name="setMemoryLength">
                        <desc>Update the memory of a RunningGaussian model. This affects how quickly a model pixel will be considered old. Setting the memory to 10 will make a point that is not touched in 10 calls to add() marked as old.
An old point is reset to the first valid pixel in an add() call and thus does not propagate old knowledge that is likely to be outdated.
An old point is treated specially in compare() calls and can be configured to either never or always be treated as foreground using the CompareDirection enum.</desc>
                        <sample for="lua">Image.BackgroundModel.setMemoryLength(bgm, memory)</sample>
                        <param name="bgm" type="object" alias="Image.BackgroundModel" desc="The background model to update the memory for."/>
                        <param name="memory" type="int" desc="The number of observations as value can be missing before being reinitialized. Defaults to 1/learningRate if zero or negative."/>
                        <return name="success" type="bool" desc="True if the memory could be set."/>
                    </function>
                    <function name="add">
                        <desc>Add an image to the model to teach it the background of the scene, the chosen model will be incrementally updated with the data in the supplied image.
The model is built by repeatedly adding images, the more images added the more accurate the model becomes. All images added must have the same size. If lineMode has been set to true, only the image width needs to be the same but the heights of the background images can vary.

If a region input is provided and a region was set by Image.BackgroundModel.setRegionOfInterest the intersection of these regions is used to update the model. If Image.BackgroundModel.setRegionOfInterest was never used the input region is used as is.

All pixel types (uint8, uint16, float32, etc.) except color RGB are supported.</desc>
                        <sample for="lua">local success = Image.BackgroundModel.add(bgm, image)</sample>
                        <param name="bgm" type="object" alias="Image.BackgroundModel" desc="The background model to use."/>
                        <param name="image" type="const object" alias="Image" desc="Background sample image."/>
                        <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="An optional region in which to update the model."/>
                        <return name="success" type="bool" desc="True if the image could be added."/>
                    </function>
                    <function name="compare">
                        <links>Image.threshold, Image.thresholdPlane, Image.thresholdCompare</links>
                        <desc>Compare a new image to the current background model to classify pixels as background or foreground. It is possible to get either ALL, BRIGHTER or DARKER pixels relative to the model. The comparison is based on the deviation d between the image pixel value I and the model average value M for the same pixel: d = I - M

The Average model uses a parameter averageThreshold and the following conditions for classifying pixels as background or foreground:
ALL: Foreground if |d| greater than averageThreshold
BRIGHTER: Foreground if d greater than averageThreshold
DARKER:  Foreground  if d lesser than -averageThreshold

The Gaussian model additionally applies the model standard deviation value S for the comparison. Specifically it puts a threshold on the normalized deviation d/S, i.e., the number of standard deviations the observed pixel value I is from the model average M:
ALL: Foreground if |d/S| greater than normalizedThreshold
BRIGHTER: Foreground if d/S greater than normalizedThreshold
DARKER: Foreground  if d/S lesser than -normalizedThreshold

Note that for a pixel to be classified as foreground by in the Gaussian model, both the check on d and d/S must be true. Using both checks captures cases when the standard deviation S has been estimated to a very low value, which can artificially make d/S very big. Including the direct threshold on the difference d only can suppress such cases from being classified as foreground. When tuning the parameters, it can be beneficial to set averageThreshold to 0 which functionally disables this check. The normalizedThreshold can then first be tuned, typically to a value around 2.0-4.0. If needed the averageThreshold can then be raised if necessary to regularize the classification result.

If a region input is provided and a region was set by Image.BackgroundModel.setRegionOfInterest the intersection of these regions is used. If Image.BackgroundModel.setRegionOfInterest was never used the input region is used as is.</desc>
                        <sample for="lua">local foregroundRegion = Image.BackgroundModel.compare(bgm, image, "ALL", roi)</sample>
                        <param name="bgm" type="object" alias="Image.BackgroundModel" desc="The background model to use."/>
                        <param name="image" type="const object" alias="Image" desc="The image to compare the model to."/>
                        <param name="direction" type="enum" multiplicity="?" ref="Image.BackgroundModel.CompareDirection" desc="Select the comparison direction to detect foreground (ALL, DARKER, BRIGHTER). Default is ALL."/>
                        <param name="averageThreshold" type="float" multiplicity="?" desc="Required deviation from the to background average for a pixel to be classified as foreground, see main function description. Default is 0.0."/>
                        <param name="normalizedThreshold" type="float" multiplicity="?" desc="Required deviation in terms of number of standard deviations for a pixel to be classified as foreground, see main function description. A higher value gives a less sensitive background model. Default is 2.5."/>
                        <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="An optional PixelRegion region in which to evaluate the model."/>
                        <param name="includeModelMissing" type="bool" multiplicity="?" desc="Select if pixels over an invalid model point should be included in the foregroundRegion. Default is true."/>
                        <return name="foregroundRegion" type="object" multiplicity="?" alias="Image.PixelRegion" desc="A pixel region containing foreground pixels."/>
                    </function>
                    <function name="reset">
                        <desc>Clear a model. This can be useful to change the image resolution or to restart the accumulators in a model. If a region was set using setRegionOfInterest() this is also reset and must be set again.</desc>
                        <sample for="lua">local success = Image.BackgroundModel.reset(bgm)</sample>
                        <param name="bgm" type="object" alias="Image.BackgroundModel" desc="The background model to reset."/>
                        <return name="success" type="bool" desc="True if the model could be reset."/>
                    </function>
                    <function name="getModelImages">
                        <desc>Return a list of model images produced within the BackgroundModel object. For the Average model the returned image contains the per-pixel average of the added training images. The Gaussian model additionally returns an image of the per-pixel variance. The final image is a pixelwise observation count. For RunningGaussian this is the remaining memory per pixel. For other methods it's simply the number of observations recorded. If the lineMode parameter has been set the returned images have a height of 1.</desc>
                        <sample for="lua">local images = Image.BackgroundModel.getModelImages(bgm)</sample>
                        <param name="bgm" type="object" alias="Image.BackgroundModel" desc="The background model instance."/>
                        <return name="images" type="object" multiplicity="[?*]" alias="Image" desc="The background model represented as float32 images. If unavailable nil is returned."/>
                    </function>
                    <function name="toString">
                        <desc>Get a textual description of the background model instance.</desc>
                        <sample for="lua">local str = Image.BackgroundModel.toString(bgm)</sample>
                        <param name="bgm" type="const object" alias="Image.BackgroundModel" desc="An background model object."/>
                        <return name="str" type="string" desc="A string representation of the model."/>
                    </function>
                    <function name="isEmpty">
                        <desc>Checks if a background model is empty or initialized by some data.</desc>
                        <sample for="lua">local isEmpty = Image.BackgroundModel.isEmpty(bgm)</sample>
                        <param name="bgm" type="const object" alias="Image.BackgroundModel" desc="An background model object."/>
                        <return name="isEmpty" type="bool" desc="True if the model is empty."/>
                    </function>
                    <function name="getImageCount">
                        <desc>Returns the total number of images accumulated in the background model when operating in area mode.
When lineMode is set to true in the model creation the count is instead the number of accumulated lines.</desc>
                        <sample for="lua">local count = Image.BackgroundModel.getImageCount(bgm)</sample>
                        <param name="bgm" type="const object" alias="Image.BackgroundModel" desc="An background model object."/>
                        <return name="count" type="int" desc="The number of added images."/>
                    </function>
                </serves>
            </crown>
            <crown name="Matching">
                <trait>released</trait>
                <desc>Functions for matching and locating objects and patterns in images based on different object models, including edge-based models, interest point models and pixel pattern models.</desc>
                <enum name="EdgeMatcherProcessingUnit" trait="released">
                    <item name="CPU" desc="Calculations will be done on the CPU.">CPU</item>
                    <item name="FPGA" desc="The FPGA will be used for hardware acceleration.">FPGA</item>
                </enum>
                <enum name="EdgeMatcherSymmetryMode" trait="hidden">
                    <item name="MODULO_360" desc="The default behavior. Use this if the matched object is asymetric and has one clearly defined orientation.">MODULO_360</item>
                    <item name="MODULO_180" desc="If the object is self similar across one dimenstion. Setting this option could improve robustness.">MODULO_180</item>
                    <item name="MODULO_90" desc="If the object is self similar across two dimensions. Setting this option could improve robustness.">MODULO_90</item>
                </enum>
                <enum name="BackgroundClutterLevel" trait="released">
                    <item name="low" desc="Very few edges not belonging to the object.">LOW</item>
                    <item name="medium" desc="Some edges in the background not belonging to the object.">MEDIUM</item>
                    <item name="high" desc="Many edges in the background not belonging to the object.">HIGH</item>
                </enum>
                <crown name="EdgeMatcher">
                    <trait>released</trait>
                    <keywords>locator, object, matching, find, shape, contour, pattern</keywords>
                    <links>Image.Matching.PointMatcher, Image.Matching.EdgeMatcher3D, Image.Matching.PatternMatcher, Image.Fixture</links>
                    <desc>Object matching of objects which are well defined by clean edges/contours in a 2D image. An alternative to the EdgeMatcher is the PointMatcher for objects whose appearance is rather described by a texture pattern. Teach an object model from a reference image and call match to find the location of the same object in a new image. The EdgeMatcher searches for translation, rotation and scale (range 80% - 120%) of objects. Results are given as pose transforms which describe how the object model is transformed to matched positions in the new image. Each match gets a score between 0.0 and 1.0 where 1.0 means a perfect match. The EdgeMatcher is often used together with the Image.Fixture object that facilitates local coordinate transforms based on the result of the EdgeMatcher.

The most important parameters for the EdgeMatcher are the following:

- Edge threshold: Make sure to select an edge strength threshold that includes the edges of the reference object but excludes clutter edges in the background. Use the getModelContours() function to graphically verify the object model obtained.

- Background clutter: If the images contain patterns and structures other than the object of interest, use the HIGH setting in setBackgroundClutter() which is the default. If the object is on a clean background one can gain speed by setting the background clutter flag to MEDIUM or LOW. There is an interaction with the background clutter setting and the downsample factor parameter below though: It can be possible to run with higher downsample factors using the HIGH background clutter and thus gain higher speed compared to runnning a MEDIUM background clutter and a lower downsample factor.

- Downsample factor: The EdgeMatcher works internally on downsampled images for computational performance reasons. The downsample factor is the most important parameter for the speed versus robustness trade-off. An initial choice of downsample factor could be one that generates a downsampled image of size about 200 x 200. For example, if images of size 1024 x 1024 are used, one could start experimenting with a downsample factor of 5. The downsample factor has an effect on the robustness of the algorithm (finding the correct match) but not on the position accuracy.

- Rotation range: The rotation range parameter should be selected to be as narrow as possible both for computational reasons and for robustness reasons. If it is known that the target object only can appear within a certain rotation interval relative to the teach pose, make sure to reduce the rotation range search parameter.

- Scale range: As with the rotation range parameter, set the scale range as narrowly as possible for computational and performance reasons.


Pixel types:
The EdgeMatcher accepts uint8 and uint16 pixel type images.

Hardware acceleration:
Some devices have FPGA-support for the EdgeMatcher. It is possible to switch between the CPU and FPGA versions using the setProcessingUnit()-function. If there is FPGA support it is set as default, but note that the FPGA is not able to support all configurations, mainly there is a lower restriction on the downsample factor for memory limitation reasons.
There is typically only one instance of the FPGA calculation unit in a device. If many EdgeMatcher instances are created running in parallel, all using the FPGA acceleration, they may try to access the FPGA resource at the same time. The behavior is then that a match call will wait until the FPGA resource is available again.

Image world coordinate system handling:
The image (x,y)-pixelsize and origin are considered within the EdgeMatcher, all calculations are made in the image world coordinate system. The output pose transforms are also expressed in the image world coordinate system.

Missing data handling:
The EdgeMatcher does not accept missing data images, turn off the missing data flag to use it anyway or use the EdgeMatcher3D.

Object model:
An object representation of the contours in the teach reference image is generated in a teach call. The center of the model, and also the rotation center, is the center of the teach region.

Saving and loading a configuration:
A trained EdgeMatcher instance can be saved and loaded (serialized/deserialized) using the Object.save() and Object.load() functions.</desc>
                    <serves>
                        <function name="create">
                            <desc>Creates a new edge matcher for object localization in 2D intensity images.</desc>
                            <sample for="lua">locator = Image.Matching.EdgeMatcher.create()</sample>
                            <return name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The new EdgeMatcher instance."/>
                        </function>
                        <function name="setProcessingUnit">
                            <trait>released</trait>
                            <desc>Sets processing unit for the calculations. Some devices support FPGA acceleration of the EdgeMatcher. If this is the case the FPGA acceleration is set by default when the EdgeMatcher object is created. This parameter can be updated in a teached matcher without re-teaching.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher.setProcessingUnit(matcher, "FPGA")</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <param name="processingUnit" type="enum" ref="EdgeMatcherProcessingUnit" desc="Which type of processing unit to use. If there is FPGA support in the device it will be used as default, otherwise CPU."/>
                            <return name="success" type="bool" desc="True if processing unit choice was successfully set. False if the processing unit or configuration is not supported."/>
                        </function>
                        <function name="isBusy">
                            <trait>hidden</trait>
                            <desc>Checks if the FPGA is currently busy or available for a match operation.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher.isBusy(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <return name="isBusy" type="bool" desc="True if the FPGA is currently doing another match operation."/>
                        </function>
                        <function name="setEdgeThreshold">
                            <desc>Sets the edge threshold, i.e., minimal edge strength. The edge strength is calculated as using a local image gradient filter so that smooth edges may generate weak edge responses. The default value is 50. For lower contrast edges one must reduce this value and for very sharp and high-contrast edges it should be raised. Check with the getModelContours() function the edges that are obtained.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher.setEdgeThreshold(matcher, 20)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <param name="threshold" type="float" desc="Edge threshold. The default value is 50."/>
                        </function>
                        <function name="getEdgeThreshold">
                            <trait>hidden</trait>
                            <desc>Gets the current edge threshold parameter.</desc>
                            <sample for="lua">threshold = Image.Matching.EdgeMatcher.getEdgeThreshold(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <return name="threshold" type="float" desc="The current edge threshold."/>
                        </function>
                        <function name="setRotationRange">
                            <trait>released</trait>
                            <links>Image.Matching.EdgeMatcher.setScaleRange</links>
                            <desc>Sets rotation interval to search in relative to the teach orientation. Narrowing the rotation search range speeds up the matching considerably. The search range is given as an angle in radian units. The rotation range interval is plus/minus the specified angle. The default value is PI radians, i.e., equal to a full rotation of plus/minus 180 degrees. If prior orientation information is known, the prior rotation can be set to allow a more narrow search range. The final search range is then up to plus/minus the search range parameter starting from the prior rotation. These parameters can be updated in a teached matcher without re-teaching.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher.setRotationRange(matcher, rotationRad, priorRotationRad)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <param name="rotationRad" type="float" desc="Angle in radian units, the maximum deviation from the original object orientation to search for. The default value is PI (180 degrees), i.e., full rotation."/>
                            <param name="priorRotationRad" type="float" multiplicity="?" desc="Optional prior orientation in radians. If specified, the orientation search range is centered around this orientation. Default is zero (i.e. same orientation as teach object)."/>
                        </function>
                        <function name="setSymmetryMode">
                            <trait>hidden</trait>
                            <desc>Select the symmetry mode to use when matching. Selecting non default modes here increases checking for alternate rotations of the matched object. This could improve robustness when object are self-similar, eg. have symmetries in one or two dimensions.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher.setSymmetryMode(matcher, "MODULO_360")</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <param name="symmetryMode" type="enum" ref="EdgeMatcherSymmetryMode" desc="The symmetry mode to use. Default is MODULO_360."/>
                        </function>
                        <function name="setScaleRange">
                            <trait>released</trait>
                            <links>Image.Matching.EdgeMatcher.setRotationRange</links>
                            <desc>Sets scale interval to search relative to the teach size. The end points are represented as scale factors. setScaleRange(0.8, 1.2) searches for objects appearing down to 20% smaller or larger than the teach object. Default is not to search in scale, i.e, scale range parameters [1.0, 1.0]. An optional prior scale can be set, this affects both the minimum and maximum scale (both limits are multiplied with the prior scale). The prior scale moves the entire scale search range and does not affect matching time. The prior scale accepts a larger range of values than the min and max scale parameters. If the object to find has a fixed non-unit scale relative to the teach object, or if prior information on the scale of the object is available, use the prior scale. The default value is 1.0. By setting both minScale and maxScale to 1.0, scale search is disabled but the prior scale parameter still has effect. These parameters can be updated in a teached matcher without re-teaching.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher.setScaleRange(matcher, minScale, maxScale, priorScale)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <param name="minScale" type="float" desc="The smallest scale factor to search for. Lower limit is 0.8. Default value is 1.0."/>
                            <param name="maxScale" type="float" desc="The largest scale factor to search for. Upper limit is 1.2. Default value is 1.0."/>
                            <param name="priorScale" type="float" multiplicity="?" desc="Optional prior scale factor. Set to the expected scale of the object to find, relative to the size of the teach object. E.g. 1.25 if the object to find is 25% larger than the teach object. Min: 0.1. Max: 10"/>
                        </function>
                        <function name="setConstantScale">
                            <trait>hidden</trait>
                            <desc>Disables scale search, this is the default behavior.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher.setConstantScale(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                        </function>
                        <function name="getScaleRange">
                            <trait>hidden</trait>
                            <desc>Gets the scale interval to search relative to the teach size, and the general prior scale factor.</desc>
                            <sample for="lua">minimalScale, maximalScale, priorScale = Image.Matching.EdgeMatcher.getScaleRange(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <return name="minimalScale" type="float" desc="The smallest scale factor to search for."/>
                            <return name="maximalScale" type="float" desc="The largest scale factor to search for."/>
                            <return name="priorScale" type="float" desc="Prior scale factor. Set to the expected scale of the object to find, relative to the size of the teach object. Default is 1.0."/>
                        </function>
                        <function name="getSymmetryMode">
                            <trait>hidden</trait>
                            <desc>Gets the current symmetry mode parameter.</desc>
                            <sample for="lua">symmetryMode = Image.Matching.EdgeMatcher.getSymmetryMode(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <return name="symmetryMode" type="enum" ref="EdgeMatcherSymmetryMode" desc="The current symmetry mode."/>
                        </function>
                        <function name="getRotationRange">
                            <trait>hidden</trait>
                            <desc>Gets the current rotation range parameter and currently set prior orientation offset.</desc>
                            <sample for="lua">rotationRad, priorRotationRad = Image.Matching.EdgeMatcher.getRotationRange(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <return name="rotationRad" type="float" desc="The current rotation range."/>
                            <return name="priorRotationRad" type="float" desc="Prior orientation in radians. The orientation search is centered around this value. The default is zero, i.e. searching around the same orientation as the teach object."/>
                        </function>
                        <function name="setDownsampleFactor">
                            <links>Image.Matching.EdgeMatcher.getDownsampleFactorLimits, Image.Matching.EdgeMatcher.setBackgroundClutter</links>
                            <desc>Sets downsampling factor in the x- and y-dimensions of the image. If the original image has size (M,N), the downsampled image has size (M/d, N/d) where d is the downsampling factor. Setting this parameter will invalidate any previous teach call.

More downsampling will increase the speed but eventually will reduce the matching robustness. Especially, for small object or thin contours the downsampling cannot be set too low as the details will become washed out in the downsampled image. However, some downsampling can also be beneficial for the matching as noise and irrelevant edges are removed. Therefore, a good downsampling is usually somewhere between 2.0 and 10.0.

Setting a high downsampling does not have an impact on the final matching position accuracy as matches are fine-tuned on finer image resolutions.

For FPGA acceleration there is lower limit on the downsampling factor due to memory limitations. This limit is different for various devices but is usually around 5.0 to 6.0. Use the getDownsampleFactorLimits to find out the lower and upper limits on the downsample factor.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher.setDownsampleFactor(matcher, 6.0)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <param name="downsampleFactor" type="float" desc="A factor larger than or equal to 1.0. The default value is 8.0."/>
                        </function>
                        <function name="getDownsampleFactor">
                            <trait>hidden</trait>
                            <desc>Gets the current downsample parameter setting.</desc>
                            <sample for="lua">downsampleFactor = Image.Matching.EdgeMatcher.getDownsampleFactor(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <return name="downsampleFactor" type="float" desc="The current downsample factor."/>
                        </function>
                        <function name="setMaxMatches">
                            <trait>released</trait>
                            <links>Image.Matching.EdgeMatcher.setMinSeparation</links>
                            <desc>Sets the maximum number of objects to find in a match call. Note that the actual number found can be smaller than this number. Increasing the number of matches to consider is also a way to control the number of match candidates considered within the algorithm. Thus, in cluttered scenes it may be possible to increase robustness to increase this parameter even if one knows that there is only one object present at the end. This parameter can be updated in a teached matcher without re-teaching.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher.setMaxMatches(matcher, 3)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <param name="matchCount" type="int" desc="An integer larger than or equal to 1 specifying the maximum number of objects to find. Maximum number is 100. The default value is 1."/>
                        </function>
                        <function name="getMaxMatches">
                            <trait>hidden</trait>
                            <desc>Gets the current maximum number of objects to find.</desc>
                            <sample for="lua">matchCount = Image.Matching.EdgeMatcher.getMaxMatches(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <return name="matchCount" type="int" desc="The current maximum number of objects to find."/>
                        </function>
                        <function name="setMinSeparation">
                            <links>Image.Matching.EdgeMatcher.setMaxMatches</links>
                            <desc>Sets the minimum separation between the centers of object matches. The unit is in image world units (typically millimeters) taking the image pixel size into account. For 2D images the pixel size is by default 1.0, in which case the value equals the separation in pixels. This parameter only has effect if the number of matches to find is larger than 1. This parameter can be updated in a teached matcher without re-teaching.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher.setMinSeparation(matcher, 100)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <param name="minSeparation" type="float" desc="The minimum separation between the centers of two objects in image world units. The default value is 50."/>
                        </function>
                        <function name="getMinSeparation">
                            <trait>hidden</trait>
                            <desc>Gets the current minimum separation between centers of object matches.</desc>
                            <sample for="lua">minSeparation = Image.Matching.EdgeMatcher.getMinSeparation(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <return name="minSeparation" type="float" desc="The minimum separation between the centers of two objects."/>
                        </function>
                        <function name="setTimeout">
                            <desc>Abort the match call if the match time exceeds a user-defined number of seconds. The main purpose is to protect against excessively long execution times, the granularity does not allow exact abortion at the given timeout parameter. This parameter can be updated in a teached matcher without re-teaching.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher.setTimeout(matcher, 2.0)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <param name="timeoutSeconds" type="float" desc="Time in seconds after which the algorithm should abort. The default value is 5 seconds."/>
                        </function>
                        <function name="getTimeout">
                            <trait>hidden</trait>
                            <desc>Gets the selected timeout for matching.</desc>
                            <sample for="lua">timeoutSeconds = Image.Matching.EdgeMatcher.getTimeout(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <return name="timeoutSeconds" type="float" desc="Time in seconds after which the algorithm will abort."/>
                        </function>
                        <function name="setBackgroundClutter">
                            <links>Image.Matching.EdgeMatcher.setDownsampleFactor</links>
                            <desc>A setting that indicates to what level the live images supplied to the match function are expected to contain non-object edges.

Keep this parameter at HIGH (default) if the image contains a lot of other edges, structures, noise, clutter in areas not belonging to the object of interest. Examples of such structures are barcodes and text which generate a lot of edge responses.

For clean scenes this parameter can be set to MEDIUM or LOW to gain speed. Note however that it may be possible to work with higher downsample factors if this parameter is set to HIGH.

Setting this parameter will invalidate any previous teach call.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher.setBackgroundClutter(matcher, backgroundClutterLevel)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <param name="backgroundClutterLevel" type="auto" desc="Set to the expected background clutter level, LOW, MEDIUM or HIGH. Default is HIGH. In a previous version of this function this input was a bool where 'true' maps to the MEDIUM enum and 'false' to the LOW enum."/>
                        </function>
                        <function name="getBackgroundClutter">
                            <trait>hidden</trait>
                            <desc>Get the setting that indicates to what level the live images supplied to the match function are expected to contain non-object edges.</desc>
                            <sample for="lua">backgroundClutterLevel = Image.Matching.EdgeMatcher.getBackgroundClutter(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <return name="backgroundClutterLevel" type="enum" multiplicity="?" ref="BackgroundClutterLevel" desc="The set background clutter level, LOW, MEDIUM or HIGH."/>
                        </function>
                        <function name="setMaxPositiveEdgeProbes">
                            <trait>hidden</trait>
                            <desc>Set maximum allowed number of positive probes.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher.setMaxPositiveEdgeProbes(matcher, positiveProbeCount)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <param name="positiveProbeCount" type="int" desc="Det maximum number of positive probes"/>
                        </function>
                        <function name="setMaxNegativeEdgeProbes">
                            <trait>hidden</trait>
                            <desc>Set maximum allowed number of negative probes.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher.setMaxNegativeEdgeProbes(matcher, negativeProbeCount)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <param name="negativeProbeCount" type="int" desc="Det maximum number of negative probes"/>
                        </function>
                        <function name="proposeDownsampleFactor">
                            <trait>hidden</trait>
                            <desc>A support function that proposes a downsample factor to use for the EdgeMatcher. The proposal is a trade-off between speed and robustness, and it is only based on the image size used for matching. Depending on the computational power and desired robustness for the application, other values for the downsampling may be necessary.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher.proposeDownsampleFactor(matcher, image)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <param name="image" type="const object" alias="Image" desc="An image with size that the EdgeMatcher will work on."/>
                            <return name="downsampleFactor" type="float" desc="The proposed downsample factor."/>
                        </function>
                        <function name="getDownsampleFactorLimits">
                            <trait>released</trait>
                            <links>Image.Matching.EdgeMatcher.setDownsampleFactor, Image.Matching.EdgeMatcher.setProcessingUnit</links>
                            <desc>A support function which outputs the minimum and maximum values of the downsample factor. In particular when FPGA acceleration is utilized there are memory limitations setting a minimal value for the downsample factor. The maximum downsample factor is derived from the smallest allowed downsampled image size to look for matches in.</desc>
                            <sample for="lua">minDsf, maxDsf = Image.Matching.EdgeMatcher.getDownsampleFactorLimits(matcher, image)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <param name="image" type="const object" alias="Image" desc="An image with the size that the EdgeMatcher will work on"/>
                            <return name="minDsf" type="float" desc="Minimum allowed downsample factor."/>
                            <return name="maxDsf" type="float" desc="Maximum allowed downsample factor."/>
                        </function>
                        <function name="teach">
                            <trait>released</trait>
                            <links>Image.Matching.EdgeMatcher.match, Image.Matching.EdgeMatcher.getModelContours, Image.Matching.EdgeMatcher.getTeachPose</links>
                            <desc>Teaches an object model from edges in an image. It is important to set the edge strength threshold properly for this to work. Graphical feedback from the teach process is obtained through the getModelContours function.

The status code indicates what happened during the call and may be set to any of the following values:
* 0:   Teaching was successful.
* 10:  Logical error, e.g. missing parameters or parameters outside the permissible range, see the printed error message.
* 90:  Error not related to any of the other categories, see the printed error message.
* 110: Timeout, teaching was aborted. Check the set time limit.
* 120: Image error, something was wrong with the input image, e.g. invalid, too small, unsupported type.
* 130: Region error, something was wrong with the teach region.
* 160: FPGA error, something was wrong with the FPGA, e.g. too large image or the FPGA was busy.
* 170: Model edge error, too few model edges were found. Check the edge threshold, the input image and that the teach region covers the object of interest.</desc>
                            <sample for="lua">teachPoseTransform, status = Image.Matching.EdgeMatcher.teach(matcher, teachImage, teachRegion)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use"/>
                            <param name="teachImage" type="const object" alias="Image" desc="The teach image or image pyramid."/>
                            <param name="teachRegion" type="const auto" desc="A pixel region or a closed 2D shape defining which area to consider as containing object edges."/>
                            <return name="teachPoseTransform" type="object" multiplicity="?" alias="Transform" desc="Pose transform of the object model, or nil if unsuccessful."/>
                            <return name="status" type="int" multiplicity="?" desc="A status code indicating what happened during the call."/>
                        </function>
                        <function name="match">
                            <trait>released</trait>
                            <links>Image.Matching.EdgeMatcher.teach, Image.Fixture, Transform</links>
                            <desc>Finds objects in an image by matching with the teach model. A teach call must be made first. The output is a vector of pose transforms, one transform for each found match. The transform describes how the object model is transformed to the match in the live image.

For the EdgeMatcher, the output posed transforms are of 2D Transform type. They can be used with the Fixture object to transform other 2D objects and regions.

The match scores are based on how well edge information in the image matches the object model.

The status code indicates what happened during the call and may be set to any of the following values:
* 0:   Matching was successful (although no objects may have been found, there was no error).
* 10:  Logical error, e.g. missing parameters or parameters outside the permissible range, see the printed error message.
* 90:  Error not related to any of the other categories, see the printed error message.
* 210: Timeout, matching was aborted. Check the set time limit.
* 220: Image error, something was wrong with the input image, e.g. invalid, too small, unsupported type.
* 230: Region error, something was wrong with the search region.
* 240: Unteached matcher, the matcher is not successfully teached.
* 260: FPGA error, something was wrong with the FPGA, e.g. too large image or the FPGA was busy.</desc>
                            <sample for="lua">transforms, scores, status = Image.Matching.EdgeMatcher.match(matcher, liveImage, searchRegion)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The matcher instance to use"/>
                            <param name="liveImage" type="const object" alias="Image" desc="The live image or image pyramid to find the object in."/>
                            <param name="searchRegion" type="const auto" multiplicity="?" desc="Optional search region in the live image, either a pixel region or a closed 2D shape such as a rectangle. Edges are only detected within this region and it should cover the entire object to be found."/>
                            <return name="poseTransforms" type="object" multiplicity="*" alias="Transform" desc="Pose transforms defining the location of each detected object."/>
                            <return name="matchScores" type="float" multiplicity="*" desc="A score between 0.0 and 1.0 for each detected object (high score means good match)."/>
                            <return name="status" type="int" multiplicity="?" desc="A status code indicating what happened during the call."/>
                        </function>
                        <function name="enableDiagnosticInfo">
                            <trait>hidden</trait>
                            <desc>Set to true for the EdgeMatcher to store results for getCoarseImages. This parameter is not serialized.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher.enableDiagnosticInfo(matcher, true)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The matcher instance to use"/>
                            <param name="enableInfo" type="bool" desc="True to store diagnostic info."/>
                        </function>
                        <function name="getCoarseImages">
                            <trait>hidden</trait>
                            <desc>Returns images coarse search images from the last match call.</desc>
                            <sample for="lua">downsampledImages, scoreImages = Image.Matching.EdgeMatcher.getCoarseImages(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The matcher instance to use"/>
                            <return name="downsampledImages" type="object" multiplicity="?" alias="Image" desc="Downsampled image."/>
                            <return name="scoreImages" type="object" multiplicity="*" desc="Vector of score images."/>
                        </function>
                        <function name="getCoarseEdgeProbes">
                            <trait>hidden</trait>
                            <desc>Returns coarse edge probes from the last teach call.</desc>
                            <sample for="lua">positiveEdgeProbes, negativeEdgeProbes = Image.Matching.EdgeMatcher.getCoarseEdgeProbes(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The matcher instance to use"/>
                            <return name="positiveEdgeProbes" type="object" multiplicity="*" desc="Vector of positive edge probes."/>
                            <return name="negativeEdgeProbes" type="object" multiplicity="*" desc="Vector of negative edge probes."/>
                        </function>
                        <function name="getEdgePoints">
                            <trait>deprecated</trait>
                            <desc>Deprecated: This function has been renamed to getModelPoints to align with the PointMatcher API. The functions give the same output.
Get sample edges of the object represented as a vector of 2D Points. This function is intended for graphical feedback using representative points on edges of the reference object. The points are returned in internal model coordinates and must be transformed using a pose transform to overlay them onto the teach or live image. Can only be called after a successful teach.</desc>
                            <sample for="lua">points = Image.Matching.EdgeMatcher.getEdgePoints(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The matcher instance to use."/>
                            <return name="points" type="object" multiplicity="*" alias="Point" desc="Edge points in internal model coordinates."/>
                        </function>
                        <function name="getModelPoints">
                            <links>Image.Matching.EdgeMatcher.getModelContours</links>
                            <desc>Get the object model as a vector of 2D Points of located edges. This function is intended for graphical feedback using representative points on edges of the reference object. The points are returned in internal model coordinates and must be transformed using a pose transform to overlay them onto the teach or live image. Can only be called after a successful teach.

Note: As it may be inefficient to overlay a lot of points in images, it is recommended to use the getModelContours function instead for graphical feedback.</desc>
                            <sample for="lua">points = Image.Matching.EdgeMatcher.getModelPoints(matcher, 1000)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The matcher instance to use."/>
                            <param name="maxCount" type="int" multiplicity="?" desc="Optional parameter to specify the maximum number of control points along the polylines to return. Default is 500 and absolute max is 5000. Note that one can obtain fewer points than the value specified here."/>
                            <return name="points" type="object" multiplicity="*" alias="Point" desc="Edge points in internal model coordinates."/>
                        </function>
                        <function name="getModelContours">
                            <links>Image.Matching.EdgeMatcher.teach, Image.Matching.EdgeMatcher.getModelPoints</links>
                            <desc>Get object model contours for visualization purposes. Results are returned as polyline shape objects.</desc>
                            <sample for="lua">polylines = Image.Matching.EdgeMatcher.getModelContours(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The matcher instance to use."/>
                            <return name="polylines" type="object" multiplicity="*" alias="Shape" desc="Edge lines in internal model coordinates."/>
                        </function>
                        <function name="getTeachPose">
                            <links>Image.Matching.EdgeMatcher.teach</links>
                            <desc>Returns the teach pose that was created and returned by the last teach call. If the last teach was unsuccessful, nil is returned.</desc>
                            <sample for="lua">teachPose = Image.Matching.EdgeMatcher.getTeachPose(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use"/>
                            <return name="teachPose" type="object" multiplicity="?" alias="Transform" desc="2D pose transform transforming the object model to its position in the teach image, or nil if unsuccessful."/>
                        </function>
                        <function name="getMatchTime">
                            <trait>hidden</trait>
                            <desc>Gets the time for the last match call in milliseconds.</desc>
                            <sample for="lua">time = Image.Matching.EdgeMatcher.getMatchTime(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The matcher instance to use."/>
                            <return name="time" type="int" desc="Time in milliseconds for the last match call."/>
                        </function>
                        <function name="getEdgeStatistics">
                            <trait>hidden</trait>
                            <desc>Returns statistics for the edge strength. Currently only a histogram.</desc>
                            <sample for="lua">histogram = Image.Matching.EdgeMatcher.getEdgeStatistics(matcher, image, region)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use."/>
                            <param name="image" type="const object" alias="Image" desc="An image with size that the EdgeMatcher will work on."/>
                            <param name="region" type="object" multiplicity="?" alias="Image.PixelRegion" desc="Region to compute edge strength statistics in."/>
                            <return name="histogram" type="object" multiplicity="?" alias="Profile" desc="Edge strength histogram."/>
                        </function>
                        <function name="toString">
                            <desc>Returns a human readable description of the matcher, including parameters.</desc>
                            <sample for="lua">description = Image.Matching.EdgeMatcher.toString(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher" desc="The instance to use"/>
                            <return name="description" type="string" multiplicity="?" desc="A description of the matcher object, or nil on failure."/>
                        </function>
                    </serves>
                </crown>
                <crown name="EdgeMatcher3D">
                    <trait>released</trait>
                    <links>Image.Matching.EdgeMatcher, Image.Fixture3D</links>
                    <desc>The EdgeMatcher3D is an extension of the EdgeMatcher for object matching in range images and heightmaps. See the EdgeMatcher documentation for information on the basic usage. The documentation below focuses on the extensions and differences to the EdgeMatcher.

The most important additional parameters and difference for the EdgeMatcher3D are the following:

- The EdgeMatcher3D searches for height and tilt (rotation around the x- and y-axes) of objects. The function setFindTiltHeight() enables and disables these additional parameters in the search. Tilt and height estimation is turned on by default. Turn these off for increased speed and robustness if the objects of interest always have the same tilt or height.

- As range images generally contain missing data pixels, there is a mandatory "reference height" parameter that is set using the setReferenceHeight(). The EdgeMatcher3D uses this parameter to replace missing data pixels internally.

- The output of the EdgeMatcher3D are 3D pose transforms. These can be used together with the Fixture3D object for locate-inspect applications.

- Teach and search regions have additional zMin and zMax parameters to specify limits along the z-dimension.

Pixel types:
The EdgeMatcher3D accepts uint16 pixel type images.

Hardware acceleration:
Some devices have FPGA-support for the EdgeMatcher3D. It is possible to switch between the CPU and FPGA versions using the setProcessingUnit()-function. If there is FPGA support it is set as default, but note that the FPGA is not able to support all configurations, mainly there is a lower restriction on the downsample factor for memory limitation reasons.
There is typically only one instance of the FPGA calculation unit in a device. If many EdgeMatcher3D instances are created running in parallel, all using the FPGA acceleration, they may try to access the FPGA resource at the same time. The behavior is then that a match call will wait until the FPGA resource is available again.

Image world coordinate system handling:
All parameters (thresholds, zMin, zMax, reference height) use the z-origin and z-pixelsize. That is, the parameters are interpreted in world units, typically in millimeters. The output pose transforms are also expressed in the image world coordinate system.

Missing data handling:
Both images with and without missing data flag are accepted. If the input image has missing data, the reference height parameter must be set to handle missing data internally.

Object model:
An object representation of the contours in the teach reference image is generated in a teach call. The center of the model, and also the rotation center, is the center of the teach region. The center in the z-dimension is (zMin + zMax)/2.

Saving and loading a configuration:
The configuration of a trained EdgeMatcher handle instance can be saved and loaded (serialized/deserialized) using the Object.save() and Object.load() functions.</desc>
                    <serves>
                        <function name="create">
                            <desc>Creates a new edge matcher for 3D object localization in range images.</desc>
                            <sample for="lua">locator = Image.Matching.EdgeMatcher3D.create()</sample>
                            <return name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The new instance."/>
                        </function>
                        <function name="setProcessingUnit">
                            <trait>released</trait>
                            <desc>Sets processing unit for the calculations. Some devices support FPGA acceleration of the EdgeMatcher3D. If this is the case the FPGA acceleration is set by default when the EdgeMatcher3D object is created. This parameter can be updated in a teached matcher without re-teaching.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher3D.setProcessingUnit(matcher, "FPGA")</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The instance to use."/>
                            <param name="processingUnit" type="enum" ref="EdgeMatcherProcessingUnit" desc="Which type of processing unit to use. If there is FPGA support in the device it will be used as default, otherwise CPU."/>
                            <return name="success" type="bool" multiplicity="?" desc="True if processing unit choice was successfully set. False if the chosen processing unit is not supported."/>
                        </function>
                        <function name="setEdgeThreshold">
                            <links>Image.Matching.EdgeMatcher3D.getModelContours</links>
                            <desc>Sets the edge threshold, i.e., minimal edge strength. The edge strength is calculated as using a local image gradient filter so that smooth edges may generate weak edge responses. The default value is 10. Check with the getModelPoints() or the getModelContours() function the edges that are obtained.

Image world coordinate system handling:
The edge threshold is interpreted in the image world coordinate system, i.e., typically in millimeters. The threshold is converted internally to a raw pixel value threshold using the z-origin and z-pixelsize of the image.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher3D.setEdgeThreshold(matcher, threshold)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The instance to use."/>
                            <param name="threshold" type="float" desc="Edge threshold interpreted in the image world coordinate system. The default value is 10 for EdgeMatcher3D."/>
                        </function>
                        <function name="getEdgeThreshold">
                            <trait>hidden</trait>
                            <desc>Gets the current edge threshold parameter.</desc>
                            <sample for="lua">threshold = Image.Matching.EdgeMatcher3D.getEdgeThreshold(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The instance to use."/>
                            <return name="threshold" type="float" multiplicity="?" desc="The current edge threshold."/>
                        </function>
                        <function name="setRotationRange">
                            <desc>Sets rotation interval around the z-axis to search in relative to the teach orientation. Narrowing the rotation search range speeds up the matching considerably. The search range is given as an angle in radian units. The rotation range interval is plus/minus the specified angle. The default value is PI radians, i.e., equal to a full rotation of plus/minus 180 degrees. This parameter can be updated in a teached matcher without re-teaching.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher3D.setRotationRange(matcher, rotationRad)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The instance to use."/>
                            <param name="rotationRad" type="float" desc="Angle in radian units, the maximum deviation from the original object orientation to search for. The default value is PI."/>
                        </function>
                        <function name="getRotationRange">
                            <trait>hidden</trait>
                            <desc>Gets the current rotation range parameter.</desc>
                            <sample for="lua">rotationRad = Image.Matching.EdgeMatcher3D.getRotationRange(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The instance to use."/>
                            <return name="rotationRad" type="float" multiplicity="?" desc="The current rotation range."/>
                        </function>
                        <function name="setSymmetryMode">
                            <trait>hidden</trait>
                            <desc>Select the symmetry mode to use when matching. Selecting non default modes here increases checking for alternate rotations of the matched object. This could improve robustness when object are self-similar, eg. have symmetries in one or two dimensions.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher3D.setSymmetryMode(matcher, "MODULO_360")</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The instance to use."/>
                            <param name="symmetryMode" type="enum" ref="EdgeMatcherSymmetryMode" desc="The symmetry mode to use. Default is MODULO_360."/>
                        </function>
                        <function name="getSymmetryMode">
                            <trait>hidden</trait>
                            <desc>Gets the current symmetry mode parameter.</desc>
                            <sample for="lua">symmetryMode = Image.Matching.EdgeMatcher3D.getSymmetryMode(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The instance to use."/>
                            <return name="symmetryMode" type="enum" ref="EdgeMatcherSymmetryMode" desc="The current symmetry mode."/>
                        </function>
                        <function name="setDownsampleFactor">
                            <links>Image.Matching.EdgeMatcher3D.getDownsampleFactorLimits</links>
                            <desc>Sets downsample factor in the x- and y-dimensions of the image. If the original image has size (M,N), the downsampled image has size (M/d, N/d) where d is the downsample factor. Setting this parameter will invalidate any previous teach call.

More downsampling will increase the speed but eventually will reduce the matching robustness. Especially, for small object or thin contours the downsampling cannot be set too low as the details will become washed out in the downsampled image. However, some downsampling can also be beneficial for the matching as noise and irrelevant edges are removed. Therefore, a good downsampling is usually somewhere between 2.0 and 10.0.

Setting a high downsampling does not have an impact on the final matching position accuracy as matches are fine-tuned on finer image resolutions.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher3D.setDownsampleFactor(matcher, downsampleFactor)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The instance to use."/>
                            <param name="downsampleFactor" type="float" desc="A factor larger than or equal to 1.0. The default value is 8.0."/>
                        </function>
                        <function name="getDownsampleFactor">
                            <trait>hidden</trait>
                            <desc>Gets the current downsample parameter setting.</desc>
                            <sample for="lua">downsampleFactor = Image.Matching.EdgeMatcher3D.getDownsampleFactor(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The instance to use."/>
                            <return name="downsampleFactor" type="float" multiplicity="?" desc="The current downsample factor."/>
                        </function>
                        <function name="getDownsampleFactorLimits">
                            <trait>released</trait>
                            <links>Image.Matching.EdgeMatcher3D.setDownsampleFactor, Image.Matching.EdgeMatcher3D.setProcessingUnit</links>
                            <desc>A support function which outputs the minimum and maximum values of the downsample factor. In particular when FPGA acceleration is utilized there are memory limitations setting a minimal value for the downsample factor. The maximum downsample factor is derived from the smallest allowed downsampled image size to look for matches in.</desc>
                            <sample for="lua">minDsf, maxDsf = Image.Matching.EdgeMatcher3D.getDownsampleFactorLimits(matcher, image)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The instance to use."/>
                            <param name="image" type="const object" alias="Image" desc="An image with the size that the EdgeMatcher3D will work on."/>
                            <return name="minDsf" type="float" desc="Minimum allowed downsample factor."/>
                            <return name="maxDsf" type="float" desc="Maximum allowed downsample factor."/>
                        </function>
                        <function name="setMaxMatches">
                            <links>Image.Matching.EdgeMatcher3D.setMinSeparation</links>
                            <desc>Sets the maximum number of objects to find in a match call. Note that the actual number found can be smaller than this number. This parameter can be updated in a teached matcher without re-teaching.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher3D.setMaxMatches(matcher, matchCount)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The instance to use."/>
                            <param name="matchCount" type="int" desc="An integer larger than or equal to 1 specifying the maximum number of objects to find. Maximum number is 100. The default value is 1."/>
                        </function>
                        <function name="getMaxMatches">
                            <trait>hidden</trait>
                            <desc>Gets the current maximum number of objects to find.</desc>
                            <sample for="lua">matchCount = Image.Matching.EdgeMatcher3D.getMaxMatches(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The instance to use."/>
                            <return name="matchCount" type="int" multiplicity="?" desc="The current maximum number of objects to find."/>
                        </function>
                        <function name="setMinSeparation">
                            <links>Image.Matching.EdgeMatcher3D.setMaxMatches</links>
                            <desc>Sets the minimum separation in the (x,y)-dimension between the centers of object matches. This parameter only has effect if the number of matches to find is larger than 1. This parameter can be updated in a teached matcher without re-teaching.

Image world coordinate system handling:
The unit is in image world units (typically millimeters) taking the image (x,y)-pixelsizes into account.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher3D.setMinSeparation(matcher, minSeparation)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The instance to use."/>
                            <param name="minSeparation" type="float" desc="The minimum separation between the centers of two objects in image world units. The default value is 50."/>
                        </function>
                        <function name="getMinSeparation">
                            <trait>hidden</trait>
                            <desc>Gets the current minimum separation between centers of object matches.</desc>
                            <sample for="lua">minSeparation = Image.Matching.EdgeMatcher3D.getMinSeparation(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The instance to use."/>
                            <return name="minSeparation" type="float" multiplicity="?" desc="The minimum separation between the centers of two objects."/>
                        </function>
                        <function name="setTimeout">
                            <desc>Abort the match call if the match time exceeds a user-defined number of seconds. The main purpose is to protect against excessively long execution times, the granularity does not allow exact abortion at the given timeout parameter. This parameter can be updated in a teached matcher without re-teaching.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher3D.setTimeout(matcher, timeoutSeconds)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The instance to use."/>
                            <param name="timeoutSeconds" type="float" desc="Time in seconds after which the algorithm should abort. The default value is 5 seconds."/>
                        </function>
                        <function name="getTimeout">
                            <trait>hidden</trait>
                            <desc>Gets the selected timeout for matching.</desc>
                            <sample for="lua">timeoutSeconds = Image.Matching.EdgeMatcher3D.getTimeout(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The instance to use."/>
                            <return name="timeoutSeconds" type="float" multiplicity="?" desc="Time in seconds after which the algorithm will abort."/>
                        </function>
                        <function name="setBackgroundClutter">
                            <desc>A setting that indicates to what level the live images supplied to the match function are expected to contain non-object edges, e.g., noise and other clutter structures. The default setting is "MEDIUM". For very cluttered scenes it is possible to use a "HIGH" setting. Setting this parameter will invalidate any previous teach call.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher3D.setBackgroundClutter(matcher, backgroundClutterLevel)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The instance to use."/>
                            <param name="backgroundClutterLevel" type="auto" desc="Set to the expected background clutter level, LOW, MEDIUM or HIGH. Default is MEDIUM."/>
                        </function>
                        <function name="getBackgroundClutter">
                            <trait>hidden</trait>
                            <desc>Gets the setting that indicates to what level the live images supplied to the match function are expected to contain non-object edges.</desc>
                            <sample for="lua">backgroundClutterLevel = Image.Matching.EdgeMatcher3D.getBackgroundClutter(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The instance to use."/>
                            <return name="backgroundClutterLevel" type="enum" multiplicity="?" ref="BackgroundClutterLevel" desc="The set background clutter level, LOW, MEDIUM or HIGH."/>
                        </function>
                        <function name="teach">
                            <trait>released</trait>
                            <links>Image.Matching.EdgeMatcher3D.match, Image.Matching.EdgeMatcher3D.getModelContours, Image.Fixture3D</links>
                            <desc>Teaches an object model from edges in an image. It is important to set the edge strength threshold properly for this to work. Graphical feedback from the teach process is obtained through the getModelPoints() or getModelContours() functions. The teach procedure extracts both edge information and planar patches within the teach region. The latter are used to estimate tilt and height parameters in match.

Image world coordinate system handling:
The two parameters zMin and zMax specify the range interval of the teach region. The parameters are interpreted in image world units, typically millimeters, taking the z-origin and z-pixelsize of the input image into account.

The status code indicates what happened during the call and may be set to any of the following values:
* 0:   Teaching was successful.
* 10:  Logical error, e.g. missing parameters or parameters outside the permissible range, see the printed error message.
* 90:  Error not related to any of the other categories, see the printed error message.
* 110: Timeout, teaching was aborted. Check the set time limit.
* 120: Image error, something was wrong with the input image, e.g. invalid, too small, unsupported type.
* 130: Region error, something was wrong with the teach region.
* 150: Reference plane error, something was wrong with the reference height for missing data.
* 160: FPGA error, something was wrong with the FPGA, e.g. too large image or the FPGA was busy.
* 170: Model edge error, too few model edges were found. Check the edge threshold, the input image and that the teach region covers the object of interest.
* 180: Model plane error, too few planar probes were found. See status code 170.</desc>
                            <sample for="lua">teachPoseTransform, status = Image.Matching.EdgeMatcher3D.teach(matcher, teachImage, teachRegion)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The instance to use"/>
                            <param name="teachImage" type="const object" alias="Image" desc="The teach image or image pyramid."/>
                            <param name="teachRegion" type="const auto" desc="A pixel region or a closed 2D shape defining which area to consider as containing object edges."/>
                            <param name="zMin" type="float" multiplicity="?" desc="Optional minimum value for z heights in world units (millimeters). Only edges and planar points above this level are included in the model. If not set, a large negative number is used as default."/>
                            <param name="zMax" type="float" multiplicity="?" desc="Optional maximum value for z heights in world units (millimeters). Only edges and planar points below this level are included in the model. If not set, a large positive number is used as default."/>
                            <return name="teachPoseTransform" type="object" multiplicity="?" alias="Transform" desc="Pose transform of the object model, or nil if unsuccessful."/>
                            <return name="status" type="int" multiplicity="?" desc="A status code indicating what happened during the call."/>
                        </function>
                        <function name="match">
                            <trait>released</trait>
                            <links>Image.Matching.EdgeMatcher3D.teach</links>
                            <desc>Finds objects in an image by matching with the teach model. A teach call must be made first. The output is a vector of pose transforms, one transform for each found match. The transform describes how the object model is transformed to the match in the live image.

For the EdgeMatcher3D, the output pose transforms are of 3D Transform type. They can be used with the Fixture3D object to transform other 3D objects and regions.

The match scores are based on how well edge information in the image matches the object model. Currently, only (x,y) locations of edges are included in the score calculation, meaning that a mismatch in z-dimension can still give a high score.

Image world coordinate system handling:
The two parameters zMin and zMax specify the range interval of the teach region. The parameters are interpreted in image world units, typically millimeters, taking the z-origin and z-pixelsize of the input image into account.

The status code indicates what happened during the call and may be set to any of the following values:
* 0:   Matching was successful (although no objects may have been found, there was no error).
* 10:  Logical error, e.g. missing parameters or parameters outside the permissible range, see the printed error message.
* 90:  Error not related to any of the other categories, see the printed error message.
* 210: Timeout, matching was aborted. Check the set time limit.
* 220: Image error, something was wrong with the input image, e.g. invalid, too small, unsupported type.
* 230: Region error, something was wrong with the search region.
* 240: Unteached matcher, the matcher is not successfully teached.
* 250: Reference plane error, something was wrong with the reference height for missing data.
* 260: FPGA error, something was wrong with the FPGA, e.g. too large image or the FPGA was busy.</desc>
                            <sample for="lua">transforms, scores = Image.Matching.EdgeMatcher3D.match(matcher, liveImage)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The matcher instance to use"/>
                            <param name="liveImage" type="const object" alias="Image" desc="The live image or image pyramid to find the object in."/>
                            <param name="searchRegion" type="const auto" multiplicity="?" desc="Optional search region in the live image, either a pixel region or a closed 2D shape such as a rectangle. Edges are only detected within this region and it should cover the entire object to be found."/>
                            <param name="zMin" type="float" multiplicity="?" desc="Optional minimum value for z heights in world units (millimeters). Only edges above this level are included as features for the matching. If not set, a large negative number is used as default."/>
                            <param name="zMax" type="float" multiplicity="?" desc="Optional maximum value for z heights in world units (millimeters). Only edges below this level are included as features for the matching. If not set, a large positive number is used as default."/>
                            <return name="poseTransforms" type="object" multiplicity="*" alias="Transform" desc="Pose transforms defining the location of each detected object."/>
                            <return name="matchScores" type="float" multiplicity="*" desc="A score between 0.0 and 1.0 for each detected object (high score means good match)."/>
                            <return name="status" type="int" multiplicity="?" desc="A status code indicating what happened during the call."/>
                        </function>
                        <function name="enableDiagnosticInfo">
                            <trait>hidden</trait>
                            <desc>Set to true for the EdgeMatcher3D to store results for getCoarseImages.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher3D.enableDiagnosticInfo(matcher, true)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The matcher instance to use"/>
                            <param name="enableInfo" type="bool" desc="True to store diagnostic info."/>
                        </function>
                        <function name="getCoarseImages">
                            <trait>hidden</trait>
                            <desc>Returns images coarse search images from the last match call.</desc>
                            <sample for="lua">downsampledImages, scoreImages = Image.Matching.EdgeMatcher3D.getCoarseImages(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The matcher instance to use"/>
                            <return name="downsampledImages" type="object" multiplicity="?" alias="Image" desc="Downsampled image."/>
                            <return name="scoreImages" type="object" multiplicity="*" desc="Vector of score images."/>
                        </function>
                        <function name="getModelPoints">
                            <links>Image.Matching.EdgeMatcher3D.getModelContours</links>
                            <desc>Gets object model points for visualization purposes. This function returns points along the edges of object. See also getModelContours.</desc>
                            <sample for="lua">points = Image.Matching.EdgeMatcher3D.getModelPoints(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The matcher instance to use."/>
                            <param name="maxCount" type="int" multiplicity="?" desc="Optional parameter to specify the maximum number points to return. Default is 500 and absolute max is 5000. Note that one can obtain fewer points than the value specified here."/>
                            <return name="points" type="object" multiplicity="*" alias="Point" desc="Edge points in internal model coordinates."/>
                        </function>
                        <function name="getModelPlanePoints">
                            <links>Image.Matching.EdgeMatcher3D.teach</links>
                            <desc>Gets object model points for visualization purposes. This function returns center points of planar patches.</desc>
                            <sample for="lua">planarPoints = Image.Matching.EdgeMatcher3D.getModelPlanePoints(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The matcher instance to use."/>
                            <param name="maxCount" type="int" multiplicity="?" desc="Optional parameter to specify the maximum number points to return. Default is 500 and absolute max is 5000. Note that one can obtain fewer points than the value specified here."/>
                            <return name="planarPoints" type="object" multiplicity="*" alias="Point" desc="Vector of 3D planar points in internal model coordinates."/>
                        </function>
                        <function name="getModelContours">
                            <links>Image.Matching.EdgeMatcher3D.teach</links>
                            <desc>Gets object model contours for visualization purposes. Results are returned as polyline Shape3D objects.</desc>
                            <sample for="lua">polylines = Image.Matching.EdgeMatcher3D.getModelContours(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The matcher instance to use."/>
                            <return name="polylines" type="object" multiplicity="*" alias="Shape3D" desc="Edge lines in internal model coordinates."/>
                        </function>
                        <function name="getTeachPose">
                            <links>Image.Matching.EdgeMatcher3D.teach</links>
                            <desc>Returns the teach pose that was created and returned by the last teach call. If the last teach was unsuccessful, nil is returned.</desc>
                            <sample for="lua">teachPose = Image.Matching.EdgeMatcher3D.getTeachPose(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The instance to use"/>
                            <return name="teachPose" type="object" multiplicity="?" alias="Transform" desc="Pose transform transforming the object model to its position in the teach image, or nil if unsuccessful."/>
                        </function>
                        <function name="setFindTiltHeight">
                            <desc>Flags to find the tilt and/or height of objects relative to the teach pose. Depending on the application, one may for example know that the tilt and or height is always the same as for the teach object. If so, turn off the estimation of these parameters for increased speed and robustness. If tilt-search is on, height-search is turned on automatically. Setting this parameter will invalidate any previous teach call.

The maximum tilt angle the algorithm can find is about 10 - 15 degrees relative to the teach pose, for higher tilts the algorithm may not match robustly.</desc>
                            <sample for="lua">Image.Matching.setFindTiltHeight(matcher, findTilt, findHeight)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The matcher instance to use."/>
                            <param name="findTilt" type="bool" desc="Set to true to find tilt of matched objects. Default is true."/>
                            <param name="findHeight" type="bool" desc="Set to true to find height of matched objects. Default is true."/>
                        </function>
                        <function name="setUsePlaneProbesInScore">
                            <trait>hidden</trait>
                            <desc>Flag to use height in the score measure. This is done by checking how good the plane probes fits in the finest scale. The sensitivity can be set. Default 1.0. Eg. 2.0 means twice as sensitive and 0.5 means half as sensitive. Not fully tested! Only for evaluation!</desc>
                            <sample for="lua">Image.Matching.setUsePlaneProbesInScore(matcher, usePlaneProbes, sensitivity)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The matcher instance to use."/>
                            <param name="usePlaneProbes" type="bool" desc="Set to true to use the plane probes in the score calculation. Default is false."/>
                            <param name="sensitivity" type="float" desc="Sensitivity. How good must the plane probes fit. Default 1.0."/>
                        </function>
                        <function name="setReferenceHeight">
                            <links>Image.Matching.EdgeMatcher3D.proposeReferenceHeight</links>
                            <desc>Sets a reference height for missing data handling. This value is used to replace missing data pixels within the algorithm. Use the height of the floor, belt or any other application-dependent height. Setting this parameter is mandatory if the input images have the missing data flag on. If missing data has been removed before calling the EdgeMatcher3D, this parameter has no effect. This parameter can be updated in a teached matcher without re-teaching.

A suggested reference height can be obtained using the proposeReferenceHeight()-function.

Image world coordinate system handling:
The reference height is interpreted in the image world coordinate system, typically in millimeters, considering the z-origin and z-pixelsize of the image.</desc>
                            <sample for="lua">Image.Matching.EdgeMatcher3D.setReferenceHeight(matcher, referenceHeight)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The matcher instance to use."/>
                            <param name="referenceHeight" type="float" desc="Reference height specified in world units, e.g., millimeters."/>
                        </function>
                        <function name="proposeReferenceHeight">
                            <links>Image.Matching.EdgeMatcher3D.setReferenceHeight</links>
                            <desc>Tries to estimate a reference height using valid pixels outside the teach region. Use this function carefully as it can give inaccurate results, for example if the teach region covers only the object partially.</desc>
                            <sample for="lua">referenceHeight = Image.Matching.EdgeMatcher3D.proposeReferenceHeight(matcher, teachImage, teachRegion)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The instance to use"/>
                            <param name="teachImage" type="const object" alias="Image" desc="The teach image."/>
                            <param name="teachRegion" type="const auto" desc="A pixel region or a closed 2D shape defining which area to consider as containing object edges."/>
                            <return name="referenceHeight" type="float" multiplicity="?" desc="An estimated reference height in image world units, typically millimeters. Returns nil if height estimation fails."/>
                        </function>
                        <function name="toString">
                            <desc>Returns a human readable description of the matcher, including parameters.</desc>
                            <sample for="lua">description = Image.Matching.EdgeMatcher3D.toString(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.EdgeMatcher3D" desc="The instance to use"/>
                            <return name="description" type="string" desc="A description of the matcher object."/>
                        </function>
                    </serves>
                </crown>
                <crown name="PatternMatcher">
                    <trait>released</trait>
                    <keywords>locator, template, correlation, matching, pixel</keywords>
                    <links>Image.Matching.PointMatcher, Image.Matching.EdgeMatcher, Image.Fixture</links>
                    <desc>Finds an object in an image based on its pixel pattern. Teach the object from a reference image and call match to find the location of the same object in a live image. The PatternMatcher primarily searches for translated and rotated objects. Search in scale can be activated. Results are given in pose transforms which describe how the object model is transformed to matched positions in the live image. Each match gets a score between 0.0 and 1.0 where 1.0 means a perfect match. The PatternMatcher is often used together with the Fixture object that facilitates local coordinate transforms based on the result of the PatternMatcher.
The most important parameters for the PatternMatcher are the following:

- Downsample factor: The PatternMatcher works internally on downsampled images for computational performance reasons. The downsample factor is the most important parameter for the speed versus robustness trade-off. A initial choice of downsample factor could be one that generates a downsampled image of size about 150 x 150. That is, if images of size 1024 x 1024 are used, one could start experimenting with a downsample factor of around 7. A warning will be issued during teach if the downsample factor makes the object model too small.

- Rotation range: The rotation range parameter should be selected to be as narrow as possible both for computational reasons and for robustness reasons. If it is known that the target object only can appear within a certain rotation interval, make sure to reduce the rotation range search parameter.</desc>
                    <enum name="EdgeSensitivity" trait="released">
                        <item name="High" desc="All pixels contribute to the verification.">HIGH</item>
                        <item name="Low" desc="Pixels close to edges are excluded.">LOW</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <desc>Creates a new pattern matcher for 2D object localization.</desc>
                            <sample for="lua">locator = Image.Matching.PatternMatcher.create()</sample>
                            <return name="locator" type="handle" alias="Image.Matching.PatternMatcher" desc="The new instance."/>
                        </function>
                        <function name="setRotationRange">
                            <desc>Sets the rotation interval to search in, relative to the teach orientation. Narrowing the rotation search range speeds up the matching considerably. The search range is given as an angle in radian units. The rotation range interval is plus/minus the specified angle.</desc>
                            <sample for="lua">Image.Matching.PatternMatcher.setRotationRange(locator, 3.1415/16)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PatternMatcher" desc="The instance to use."/>
                            <param name="rotationRad" type="float" desc="Angle in radian units, the maximum deviation from the original object orientation to search for. The default value is PI/16."/>
                        </function>
                        <function name="getRotationRange">
                            <desc>Gets the current rotation range parameter.</desc>
                            <sample for="lua">rotationRad = Image.Matching.PatternMatcher.getRotationRange(locator)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PatternMatcher" desc="The instance to use."/>
                            <return name="rotationRad" type="float" multiplicity="?" desc="The current rotation range."/>
                        </function>
                        <function name="setDownsampleFactor">
                            <desc>Sets the downsample factor. Increasing this value will reduce computation time, but also reduce accuracy.</desc>
                            <sample for="lua">Image.Matching.PatternMatcher.setDownsampleFactor(locator, 10.0)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PatternMatcher" desc="The instance to use."/>
                            <param name="downsampleFactor" type="float" desc="A factor larger than or equal to 1.0. The default value is 16."/>
                        </function>
                        <function name="getDownsampleFactor">
                            <desc>Gets the current downsample parameter setting.</desc>
                            <sample for="lua">downsampleFactor = Image.Matching.PatternMatcher.getDownsampleFactor(locator)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PatternMatcher" desc="The instance to use."/>
                            <return name="downsampleFactor" type="float" multiplicity="?" desc="The current downsample factor."/>
                        </function>
                        <function name="setMaxMatches">
                            <desc>Sets the maximum number of objects to find in a match call. The actual number of matches found can be smaller than this number. This parameter can be changed without re-teaching.</desc>
                            <sample for="lua">Image.Matching.PatternMatcher.setMaxMatches(locator, 3)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PatternMatcher" desc="The instance to use."/>
                            <param name="matchCount" type="int" desc="An integer larger or equal than 1 specifying the maximum number of object to find."/>
                        </function>
                        <function name="getMaxMatches">
                            <desc>Gets the current maximum number of objects to find.</desc>
                            <sample for="lua">matchCount = Image.Matching.PatternMatcher.getMaxMatches(locator)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PatternMatcher" desc="The instance to use."/>
                            <return name="matchCount" type="int" multiplicity="?" desc="The current maximum number of objects to find."/>
                        </function>
                        <function name="setMinSeparation">
                            <desc>Sets the minimum separation between the centers of object matches.  The unit is in image world units (typically millimeters) taking the image pixel size into account. For 2D images the pixel size is by default 1.0, in which case the value equals the separation in pixels. This parameter can be changed without re-teaching.</desc>
                            <sample for="lua">Image.Matching.PatternMatcher.setMinSeparation(locator, 50)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PatternMatcher" desc="The instance to use."/>
                            <param name="minSeparation" type="float" desc="The minimum separation between the centers of two objects in image world units. The default value is 50."/>
                        </function>
                        <function name="getMinSeparation">
                            <desc>Gets the current minimum separation between centers of object matches.</desc>
                            <sample for="lua">minSeparation = Image.Matching.PatternMatcher.getMinSeparation(locator)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PatternMatcher" desc="The instance to use."/>
                            <return name="minSeparation" type="float" multiplicity="?" desc="The minimum separation between the centers of two objects in image world units."/>
                        </function>
                        <function name="setTimeout">
                            <desc>Abort the match call if the match time exceeds a user-defined number of seconds. The default value is 5 seconds. This parameter can be changed without re-teaching.</desc>
                            <sample for="lua">Image.Matching.PatternMatcher.setTimeout(locator, 10.0)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PatternMatcher" desc="The instance to use."/>
                            <param name="timeoutSeconds" type="float" desc="Time in seconds after which the algorithm should abort."/>
                        </function>
                        <function name="getTimeout">
                            <desc>Gets the selected timeout for matching.</desc>
                            <sample for="lua">timeoutSeconds = Image.Matching.PatternMatcher.getTimeout(locator)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PatternMatcher" desc="The instance to use."/>
                            <return name="timeoutSeconds" type="float" multiplicity="?" desc="Time in seconds after which the algorithm will abort."/>
                        </function>
                        <function name="proposeDownsampleFactor">
                            <trait>hidden</trait>
                            <desc>A support function that proposes a downsample factor to use for the PatternMatcher. The proposal is a trade-off between speed and robustness, and it is only based on the image size used for matching. Depending on the computational power and desired robustness for the application, other values for the downsampling may be necessary.</desc>
                            <sample for="lua">Image.Matching.PatternMatcher.proposeDownsampleFactor(locator, image)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PatternMatcher" desc="The instance to use."/>
                            <param name="image" type="const object" alias="Image" desc="An image with size that the PatternMatcher will work on."/>
                            <return name="downsampleFactor" type="float" multiplicity="?" desc="The proposed downsample factor."/>
                        </function>
                        <function name="setConstantScale">
                            <trait>hidden</trait>
                            <desc>Sets relative scale of objects to detect relative to teach object, default 1.0.</desc>
                            <sample for="lua">Image.Matching.PatternMatcher.setConstantScale(locator, objectScale)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PatternMatcher" desc="The instance to use."/>
                            <param name="objectScale" type="float" desc="Size of objects relative to teach object."/>
                        </function>
                        <function name="setScaleSearch">
                            <desc>Activates searching for objects of different scales, from minimalSize to maximalSize. By default, no scale search is active, corresponding to setScaleSearch(1.0, 1.0).</desc>
                            <sample for="lua">Image.Matching.PatternMatcher.setScaleSearch(locator, minimalScale, maximalScale)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PatternMatcher" desc="The instance to use"/>
                            <param name="minimalScale" type="float" desc="Size of objects relative to teach object, 0.5 searches for objects down to half the size of the teach object."/>
                            <param name="maximalScale" type="float" desc="Size of objects relative to teach object, 2.0 searches for objects up to double the size of the teach object."/>
                        </function>
                        <function name="setEdgeSensitivity">
                            <desc>Sets sensitivity to edge pixel intensity values used when matching. Sharp edges generate large errors for noisy edge positions, setting a low sensitivity (default) reduces errors due to small edge position variations among objects and typically increases the performance of the matcher.</desc>
                            <sample for="lua">Image.Matching.PatternMatcher.setEdgeSensitivity(locator, edgeSensitivity)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PatternMatcher" desc="The instance to use."/>
                            <param name="edgeSensitivity" type="enum" ref="EdgeSensitivity" desc="Sensitivity to edge pixels (e.g.: LOW, HIGH)."/>
                        </function>
                        <function name="getTeachPose">
                            <trait>released</trait>
                            <desc>Returns the teach pose that was created and returned by the last teach call. If the last teach was unsuccessful, nil is returned.</desc>
                            <sample for="lua">teachPose = Image.Matching.PatternMatcher.getTeachPose(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.PatternMatcher" desc="The instance to use."/>
                            <return name="teachPose" type="object" multiplicity="?" alias="Transform" desc="Pose transform transforming the object model to its position in the teach image, or nil if unsuccessful."/>
                        </function>
                        <function name="getModelBoundingBox">
                            <desc>Get a bounding box of the teach object centered on the image world origin. It can be transformed directly by the pose transformations obtained from match to visualize matching results.</desc>
                            <sample for="lua">modelBox = Image.Matching.PatternMatcher.getModelBoundingBox(locator)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PatternMatcher" desc="The instance to use."/>
                            <return name="modelBox" type="object" multiplicity="?" alias="Shape" desc="A rectangle Shape representing the bounding box of the teach region, or nil if unsuccessful."/>
                        </function>
                        <function name="getModelPatch">
                            <trait>hidden</trait>
                            <desc>Get the model patch image and pixel region from a trained matcher.</desc>
                            <sample for="lua">patchImage, patchRegion = Image.Matching.PatternMatcher.getModelPatch(locator)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PatternMatcher" desc="The instance to use."/>
                            <return name="patchImage" type="object" multiplicity="?" alias="Image" desc="Patch image, cropped to bounding box of object, or nil if unsuccessful."/>
                            <return name="patchRegion" type="object" multiplicity="?" alias="Image.PixelRegion" desc="Patch region, or nil if unsuccessful."/>
                        </function>
                        <function name="getDownsampledImage">
                            <trait>hidden</trait>
                            <desc>Generates a downsampled image using the current coarsest downsampling factor.</desc>
                            <sample for="lua">downsampledImage = Image.Matching.PatternMatcher.getDownsampledImage(locator, image)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PatternMatcher" desc="The instance to use."/>
                            <param name="image" type="const object" alias="Image" desc="Image to downsample."/>
                            <return name="downsampledImage" type="object" multiplicity="?" alias="Image" desc="Downsampled image, or nil if unsuccessful."/>
                        </function>
                        <function name="teach">
                            <links>Image.Matching.PatternMatcher.match</links>
                            <desc>Teaches an object model from an image. It is important to set a reasonable downsample factor and the desired rotational range beforehand.</desc>
                            <sample for="lua">teachPose = Image.Matching.PatternMatcher.teach(locator, teachImage, teachRegion)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PatternMatcher" desc="The instance to use."/>
                            <param name="teachImage" type="const object" alias="Image" desc="The teach image."/>
                            <param name="teachRegion" type="const auto" desc="A pixel region or closed 2D shape defining which area to consider as containing the object."/>
                            <return name="teachPoseTransform" type="object" multiplicity="?" alias="Transform" desc="Pose transform of the object model, or nil if unsuccessful."/>
                        </function>
                        <function name="match">
                            <links>Image.Matching.PatternMatcher.teach</links>
                            <desc>Finds objects in an image by matching with the teach model. A teach call must be made first. The output is a vector of pose transforms, one transform for each found match. The transform describes how the object model is transformed to matched positions in the live image.</desc>
                            <sample for="lua">transforms, scores = Image.Matching.PatternMatcher.match(locator, liveImage)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PatternMatcher" desc="The matcher instance to use."/>
                            <param name="liveImage" type="const object" alias="Image" desc="The live image to find the object in."/>
                            <param name="searchRegion" type="const object" multiplicity="?" alias="Shape" desc="Optional search region in the live image, must be a rectangle."/>
                            <return name="poseTransforms" type="object" multiplicity="*" alias="Transform" desc="Pose transforms defining the location of each detected object."/>
                            <return name="matchScores" type="float" multiplicity="*" desc="A score between 0.0 and 1.0 for each detected object (high score means good match)."/>
                        </function>
                        <function name="matchCloseTo">
                            <trait>hidden</trait>
                            <desc>Finds an object in an image close to the given pose. The match score and pose of the found object is returned. The relative pose in relation to the expected pose can be found by Transform.decomposeRelativePose2D.</desc>
                            <sample for="lua">pose, score = Image.Matching.PatternMatcher.matchCloseTo(handle, liveImage, expectedPose, translationSearchRange, rotationSearchRange)</sample>
                            <param name="handle" type="handle" alias="Image.Matching.PatternMatcher" desc="The matcher instance to use."/>
                            <param name="liveImage" type="const object" alias="Image" desc="The live image to find the object in."/>
                            <param name="expectedPose" type="const object" alias="Transform" desc="The expected pose of the object to locate."/>
                            <param name="translationSearchRange" type="float" desc="The search distance in all directions, in world coordinates."/>
                            <param name="rotationSearchRange" type="float" desc="The rotational search distance, in radians."/>
                            <return name="pose" type="object" multiplicity="?" alias="Transform" desc="The pose of the found object, in world coordinates."/>
                            <return name="score" type="float" multiplicity="?" desc="The match score of the best match, the range is -1 to 1 (best)."/>
                        </function>
                        <function name="toString">
                            <desc>Returns a human readable description of the matcher, including parameters.</desc>
                            <sample for="lua">description = Image.Matching.PatternMatcher.toString(handle)</sample>
                            <param name="handle" type="handle" alias="Image.Matching.PatternMatcher" desc="The matcher instance to use."/>
                            <return name="description" type="string" multiplicity="?" desc="A description of the matcher object, or nil on failure."/>
                        </function>
                    </serves>
                </crown>
                <crown name="PatternVerifier">
                    <trait>released</trait>
                    <keywords>correlation, verification, checking, comparison, pixel</keywords>
                    <links>Image.Matching.PatternMatcher</links>
                    <desc>Verifies a pixel value pattern. Create a new instance using the create function, set parameters using the set functions, teach the correct pattern from a reference image and call verify to find the similarity to the taught pattern. The PatternVerifier can tolerate some errors in the given translation, rotation and scale of the pattern to verify, however for large uncertainties, use a matcher object to find the pattern first. By default all tolerances are set to zero. Results are given as similarity scores as well as an image indicating where the differences are. A refined pose is returned.</desc>
                    <enum name="EdgeSensitivity" trait="released">
                        <item name="High" desc="All pixels contribute to the verification.">HIGH</item>
                        <item name="Low" desc="Pixels close to edges are excluded.">LOW</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <desc>Creates a new pattern verifier for pixel value pattern verification.</desc>
                            <sample for="lua">verifier = Image.Matching.PatternVerifier.create()</sample>
                            <return name="verifier" type="handle" alias="Image.Matching.PatternVerifier" desc="The new instance."/>
                        </function>
                        <function name="setPositionTolerance">
                            <desc>Sets how much the position of the pattern may deviate from the pose given to the verify function. Narrowing the translational search range speeds up the verification considerably. The range is given as a distance in world units, allowing the pattern to be translated up to plus/minus the distance along both dimensions.</desc>
                            <sample for="lua">Image.Matching.PatternVerifier.setPositionTolerance(verifier, 2.0)</sample>
                            <param name="verifier" type="handle" alias="Image.Matching.PatternVerifier" desc="The instance to use."/>
                            <param name="translation" type="float" desc="Allowed distance in world units. The default tolerance is zero."/>
                        </function>
                        <function name="setRotationTolerance">
                            <desc>Sets how much the rotation of the pattern may deviate from the pose given to the verify function. Narrowing the rotation search range speeds up the verification considerably. The range is given as an angle in radian units. The rotation range interval is plus/minus the specified angle.</desc>
                            <sample for="lua">Image.Matching.PatternVerifier.setRotationTolerance(verifier, 3.1415/16)</sample>
                            <param name="verifier" type="handle" alias="Image.Matching.PatternVerifier" desc="The instance to use."/>
                            <param name="rotationRad" type="float" desc="Angle in radian units, the maximum deviation from the given object orientation to search for. The default tolerance is zero."/>
                        </function>
                        <function name="setScaleTolerance">
                            <desc>Sets how much the scale of the pattern may deviate from the pose given to the verify function. Narrowing the scale search range speeds up the verification considerably. The range is given as the minimum and maximum size of the pattern, relative to the transformation supplied to the verify function. The default is no scale change tolerance, i.e., setScaleTolerance(1.0, 1.0).</desc>
                            <sample for="lua">Image.Matching.PatternVerifier.setScaleTolerance(verifier, 0.9, 1.1)</sample>
                            <param name="verifier" type="handle" alias="Image.Matching.PatternVerifier" desc="The instance to use."/>
                            <param name="minimumScale" type="float" desc="Minimum relative scale to accept, e.g. setting to 0.9 allows pattern sizes down to 90%."/>
                            <param name="maximumScale" type="float" desc="Maximum relative scale to accept, e.g. setting to 1.1 allows pattern sizes up to 110%."/>
                        </function>
                        <function name="setNoSearch">
                            <trait>hidden</trait>
                            <desc>Disables pattern search, that is, sets translation, rotation and scale tolerances to zero.</desc>
                            <sample for="lua">Image.Matching.PatternVerifier.setNoSearch(verifier)</sample>
                            <param name="verifier" type="handle" alias="Image.Matching.PatternVerifier" desc="The instance to use."/>
                        </function>
                        <function name="setTimeout">
                            <desc>Abort the verify call if the verify time exceeds a user-defined number of seconds. The default value is 5 seconds.</desc>
                            <sample for="lua">Image.Matching.PatternVerifier.setTimeout(verifier, 2.0)</sample>
                            <param name="verifier" type="handle" alias="Image.Matching.PatternVerifier" desc="The instance to use."/>
                            <param name="timeoutSeconds" type="float" desc="Time in seconds after which the algorithm should abort."/>
                        </function>
                        <function name="setEdgeSensitivity">
                            <desc>Sets the sensitivity to edge pixel intensity values used when verifying. Sharp edges generate large errors for noisy edge positions, setting a low sensitivity (default) reduces errors due to small edge position variations among objects.</desc>
                            <sample for="lua">Image.Matching.PatternVerifier.setEdgeSensitivity(verifier, edgeSensitivity)</sample>
                            <param name="verifier" type="handle" alias="Image.Matching.PatternVerifier" desc="The instance to use."/>
                            <param name="edgeSensitivity" type="enum" ref="EdgeSensitivity" desc="Sensitivity to edge pixels (e.g.: HIGH, LOW)."/>
                        </function>
                        <function name="getModelBoundingBox">
                            <desc>Get a bounding box of the teach object centered on the image world origin. It can be transformed directly by the pose transformations sent to and obtained from verify to visualize the working area of the verifier.</desc>
                            <sample for="lua">modelBox = Image.Matching.PatternVerifier.getModelBoundingBox(verifier)</sample>
                            <param name="verifier" type="handle" alias="Image.Matching.PatternVerifier" desc="The instance to use."/>
                            <return name="modelBox" type="object" multiplicity="?" alias="Shape" desc="A rectangle Shape representing the bounding box of the teach region, or nil if unsuccessful."/>
                        </function>
                        <function name="getModelPatch">
                            <trait>hidden</trait>
                            <desc>Get the model patch image and pixel region from a trained verifier.</desc>
                            <sample for="lua">patchImage, patchRegion = Image.Matching.PatternVerifier.getModelPatch(verifier)</sample>
                            <param name="verifier" type="handle" alias="Image.Matching.PatternVerifier" desc="The instance to use."/>
                            <return name="patchImage" type="object" multiplicity="?" alias="Image" desc="Patch image, cropped to bounding box of object, or nil if unsuccessful."/>
                            <return name="patchRegion" type="object" multiplicity="?" alias="Image.PixelRegion" desc="Patch region, defined in the pixels of the patch image, or nil if unsuccessful."/>
                        </function>
                        <function name="teach">
                            <links>Image.Matching.PatternVerifier.verify</links>
                            <desc>Teaches a pattern from an image. The returned pose is usually appended to a Fixture related to the main inspected object.</desc>
                            <sample for="lua">teachPose = Image.Matching.PatternVerifier.teach(verifier, teachImage, teachRegion)</sample>
                            <param name="verifier" type="handle" alias="Image.Matching.PatternVerifier" desc="The instance to use."/>
                            <param name="teachImage" type="const object" alias="Image" desc="The teach image."/>
                            <param name="teachRegion" type="const object" alias="Image.PixelRegion" desc="A pixel region defining which area to consider as containing the pattern."/>
                            <return name="teachPoseTransform" type="object" multiplicity="?" alias="Transform" desc="Pose transform of the pattern, or nil if unsuccessful."/>
                        </function>
                        <function name="verify">
                            <links>Image.Matching.PatternVerifier.teach</links>
                            <desc>Verifies a pattern by comparing to the teach pattern. A teach call must be made first. Some errors in the pose can be tolerated by setting the respective tolerance values.</desc>
                            <sample for="lua">score, differenceImage, refinedPose = Image.Matching.PatternVerifier.verify(verifier, liveImage, pose)</sample>
                            <param name="verifier" type="handle" alias="Image.Matching.PatternVerifier" desc="The instance to use."/>
                            <param name="liveImage" type="const object" alias="Image" desc="The live image to verify the pattern in."/>
                            <param name="pose" type="const object" alias="Transform" desc="The pose of the pattern to be verified, usually obtained from a Fixture."/>
                            <return name="score" type="float" multiplicity="?" desc="A score between 0.0 and 1.0, or nil if unsuccessful. High score means the pattern is similar to the teach pattern."/>
                            <return name="differenceImage" type="object" multiplicity="?" alias="Image" desc="The difference image, indicating where the patterns differ, or nil if unsuccessful. Pixel values close to zero indicate areas where the patterns match. The default image contains the absolute pixel value differences between the live image and the transformed teach pattern. The difference image is sampled in an object-centered coordinate system with the origin in the center of the image, and cropped to the bounding box of the teach pattern. Any indications in the difference image should be transformed using the refinedPose to obtain the corresponding position in the live image."/>
                            <return name="refinedPose" type="object" multiplicity="?" alias="Transform" desc="The refined pose of the pattern, or nil if unsuccessful. If all tolerances are set to zero, this will be equal to the given pose."/>
                        </function>
                        <function name="generateOverlay">
                            <desc>Generates an overlay PixelRegion by thresholding a difference image. The overlay is transformed to match the latest live image and refined pose.</desc>
                            <sample for="lua">overlay = Image.Matching.PatternVerifier.generateOverlay(verifier, differenceImage, threshold)</sample>
                            <param name="verifier" type="handle" alias="Image.Matching.PatternVerifier" desc="The instance to use."/>
                            <param name="differenceImage" type="const object" alias="Image" desc="Difference image to threshold."/>
                            <param name="threshold" type="float" desc="Threshold for difference image, all pixels with values above the threshold will be included in the pixel region."/>
                            <return name="overlay" type="object" multiplicity="?" alias="Image.PixelRegion" desc="Overlay pixel region, or nil if unsuccessful."/>
                        </function>
                        <function name="toString">
                            <desc>Returns a human readable description of the pattern verifier, including parameters.</desc>
                            <sample for="lua">description = Image.Matching.PatternVerifier.toString(verifier)</sample>
                            <param name="verifier" type="handle" alias="Image.Matching.PatternVerifier" desc="The instance to use."/>
                            <return name="description" type="string" multiplicity="?" desc="A description of the verifier, or nil on failure."/>
                        </function>
                    </serves>
                </crown>
                <crown name="PointMatcher">
                    <trait>released</trait>
                    <keywords>locator, object, descriptor, interest point, landmark, feature point, keypoint, matching, perspective</keywords>
                    <links>Image.Matching.EdgeMatcher, Image.Matching.PatternMatcher, Image.Fixture</links>
                    <desc>Finds an object in an image based on feature points. Salient points are found on the reference object and similar points are searched for in the live images. Teach the object from a reference image and call match to find the location of the same object in a live image. The strength of the PointMatcher relative the EdgeMatcher is for objects whose appearance can be described in terms of textured pattern rather than clear edges or contours. The PointMatcher can also easily find large scale or perspective changes which the EdgeMatcher cannot.

The outputs from the PointMatcher are a so-called pose transform and a match score. The pose transform is a Transform object which transforms the model points extracted in the teach step to the matched location in the live image. The PointMatcher is often used together with the Fixture object that facilitates local coordinate transforms based on the pose transform. The match score is a number between 0.0 and 1.0 indicating the fraction of model points that have a match in the input image.

The most important parameters for the PointMatcher are the following:

- Pose type: This parameter tells the PointMatcher which type of appearance change to look for in the match process, e.g., does the object of interest change size relative to the teach object, does the camera position change leading to a perspective change of the imaged object, etc.? Restrict the pose type as much as possible for a more robust matching. By default, the pose type is restricted and must explicitly be set to allow more general pose transforms. See the documentation of the setPoseType-function for more information.

- Pose variability: If the object of interest is imaged from very different angles or distances, leading to large perspective or scale changes, set the pose variability to HIGH for more robustness. Otherwise, set the pose variability to LOW for a higher matching speed. Use the setPoseVariability-function to set the pose variability.

- Point count: The target number of salient points to extract. Fewer points will make the matching faster, but with too few points the matching will fail. Use setPointCount() to reduce the number of points.

- Downsample factor: Tells the PointMatcher to work on a downsampled version of the input image. This can increase speed and in some cases even robustness if the original image is of high-resolution. Setting the downsample factor too high reduces the robustness though as the feature points in the ensuing low resolution image are not distinct enough.

- Rotation range: The rotation range narrows the expected rotations relative to the teach pose. This parameter does not affect matching speed but increases robustness as false matches can be rejected. Set this range as narrow as possible but still wide enough to let valid matches through.

- Scale range: The scale range narrows the expected scale change to the teach pose. This parameter does not affect matching speed but increases robustness as false matches can be rejected. Set this range as narrow as possible but still wide enough to let valid matches through.

Restrictions:
- Only uint8 images are accepted.
- The PointMatcher can currently only find 1 object instance per image.

Image world coordinate system handling:
The image (x,y)-pixelsize and origin are considered, all calculations are made in the image world coordinate system. The output pose transforms are also expressed in the image world coordinate system.

Missing data handling:
The PointMatcher does not accept missing data images, remove missing data first before usage.</desc>
                    <enum name="PoseType" trait="released">
                        <item name="Rigid" desc="Searches for objects whose image appears translated and rotated. The scale range is ignored in this mode.">RIGID</item>
                        <item name="Similarity" desc="Searches for objects whose image appears translated, rotated and uniformly scaled.">SIMILARITY</item>
                        <item name="Affine" desc="Searches for objects whose image appears translated, rotated, non-uniformly scaled and skewed.">AFFINE</item>
                        <item name="Homography" desc="This is the most general transform, it allows e.g. out-of-plane rotation for flat objects.">HOMOGRAPHY</item>
                    </enum>
                    <enum name="DetectorDescriptorType" trait="hidden">
                        <item name="FAST" desc="The FAST detector, gridded.">FAST</item>
                        <item name="BRISK" desc="Binary robust invariant scalable keypoints.">BRISK</item>
                        <item name="BRISKGRID" desc="Gridded BRISK.">BRISKGRID</item>
                        <item name="ORB" desc="Oriented BRIEF, binary robust independent elementary features.">ORB</item>
                    </enum>
                    <enum name="PoseVariability" trait="released">
                        <item name="HIGH" desc="High pose variability: larger scale changes and visible perspective effects.">HIGH</item>
                        <item name="LOW" desc="Low pose variability: scale changes up to 30% and only small perspective effects.">LOW</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <desc>Creates a new point matcher for 2D object localization.</desc>
                            <sample for="lua">locator = Image.Matching.PointMatcher.create()</sample>
                            <return name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The new instance."/>
                        </function>
                        <function name="setMaxMatches">
                            <trait>hidden</trait>
                            <desc>Sets the maximum number of objects to find in a match call. The actual number of matches found can be smaller than this number. The default value is one. If there is only one object of the searched-for type in the live image, a much more robust matching of salient points can be performed. Thus it is recommended to leave this setting at one unless something else is specifically required.</desc>
                            <sample for="lua">Image.Matching.PointMatcher.setMaxMatches(locator, matchCount)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <param name="matchCount" type="int" desc="An integer larger or equal than 1 specifying the maximum number of object to find."/>
                        </function>
                        <function name="getMaxMatches">
                            <trait>hidden</trait>
                            <desc>Gets the current maximum number of objects to find.</desc>
                            <sample for="lua">matchCount = Image.Matching.PointMatcher.getMaxMatches(locator)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <return name="matchCount" type="int" multiplicity="?" desc="The current maximum number of objects to find."/>
                        </function>
                        <function name="setMinSeparation">
                            <trait>hidden</trait>
                            <desc>Sets the minimum separation between the centers of object matches. The unit is in image world units (typically millimeters) taking the image pixel size into account. For 2D images the pixel size is by default 1.0, in which case the value equals the separation in pixels.</desc>
                            <sample for="lua">Image.Matching.PointMatcher.setMinSeparation(locator, minSeparation)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <param name="minSeparation" type="float" desc="The minimum separation between the centers of two objects in image world units. The default value is 50."/>
                        </function>
                        <function name="getMinSeparation">
                            <trait>hidden</trait>
                            <desc>Gets the current minimum separation between centers of object matches.</desc>
                            <sample for="lua">minSeparation = Image.Matching.PointMatcher.getMinSeparation(locator)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <return name="minSeparation" type="float" multiplicity="?" desc="The minimum separation between the centers of two objects in image world units."/>
                        </function>
                        <function name="setTimeout">
                            <desc>Abort the match call if the match time exceeds a user-defined number of seconds. The default value is 5 seconds.</desc>
                            <sample for="lua">Image.Matching.PointMatcher.setTimeout(locator, timeoutSeconds)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <param name="timeoutSeconds" type="float" desc="Time in seconds after which the algorithm should abort."/>
                        </function>
                        <function name="getTimeout">
                            <trait>hidden</trait>
                            <desc>Gets the selected timeout for matching.</desc>
                            <sample for="lua">timeoutSeconds = Image.Matching.PointMatcher.getTimeout(locator)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <return name="timeoutSeconds" type="float" multiplicity="?" desc="Time in seconds after which the algorithm should abort."/>
                        </function>
                        <function name="setScaleRange">
                            <desc>Sets scale interval where objects are expected to appear. Tentative objects with a scale outside the scale range are discarded. Default range is from 0.5 to 2.0, searching for object from half to twice the size of the teach object. For transform types without a specific scale (affine and homogeneous), an approximate apparent scale is used. The scale range is ignored when the matcher is in rigid mode. For the point matcher, the search time is not affected by the scale range. A too narrow range will remove all tentative matches. An optional prior scale can be set, this affects both the minimum and maximum scale (both limits are multiplied with the prior scale). The prior scale accepts a larger range of values than the min and max scale parameters. If the object to find has a fixed non-unit scale relative to the teach object, or if prior information on the scale of the object is available, use the prior scale. The default value is 1.0. By setting both minScale and maxScale to 1.0, scale search is disabled but the prior scale parameter still has effect. These parameters can be updated in a teached matcher without re-teaching.</desc>
                            <sample for="lua">Image.Matching.PointMatcher.setScaleRange(matcher, minScale, maxScale)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <param name="minScale" type="float" desc="The smallest scale factor to allowed."/>
                            <param name="maxScale" type="float" desc="The largest scale factor to allowed."/>
                            <param name="priorScale" type="float" multiplicity="?" desc="Optional prior scale factor. Set to the expected scale of the object to find, relative to the size of the teach object. E.g. 1.25 if the object to find is 25% larger than the teach object."/>
                        </function>
                        <function name="getScaleRange">
                            <trait>hidden</trait>
                            <desc>Gets scale interval used to filter tentative found objects, and the general prior scale factor.</desc>
                            <sample for="lua">minimalScale, maximalScale = Image.Matching.PointMatcher.getScaleRange(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <return name="minimalScale" type="float" multiplicity="?" desc="The smallest scale factor allowed."/>
                            <return name="maximalScale" type="float" multiplicity="?" desc="The largest scale factor allowed."/>
                            <return name="priorScale" type="float" multiplicity="?" desc="Prior scale factor. Set to the expected scale of the object to find, relative to the size of the teach object. Default is 1.0."/>
                        </function>
                        <function name="setRotationRange">
                            <desc>Sets rotation interval to search within, in relation to the teach orientation. The search range is given as a positive angle in radians. The rotation range interval is plus/minus the specified angle. The default value is PI radians, i.e., equal to a full rotation of plus/minus 180 degrees. For the point matcher, the search time is not affected by the rotation range. A too narrow range will remove all tentative matches.  If prior orientation information is known, the prior rotation can be set to allow a more narrow search range. The final search range is then up to plus/minus the search range parameter starting from the prior rotation. These parameters can be updated in a teached matcher without re-teaching.

When pose type is set to RIGID or SIMILARITY, setting the rotation range to zero will force the matcher to look for pure translations, or translation and scaling only.</desc>
                            <sample for="lua">Image.Matching.PointMatcher.setRotationRange(matcher, rotationRad)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <param name="rotationRad" type="float" desc="Angle in radians, the maximum deviation from the original object orientation to search for. The default value is PI. Input is silently clamped to the range from 0 to PI."/>
                            <param name="priorRotationRad" type="float" multiplicity="?" desc="Optional prior orientation in radians. If specified, the orientation search range is centered around this orientation. Default is zero (i.e. same orientation as teach object)."/>
                        </function>
                        <function name="getRotationRange">
                            <trait>hidden</trait>
                            <desc>Gets the rotation interval to search within, in relation to the teach orientation.</desc>
                            <sample for="lua">rotationRad = Image.Matching.PointMatcher.getRotationRange(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <return name="rotationRad" type="float" multiplicity="?" desc="Angle in radians, the maximum deviation from the original object orientation to search for."/>
                            <return name="priorRotationRad" type="float" multiplicity="?" desc="Prior orientation in radians. The orientation search is centered around this value. The default is zero, i.e. searching around the same orientation as the teach object."/>
                        </function>
                        <function name="setDownsampleFactor">
                            <desc>Sets the factor in the x- and y-dimensions for the internal downsampling of the image. Increasing this value will reduce the time required for detecting salient points. A larger downsampling factor may improve results in cases where the image structure is smooth or slightly out of focus. A higher downsampling factor reduces the accuracy of the estimated pose.</desc>
                            <sample for="lua">Image.Matching.PointMatcher.setDownsampleFactor(matcher, downsampleFactor)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use. Default is 2.0."/>
                            <param name="downsampleFactor" type="float" desc="A factor larger than or equal to 1.0."/>
                        </function>
                        <function name="getDownsampleFactor">
                            <trait>hidden</trait>
                            <desc>Gets the current downsample parameter setting.</desc>
                            <sample for="lua">downsampleFactor = Image.Matching.PointMatcher.getDownsampleFactor(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <return name="downsampleFactor" type="float" multiplicity="?" desc="The current downsample factor."/>
                        </function>
                        <function name="setPointCount">
                            <desc>Sets the desired number of salient points to detect in an image. The final number of points may be larger or smaller. The desired number of points is related to the full image. For a part of an image, the number of found points is lower in general.</desc>
                            <sample for="lua">Image.Matching.PointMatcher.setPointCount(locator, desiredPointCount)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <param name="desiredPointCount" type="int" desc="A larger number generates more keypoints, default 1000. "/>
                        </function>
                        <function name="getPointCount">
                            <trait>hidden</trait>
                            <desc>Gets the desired point count of the detector.</desc>
                            <sample for="lua">desiredPointCount = Image.Matching.PointMatcher.getPointCount(locator)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <return name="desiredPointCount" type="int" multiplicity="?" desc="The target number of salient points to extract from an image."/>
                        </function>
                        <function name="setOctaves">
                            <trait>hidden</trait>
                            <desc>Controls the search for salient points at different scales and also the tolerance to scale changes. A larger number increases the tolerance.</desc>
                            <sample for="lua">Image.Matching.PointMatcher.setOctaves(locator, octaves)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <param name="octaves" type="int" desc="A larger number leads to searching among larger scale variations, default 2."/>
                        </function>
                        <function name="getOctaves">
                            <trait>hidden</trait>
                            <desc>Gets the salient point scale tolerance number.</desc>
                            <sample for="lua">octaves = Image.Matching.PointMatcher.getOctaves(locator)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <return name="octaves" type="int" multiplicity="?" desc="A larger number leads to searching among larger scale variations."/>
                        </function>
                        <function name="setPoseVariability">
                            <desc>Set to the expected variability in pose of the objects in the live image. Setting a higher variability will use more robust salient point detectors and descriptors but those will be slower in most cases. In general, try the lowest setting first and change to higher settings if required.

"HIGH" - The default value, more robust but also slower in general.
"LOW" - Faster in general and should be fine for any rotation, scale changes up to at least 30% and small perspective effects. When using this mode, the image size in pixels must be the same for all images.</desc>
                            <sample for="lua">Image.Matching.PointMatcher.setPoseVariability(locator, variability)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <param name="variability" type="enum" ref="PoseVariability" desc="The expected pose variability of objects in the live image."/>
                        </function>
                        <function name="setDetectorType">
                            <trait>hidden</trait>
                            <desc>Sets the type of point matcher and descriptor to be used.

"FAST" - The FAST detector, gridded.
"BRISK" - Binary robust invariant scalable keypoints (DEFAULT).
"BRISKGRID" - Gridded brisk.
"ORB" - Oriented BRIEF, binary robust independent elementary features.</desc>
                            <sample for="lua">Image.Matching.PointMatcher.setDetectorType(locator, detector)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <param name="detector" type="enum" ref="DetectorDescriptorType" desc="The detector/descriptor to be used for finding keypoints."/>
                        </function>
                        <function name="getDetectorType">
                            <trait>hidden</trait>
                            <desc>Gets the type of point matcher and descriptor used.</desc>
                            <sample for="lua">detector = Image.Matching.PointMatcher.getDetectorType(locator)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <return name="detector" type="enum" multiplicity="?" ref="DetectorDescriptorType" desc="The detector/descriptor used for finding keypoints."/>
                        </function>
                        <function name="setPoseType">
                            <desc>The pose type puts a limit on the generality of pose transforms returned by the match function. In the following list, the first option is the most restrictive and every new type contains all previously listed types as special cases.

"RIGID" - Searches for objects whose image appears translated and rotated. The scale range is ignored in this mode. Set rotation range to zero for pure translations.
"SIMILARITY" - Searches for objects whose image appears translated, rotated and uniformly scaled. This is the default option. Set rotation range to zero for translation and scaling only.
"AFFINE" - Searches for objects whose image appears translated, rotated, non-uniformly scaled and skewed.
"HOMOGRAPHY" - This is the most general transform, it allows e.g. out-of-plane rotation for flat objects.</desc>
                            <sample for="lua">Image.Matching.PointMatcher.setPoseType(locator, poseTransformType)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <param name="poseTransformType" type="enum" ref="Image.Matching.PointMatcher.PoseType" desc="The type of pose transformation to allow when searching for matching objects."/>
                        </function>
                        <function name="getPoseType">
                            <trait>hidden</trait>
                            <desc>Gets the most general allowed pose transform type for the geometrically matching objects.</desc>
                            <sample for="lua">poseTransformType = Image.Matching.PointMatcher.getPoseType(locator)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <return name="poseTransformType" type="enum" multiplicity="?" ref="Image.Matching.PointMatcher.PoseType" desc="The type of pose transformation allowed when searching for matching objects."/>
                        </function>
                        <function name="setOutlierMargin">
                            <desc>Set the outlier margin in world units, must be greater than zero. The point matcher searches for the transform that is supported by the highest number of salient points. This setting determines how far a transformed model point can be from the corresponding live image point before it is considered an outlier and not supporting the current transform hypothesis.
Decreasing this parameter will require the salient points of the template and live images to be geometrically more coherent. A too small value will remove almost all point match candidates, which will reduce object match accuracy significantly.</desc>
                            <sample for="lua">Image.Matching.PointMatcher.setOutlierMargin(locator, margin)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <param name="margin" type="float" desc="Outlier margin in world units, the default is 5.0."/>
                        </function>
                        <function name="getOutlierMargin">
                            <trait>hidden</trait>
                            <desc>Gets the outlier margin in world units for the final geometrical fitting step.</desc>
                            <sample for="lua">margin = Image.Matching.PointMatcher.getOutlierMargin(locator)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <return name="margin" type="float" multiplicity="?" desc="Outlier margin in world units."/>
                        </function>
                        <function name="setIterations">
                            <desc>Sets the maximum number of iterations in the geometrical robust fitting step. Decreasing this parameter makes the geometrical matching faster, however using too small values, good matches may be missed. When a match with high probability of being the correct one is found, fewer iterations may be used. The number of iterations set here is also used to control the probability threshold, where a higher number of iterations corresponds to requiring a higher probability of a correct match before stopping the iteration in advance.</desc>
                            <sample for="lua">Image.Matching.PointMatcher.setIterations(locator, iterations)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <param name="iterations" type="int" desc="Number of iterations, must be larger than one, the default is 5000."/>
                        </function>
                        <function name="getIterations">
                            <trait>hidden</trait>
                            <desc>Gets the maximum number of iterations in the geometrical robust fitting step.</desc>
                            <sample for="lua">iterations = Image.Matching.PointMatcher.getIterations(locator)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <return name="iterations" type="int" multiplicity="?" desc="Number of iterations."/>
                        </function>
                        <function name="getModelPoints">
                            <links>Image.Matching.PointMatcher.getDetectedPoints</links>
                            <desc>Gets the list of salient points detected during the last teach call as a vector of 2D Points. The points are returned in internal model coordinates and must be transformed using a pose transform to overlay them onto the teach or live image. A maximum number of points to return may be specified. The default is to return all points. This function is intended for graphical feedback. Note: to control the number of points detected in the image and used when matching, use the setPointCount function.</desc>
                            <sample for="lua">points = Image.Matching.PointMatcher.getModelPoints(locator, maxCount)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <param name="maxCount" type="int" multiplicity="?" desc="Optional parameter to specify the maximum number of points to return. Default is to return all points. Note that one can obtain fewer points than the value specified here."/>
                            <return name="points" type="object" multiplicity="+" alias="Point" desc="Salient model points in internal model coordinates, may be empty."/>
                        </function>
                        <function name="getDetectedPoints">
                            <links>Image.Matching.PointMatcher.getModelPoints</links>
                            <desc>Fetches two lists with salient points that were detected in the live image during the last match call. Points are returned in world coordinates and are intended to be plotted directly on the live image for graphical feedback. The first list contains all detected points while the second list only contains those points that were matched and found to be geometrically consistent with the corresponding model point under the found pose transformation.</desc>
                            <sample for="lua">detectedPointsWorld, matchedPointsWorld = Image.Matching.PointMatcher.getDetectedPoints(locator)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <return name="detectedPointsWorld" type="object" multiplicity="+" alias="Point" desc="Detected salient points during the last call to match, may be empty."/>
                            <return name="matchedPointsWorld" type="object" multiplicity="+" alias="Point" desc="Matched points in the last live image, in world coordinates. The matched points are a subset of the detected salient points."/>
                        </function>
                        <function name="getCorrespondingModelPoints">
                            <trait>hidden</trait>
                            <desc>Fetches a list of points from the internal model that were matched to live image points. The points are ordered such that the first point in the list was matched to the first point in the second list returned by getDetectedPoints, and so on. The model points are in the internal model coordinate system and can be transformed to the respective image using either the teach transform or a match transform. The set of matched model points is a subset of the detected points returned from getModelPoints(). Points may appear more than once, especially for multiple matched objects.</desc>
                            <sample for="lua">matchedModelPoints = Image.Matching.PointMatcher.getCorrespondingModelPoints(locator)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <return name="matchedModelPoints" type="object" multiplicity="+" alias="Point" desc="Matched points in the teach image, in the internal model coordinate system."/>
                        </function>
                        <function name="getTeachPose">
                            <trait>released</trait>
                            <desc>Returns the teach pose that was created and returned by the last teach call. If the last teach was unsuccessful, nil is returned.</desc>
                            <sample for="lua">teachPose = Image.Matching.PointMatcher.getTeachPose(matcher)</sample>
                            <param name="matcher" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use"/>
                            <return name="teachPose" type="object" multiplicity="?" alias="Transform" desc="Pose transform transforming the object model to its position in the teach image, or nil if unsuccessful."/>
                        </function>
                        <function name="toString">
                            <desc>Get a user-friendly string description of the matcher. The parameters are the internal parameters of the matcher, call teach for parameter changes to take effect and appear in the description string.</desc>
                            <sample for="lua">description = Image.Matching.PointMatcher.toString(locator)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <return name="description" type="string" multiplicity="?" desc="User-friendly description of the matcher."/>
                        </function>
                        <function name="teach">
                            <links>Image.Matching.PointMatcher.match</links>
                            <desc>Teaches an object model from an image. Use getModelPoints after teach to visualize the detected salient points on the teach object.</desc>
                            <sample for="lua">teachPose = Image.Matching.PointMatcher.teach(locator, teachImage, teachRegion)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The instance to use."/>
                            <param name="teachImage" type="const object" alias="Image" desc="The teach image."/>
                            <param name="teachRegion" type="const auto" desc="A pixel region or closed 2D shape defining which area to consider as containing the object."/>
                            <return name="teachPoseTransform" type="object" multiplicity="?" alias="Transform" desc="Pose transform of the object model, or nil if unsuccessful."/>
                        </function>
                        <function name="match">
                            <links>Image.Matching.PointMatcher.teach</links>
                            <desc>Finds objects in an image by matching with the teach model. A teach call must be made first. The output is a vector of pose transforms with one or zero entries, or nil. An empty vector indicates that no object was found while nil indicates that the matcher encountered an error. The transform describes how the object model is transformed to matched positions in the live image. The optional search region indicates where salient points will be extracted and should include the entire area where the object may appear. By default, the entire image is used. Use getDetectedPoints after match to visualize detected salient points in the live image and salient points matched to the model.</desc>
                            <sample for="lua">poseTransforms, matchScores, inlierRMS = Image.Matching.PointMatcher.match(locator, liveImage)</sample>
                            <param name="locator" type="handle" alias="Image.Matching.PointMatcher" desc="The matcher instance to use."/>
                            <param name="liveImage" type="const object" alias="Image" desc="The live image to find the object in."/>
                            <param name="searchRegion" type="const object" multiplicity="?" alias="Shape" desc="Optional search region in the live image, must be a rectangle."/>
                            <return name="poseTransforms" type="object" multiplicity="*" alias="Transform" desc="Pose transform defining the location of any detected object. Note that this is a vector with at most one element/transform for future compatibility when adding multiple matches."/>
                            <return name="matchScores" type="float" multiplicity="*" desc="A score between 0.0 and 1.0 for any detected object (high score means good match). Note that this is a vector with at most one element/score for future compatibility when adding multiple matches."/>
                            <return name="inlierRMS" type="float" multiplicity="*" desc="The root mean squared error among inlier points in world coordinates (lower is better). Note that this is a vector with at most one element/value for future compatibility when adding multiple matches."/>
                        </function>
                    </serves>
                </crown>
            </crown>
            <crown name="ShapeFitter">
                <trait>released</trait>
                <keywords>fitting, least squares, RANSAC, edges, contour, model</keywords>
                <links>Image.SurfaceFitter, Shape</links>
                <desc>This is a tool for fitting geometrical object like lines, circles and ellipses to edges and contours in an image. For grayscale images, the geometrical objects are fitted to transitions between dark and bright image contents. For heightmaps, they are fitted to transitions between low and high z values.

To get started, create a ShapeFitter with the create function and then call fitLine, fitCircle or fitEllipse to adjust a line, circle or ellipse to fit to the image data. These are primarily intended for intensity images, however images with missing data are supported.
For height maps, the function fitLine3D fits a 3D line to edges in the height map.

For more detailed control of the fitting behavior, call the set functions before calling the fit function.

The shape fitting procedure consists of the following steps:
- A number of probe lines are created along the search region. An edge point is found on each probe line.
- The geometrical object that best fits to the detected edge points is returned.</desc>
                <enum name="EdgeSelection" trait="released">
                    <item name="strongest" desc="Strongest edge found">STRONGEST</item>
                    <item name="first" desc="First edge found">FIRST</item>
                    <item name="last" desc="Last edge found">LAST</item>
                </enum>
                <serves>
                    <function name="create">
                        <trait>released</trait>
                        <desc>Create a shape fitter with default settings.</desc>
                        <sample for="lua">shapeFitter = Image.ShapeFitter.create()</sample>
                        <return name="shapeFitter" type="handle" alias="Image.ShapeFitter" desc="Created shape fitter."/>
                    </function>
                    <function name="setPolarity">
                        <trait>released</trait>
                        <links>Image.ShapeFitter.setSide, Image.ShapeFitter.setSelection</links>
                        <desc>Set the edge polarity that the shape fitter is looking for.
This controls the kind of transition that the fitter will look for:
- POSITIVE means dark-to-bright for grayscale images, and low-to-high for heightmaps.
- NEGATIVE means bright-to-dark for grayscale images and high-to-low for heightmaps.
- ANY means any of the above (default).
This is related to the probe direction, which for line fitting is a parameter to fitLine. For circle and ellipse fitting, the probe direction is always from the center and out.</desc>
                        <sample for="lua">Image.ShapeFitter.setPolarity(shapeFitter, "POSITIVE")</sample>
                        <param name="shapeFitter" type="handle" alias="Image.ShapeFitter" desc="Shape fitter to use."/>
                        <param name="polarity" type="enum" ref="Profile.SlopePolarity" desc="Edge polarity."/>
                    </function>
                    <function name="setProbeCount">
                        <trait>released</trait>
                        <desc>Set the edge probe count.
A lower number reduces computation time but also reduces accuracy. If a very large number if specified, the number of probes is limited such that the spacing between probes is at most one pixel. Default: 100 probes.</desc>
                        <sample for="lua">Image.ShapeFitter.setProbeCount(shapeFitter, count)</sample>
                        <param name="shapeFitter" type="handle" alias="Image.ShapeFitter" desc="Shape fitter to use."/>
                        <param name="count" type="int" desc="Probe count. Must be &gt;= 4."/>
                    </function>
                    <function name="setSelection">
                        <trait>released</trait>
                        <links>Image.ShapeFitter.setSide, Image.ShapeFitter.setPolarity</links>
                        <desc>Decide which edge point to select if there are several candidates available.
The selection is related to the probe direction, which for line fitting is a parameter to fitLine. For circle and ellipse fitting, the probe direction is always from the center and out. If using FIRST or LAST, remember to set the edge threshold.
- STRONGEST selects the strongest edge along the probe (default).
- FIRST selects the first edge encountered along the probe.
- LAST selects the last edge encountered along the probe.</desc>
                        <sample for="lua">Image.ShapeFitter.setSelection(shapeFitter, "FIRST")</sample>
                        <param name="shapeFitter" type="handle" alias="Image.ShapeFitter" desc="Shape fitter to use."/>
                        <param name="selection" type="enum" ref="EdgeSelection" desc="Edge selection criteria."/>
                    </function>
                    <function name="setSide">
                        <trait>released</trait>
                        <links>Image.ShapeFitter.setSelection, Image.ShapeFitter.setPolarity</links>
                        <desc>Decide which side of the edge to adjust to.
This will adjust the edge points slightly towards the high or low side of the edge, or keep the edge at the center.
- CENTER centers the point on the edge (default for intensity images).
- HIGH selects the point on the high/bright side of the edge (default for heightmaps and images with missing data).
- LOW selects the point on the low/dark side of the edge.</desc>
                        <sample for="lua">Image.ShapeFitter.setSide(shapeFitter, "HIGH")</sample>
                        <param name="shapeFitter" type="handle" alias="Image.ShapeFitter" desc="Shape fitter to use."/>
                        <param name="side" type="enum" ref="Profile.EdgeSide" desc="Edge side."/>
                    </function>
                    <function name="setInterpolation">
                        <trait>released</trait>
                        <desc>Set which interpolation method to use in the edge profiles.
The default value, NEAREST, is often a good choice. Changing to LINEAR can give slightly better accuracy, but with additional computational cost.</desc>
                        <sample for="lua">Image.ShapeFitter.setInterpolation(shapeFitter, "LINEAR")</sample>
                        <param name="shapeFitter" type="handle" alias="Image.ShapeFitter" desc="Shape fitter to use."/>
                        <param name="interpolation" type="enum" ref="InterpolationMethod" desc="Interpolation method."/>
                    </function>
                    <function name="setDifferenceStep">
                        <trait>released</trait>
                        <links>Image.ShapeFitter.setThreshold</links>
                        <desc>Controls the distance between the two points from which the edge height / strength is measured.
Increasing this value can improve the accuracy for very blurred edges, where there is no sharp transition from dark to bright (or from low to high z value for heightmaps).</desc>
                        <sample for="lua">Image.ShapeFitter.setDifferenceStep(shapeFitter, 5)</sample>
                        <param name="shapeFitter" type="handle" alias="Image.ShapeFitter" desc="Shape fitter to use."/>
                        <param name="step" type="int" desc="Difference step in pixels, must be greater than or equal to 1. The default values is 2."/>
                    </function>
                    <function name="setThreshold">
                        <trait>released</trait>
                        <links>Image.ShapeFitter.setDifferenceStep, Image.ShapeFitter.setSelection</links>
                        <desc>Set the edge threshold.
For grayscale images, this can be interpreted as the required edge sharpness. For heightmaps, this can be interpreted as the edge step.
A higher value means that only strong transitions are considered.
The default value is 0, which only works well together with STRONGEST as edge selection criterion (see setSelection).
If the selection criteria is FIRST or LAST, a threshold should be specified using this function.

Image world coordinate system handling:
The threshold is expressed in world coordinates, taking the pixel z-size into account.</desc>
                        <sample for="lua">Image.ShapeFitter.setThreshold(shapeFitter, 10)</sample>
                        <param name="shapeFitter" type="handle" alias="Image.ShapeFitter" desc="Shape fitter to use."/>
                        <param name="threshold" type="float" desc="Threshold value. The default value is 0, which only works well together with STRONGEST as edge selection critetion in the setSelection function. Increase threshold for other setting of setSelection."/>
                    </function>
                    <function name="setOutlierMargin">
                        <trait>released</trait>
                        <links>Image.ShapeFitter.setFitMode</links>
                        <desc>Set the outlier margin in world units for the final geometrical fitting step. This parameter is not used for the default fitting method, least squares.
The interpretation of the parameter depends on the fitting mode parameter:
- ABSOLUTE: the outlier margin is defined in absolute world units (typically mm). Any points further away from the fitted geometrical object than this margin will be ignored.
- RANK: the outlier margin is interpreted as a rank measure, defining the rate of points to include. In this case, the margin must be in the range (0.0, 1.0). A rank margin of 0.7 means that only the best fitting 70% of all points will be included, and the rest ignored.
In general a larger value means that more points are included in the fitting, which can improve the accuracy as long as all included points are valid. A smaller value makes the algorithm reject more points, which can increases robustness against single erroneous points. The default is an ABSOLUTE margin of 1.0 world units.

Image world coordinate system handling:
The ABSOLUTE margin is expressed in world coordinate units.</desc>
                        <sample for="lua">Image.ShapeFitter.setOutlierMargin(shapeFitter, margin, marginType)</sample>
                        <param name="shapeFitter" type="handle" alias="Image.ShapeFitter" desc="Shape fitter to use."/>
                        <param name="margin" type="float" desc="Outlier margin, expressed in world coordinate units or as a rank measure, depending on the marginType."/>
                        <param name="marginType" type="enum" multiplicity="?" ref="Shape.OutlierMarginType" desc="Outlier margin type. Default is ABSOLUTE."/>
                    </function>
                    <function name="setFitMode">
                        <trait>released</trait>
                        <links>Image.ShapeFitter.setOutlierMargin, Image.ShapeFitter.setIterations</links>
                        <desc>Set the geometrical fitting mode.
The following modes are supported:
- LEASTSQUARES uses all points. This is fast and easy, but can produce poor results if there are many spurious edge points nearby (default). When using this method, the inlier rate will always be 100%.
- RANSAC is a robust method with outlier rejection. Using this method, spurious edge points can be ignored. This mode requires an outlier margin to be set by setOutlierMargin. The number of iterations can be set by setIterations.
- TRIMMED is a two-stage least squares method, where points further away from the fitted shape in the first round than the outlier margin (set by setOutlierMargin) is removed before using least squares again to fit a new shape to the remaining points. This is faster than RANSAC but not as robust to outliers.</desc>
                        <sample for="lua">Image.ShapeFitter.setFitMode(shapeFitter, "RANSAC")</sample>
                        <param name="shapeFitter" type="handle" alias="Image.ShapeFitter" desc="Shape fitter to use."/>
                        <param name="fitMode" type="enum" ref="Shape.PointFitMode" desc="Geometrical fitting mode to use. The default is LEASTSQUARES. For many applications this should be changed to RANSAC to be robust to outliers."/>
                    </function>
                    <function name="setIterations">
                        <trait>released</trait>
                        <links>Image.ShapeFitter.setFitMode</links>
                        <desc>Set the number of iterations in the point fitting step. Only used when setFitMode specifies a robust method like RANSAC. A higher value makes the method more robust, but consumes more computation time. The default is 100 iterations.</desc>
                        <sample for="lua">Image.ShapeFitter.setIterations(shapeFitter, 50)</sample>
                        <param name="shapeFitter" type="handle" alias="Image.ShapeFitter" desc="Shape fitter to use."/>
                        <param name="iterations" type="int" desc="Number of iterations."/>
                    </function>
                    <function name="fitCircle">
                        <trait>released</trait>
                        <links>Image.ShapeFitter.fitEllipse</links>
                        <desc>Fit a circle using the current settings. The outerCircle and innerRadius parameters control the edge search region in the image, while the minRadius and maxRadius parameters applies to the fitted circle. Image edges to fit the circle to is searched for radially within a search region defined by two concentric circles, but the fitted circle itself may extend outside or inside the search region. If no minRadius or maxRadius is provided, the fitted circle may have any size. Note that the min/max radius act like a filter, setting too narrow tolerance will result in nil output. Set the minimum and maximum radius exacty equal to fit a circle with fixed radius. Always use RANSAC fit mode to fit circles unless there is a strong reason not to.

Image world coordinate system handling:
The circle is fitted in world coordinates.

Missing data handling:
Edges between data and missing data are valid for fitting in images with missing data.</desc>
                        <sample for="lua">circle, quality = Image.ShapeFitter.fitCircle(shapeFitter, image, outerCircle, innerRadius)</sample>
                        <param name="shapeFitter" type="handle" alias="Image.ShapeFitter" desc="Shape fitter to use."/>
                        <param name="image" type="const object" alias="Image" desc="Input image."/>
                        <param name="outerCircle" type="const object" alias="Shape" desc="Outer circle of the search region, defining the search region center and outer radius of the search region."/>
                        <param name="innerRadius" type="float" desc="Inner radius of the search region."/>
                        <param name="minRadius" type="float" multiplicity="?" desc="Candidates with radius smaller than this are removed. Optional, default is no minimum limit."/>
                        <param name="maxRadius" type="float" multiplicity="?" desc="Candidates with radius larger than this are removed. Optional, default is no maximum limit."/>
                        <return name="circle" type="object" multiplicity="?" alias="Shape" desc="Fitted circle."/>
                        <return name="quality" type="float" multiplicity="*" desc="Vector with fitting quality measurements [meanError, inlierRate, edgePointRate], where meanError is the average fitting error of inlier points in world coordinates, inlierRate is the rate of input points that were used to fit the final circle and edgePointRate is the rate of edge probes where an edge point was found. For the least squares method, all points are used and the inlier rate is always 100%."/>
                    </function>
                    <function name="fitArc">
                        <trait>released</trait>
                        <desc>Fit a circular arc using the current settings within a search region defined by a shape sector. The angular extent of the fitted arc is copied from the search sector. Always use RANSAC fit mode to fit arcs unless there is a strong reason not to.

Image world coordinate system handling:
The arc is fitted in world coordinates.

Missing data handling:
Edges between data and missing data are valid for fitting in images with missing data.</desc>
                        <sample for="lua">arc, quality = Image.ShapeFitter.fitArc(shapeFitter, image, searchSector)</sample>
                        <param name="shapeFitter" type="handle" alias="Image.ShapeFitter" desc="Shape fitter to use."/>
                        <param name="image" type="const object" alias="Image" desc="Input image."/>
                        <param name="searchSector" type="const object" alias="Shape" desc="Search region, defining the search region center, inner and outer radii, and the angles that limit the sector."/>
                        <return name="arc" type="object" multiplicity="?" alias="Shape" desc="Fitted arc."/>
                        <return name="quality" type="float" multiplicity="*" desc="Vector with fitting quality measurements [meanError, inlierRate, edgePointRate], where meanError is the average fitting error of inlier points in world coordinates, inlierRate is the rate of input points that were used to fit the final circle and edgePointRate is the rate of edge probes where an edge point was found. For the least squares method, all points are used and the inlier rate is always 100%."/>
                    </function>
                    <function name="fitEllipse">
                        <trait>released</trait>
                        <links>Image.ShapeFitter.fitCircle</links>
                        <desc>Fit an ellipse using the current settings. The outerShape and innerRadius parameters control the edge search region in the image, while the minRadius and maxRadius parameters applies to the fitted ellipse. The fitted ellipse may extend outside the search region in the image. If no minRadius or maxRadius is provided, the fitted ellipse may have any size. Note that the min/max radius act like a filter, setting too narrow tolerance will result in nil output. For ellipse fitting, least squares methods are very sensitive to noise. Always use RANSAC fit mode to fit ellipses unless there is a strong reason not to.

Image world coordinate system handling:
The ellipse is fitted in world coordinates.

Missing data handling:
Edges between data and missing data are valid for fitting in images with missing data.</desc>
                        <sample for="lua">ellipse, quality = Image.ShapeFitter.fitEllipse(shapeFitter, image, outerCircularShape, innerRadius)</sample>
                        <param name="shapeFitter" type="handle" alias="Image.ShapeFitter" desc="Shape fitter to use."/>
                        <param name="image" type="const object" alias="Image" desc="Input image."/>
                        <param name="outerShape" type="const object" alias="Shape" desc="Outer shape (circle or ellipse) of the search region, defining the search region center and outer radius (if an ellipse the outer radiusX and radiusY) of the search region."/>
                        <param name="innerRadius" type="float" desc="If the outer shape is a circle, the inner radius corresponds to the radius of the inner search region circle. If the outer shape is an ellipse, the inner radius corresponds to radiusX of an inner ellipse wich has the same orientation and center of the outer ellipse (radiusX is used to scale the two ellipses)."/>
                        <param name="minRadius" type="float" multiplicity="?" desc="Candidates with any radius smaller than this are removed. Optional, default is no minimum limit."/>
                        <param name="maxRadius" type="float" multiplicity="?" desc="Candidates with any radius larger than this are removed. Optional, default is no maximum limit."/>
                        <return name="ellipse" type="object" multiplicity="?" alias="Shape" desc="Fitted ellipse, or nil on failure."/>
                        <return name="quality" type="float" multiplicity="*" desc="Vector with fitting quality measurements [meanError, inlierRate, edgePointRate], where meanError is the average fitting error of inlier points in world coordinates, inlierRate is the rate of input points that were used to fit the final ellipse and edgePointRate is the rate of edge probes where an edge point was found. For the least squares method, all points are used and the inlier rate is always 100%."/>
                    </function>
                    <function name="fitLine">
                        <trait>released</trait>
                        <links>Image.ShapeFitter.fitLine3D</links>
                        <desc>Fit a line using the current settings. The direction parameter specifies the direction of the probe lines, and should be an angle in radians pointing across the edge.
- If direction = 0, the probes are oriented left-to-right (expecting to cross the edge when moving left-to-right in the image).
- If direction = PI/2, the probes are oriented top-to-bottom (expecting to cross the edge when moving top-to-bottom in the image).

Image world coordinate system handling:
The line is fitted in world coordinates.

Missing data handling:
Edges between data and missing data are valid for fitting in images with missing data.</desc>
                        <sample for="lua">lineSeg, quality = Image.ShapeFitter.fitLine(shapeFitter, image, region, direction)</sample>
                        <param name="shapeFitter" type="handle" alias="Image.ShapeFitter" desc="Shape fitter to use."/>
                        <param name="image" type="const object" alias="Image" desc="Input image."/>
                        <param name="region" type="const object" alias="Image.PixelRegion" desc="Input region."/>
                        <param name="direction" type="float" desc="Approximate edge direction in radians, defines the direction of the edge probes."/>
                        <return name="lineSeg" type="object" multiplicity="?" alias="Shape" desc="Fitted line segment or nil on failure."/>
                        <return name="quality" type="float" multiplicity="*" desc="Vector with fitting quality measurements [meanError, inlierRate, edgePointRate], where meanError is the average fitting error of inlier points in world coordinates, inlierRate is the rate of input points that were used to fit the final line and edgePointRate is the rate of edge probes where an edge point was found. For the least squares method, all points are used and the inlier rate is always 100%."/>
                    </function>
                    <function name="fitLine3D">
                        <trait>released</trait>
                        <links>Shape3D.fitLine, Image.ShapeFitter.fitLine</links>
                        <desc>Fit a 3D line using the current settings. In addition to the xy-region defined by the PixelRegion parameter, the zBounds parameter allows limiting the edge point search space in height. The direction parameter specifies the direction of the probe lines, and should be an angle in radians pointing across the edge.
- If direction = 0, the probes are oriented left-to-right (expecting to cross the edge when moving left-to-right in the image).
- If direction = PI/2, the probes are oriented top-to-bottom (expecting to cross the edge when moving top-to-bottom in the image).

Image world coordinate system handling:
The line is fitted in world coordinates.

Missing data handling:
Edges between data and missing data are valid for fitting in images with missing data.</desc>
                        <sample for="lua">lineSegment, quality = Image.ShapeFitter.fitLine3D(shapeFitter, image, region, zBounds, direction)</sample>
                        <param name="shapeFitter" type="handle" alias="Image.ShapeFitter" desc="Shape fitter to use."/>
                        <param name="image" type="const object" alias="Image" desc="Input image."/>
                        <param name="region" type="const object" alias="Image.PixelRegion" desc="Input region, defines an area in xy-space."/>
                        <param name="zBounds" type="float" multiplicity="+" desc="Two values providing the min and max z values where edges are searched for."/>
                        <param name="direction" type="float" desc="Approximate edge direction in radians, defines the direction of the edge probes."/>
                        <return name="lineSegment" type="object" multiplicity="?" alias="Shape3D" desc="The fitted line segment or nil on failure."/>
                        <return name="quality" type="float" multiplicity="*" desc="Vector with fitting quality measurements [meanError, inlierRate, edgePointRate], where meanError is the average fitting error of inlier points in world coordinates, inlierRate is the rate of input points that were used to fit the final line and edgePointRate is the rate of edge probes where an edge point was found. For the least squares method, all points are used and the inlier rate is always 100%."/>
                    </function>
                    <function name="fitCircle3D">
                        <trait>released</trait>
                        <desc>Fit a circle in 3D using the current settings. In addition to the xy-region defined by the outerCircle and the innerRadius, the zBounds parameter allows limiting the edge point search space in height. The minRadius and maxRadius parameters affect the fitted circle, limiting its radius. If no minRadius or maxRadius is provided, the fitted circle may have any size. Note that the min/max radius act like a filter, setting too narrow tolerance will result in nil output. Set the minimum and maximum radius exacty equal to fit a circle with fixed radius. Always use RANSAC fit mode to fit circles unless there is a strong reason not to.

Image world coordinate system handling:
The circle is fitted in world coordinates.

Missing data handling:
Edges between data and missing data are valid for fitting in images with missing data.</desc>
                        <sample for="lua">circle, quality = Image.ShapeFitter.fitCircle3D(shapeFitter, image, outerCircle, innerRadius, zBounds</sample>
                        <param name="shapeFitter" type="handle" alias="Image.ShapeFitter" desc="Shape fitter to use."/>
                        <param name="image" type="const object" alias="Image" desc="Input image."/>
                        <param name="outerCircle" type="const object" alias="Shape" desc="Outer circle of the search region, defining the search region center and outer radius of the search region."/>
                        <param name="innerRadius" type="float" desc="Inner radius of the search region."/>
                        <param name="zBounds" type="float" multiplicity="+" desc="Two values providing the min and max z values where edges are searched for."/>
                        <param name="minRadius" type="float" multiplicity="?" desc="Candidates with radius smaller than this are removed. Optional, default is no minimum limit."/>
                        <param name="maxRadius" type="float" multiplicity="?" desc="Candidates with radius larger than this are removed. Optional, default is no maximum limit."/>
                        <return name="circle" type="object" multiplicity="?" alias="Shape3D" desc="Fitted circle."/>
                        <return name="quality" type="float" multiplicity="*" desc="Vector with fitting quality measurements [meanError, inlierRate, edgePointRate], where meanError is the average fitting error of inlier points in world coordinates, inlierRate is the rate of input points that were used to fit the final line and edgePointRate is the rate of edge probes where an edge point was found. For the least squares method, all points are used and the inlier rate is always 100%."/>
                    </function>
                    <function name="getEdgePoints">
                        <trait>released</trait>
                        <desc>Get the edge points used in the last call to any of the 2D fit functions. Intended for visualization, parameter tuning and debugging. Two lists are returned, the first contains all points that were used to fit the final shape. The second list contains all points that were extracted but not used for fitting the shape. For the least squares method, all points are always in the first list.

Image world coordinate system handling:
The points are returned in world coordinates.</desc>
                        <sample for="lua">inlierPoints, outlierPoints = Image.ShapeFitter.getEdgePoints(shapeFitter)</sample>
                        <param name="shapeFitter" type="handle" alias="Image.ShapeFitter" desc="Shape fitter to use."/>
                        <return name="inlierPoints" type="object" multiplicity="*" alias="Point" desc="Points used for the final fitting of the shape, a subset of the detected points."/>
                        <return name="outlierPoints" type="object" multiplicity="*" alias="Point" desc="Points not used for the final fitting, the remainder of the detected points."/>
                    </function>
                    <function name="getEdgePoints3D">
                        <trait>released</trait>
                        <desc>Get the 3D edge points used in the last call to any of the 3D fit functions. Intended for visualization, parameter tuning and debugging. Two lists are returned, the first contains all points that were used to fit the final shape. The second list contains all points that were extracted but not used for fitting the shape. For the least squares method, all points are always in the first list.

Image world coordinate system handling:
The points are returned in world coordinates.</desc>
                        <sample for="lua">points = Image.ShapeFitter.getEdgePoints3D(shapeFitter)</sample>
                        <param name="shapeFitter" type="handle" alias="Image.ShapeFitter" desc="Shape fitter to use."/>
                        <return name="inlierPoints" type="object" multiplicity="*" alias="Point" desc="Points used for the final fitting of the shape, a subset of the detected points."/>
                        <return name="outlierPoints" type="object" multiplicity="*" alias="Point" desc="Points not used for the final fitting, the remainder of the detected points."/>
                    </function>
                </serves>
            </crown>
            <crown name="SurfaceFitter">
                <trait>released</trait>
                <keywords>fitting, least squares, RANSAC, model</keywords>
                <links>PointCloud.ShapeFitter, Shape3D.fitPlane, Image.ShapeFitter</links>
                <desc>This is a tool for fitting geometrical 3D object like planes and rectangles to surfaces in range images. To get started, create a SurfaceFitter with the create function and then call fitPlane or fitRectangle to adjust a plane or rectangle to image data.  For more detailed control of the fitting behavior, call the set functions before calling the fit function.

The surface fitting procedure consists of the following steps:
- The set of points corresponding to the pixels within the PixelRegion and z-value bounds is found. A 3D shape enclosing the desired part of the height map can be converted to a PixelRegion and z-bounds via Shape3D.toPixelRegion().
- The geometrical object that best fits the detected points is returned.</desc>
                <serves>
                    <function name="create">
                        <trait>released</trait>
                        <desc>Create a surface fitter with default settings.</desc>
                        <sample for="lua">surfaceFitter = Image.SurfaceFitter.create()</sample>
                        <return name="surfaceFitter" type="handle" alias="Image.SurfaceFitter" desc="Created surface fitter."/>
                    </function>
                    <function name="setReductionFactor">
                        <trait>released</trait>
                        <desc>Allows for quick reduction of the number of points to fit a shape to for large surfaces. Every N:th pixel in every N:th row is used, reducing computation time. Setting this parameter to one (default) fits the shape to all pixels in the region. Setting this parameter to two, approximately one quarter of the pixels are used.</desc>
                        <sample for="lua">Image.SurfaceFitter.setReductionFactor(surfaceFitter, n)</sample>
                        <param name="surfaceFitter" type="handle" alias="Image.SurfaceFitter" desc="Surface fitter to use."/>
                        <param name="n" type="int" desc="Using every n:th pixel in every n:th row."/>
                    </function>
                    <function name="setOutlierMargin">
                        <trait>released</trait>
                        <links>Image.SurfaceFitter.setFitMode</links>
                        <desc>Set the outlier margin for the final geometrical fitting step.
The interpretation of the margin value depends on the margin type. For an ABSOLUTE margin, any points further away from the fitted geometrical object than this margin will be ignored. The RANK margin includes a given part of the point set, i.e. a rank margin of 0.7 will search for the best shape fitting 70% of the points. For both margin types, a large value means that more points are included in the fitting, which can improve the accuracy as long as all included points are valid. A smaller value makes the algorithm reject more points, which can increases robustness against single erroneous points. The default value is 1.0 world units.

Image world coordinate system handling:
The ABSOLUTE margin is in image world coordinates.</desc>
                        <sample for="lua">Image.SurfaceFitter.setOutlierMargin(surfaceFitter, margin, marginType)</sample>
                        <param name="surfaceFitter" type="handle" alias="Image.SurfaceFitter" desc="Surface fitter to use."/>
                        <param name="margin" type="float" desc="Outlier margin, expressed in world coordinate unit or as a rank measure, depending on the marginType."/>
                        <param name="marginType" type="enum" multiplicity="?" ref="Shape.OutlierMarginType" desc="Outlier margin type. Default is ABSOLUTE."/>
                    </function>
                    <function name="setFitMode">
                        <trait>released</trait>
                        <links>Image.SurfaceFitter.setOutlierMargin, Image.SurfaceFitter.setIterations</links>
                        <desc>Set the geometrical fitting mode.
The following modes are supported:
- LEASTSQUARES includes all points. This is fast and easy, but can produce poor results if there are many spurious points nearby (default).
- RANSAC is a robust method with outlier rejection. Using this method, spurious points can be ignored. This mode requires an outlier margin to be set by setOutlierMargin and uses the number of iterations set through setIterations.
- TRIMMED is faster than ransac and more robust than least squares. It first fits a plane to all points using least squares. The points farther from the plane than set outlierMargin are removed and a new plane is fitted to the remaining points using least squares.</desc>
                        <sample for="lua">Image.SurfaceFitter.setFitMode(surfaceFitter, fitMode)</sample>
                        <param name="surfaceFitter" type="handle" alias="Image.SurfaceFitter" desc="Surface fitter to use."/>
                        <param name="fitMode" type="enum" ref="Shape.PointFitMode" desc="Geometrical fitting mode to use. The default is LEASTSQUARES. For many applications this should be changed to RANSAC to be robust to outliers."/>
                    </function>
                    <function name="setIterations">
                        <trait>released</trait>
                        <links>Image.SurfaceFitter.setFitMode</links>
                        <desc>Set the number of iterations in the point fitting step. Only used when setFitMode specifies a robust method like RANSAC. A higher value makes the method more robust, but consumes more computation time.</desc>
                        <sample for="lua">Image.SurfaceFitter.setIterations(surfaceFitter, iterations)</sample>
                        <param name="surfaceFitter" type="handle" alias="Image.SurfaceFitter" desc="Surface fitter to use."/>
                        <param name="iterations" type="int" desc="Number of iterations. The default is 100 iterations."/>
                    </function>
                    <function name="fitPlane">
                        <trait>released</trait>
                        <links>Image.SurfaceFitter.fitRectangle, Shape3D.fitPlane</links>
                        <desc>Fit a 3D plane to image height values within a specified region using the current fit mode. The distance along the z-direction from the height map entries to the plane is minimized.

Image world coordinate system handling:
The plane is fitted in world coordinates.

Missing data handling:
Pixels with missing data are disregarded, the plane is only fitted to valid data.</desc>
                        <sample for="lua">plane, quality = Image.SurfaceFitter.fitPlane(surfaceFitter, image, region, lowerBoundZ, upperBoundZ)</sample>
                        <param name="surfaceFitter" type="handle" alias="Image.SurfaceFitter" desc="Surface fitter to use."/>
                        <param name="image" type="const object" alias="Image" desc="Input image."/>
                        <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Input region indicating which area to fit to. Optional, the default is to use the entire image."/>
                        <param name="boundsZ" type="float" multiplicity="*" desc="Lower and upper z-bound. Optional, the default is to use all points."/>
                        <return name="plane" type="object" multiplicity="?" alias="Shape3D" desc="The fitted plane."/>
                        <return name="quality" type="float" multiplicity="*" desc="Vector with fitting quality measurements [meanError, inlierRate], where meanError is the average fitting error of inlier points in world coordinates and inlierRate is the rate of input points that were accepted as belonging to the plane."/>
                    </function>
                    <function name="fitRectangle">
                        <trait>released</trait>
                        <links>Image.SurfaceFitter.fitPlane, Shape3D.fitPlane</links>
                        <desc>Fit a rectangle in 3D to image height values within a specified region using the current fit mode. Similar to fitPlane but the rectangle is limited to the extent of the fitted points. By default, the rectangle is rotated in-plane to find the minimal area rectangle enclosing the inlier points. The distance along the z-direction from the height map entries to the plane is minimized.

Image world coordinate system handling:
The rectangle is fitted in world coordinates.

Missing data handling:
Pixels with missing data are disregarded, the rectangle is only fitted to valid data.</desc>
                        <sample for="lua">rectangle, quality = Image.SurfaceFitter.fitRectangle(surfaceFitter, image, region, zBounds, oriented)</sample>
                        <param name="surfaceFitter" type="handle" alias="Image.SurfaceFitter" desc="Surface fitter to use."/>
                        <param name="image" type="const object" alias="Image" desc="Input image."/>
                        <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Input region indicating which area to fit to. Optional, the default is to use the entire image."/>
                        <param name="boundsZ" type="float" multiplicity="*" desc="Lower and upper z-bound. Optional, the default is to use all points."/>
                        <param name="oriented" type="bool" multiplicity="?" desc="Flag controlling if the rectangle should be rotated to minimize rectangle area (default). If set to false, the in-plane rotation of the fitted rectangle is related to the coordinate axes."/>
                        <return name="rectangle" type="object" multiplicity="?" alias="Shape3D" desc="The fitted rectangle."/>
                        <return name="quality" type="float" multiplicity="*" desc="Vector with fitting quality measurements [meanError, inlierRate], where meanError is the average fitting error of inlier points in world coordinates and inlierRate is the rate of input points that were accepted as belonging to the rectangle."/>
                    </function>
                    <function name="fitPolynomial">
                        <trait>released</trait>
                        <keywords>quadratic</keywords>
                        <links>Image.SurfaceFitter.fitPlane, Shape3D.fitPlane, Image.subtractPolynomial, Image.thresholdPolynomial, Image.clampPolynomial, Image.binarizePolynomial, Image.renderPolynomial</links>
                        <desc>Fit a 2nd order polynomial to pixel values within a specified image region, similar to SurfaceFitter.fitPlane but with a quadratic surface. The difference between the polynomial and the pixel values is minimized in a least squares sense. Robust fitting modes such as RANSAC is supported, see SurfaceFitter.setFitMode.

The fitted 2nd order polynomial is of the following form:
z = Ac + Ax*x + Ay*y + Axx*x*x + Axy*x*y + Ayy*y*y
where Ac, Ax, Ay, Axx, Axy, Ayy are the polynomial coefficients and x, y are the coordinates of the pixels.
The result of the fitting process is a vector of floats representing the coefficients in the order specified above.

Image world coordinate system handling:
The polynomial is fitted in world coordinates, i.e., the (x,y)-coordinates of each pixel is calculated using the pixel sizes and origins in the (x,y)-dimensions, and the z-pizelsize and origin is used to convert to world measurements for each pixel value.

Missing data handling:
Pixels with missing data are disregarded, the polynomial is only fitted to valid pixels.</desc>
                        <sample for="lua">polynomial, quality = Image.SurfaceFitter.fitPolynomial(surfaceFitter, image, region, zBounds)</sample>
                        <param name="surfaceFitter" type="handle" alias="Image.SurfaceFitter" desc="SurfaceFitter instance to use."/>
                        <param name="image" type="const object" alias="Image" desc="Input image."/>
                        <param name="region" type="const object" multiplicity="?" alias="Image.PixelRegion" desc="Input region indicating which area to fit to. Optional, the default is to use the entire image."/>
                        <param name="boundsZ" type="float" multiplicity="*" desc="Lower and upper z-bounds in world coordinates. Pixels with values outside this range are excluded from the fitting. Optional, the default is to use all points."/>
                        <return name="polynomial" type="float" multiplicity="*" desc="The fitted polynomial as a vector of coefficients Ac, Ax, Ay, Axx, Axy, Ayy."/>
                        <return name="quality" type="float" multiplicity="*" desc="Vector with fitting quality measurements [meanError, inlierRate], where meanError is the average fitting error of inlier points in world coordinates and inlierRate is the rate of input points that were accepted as belonging to the polynomial."/>
                    </function>
                    <function name="getSurfacePoints">
                        <trait>released</trait>
                        <desc>Get the 3D points used in the last call to any of the fit functions. Intended for visualization, parameter tuning and debugging. Two lists are returned, the first contains all points that were used to fit the final shape. The second list contains all points that were extracted but not used for fitting the shape. For the least squares method, all points are always in the first list. The number of returned points is limited. If the total number of points exceeds the set limit, the last points are skipped.

Image world coordinate system handling:
The returned points are in world coordinates.

Missing data handling:
Pixels with missing data are disregarded.</desc>
                        <sample for="lua">inlierPoints, outlierPoints = Image.SurfaceFitter.getSurfacePoints(surfaceFitter)</sample>
                        <param name="surfaceFitter" type="handle" alias="Image.SurfaceFitter" desc="Surface fitter to use."/>
                        <param name="pointCountLimit" type="int" multiplicity="?" desc="Limit the number of points returned. Optional, default is 50000 points maximum."/>
                        <return name="inlierPoints" type="object" multiplicity="*" alias="Point" desc="Points used for the final fitting of the shape, a subset of the detected points."/>
                        <return name="outlierPoints" type="object" multiplicity="*" alias="Point" desc="Points not used for the final fitting, the remainder of the detected points."/>
                    </function>
                </serves>
            </crown>
            <crown name="Pyramid">
                <trait>released</trait>
                <keywords>scale, scalespace, downsample, resample, subsample, decimate</keywords>
                <links>Image.resize, Image.resizeScale</links>
                <desc>A multiscale representation of an image. Each level in the pyramid contains an image that is downsampled a factor 2 relative to the preceding level.
Level 0 of the ImagePyramid keeps the original image. There are two smoothing operators that can be used to avoid aliasing artifacts in the downsampled images:
"LINEAR" and "GAUSSIAN". The default method is "LINEAR". A non-interpolating nearest neighbor method is also available, "NEAREST". The coarsest level cannot contain an image smaller than 16x16 pixels, levels below this size are not created
even if more levels are specified upon ImagePyramid creation. For odd-sized images, the output size after downscaling is different for the "LINEAR" and "GAUSSIAN" cases: if the size N is odd, the output size is (N-1)/2 for "LINEAR" and "NEAREST" while it is (N+1)/2 for "GAUSSIAN".

Image world coordinate system handling:
The coordinate system of the output image will be slightly adjusted in relation to the input to take into account pixel size changes. Eg. both the origin and pixel size of the image will typically change. World positions in the image should be retained such that for example overlay graphics can remain on the same position when plotted on different pyramid levels. Values in z, both origin and pixel size, are copied directly from the input image.

Missing data handling:
When using "LINEAR" or "NEAREST" as the DownsamplingMethod missing data is handled. For linear interpolation, missing data will remain if all points in the interpolation neighborhood are missing. Otherwise the missing data value will be ignored and the output will be the linear interpolation of the valid neighbors. DownsamplingMethod "GAUSSIAN", currently does not support missing data.

Hardware acceleration:
Some devices have FPGA-support for the pyramid generation. It is possible to switch between the CPU and FPGA versions using the setProcessingUnit()-function.
Please note that if the FPGA accelerator is busy the processing will fall-back to CPU processing. The processing may also fall-back to CPU for some unsupported configurations.

The rounding done in the CPU and the FPGA version may differ slightly resulting in different values in the least significant bit of the generated pyramid levels.</desc>
                <enum name="DownsamplingMethod" trait="released">
                    <item name="nearest" desc="Downsample using nearest neighbor.">NEAREST</item>
                    <item name="linear" desc="Downsample using 2x2 linear interpolation.">LINEAR</item>
                    <item name="gaussian" desc="Downsample using a Gaussian interpolation.">GAUSSIAN</item>
                </enum>
                <enum name="ProcessingUnit" trait="released">
                    <item name="CPU" desc="Calculations will be done on the CPU.">CPU</item>
                    <item name="FPGA" desc="The FPGA will be used for hardware acceleration.">FPGA</item>
                </enum>
                <serves>
                    <function name="create">
                        <trait>released</trait>
                        <links>Image.Pyramid.generate, Image.Pyramid.setProcessingUnit, Image.Pyramid.resize</links>
                        <desc>Create an image pyramid. If no arguments are given an unintialized pyramid will be created, which can be populated at a later stage using the Image.Pyramid.generate() function.</desc>
                        <sample for="lua">pyramidImage = Image.Pyramid.create(image, levelCount, "LINEAR", "CPU")</sample>
                        <param name="image" type="const object" multiplicity="?" alias="Image" desc="Optional: Source image. Supported image types depends on used device type."/>
                        <param name="levelCount" type="int" multiplicity="?" desc="Optional: Desired number of pyramid levels. One level will be used for the original image, so to get at least one downscaled version the levelCount parameter must be larger than 1. Note that the created ImagePyramid may contain fewer levels as the coarsest level is limited to a side of minimum 16 pixels. If this parameter is not set the maximum number of levels are created."/>
                        <param name="method" type="enum" multiplicity="?" ref="DownsamplingMethod" desc="Optional: The downsampling method, currently NEAREST, LINEAR or GAUSSIAN are available. Default is LINEAR."/>
                        <param name="processingUnit" type="enum" multiplicity="?" ref="ProcessingUnit" desc="Optional: Processing Unit to use (CPU, FPGA). Default is CPU."/>
                        <param name="cloneData" type="bool" multiplicity="?" desc="Optional: If set to true a cloned copy of the original input image is made in the pyramid object. If set to false a reference copy is made, which saves execution time and memory. Note however, any other change made later to the input image will then also affect the base layer in the pyramid object. Default is true, i.e., to make a cloned copy."/>
                        <return name="pyramidImage" type="object" multiplicity="?" alias="Image.Pyramid" desc="The created image pyramid."/>
                    </function>
                    <function name="generate">
                        <trait>released</trait>
                        <links>Image.Pyramid.create, Image.Pyramid.setProcessingUnit, Image.Pyramid.resize</links>
                        <desc>Generate pyramid levels for an existing image pyramid, replacing any existing data in the pyramid object. The function works inplace, i.e., the object is modified directly.</desc>
                        <sample for="lua">pyramidImage = Image.Pyramid.generate(pyramidImage, image, levelCount, "LINEAR", "CPU")</sample>
                        <param name="pyramidImage" type="object" alias="Image.Pyramid" desc="The image pyramid."/>
                        <param name="image" type="const object" alias="Image" desc="Source image. Supported image types depends on used device type."/>
                        <param name="levelCount" type="int" desc="Desired number of pyramid levels. One level will be used for the original image, so to get at least one downscaled version the levelCount parameter must be larger than 1. Note that the created ImagePyramid may contain fewer levels as the coarsest level is limited to a side of minimum 16 pixels."/>
                        <param name="method" type="enum" multiplicity="?" ref="DownsamplingMethod" desc="The downsampling method, currently NEAREST, LINEAR or GAUSSIAN are available. Default is LINEAR."/>
                        <param name="processingUnit" type="enum" multiplicity="?" ref="ProcessingUnit" desc="Optional: Processing Unit to use (CPU, FPGA). Default is CPU."/>
                        <param name="cloneData" type="bool" multiplicity="?" desc="Optional: If set to true a cloned copy of the original input image is made in the pyramid object. If set to false a reference copy is made, which saves execution time and memory. Note however, any other change made later to the input image will then also affect the base layer in the pyramid object. Default is true, i.e., to make a cloned copy."/>
                        <return name="pyramidImage" type="object" multiplicity="?" alias="Image.Pyramid" desc="Reference to the pyramid with generated pyramid levels, or nil if something goes wrong. Note that the function works inplace, modifying the object directly, the output is mainly for error checking."/>
                    </function>
                    <function name="resize">
                        <trait>released</trait>
                        <keywords>extend, remove, cut</keywords>
                        <links>Image.Pyramid.generate</links>
                        <desc>Resizes an existing image pyramid in terms of the number of pyramid levels, i.e., the pyramid is extendend with more levels or levels are removed. The pyramid is updated inplace.</desc>
                        <sample for="lua">pyramidImage = Image.Pyramid.resize(pyramidImage, levelCount)</sample>
                        <param name="pyramidImage" type="object" alias="Image.Pyramid" desc="The image pyramid."/>
                        <param name="levelCount" type="int" desc="The new number of pyramid levels. One level will be used for the original image, so to get at least one downscaled version the levelCount parameter must be larger than 1. Note that the created ImagePyramid may contain fewer levels as the coarsest level is limited to a side of max 16 pixels."/>
                        <return name="pyramidImage" type="object" multiplicity="?" alias="Image.Pyramid" desc="Reference to the resized pyramid, or nil if something goes wrong. Note that the function works inplace, modifying the object directly, the output is mainly for error checking."/>
                    </function>
                    <function name="getLevelCount">
                        <trait>released</trait>
                        <desc>Get the number of pyramid levels.</desc>
                        <sample for="lua">levelCount = Image.Pyramid.getLevelCount(pyramidImage)</sample>
                        <param name="pyramidImage" type="const object" alias="Image.Pyramid" desc="The image pyramid."/>
                        <return name="levelCount" type="int" multiplicity="1" desc="The number of pyramid levels."/>
                    </function>
                    <function name="getImage">
                        <trait>released</trait>
                        <desc>Get the image at the specified pyramid level. 0 is the 'finest' level i.e. the original image. The return image is a deep copy of the level image</desc>
                        <sample for="lua">image = Image.Pyramid.getImage(pyramidImage, levelCount) </sample>
                        <param name="pyramidImage" type="const object" alias="Image.Pyramid" desc="The image pyramid."/>
                        <param name="level" type="int" desc="The pyramid level to grab the image from."/>
                        <return name="image" type="object" multiplicity="?" alias="Image" desc="The image at the specified pyramid level."/>
                    </function>
                    <function name="getConstImage">
                        <trait>hidden</trait>
                        <desc>Get the image at the specified pyramid level. 0 is the 'finest' level i.e. the original image. The return image is a shallow copy of the level image</desc>
                        <sample for="lua">image = Image.Pyramid.getConstImage(pyramidImage, levelCount) </sample>
                        <param name="pyramidImage" type="const object" alias="Image.Pyramid" desc="The image pyramid."/>
                        <param name="level" type="int" desc="The pyramid level to grab the image from."/>
                        <return name="image" type="const object" multiplicity="?" alias="Image" desc="The image at the specified pyramid level."/>
                    </function>
                    <function name="toString">
                        <trait>released</trait>
                        <desc>Get a brief string description of the image pyramid. This is equal to the text shown in the debugger to describe the image pyramid.</desc>
                        <sample for="lua">print("Description: " .. Image.Pyramid.toString(pyramidImage))</sample>
                        <param name="pyramidImage" type="const object" alias="Image.Pyramid" desc="The image pyramid."/>
                        <return name="string" type="string" desc="Description of the image pyramid"/>
                    </function>
                    <function name="setProcessingUnit">
                        <trait>released</trait>
                        <desc>Set processing unit to use for pyramid generation.</desc>
                        <sample for="lua">success = Image.Pyramid.setProcessingUnit(pyramidImage, "CPU")</sample>
                        <param name="pyramidImage" type="object" alias="Image.Pyramid" desc="The image pyramid."/>
                        <param name="processingUnit" type="enum" ref="ProcessingUnit" desc="Processing Unit to use (CPU, FPGA)."/>
                        <return name="success" type="bool" desc="True if set was successful."/>
                    </function>
                    <function name="getProcessingUnit">
                        <trait>released</trait>
                        <desc>Get configured processing unit.</desc>
                        <sample for="lua">processingUnit = Image.Pyramid.getProcessingUnit(pyramidImage)</sample>
                        <param name="pyramidImage" type="object" alias="Image.Pyramid" desc="The image pyramid."/>
                        <return name="processingUnit" type="enum" ref="ProcessingUnit" desc="Processing Unit to use (CPU, FPGA)."/>
                    </function>
                </serves>
            </crown>
            <crown name="Fixture">
                <trait>released</trait>
                <keywords>coordinate system, local, object, reference</keywords>
                <links>Image.Matching.EdgeMatcher, Image.Matching.PointMatcher, Image.Fixture3D</links>
                <desc>Helper object for transformation of geometrical primitives between different views of the same object.
This object is typically used in a locate-inspect concept, where a teach image is used to define a set of measurement tasks.
These measurement tasks will then be executed on a set of live images, where the object to measure may be translated, rotated and/or scaled differently than in the teach image.

Typically, the following steps are included in locate-inspect applications:
- Teach a matching algorithm (EdgeMatcher, PointMatcher, PatternMatcher) from a teach image. Use the teach pose returned from the teach procedure as reference pose for the fixture.
- Define a set of points or shapes in the teach image, related to various measurement tasks. Append these to the fixture using the append functions.
- For each live image, find the object using a match call of the selected matching algorithm. Transform the fixture to this new object pose using Fixture.transform.
- Get the transformed points or shapes using the get functions, now relating to the found pose of the object in the live image.
Saving and loading a fixture:
A Image.Fixture instance can be saved and loaded (serialized/deserialized) using the Object.save() and Object.load() functions.</desc>
                <serves>
                    <function name="create">
                        <desc>Create a new fixture.</desc>
                        <sample for="lua">fixture = Image.Fixture.create()</sample>
                        <return name="fixture" type="handle" alias="Image.Fixture" desc="The new fixture."/>
                    </function>
                    <function name="appendPoint">
                        <desc>Append a point to the fixture.</desc>
                        <sample for="lua">Image.Fixture.appendPoint(fixture, "point1", point)</sample>
                        <param name="fixture" type="handle" alias="Image.Fixture" desc="Fixture object."/>
                        <param name="name" type="string" desc="Name of the point, used when retrieving the point later on."/>
                        <param name="point" type="const object" alias="Point" desc="Point to append."/>
                    </function>
                    <function name="appendShape">
                        <desc>Append a shape or composite shape to the fixture.</desc>
                        <sample for="lua">Image.Fixture.appendShape(fixture, "shape1", shape)</sample>
                        <param name="fixture" type="handle" alias="Image.Fixture" desc="Fixture object."/>
                        <param name="name" type="string" desc="Name of the shape, used when retrieving the shape later on."/>
                        <param name="shape" type="const object" alias="Shape" desc="Shape or composite shape to append."/>
                    </function>
                    <function name="appendAngle">
                        <desc>Append an angle to the fixture.</desc>
                        <sample for="lua">Image.Fixture.appendAngle(fixture, "angle1", 3.1415/2)</sample>
                        <param name="fixture" type="handle" alias="Image.Fixture" desc="Fixture object."/>
                        <param name="name" type="string" desc="Name of the angle, used when retrieving the angle later on."/>
                        <param name="angle" type="float" desc="Angle to append."/>
                    </function>
                    <function name="appendPose">
                        <desc>Append a pose transform to the fixture.
Typically, the appended pose defines the pose of an object part.
For example, the pose returned from the PatternVerifier teach method can be appended to a fixture.
After calling Fixture.transform() to transform the fixture to a live image, Fixture.getPose() will give the pose of the part in the live image. The output from getPose can then be used in a call to PatternVerifier.verify() to verify the part in the live image.</desc>
                        <sample for="lua">Image.Fixture.appendPose(fixture, "pose1", pose)</sample>
                        <param name="fixture" type="handle" alias="Image.Fixture" desc="Fixture object."/>
                        <param name="name" type="string" desc="Name of the pose, used when retrieving the pose later on."/>
                        <param name="pose" type="const object" alias="Transform" desc="Pose to append, defined in image world coordinates."/>
                    </function>
                    <function name="getPoint">
                        <desc>Get a point from the fixture, transformed according to the current fixture transform.</desc>
                        <sample for="lua">point = Image.Fixture.getPoint(fixture, "point1")</sample>
                        <param name="fixture" type="handle" alias="Image.Fixture" desc="Fixture object."/>
                        <param name="name" type="string" desc="Name of the point to retrieve."/>
                        <return name="point" type="object" multiplicity="?" alias="Point" desc="The retrieved point."/>
                    </function>
                    <function name="getShape">
                        <desc>Get a shape or composite shape from the fixture, transformed according to the current fixture transform. Nil is returned if the shape can not be transformed accordingly.</desc>
                        <sample for="lua">shape = Image.Fixture.getShape(fixture, "shape1")</sample>
                        <param name="fixture" type="handle" alias="Image.Fixture" desc="Fixture object."/>
                        <param name="name" type="string" desc="Name of the object to retrieve."/>
                        <return name="shape" type="auto" multiplicity="?" desc="The retrieved shape or composite shape."/>
                    </function>
                    <function name="getAngle">
                        <desc>Get an angle from the fixture, transformed according to the current fixture transform.</desc>
                        <sample for="lua">angle = Image.Fixture.getAngle(fixture, "angle1")</sample>
                        <param name="fixture" type="handle" alias="Image.Fixture" desc="Fixture object."/>
                        <param name="name" type="string" desc="Name of the angle to retrieve."/>
                        <return name="angle" type="float" multiplicity="?" desc="The retrieved angle."/>
                    </function>
                    <function name="getPose">
                        <desc>Get a pose from the fixture, transformed according to the current fixture transform.
Typically, this is used to get the pose of an object part. For example, the pose returned from getPose can be used as input to the PatternVerifier match function. See appendPose for more information.</desc>
                        <sample for="lua">pose = Image.Fixture.getPose(fixture, "pose1")</sample>
                        <param name="fixture" type="handle" alias="Image.Fixture" desc="Fixture object."/>
                        <param name="name" type="string" desc="Name of the pose to retrieve."/>
                        <return name="pose" type="object" multiplicity="?" alias="Transform" desc="The retrieved pose."/>
                    </function>
                    <function name="getAsPixelRegion">
                        <desc>Get a shape or composite shape region from the fixture, transformed directly to a pixel region for use as algorithm input. Since the returned object is not a shape, more general transformations are supported by this function compared to getShape().</desc>
                        <sample for="lua">region = Image.Fixture.getAsPixelRegion(fixture, "shape1", referenceImage)</sample>
                        <param name="fixture" type="handle" alias="Image.Fixture" desc="Fixture object."/>
                        <param name="name" type="string" desc="Name of the shape or composite shape to retrieve."/>
                        <param name="referenceImage" type="const object" alias="Image" desc="Reference image, use to determine the pixel-world mapping."/>
                        <return name="region" type="object" multiplicity="?" alias="Image.PixelRegion" desc="The transformed shape, converted to a pixel region."/>
                    </function>
                    <function name="setReferencePose">
                        <desc>Set the reference pose of this fixture. This defines the object pose that all geometrical items will be related to. Typically, the teachPose output from the teach function of a matching tool (for example Image.Matching.EdgeMatcher.teach()) is used as input to this function.</desc>
                        <sample for="lua">Image.Fixture.setReferencePose(fixture, referencePose)</sample>
                        <param name="fixture" type="handle" alias="Image.Fixture" desc="Fixture object."/>
                        <param name="referencePose" type="const object" alias="Transform" desc="Pose transform of the object that all appended geometrical items will be related to."/>
                    </function>
                    <function name="transform">
                        <desc>Transform the fixture to a new pose. This will affect the pose of all geometrical items retrieved using the get functions. Typically, the pose transform output from the match function of a matching tool (for example Image.Matching.EdgeMatcher.match()) is often used as input to this function.</desc>
                        <sample for="lua">Image.Fixture.transform(fixture, poseTransform)</sample>
                        <param name="fixture" type="handle" alias="Image.Fixture" desc="Fixture object."/>
                        <param name="poseTransform" type="const object" alias="Transform" desc="Pose transform of the new fixture pose."/>
                    </function>
                    <function name="toString">
                        <desc>Get a user-friendly string description of the fixture.</desc>
                        <sample for="lua">local description = Image.Fixture.toString(fixture)</sample>
                        <param name="fixture" type="handle" alias="Image.Fixture" desc="Fixture object."/>
                        <return name="description" type="string" multiplicity="?" desc="User-friendly description of the fixture."/>
                    </function>
                </serves>
            </crown>
            <crown name="Fixture3D">
                <trait>released</trait>
                <keywords>coordinate system, local, object, reference</keywords>
                <links>Image.Matching.EdgeMatcher3D, Image.Fixture</links>
                <desc>Helper object for transformation of 3D geometrical primitives (Shapes, Points, regions).
This object is typically used in a locate-inspect concept together with the EdgeMatcher3D, where a teach image is used to define a set of measurement tasks. These measurement tasks will then be executed on a set of live images, where the object to measure may be translated, rotated and/or scaled differently than in the teach image.

The shadow region of a shape on the z=0 plane can be obtained directly using getAsPixelRegion. This function also allows more general transforms compared to the getShape function. E.g. using getPose on a circle will only allow up to similarity transforms, while getAsPixelRegion allows homography transforms.

Typically, the following steps are included in locate-inspect applications:
- Teach a 3D matching algorithm such as EdgeMatcher3D using a teach image. Use the teach pose returned from the teach procedure as reference pose for the fixture.
- Define a set of points or shapes in the teach image, related to various measurement tasks. Append these to the fixture using the append functions.
- For each live image, find the object using a match call of the selected matching algorithm. Transform the fixture to this new object pose using Fixture3D.transform().
- Get the transformed points or shapes using the get functions, now relating to the found pose of the object in the live image.
Saving and loading a fixture:
A Image.Fixture3D instance can be saved and loaded (serialized/deserialized) using the Object.save() and Object.load() functions.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new 3D fixture.</desc>
                        <sample for="lua">fixture = Image.Fixture3D.create()</sample>
                        <return name="fixture" type="handle" alias="Image.Fixture3D" desc="The new fixture."/>
                    </function>
                    <function name="appendPoint">
                        <desc>Appends a 3D point to the fixture.</desc>
                        <sample for="lua">Image.Fixture3D.appendPoint(fixture, "point1", point)</sample>
                        <param name="fixture" type="handle" alias="Image.Fixture3D" desc="Fixture object."/>
                        <param name="name" type="string" desc="Name of the point, used when retrieving the point later on."/>
                        <param name="point" type="const object" alias="Point" desc="3D point to append."/>
                    </function>
                    <function name="appendShape">
                        <desc>Appends a Shape3D object to the fixture.</desc>
                        <sample for="lua">Image.Fixture3D.appendShape(fixture, "shape1", shape)</sample>
                        <param name="fixture" type="handle" alias="Image.Fixture3D" desc="Fixture object."/>
                        <param name="name" type="string" desc="Name of the shape, used when retrieving the shape later on."/>
                        <param name="shape" type="const object" alias="Shape3D" desc="Shape3D object to append."/>
                    </function>
                    <function name="appendPose">
                        <desc>Appends a pose transform (Transform 3D object) to the fixture. Typically, the appended pose defines the pose of an object part, for example, the pose returned from teaching 3D matchers for sub-components. After calling Fixture3D.transform() to transform the fixture to a live image, Fixture3D.getPose() will give the pose of the part in the live image.</desc>
                        <sample for="lua">Image.Fixture3D.appendPose(fixture, "pose1", pose)</sample>
                        <param name="fixture" type="handle" alias="Image.Fixture3D" desc="Fixture object."/>
                        <param name="name" type="string" desc="Name of the pose, used when retrieving the pose later on."/>
                        <param name="pose" type="const object" alias="Transform" desc="Transform pose (3D Transform) to append, defined in image world coordinates."/>
                    </function>
                    <function name="getPoint">
                        <desc>Gets a point from the fixture, transformed according to the current fixture transform.</desc>
                        <sample for="lua">point = Image.Fixture3D.getPoint(fixture, "point1")</sample>
                        <param name="fixture" type="handle" alias="Image.Fixture3D" desc="Fixture object."/>
                        <param name="name" type="string" desc="Name of the point to retrieve."/>
                        <return name="point" type="object" multiplicity="?" alias="Point" desc="The retrieved 3D point."/>
                    </function>
                    <function name="getShape">
                        <desc>Gets a shape from the fixture, transformed according to the current fixture transform.</desc>
                        <sample for="lua">shape = Image.Fixture3D.getShape(fixture, "shape1")</sample>
                        <param name="fixture" type="handle" alias="Image.Fixture3D" desc="Fixture object."/>
                        <param name="name" type="string" desc="Name of the shape to retrieve."/>
                        <return name="shape" type="object" multiplicity="?" alias="Shape3D" desc="The retrieved 3D shape."/>
                    </function>
                    <function name="getPose">
                        <desc>Gets a pose from the fixture, transformed according to the current fixture transform. Typically, this is used to get the pose of an object part.</desc>
                        <sample for="lua">pose = Image.Fixture3D.getPose(fixture, "pose1")</sample>
                        <param name="fixture" type="handle" alias="Image.Fixture3D" desc="Fixture object."/>
                        <param name="name" type="string" desc="Name of the pose to retrieve."/>
                        <return name="pose" type="object" multiplicity="?" alias="Transform" desc="The retrieved pose transform (Transform 3D)."/>
                    </function>
                    <function name="getAsPixelRegion">
                        <desc>Gets a 3D shape from the fixture represented as a pixel region plus height boundaries (zMin, zMax). The pixel region is the convex hull of the shape projected onto the plane z = 0. More general transforms are allowed when using getAsPixelRegion, even transforms that changes the type of shape.</desc>
                        <sample for="lua">region = Image.Fixture3D.getAsPixelRegion(fixture, "shape1", referenceImage)</sample>
                        <param name="fixture" type="handle" alias="Image.Fixture3D" desc="Fixture object."/>
                        <param name="name" type="string" desc="Name of the shape to retrieve."/>
                        <param name="referenceImage" type="const object" alias="Image" desc="Reference image, used to supply the image world coordinate system."/>
                        <return name="region" type="object" multiplicity="?" alias="Image.PixelRegion" desc="The transformed shape, converted to a pixel region."/>
                        <return name="zMin" type="float" multiplicity="?" desc="The lowest z-value encountered in the shape after transformation but before projection."/>
                        <return name="zMax" type="float" multiplicity="?" desc="The highest z-value encountered in the shape after transformation but before projection."/>
                    </function>
                    <function name="setReferencePose">
                        <desc>Sets the reference pose of this fixture. This defines the object pose that all geometrical items will be related to. Typically, the teachPose output from the teach function of a matching tool, e.g., EdgeMatcher3D, is used as input to this function.</desc>
                        <sample for="lua">Image.Fixture3D.setReferencePose(fixture, referencePose)</sample>
                        <param name="fixture" type="handle" alias="Image.Fixture3D" desc="Fixture object."/>
                        <param name="referencePose" type="const object" alias="Transform" desc="Pose transform (Transform3D) of the object that all appended geometrical items will be related to."/>
                    </function>
                    <function name="transform">
                        <desc>Transforms the fixture to a new pose. This will affect the pose of all geometrical items retrieved using the get functions. Typically, the pose transform output from the match function of a matching tool is often used as input to this function.</desc>
                        <sample for="lua">Image.Fixture3D.transform(fixture, poseTransform)</sample>
                        <param name="fixture" type="handle" alias="Image.Fixture3D" desc="Fixture object."/>
                        <param name="poseTransform" type="const object" alias="Transform" desc="Pose transform (Transform 3D object) of the new fixture pose."/>
                    </function>
                    <function name="toString">
                        <desc>Gets a user-friendly string description of the fixture.</desc>
                        <sample for="lua">local description = Image.Fixture3D.toString(fixture)</sample>
                        <param name="fixture" type="handle" alias="Image.Fixture3D" desc="Fixture object."/>
                        <return name="description" type="string" desc="User-friendly description of the fixture."/>
                    </function>
                </serves>
            </crown>
            <crown name="Benchmark">
                <trait>hidden</trait>
                <desc>Support functionality used to benchmark the design.</desc>
                <serves>
                    <function name="create">
                        <trait>hidden</trait>
                        <desc>Creates a new benchmark instance.</desc>
                        <sample for="lua">benchmark = Image.Benchmark.create()</sample>
                        <return name="benchmark" type="handle" alias="Image.Benchmark" desc="The new benchmark instance."/>
                    </function>
                    <function name="setNumThreads">
                        <trait>hidden</trait>
                        <desc>Set the maximum number of threads allowed in OpenMP parallel regions</desc>
                        <sample for="lua">Image.Benchmark.setNumThreads(benchmark, numThreads)</sample>
                        <param name="benchmark" type="handle" alias="Image.Benchmark" desc="The benchmark instance."/>
                        <param name="numThreads" type="int" multiplicity="1" desc="Number of threads to use"/>
                        <return name="result" type="bool" multiplicity="1" desc="True if set successful"/>
                    </function>
                    <function name="resetNumThreads">
                        <trait>hidden</trait>
                        <desc>Reset maximum number of threads to initial value.</desc>
                        <sample for="lua">Image.Benchmark.resetNumThreads(benchmark)</sample>
                        <param name="benchmark" type="handle" alias="Image.Benchmark" desc="The benchmark instance."/>
                        <return name="result" type="bool" multiplicity="1" desc="True if reset successful"/>
                    </function>
                    <function name="getMaxThreads">
                        <trait>hidden</trait>
                        <desc>Get maximum number of allowed threads in OpenMP parallel regions.</desc>
                        <sample for="lua">local maxThreads = Image.Benchmark.getMaxThreads(benchmark)</sample>
                        <param name="benchmark" type="handle" alias="Image.Benchmark" desc="The benchmark instance."/>
                        <return name="maxThreads" type="int" multiplicity="1" desc="Maximum allowed number of threads"/>
                    </function>
                    <function name="getNumProcs">
                        <trait>hidden</trait>
                        <desc>Get number of processors.</desc>
                        <sample for="lua">local maxThreads = Image.Benchmark.getNumProcs(benchmark)</sample>
                        <param name="benchmark" type="handle" alias="Image.Benchmark" desc="The benchmark instance."/>
                        <return name="numProcs" type="int" multiplicity="1" desc="Number of processors"/>
                    </function>
                    <function name="run">
                        <trait>hidden</trait>
                        <desc>Run benchmark. Supported image types are {UINT8, UINT16, INT16, FLOAT32}</desc>
                        <sample for="lua">local time = Image.Benchmark.run(benchmark, test, image0, image1)</sample>
                        <param name="benchmark" type="handle" alias="Image.Benchmark" desc="The benchmark instance."/>
                        <param name="test" type="int" multiplicity="1" desc="Benchmark to run"/>
                        <param name="image0" type="const object" multiplicity="1" alias="Image" desc="Source image 0."/>
                        <param name="image1" type="const object" multiplicity="?" alias="Image" desc="Optional: Source image 1."/>
                        <return name="procTime" type="int" multiplicity="1" desc="Benchmark results"/>
                    </function>
                </serves>
            </crown>
        </crown>
        <crown name="Profile">
            <trait>released</trait>
            <keywords>vector,array,1d,scan</keywords>
            <desc>A data type for vector of 1D measurements. Three main components of the data type are

- A vector of measurement values represented in 32 bit float precision.
- An optional vector of valid flags indicating if the measurement value at the same index is valid. An integer representation is used where 0 means invalid and 1 means valid measurement. A global flag indicates if algorithms must consider the valid flags vector at all in computations.
- Coordinate information for each measurement value, relating the measurement to a world position (temporal or spatial).

The main purpose of the Profile type is for 1D processing, e.g., filtering finding peaks and edges, analyze trends, matching 1D patterns etc. Processing is done on the measurement vector, taking the valid flag vector into account if enabled. The purpose of the coordinate vector is to relate the measurements with a world position. The world position can be both temporal or spatial, e.g., time, angle or 2D (x,y) position. The following three examples illustrate possible use cases for the Profile type:

Example 1: The measurement values represent the number of sent packages in a logistics center each day. The coordinate information represents time (day) and the valid flags vector if there was a valid package count on the corresponding day.

Example 2: The measurements are range values from a LiDAR scan in polar format. The coordinate is the angle for each range measurement. The valid flag vector indicates whether the corresponding range value is valid, e.g., if there was a reliable "echo" received.

Example 3: The measurement values are the height values sampled evenly along a straight line in a heightmap image. The coordinate vector in this case is a (x,y) world coordinate in millimeters or pixels, where each height value was sampled. As heightmaps can contain missing data pixels (no height value available), the valid flag vector carries this information.

The coordinate information can be represented in different ways: An implicit representation stores a start coordinate (1D float value or 2D point) and a constant delta (1D float value or 2D vector). An explicit representation stores the coordinate (1D float value or 2D point) in a vector of the same length as the measurement vector. How the coordinate information is represented is determined when the Profile object is created.

There is also a 'isClosed'-flag indicating if the coordinates wraps around so that the first and last samples are neighbors. This can happen for example for a 360 degree LiDAR scan or if one samples height values from a circle in a heightmap. This has effect in certain filtering operations where neighboring samples are considered to produce an output.</desc>
            <enum name="ExtremaType">
                <item name="max" desc="Local maxima">MAX</item>
                <item name="min" desc="Local minima">MIN</item>
            </enum>
            <enum name="ContrastDifferenceMode">
                <item name="one" desc="At least one point on each side in the neighborhood should have the specified value margin to the extremal point.">ONE</item>
                <item name="all" desc="All points in the neighborhood should have the specified value margin to the extremal point.">ALL</item>
            </enum>
            <enum name="DifferentiationOrder">
                <item name="first" desc="First order">FIRST</item>
                <item name="second" desc="Second order">SECOND</item>
            </enum>
            <enum name="AggregateOperation">
                <item name="sum" desc="Sum of values.">SUM</item>
                <item name="min" desc="Minimal value.">MIN</item>
                <item name="max" desc="Maximal value.">MAX</item>
                <item name="mean" desc="Mean value.">MEAN</item>
                <item name="median" desc="Median value.">MEDIAN</item>
            </enum>
            <enum name="SlopePolarity">
                <item name="positive" desc="Positive slope (low to high value)">POSITIVE</item>
                <item name="negative" desc="Negative slope (high to low value)">NEGATIVE</item>
                <item name="any" desc="Either positive or negative">ANY</item>
            </enum>
            <enum name="EdgeSide">
                <item name="high" desc="Snap to the high side of the slope">HIGH</item>
                <item name="low" desc="Snap to the low side of the slope">LOW</item>
                <item name="center" desc="Snap to the slope center (point of maximal derivative)">CENTER</item>
            </enum>
            <enum name="FillInvalidMethod">
                <item name="linear" desc="Squared difference.">LINEAR</item>
                <item name="neighbor_min" desc="Squared difference.">NEIGHBOR_MIN</item>
                <item name="neighbor_max" desc="Squared difference.">NEIGHBOR_MAX</item>
                <item name="neighbor_mean" desc="Squared difference.">NEIGHBOR_MEAN</item>
            </enum>
            <enum name="DifferenceMode">
                <item name="abs" desc="Absolute difference.">ABS</item>
                <item name="square" desc="Squared difference.">SQUARE</item>
            </enum>
            <enum name="CoordinateType">
                <item name="implicit_1d" desc="Squared difference.">IMPLICIT_1D</item>
                <item name="explicit_1d" desc="Squared difference.">EXPLICIT_1D</item>
                <item name="implicit_2d" desc="Squared difference.">IMPLICIT_2D</item>
                <item name="explicit_2d" desc="Squared difference.">EXPLICIT_2D</item>
            </enum>
            <enum name="NoiseType">
                <item name="normal" desc="Normal distribution.">NORMAL</item>
                <item name="uniform" desc="Uniform distribution.">UNIFORM</item>
            </enum>
            <enum name="NormalizationMethod">
                <item name="standard_deviation" desc="Scales the values so that they get the supplied mean and standard deviation.">STDDEV</item>
                <item name="range" desc="Scales the values so that the minimum and maximum fits the given range.">RANGE</item>
            </enum>
            <enum name="ImageType">
                <item name="int8" desc="signed 8-bit integer">INT8</item>
                <item name="int16" desc="signed 16-bit integer">INT16</item>
                <item name="int32" desc="signed 32-bit integer">INT32</item>
                <item name="int64" desc="signed 64-bit integer">INT64</item>
                <item name="uint8" desc="unsigned 8-bit integer">UINT8</item>
                <item name="uint16" desc="unsigned 16-bit integer">UINT16</item>
                <item name="uint32" desc="unsigned 32-bit integer">UINT32</item>
                <item name="uint64" desc="unsigned 64-bit integer">UINT64</item>
                <item name="float32" desc="32-bit floating-point">FLOAT32</item>
                <item name="float64" desc="64-bit floating-point">FLOAT64</item>
            </enum>
            <enum name="SortKey">
                <item name="by_value" desc="Sort by value.">BY_VALUE</item>
                <item name="by_coordinate" desc="Sort by coordinate.">BY_COORDINATE</item>
            </enum>
            <serves>
                <function name="create">
                    <trait>released</trait>
                    <links>Profile.clone</links>
                    <desc>Creates a new Profile object with all measurements set to a constant value.

Coordinate system handling:
The coordinate representation can be:
implicit 1D, start coordinate at 0 with a delta value of 1 (default)
explicit 1D, vector of absolute coordinates starting at 0 with a delta value of 1
implicit 2D, start coordinate at (0,0) with a delta value of (0,1)
explicit 2D, vector of absolute coordinates starting at (0,0) with a delta value of (0,1)

Valid flags handling:
All measurements are considered as valid. No valid flags vector is created.</desc>
                    <sample for="lua">local profile = Profile.create(size, constantValue)</sample>
                    <param name="size" type="int" desc="The number of measurements in the profile."/>
                    <param name="constantValue" type="float" multiplicity="?" desc="The fill value, default is 0."/>
                    <param name="coordinateType" type="enum" multiplicity="?" ref="CoordinateType" desc="Coordinate type to use, default is implicit 1D."/>
                    <return name="profile" type="object" alias="Profile" desc="The new profile."/>
                </function>
                <function name="load">
                    <trait>released</trait>
                    <keywords>csv, import</keywords>
                    <links>Object.load, File</links>
                    <desc>Imports a profile from the specified file path.
The format is defined by the file extension:
.csv:     Comma-separated value file
.json:    JSON (native AppSpace format)
.msgpack: MessagePack (native AppSpace format)

The csv-file should have numbers written as text, separated by at least one character that is not normally used in numbers (e.g. tab, semicolon, colon, etc.). Only decimal points are accepted, commas are interpreted as delimiters between entries. Values like -1.555e-3 are accepted. Regular spaces are ignored. The first row is taken as values for the profile. If the second row is equal in length, those numbers are interpreted as validity flags (zero means invalid, nonzero means valid). If the third row is equal in length, those numbers are interpreted as coordinates for the samples. Coordinates should be monotonically increasing.

Coordinate system handling:
If no coordinate row of correct length is present, the coordinate representation will be implicit 1D, starting at 0 with a delta value of 1. If the coordinate row is valid, coordinates will be as given in the third row and of type explicit 1D.

Valid flags handling:
If no validity row of correct length is present, all measurements are considered as valid. No valid flags vector is created. If the validity mask row is present, the validity flags are set as given in the second row.</desc>
                    <sample for="lua">local profile = Profile.load("private/profile.csv")</sample>
                    <param name="filepath" type="string" desc="The path and name of the file to load the profile from."/>
                    <return name="profile" type="object" multiplicity="?" alias="Profile" desc="The new profile or nil on failure."/>
                </function>
                <function name="save">
                    <trait>released</trait>
                    <keywords>csv, export</keywords>
                    <links>Object.save, File</links>
                    <desc>Writes a profile to the specified file path.
Overwrites the file if it already exists.
The format is defined by the file extension:
.csv:     Comma-separated value file, using a semicolon as separator.
.json:    JSON (native AppSpace format)
.msgpack: MessagePack (native AppSpace format)

For the csv-file format the first line contains the profile values. If the validity flags are active, the second line contains the flags (0 means invalid, 1 means valid). If coordinates are explicit 1D, the third line contains the coordinate of each sample.

Coordinate system handling:
Only 1D coordinates are supported. Implicit coordinates are not written to the file. Explicit coordinates are written to the third line in the output file.

Valid flags handling:
If the validity flags are active, those are written to the second line in the output file.</desc>
                    <sample for="lua">local success = Profile.save(profile, "private/profile.csv")</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The profile to store."/>
                    <param name="filepath" type="string" desc="The path and name of the file to write the profile to."/>
                    <return name="success" type="bool" multiplicity="?" desc="True on success, false on write error, nil if the call was malformed."/>
                </function>
                <function name="createFromVector">
                    <trait>released</trait>
                    <keywords>convert</keywords>
                    <links>Profile.toVector, Profile.clone</links>
                    <desc>Creates a new profile from a vector of measurement values, coordinates and valid flags.

Coordinate system handling:
The coordinate vector is optional, if not supplied 1D implicit coordinates starting at 0 with delta 1 is created. If supplied it can be both a float vector or a vector of 2D Points. An explicit coordinate representation is then created.

Valid flags handling:
The valid flags vector is optional. If no vector is supplied the global flag to use the valid flags is turned off. If supplied it must have the same length as the measurement vector, with 0 meaning that the corresponding measurement is invalid and non-zero that it is valid.</desc>
                    <sample for="lua">local profile = Profile.createFromVector(values, coordinates, flags)</sample>
                    <param name="values" type="float" multiplicity="+" desc="The vector of measurement values."/>
                    <param name="coordinates" type="const auto" multiplicity="*" desc="Optional vector of world coordinates (float or 2D points)."/>
                    <param name="flags" type="int" multiplicity="*" desc="Optional vector of valid flags of the same length as the measurement vector."/>
                    <return name="profile" type="object" multiplicity="?" alias="Profile" desc="The new profile."/>
                </function>
                <function name="toVector">
                    <trait>released</trait>
                    <keywords>convert</keywords>
                    <links>Profile.createFromVector</links>
                    <desc>Returns the measurement values, coordinates and valid flags of a profile as vectors.

Coordinate system handling:
A coordinate vector of the same length as the measurement vector is returned. If the coordinate representation is of implicit type, the vector is calculated.

Valid flags handling:
If the valid flags are disabled, no flags are returned.</desc>
                    <sample for="lua">local values, coordinates, flags = Profile.toVector(profile)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The profile."/>
                    <return name="values" type="float" multiplicity="*" desc="The vector of measurement values, or nil if the profile is not valid."/>
                    <return name="coordinates" type="const auto" multiplicity="*" desc="Vector of world coordinates (floats or 2D points), nor nil if the profile is not valid."/>
                    <return name="flags" type="int" multiplicity="*" desc="Vector of valid data flags, or nil if the flags are not enabled."/>
                </function>
                <function name="createFromPoints">
                    <keywords>convert</keywords>
                    <links>Profile.toVector, Profile.createFromVector, Profile.toPoints</links>
                    <desc>Creates a new profile from a vector of points.

Coordinate system handling:
For 2D points the profile will have EXPLICIT_1D coordinates, where the x-coordinates will become the coordinates in the Profile and the y-coordinates will become the corresponding values. For 3D points the profile will have EXPLICIT_2D coordinates, where the x,y-coordinates will become the coordinates in the Profile and the z-coordinates will become the corresponding values.</desc>
                    <sample for="lua">local profile = Profile.createFromPoints(points)</sample>
                    <param name="points" type="const object" multiplicity="+" alias="Point" desc="The vector of points."/>
                    <return name="profile" type="object" multiplicity="?" alias="Profile" desc="The new profile."/>
                </function>
                <function name="toPoints">
                    <trait>released</trait>
                    <keywords>convert</keywords>
                    <links>Profile.createFromPoints</links>
                    <desc>Returns all valid samples as a vector of points. An IndexRegion may be used to select which samples to return. The region must not contain samples outside the profile.

Coordinate system handling:
For 1D coordinates, the coordinate is mapped to the x-axis of the point space, and the sample value to the point space y-axis. For 2D sample coordinates, the coordinate is mapped to the x- and y-axis of the point space, and the sample value to the z-axis.

Valid flags handling:
Only samples marked as valid are returned, if valid flags are disabled, all samples in the region are returned.</desc>
                    <sample for="lua">points = Profile.toPoints(profile, region)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The profile."/>
                    <param name="region" type="const object" multiplicity="?" alias="Profile.IndexRegion" desc="Optional region where to extract samples, default is from the entire profile."/>
                    <return name="points" type="object" multiplicity="*" alias="Point" desc="The vector of points, 2D or 3D depending on the profile coordinate type, or nil in case of an error."/>
                </function>
                <function name="clone">
                    <trait>released</trait>
                    <keywords>copy</keywords>
                    <links>Profile.create, Profile.createFromVector</links>
                    <desc>Creates an independent copy of a profile.</desc>
                    <sample for="lua">local clonedProfile = Profile.clone(profile)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="Input profile."/>
                    <return name="clonedProfile" type="object" alias="Profile" desc="Copy of the input profile."/>
                </function>
                <function name="crop">
                    <keywords>region, sub profile, range</keywords>
                    <desc>Creates a new profile by cropping a segment of another profile.

Coordinate system handling:
The coordinate representation of the output profile is modified: If an implicit coordinate representation is used, the start coordinate is adjusted. If an explicit representation is used, the coordinate vector is cropped accordingly.

Valid flags handling:
The valid flags vector is cropped also if it exists.</desc>
                    <sample for="lua">local croppedProfile = Profile.crop(profile, startIndex, stopIndex)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="Input profile"/>
                    <param name="startIndex" type="int" desc="The start index, zero-based indexing."/>
                    <param name="stopIndex" type="int" desc="The end index, zero-based indexing."/>
                    <return name="croppedProfile" type="object" multiplicity="?" alias="Profile" desc="The new cropped profile. Returns nil if any index is out-of-range or if stop index is smaller than start index."/>
                </function>
                <function name="setValidFlagsComposite">
                    <trait>released</trait>
                    <keywords>missing data, region, sub profile, mask</keywords>
                    <links>Profile.setValidFlagsCompositeInplace, Composite.create, Composite.addShape, Profile.setValidFlag, Profile.threshold, Profile.crop, Profile.clamp</links>
                    <desc>Creates a new profile by invalidating all points in a profile outside a composite shape.

Positive and negative masks can be added as separate shapes in the composite shape.
The union of all positive shape defines an area in which the current valid flag is kept, outside this region or inside any negative shape the valid flag is set to invalid. Thus, if a point is inside any positive shape and outside all negative shapes it's valid flag is kept, otherwise it is set to invalid.

The shape is defined in the xy-plane and the profile values are mapped to y and the profile x-coordinate to x. The 2d composite shape is used as a layered mask with one shape per layer.
For profiles with 2d-coordinates the y-coordinate is not used in the processing.

All shapes in the composite shape must be closed and if not a nil value is returned.

Coordinate system handling:
The coordinate representation is copied to the output profile.

Valid flags handling:
The valid flags vector is enabled and set regardless of the input valid flag state.</desc>
                    <sample for="lua">local profiles = Profile.setValidFlagsComposite(profiles, composite)</sample>
                    <param name="profiles" type="const object" multiplicity="[1+]" alias="Profile" desc="Input profiles"/>
                    <param name="composite" type="const object" multiplicity="1" alias="Shape.Composite" desc="The composite shape defines the outline to use when invalidating points."/>
                    <return name="profiles" type="object" multiplicity="[?*]" alias="Profile" desc="The new profiles. Returns nil if processing not possible."/>
                </function>
                <function name="setValidFlagsCompositeInplace">
                    <trait>released</trait>
                    <keywords>missing data, region, sub profile, mask</keywords>
                    <links>Profile.setValidFlagsComposite, Composite.create, Composite.addShape, Profile.setValidFlag, Profile.threshold, Profile.crop, Profile.clamp</links>
                    <desc>Sets the profile valid flags (inplace) by invalidating all points in a profile outside a composite shape.

Positive and negative masks can be added as separate shapes in the composite shape.
The union of all positive shape defines an area in which the current valid flag is kept, outside this region or inside any negative shape the valid flag is set to invalid. Thus, if a point is inside any positive shape and outside all negative shapes it's valid flag is kept, otherwise it is set to invalid.

The shape is defined in the xy-plane and the profile values are mapped to y and the profile x-coordinate to x. The 2d composite shape is used as a layered mask with one shape per layer.
For profiles with 2d-coordinates the y-coordinate is not used in the processing.

All shapes in the composite shape must be closed and if not a nil value is returned.

Coordinate system handling:
The coordinate representation is copied to the output profile.

Valid flags handling:
The valid flags vector is enabled and set regardless of the input valid flag state.</desc>
                    <sample for="lua">local profiles = Profile.setValidFlagsCompositeInplace(profiles, composite)</sample>
                    <param name="profiles" type="object" multiplicity="[1+]" alias="Profile" desc="Input profiles"/>
                    <param name="composite" type="const object" multiplicity="1" alias="Shape.Composite" desc="The composite shape defines the outline to use when invalidating points."/>
                    <return name="profiles" type="object" multiplicity="[?*]" alias="Profile" desc="The new profiles. Returns nil if processing not possible."/>
                </function>
                <function name="getSize">
                    <trait>released</trait>
                    <keywords>length, width</keywords>
                    <desc>Returns the number of measurements in the profile.</desc>
                    <sample for="lua">local size = Profile.getSize(profile)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The profile object."/>
                    <return name="size" type="int" multiplicity="?" desc="The number of measurements in the profile."/>
                </function>
                <function name="getValue">
                    <trait>released</trait>
                    <keywords>element, sample</keywords>
                    <links>Profile.setValue, Profile.getValidFlag, Profile.getCoordinate, Profile.getPoint, Profile.toPoints</links>
                    <desc>Returns the measurement values of a profile at the provided index or indexes. All values are returned if no index is supplied.</desc>
                    <sample for="lua">local value = Profile.getValue(profile, index)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The profile object."/>
                    <param name="index" type="int" multiplicity="[?*]" desc="The index or vector if indexes to get. Zero-based indexing."/>
                    <return name="value" type="float" multiplicity="[?*]" desc="The value(s). Returns nil if any index is out-of-range."/>
                </function>
                <function name="setValue">
                    <trait>released</trait>
                    <keywords>element, sample</keywords>
                    <links>Profile.getValue, Profile.setValidFlag, Profile.setCoordinate, Profile.setPoint</links>
                    <desc>Set a measurement value in a profile at one or multiple given position(s). Out-of-range indexes are ignored.</desc>
                    <sample for="lua">Profile.setValue(profile, index, value)</sample>
                    <param name="profile" type="object" alias="Profile" desc="The profile object."/>
                    <param name="index" type="int" multiplicity="[1+]" desc="The index or indexes to set. Zero-based indexing."/>
                    <param name="value" type="float" desc="The measurement value to set."/>
                </function>
                <function name="getValidFlagsEnabled">
                    <trait>released</trait>
                    <keywords>missing data</keywords>
                    <links>Profile.setValidFlagsEnabled</links>
                    <desc>Checks if global usage of valid flags is enabled. 'False' means that all measurement values are treated as valid regardless of the valid flags vector. 'True' means that the valid flag is regarded for each measurement.</desc>
                    <sample for="lua">local validFlagsEnabled = Profile.getValidFlagsEnabled(profile)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The profile object."/>
                    <return name="validFlagsEnabled" type="bool" desc="Indicating if the valid flags are enabled."/>
                </function>
                <function name="setValidFlagsEnabled">
                    <trait>released</trait>
                    <keywords>missing data</keywords>
                    <links>Profile.getValidFlagsEnabled</links>
                    <desc>Enables or disables the individual valid flag of each measurement. 'False' means that all measurement values are treated as valid regardless of the valid flags set. 'True' means that the valid flag is regarded for each measurement. If the flags are enabled and the profile did not contain a valid flags vector, the vector is generated.</desc>
                    <sample for="lua">Profile.setValidFlagsEnabled(profile, validFlagsEnabled)</sample>
                    <param name="profile" type="object" alias="Profile" desc="The profile object."/>
                    <param name="validFlagsEnabled" type="bool" desc="Activating or deactivating the usage of the valid data flags vector."/>
                </function>
                <function name="getCoordinate">
                    <trait>released</trait>
                    <keywords>spatial, location, position</keywords>
                    <links>Profile.setCoordinate, Profile.getValue, Profile.getValidFlag, Profile.getPoint, Profile.toPoints, Profile.getImplicitCoordinates</links>
                    <desc>Returns the coordinates of the given index or vector of indexes. All coordinates are returned if no index is supplied.</desc>
                    <sample for="lua">local coordinate = Profile.getCoordinate(profile, index)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The profile object."/>
                    <param name="index" type="int" multiplicity="[?*]" desc="The index or vector of indexes. Zero-based indexing."/>
                    <return name="coordinate" type="auto" multiplicity="[?*]" desc="The world coordinate(s), a (vector of) floating point number(s) for 1D coordinates and a (vector of) 2D point(s) for 2D coordinates. Returns nil if any index is out-of-range."/>
                </function>
                <function name="setCoordinate">
                    <trait>released</trait>
                    <keywords>spatial, location, position</keywords>
                    <links>Profile.getCoordinate, Profile.setValue, Profile.setValidFlag, Profile.setPoint, Profile.setImplicitCoordinates</links>
                    <desc>Sets the coordinates of the given index or indexes. The dimensionality of the new coordinates must match those of the profile, e.g. only 2D coordinates can be set in a profile already using 2D coordinates. If the coordinate representation of the profile is implicit, it is silently converted to an explicit representation before updating coordinates. Use setImplicitCoordinates to setup an implicit coordinate system.</desc>
                    <sample for="lua">Profile.setCoordinate(profile, index, coordinate)</sample>
                    <param name="profile" type="object" alias="Profile" desc="The profile object."/>
                    <param name="index" type="int" multiplicity="[1+]" desc="The index or vector of indexes. Zero-based indexing. Out-of-range indexes are ignored."/>
                    <param name="coordinate" type="const auto" multiplicity="[1+]" desc="The world coordinates, a (vector of) floating point number(s) for 1D coordinates and a (vector of) 2D point(s) for 2D coordinates. The vector must be of the same length as the index vector."/>
                </function>
                <function name="getImplicitCoordinates">
                    <trait>released</trait>
                    <keywords>spatial, location, position</keywords>
                    <links>Profile.getCoordinate</links>
                    <desc>Gets implicit coordinate specification (the coordinates of the first sample and the difference between samples). Returns two floating point numbers if implicit 1D coordinates, or two 2D points if implicit 2D coordinates. Use getCoordinate to get explicit coordinates of specific samples.</desc>
                    <sample for="lua">local start, delta = Profile.getImplicitCoordinates(profile)</sample>
                    <param name="profile" type="object" alias="Profile" desc="The profile object."/>
                    <return name="start" type="const auto" desc="The coordinates of the first sample, a scalar value or 2D Point."/>
                    <return name="delta" type="const auto" desc="The difference in position of each two consecutive samples, a scalar value or 2D Point."/>
                </function>
                <function name="setImplicitCoordinates">
                    <trait>released</trait>
                    <keywords>spatial, location, position</keywords>
                    <links>Profile.setCoordinate</links>
                    <desc>Sets the coordinates of the profile to implicit type (the coordinates of the first sample and a difference between samples). Provide two floating point numbers to set 1D coordinates, or two 2D points to set 2D coordinates. Use setCoordinate to set explicit coordinates of specific samples.</desc>
                    <sample for="lua">Profile.setImplicitCoordinates(profile, start, delta)</sample>
                    <param name="profile" type="object" alias="Profile" desc="The profile object."/>
                    <param name="start" type="const auto" desc="The coordinates of the first sample, a scalar value or 2D Point."/>
                    <param name="delta" type="const auto" desc="The difference in position of each two consecutive samples, a scalar value or 2D Point."/>
                </function>
                <function name="getPoint">
                    <trait>released</trait>
                    <keywords>spatial, location, position</keywords>
                    <links>Profile.setPoint, Profile.getCoordinate, Profile.getValue, Profile.getValidFlag, Profile.toPoints</links>
                    <desc>Returns the coordinates and measurement values of the given index or vector of indexes, as points [coordinate,value].</desc>
                    <sample for="lua">local point = Profile.getPoint(profile, index)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The profile object."/>
                    <param name="index" type="int" multiplicity="[1+]" desc="The index or vector of indexes. Zero-based indexing."/>
                    <return name="point" type="auto" multiplicity="[?*]" desc="The world coordinate(s) and measurement values, a (vector of) 2D point(s) for 1D coordinates and a (vector of) 3D point(s) for 2D coordinates. Returns nil if any index is out-of-range."/>
                </function>
                <function name="setPoint">
                    <trait>released</trait>
                    <keywords>spatial, location, position</keywords>
                    <links>Profile.getPoint, Profile.setCoordinate, Profile.setValue, Profile.setValidFlag</links>
                    <desc>Sets the coordinates and measurement values of the given index or indexes. The dimensionality of the new coordinates must match those of the profile, e.g. only 2D coordinates (the input is a 3D point. Value + coordinate) can be set in a profile already using 2D coordinates. If the coordinate representation of the profile is implicit, it is silently converted to an explicit representation before updating coordinates. Use setImplicitCoordinates to setup an implicit coordinate system.</desc>
                    <sample for="lua">Profile.setPoint(profile, index, point)</sample>
                    <param name="profile" type="object" alias="Profile" desc="The profile object."/>
                    <param name="index" type="int" multiplicity="[1+]" desc="The index or vector of indexes. Zero-based indexing. Out-of-range indexes are ignored."/>
                    <param name="point" type="const auto" multiplicity="[1+]" desc="The world coordinates and measurement values [coordinate,value], a (vector of) 2D point(s) for 1D coordinates and a (vector of) 3D point(s) for 2D coordinates. The vector must be of the same length as the index vector."/>
                </function>
                <function name="getValidFlag">
                    <trait>released</trait>
                    <keywords>missing data</keywords>
                    <links>Profile.setValidFlag, Profile.getValue, Profile.getCoordinate</links>
                    <desc>Returns the valid flag of the measurements at the given index or vector of indexes. All valid flags are returned if no index is supplied.</desc>
                    <sample for="lua">local flag = Profile.getValidFlag(profile, index)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The profile object."/>
                    <param name="index" type="int" multiplicity="[?*]" desc="The index or vector of indexes. Zero-based indexing."/>
                    <return name="flag" type="int" multiplicity="[?*]" desc="The valid flag. 0 means invalid data and non-zero valid data. Returns nil if any index is out-of-range."/>
                </function>
                <function name="setValidFlag">
                    <trait>released</trait>
                    <keywords>missing data</keywords>
                    <links>Profile.getValidFlag, Profile.setValue, Profile.setCoordinate</links>
                    <desc>Set the valid flags of a profile at the given index or vector of indexes. Sets the flags in the input profile (in-place).</desc>
                    <sample for="lua">Profile.setValidFlag(profile, index, flag)</sample>
                    <param name="profile" type="object" alias="Profile" desc="The profile object."/>
                    <param name="index" type="int" multiplicity="[1+]" desc="The index or vector of indexes. Zero-based indexing. Out-of-range indexes are ignored."/>
                    <param name="flag" type="int" desc="The valid flag to set to the indices. 0 means invalid and non-zero means valid."/>
                </function>
                <function name="setValidFlagRange">
                    <trait>released</trait>
                    <desc>Set a range of valid flags in the input profile (inplace). Sets all valid flags between startIndex and stopIndex to the specified flag.

If stopIndex is omitted all flags from startIndex to the end of the profile is set.</desc>
                    <sample for="lua">result = Profile.setValidFlagRange(profile, flag, startIndex, stopIndex)</sample>
                    <param name="profile" type="object" alias="Profile" desc="The profile object."/>
                    <param name="flag" type="int" multiplicity="[1+]" desc="The valid flag or vector of valid flags, to set to the indices. 0 means invalid and non-zero means valid."/>
                    <param name="startIndex" type="int" multiplicity="[1+]" desc="Start index or vector of start indices. Zero-based indexing."/>
                    <param name="stopIndex" type="int" multiplicity="[?*]" desc="Stop index or vector of stop indices. Zero-based indexing. Optional."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="Reference to the result profile."/>
                </function>
                <function name="removeValidFlagVector">
                    <trait>released</trait>
                    <desc>Remove the valid flag vector from the profile.</desc>
                    <sample for="lua"> Profile.removeValidFlagVector(profile)</sample>
                    <param name="profile" type="object" alias="Profile" desc="The profile object."/>
                </function>
                <function name="getValidCount">
                    <trait>released</trait>
                    <desc>Get the number of valid elements in a profile or set of profiles, one count for each profile is returned. If valid flags are not used validCount = profile.Size().</desc>
                    <sample for="lua"> local validCount = Profile.getValidCount(profile)</sample>
                    <param name="profile" type="const object" multiplicity="[1+]" alias="Profile" desc="The profile or profiles."/>
                    <return name="validCount" type="int" multiplicity="[?*]" desc="Number of valid elements."/>
                </function>
                <function name="convertCoordinateType">
                    <trait>released</trait>
                    <desc>Converts sample coordinates in the profile. Possible coordinate types: IMPLICIT_1D, EXPLICIT_1D, IMPLICIT_2D, EXPLICIT_2D. Note that the values in the profile are kept unchanged.

Implicit to explicit:   Change the coordinate representation from start + delta representation, to vector with absolute positions.
Explicit to implicit:   Change the coordinate representation from vector with absolute coordinates, to a start + delta representation. Preserving the coordinates for the first and last sample.
1D to 2D:               The 1D coordinates are placed on the x-axis in the 2D coordinates.
2D to 1D:               The accumulated curve length in 2D is used as the new 1D coordinates. Thus, start position is 0.0.</desc>
                    <sample for="lua"> local result = Profile.convertCoordinateType(profile, coordinateType)</sample>
                    <param name="profile" type="object" alias="Profile" desc="The profile object."/>
                    <param name="coordinateType" type="enum" ref="CoordinateType" desc="New coordinate type."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="Reference to the result profile."/>
                </function>
                <function name="getCoordinateType">
                    <desc>Return the used coordinate representation type. Possible coordinate types: IMPLICIT_1D, EXPLICIT_1D, IMPLICIT_2D, EXPLICIT_2D.</desc>
                    <sample for="lua">coordinateType = Profile.getCoordinateType(profile)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The profile object."/>
                    <return name="coordinateType" type="enum" ref="CoordinateType" desc="The coordinate type."/>
                </function>
                <function name="getClosed">
                    <trait>released</trait>
                    <keywords>periodic, circular, infinite</keywords>
                    <links>Profile.setClosed</links>
                    <desc>Returns if the closed flag is enabled. If the flag is enabled, the profile is considered closed, meaning that the first measurement follows after the last. This affects the border handling of some operations such as filtering algorithms.</desc>
                    <sample for="lua">local isClosed = Profile.getClosed(profile)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The profile object."/>
                    <return name="isClosed" type="bool" desc="Indicating if the profile is closed."/>
                </function>
                <function name="setClosed">
                    <trait>released</trait>
                    <keywords>periodic, circular, infinite</keywords>
                    <links>Profile.getClosed</links>
                    <desc>Sets the closed flag. If the flag is enabled, the profile is considered closed, meaning that the first measurement follows after the last. This affects the border handling of some algorithms. This operation does not affect any values, coordinates of measurements or valid flags.</desc>
                    <sample for="lua">Profile.setClosed(profile, true)</sample>
                    <param name="profile" type="object" alias="Profile" desc="The profile object."/>
                    <param name="setClosed" type="bool" desc="Marking the profile as closed (true) or as open (false)."/>
                </function>
                <function name="toPolylineGraph">
                    <trait>hidden</trait>
                    <desc>Creates a 2D polyline with vertices corresponding to the sampled points. The x-coordinate of each vertex corresponds to the distance in world coordinates from the profile origin to the current sample measured along the shape it was extracted along. The y-coordinate of each vertex is the sampled value. Invalid data is drawn as zero.</desc>
                    <sample for="lua">local polyline = Profile.toPolylineGraph(profile)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The profile object."/>
                    <return name="polyline" type="object" multiplicity="?" alias="Shape" desc="The generated polyline."/>
                </function>
                <function name="toString">
                    <trait>released</trait>
                    <keywords>print, help, description</keywords>
                    <desc>Gets a user-friendly string description of the profile.</desc>
                    <sample for="lua">local str = Profile.toString(profile)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The profile object."/>
                    <return name="str" type="string" desc="User-friendly description of the profile."/>
                </function>
                <function name="getDistance">
                    <trait>released</trait>
                    <keywords>euclidian</keywords>
                    <desc>Returns the Euclidian distances between two specified profile elements. Two distances are returned, one along the coordinate axis and one between the two points represented by the (coordinate, value) pairs. For example, if the coordinates represent 2D points, the distances are calculated as follows respectively:

coordinage distance:  sqrt(dX^2 + dY^2)
total distance:  sqrt(dX^2 + dY^2 + dValue^2)</desc>
                    <sample for="lua">local coordDist, totalDist = Profile.getDistance(profile, index1, index2)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The profile object."/>
                    <param name="index1" type="int" multiplicity="[1+]" desc="Index of sample 1 or vector with indices."/>
                    <param name="index2" type="int" multiplicity="[1+]" desc="Index of sample 2 or vector with indices.."/>
                    <return name="coordDist" type="float" multiplicity="[?*]" desc="Distance in the coordinate dimensions (Euclidean distance)."/>
                    <return name="totalDist" type="float" multiplicity="[?*]" desc="Distance in the value + coordinate dimensions (Euclidean distance)."/>
                </function>
                <function name="getExtractionPolyline">
                    <trait>hidden</trait>
                    <desc>Returns the polyline approximating the shape along which the profile was extracted.</desc>
                    <sample for="lua">local polyline = Profile.getExtractionPolyline(profile)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The profile."/>
                    <return name="polyline" type="object" multiplicity="?" alias="Shape" desc="The polyline indicating where the profile was extracted."/>
                </function>
                <function name="toLineSegment">
                    <trait>hidden</trait>
                    <desc>Return the 2D line segment along which the profile is sampled. The end points of the segments are at the first and last sample respectively.</desc>
                    <sample for="lua">local lineSegment = Profile.toLineSegment(profile)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The profile."/>
                    <return name="lineSegment" type="object" multiplicity="?" alias="Shape" desc="The line segment indicating where the profile was sampled."/>
                </function>
                <function name="interpolateCoordinate">
                    <trait>released</trait>
                    <desc>Returns coordinate(s) and value(s) which are linearly interpolated between the two closest indexes in the profile.

Coordinate system handling:
The function returns coordinates as 2D Points for profiles with 2D coordinates and floats for profiles with 1D coordinates. If the profile is 1D and closed, an extrapolation is done at the wrap around (between first and last sample).

Valid flags handling:
Valid flags are only considered for the value interpolation. If any sample used in the interpolation is not valid, the output value is NaN.</desc>
                    <sample for="lua">local coordinate = Profile.interpolateCoordinate(profile, indexFloat)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The profile."/>
                    <param name="indexFloat" type="float" multiplicity="[1+]" desc="Index or indexes in floating point precision. Zero-based indexing."/>
                    <return name="coordinate" type="auto" multiplicity="[?*]" desc="The world coordinate(s) as a single value/point or as a vector of values/points. Returns nil if any index is out-of-range."/>
                    <return name="value" type="float" multiplicity="[?*]" desc="The value(s) as a single value or as a vector of values."/>
                </function>
                <function name="resize">
                    <trait>released</trait>
                    <keywords>resample, scale, subsample, decimate, interpolate, equidistant</keywords>
                    <links>Profile.resizeScale</links>
                    <desc>Samples the profile using the given number of samples and outputs these as a new profile. Linear interpolation is used. Both input and output profiles must have at least two samples. The new samples are placed equidistantly. For explicit 2D coordinates, the distance along the coordinate polygon is used. All input samples must have unique positions. Explicit 1D coordinates in the input profile must be strictly monotonic.

Coordinate system handling:
Implicit 1D coordinates are used for the output when the input coordinates are 1D (implicit or explicit). For 2D coordinates, the output coordinate type is the same as the input coordinate type. The closedness of the profile is taken into account when placing the new samples in all cases except for explicit 1D coordinates, where the wrap-around point is undefined.

Valid flags handling:
Valid flags are respected. Any output sample where at least one of the input samples used for interpolation is invalid, is marked as invalid.</desc>
                    <sample for="lua">local newProfile = Profile.resize(profile, newSize)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The profile to resize."/>
                    <param name="newSize" type="int" desc="The desired size of the new profile in samples."/>
                    <return name="newProfile" type="object" multiplicity="?" alias="Profile" desc="The new profile, or nil on error."/>
                </function>
                <function name="resizeScale">
                    <trait>released</trait>
                    <keywords>resample, scale, subsample, decimate, interpolate, equidistant</keywords>
                    <links>Profile.resize</links>
                    <desc>Samples the profile using the given scale factor of samples in relation to the number of samples in the input profile. E.g. a factor 2 generates twice as many samples in the new profile. Linear interpolation is used. Both input and output profiles must have at least two samples. The new samples are placed equidistantly. For explicit 2D coordinates, the distance along the coordinate polygon is used. All input samples must have unique positions. Explicit 1D coordinates in the input profile must be strictly monotonic.

Coordinate system handling:
Implicit 1D coordinates are used for the output when the input coordinates are 1D (implicit or explicit). For 2D coordinates, the output coordinate type is the same as the input coordinate type. The closedness of the profile is taken into account when placing the new samples in all cases except for explicit 1D coordinates, where the wrap-around point is undefined.

Valid flags handling:
Valid flags are respected. Any output sample where at least one of the input samples used for interpolation is invalid, is marked as invalid.</desc>
                    <sample for="lua">local newProfile = Profile.resizeScale(profile, factor)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The profile to resize."/>
                    <param name="factor" type="float" desc="Resize factor, e.g, 0.5 or 2.0."/>
                    <return name="newProfile" type="object" multiplicity="?" alias="Profile" desc="The new profile, or nil on error."/>
                </function>
                <function name="normalize">
                    <trait>released</trait>
                    <keywords>equalize, scale, stretch</keywords>
                    <links>Profile.normalizeInplace, Profile.multiplyConstant, Profile.multiplyAddConstant</links>
                    <desc>Normalizes the profile values. Normalization can be done either by standard deviation or range. Using standard deviation the values are scaled to get the mean and standard deviation set by the input parameters. Default is mean 0 and standard deviation 1. Using range the values are scaled so that the minimum and maximum fits the given range.

normMethod STDDEV:
param1: standard deviation.
param2: mean.

normMethod RANGE:
param1: Minimum value.
param2: Maximum value.

Coordinate system handling:
The coordinate representation of the input profile is copied to the output profile.

Valid flags handling:
The valid flags representation of the input profile is copied to the output profile.</desc>
                    <sample for="lua">local result = Profile.normalize(profile, normMethod, param1, param2)</sample>
                    <param name="profile" type="const object" multiplicity="[1+]" alias="Profile" desc="The source profile or vector of profiles."/>
                    <param name="normMethod" type="enum" ref="NormalizationMethod" desc="Normalization method. STDDEV or RANGE."/>
                    <param name="param1" type="float" multiplicity="?" desc="Standard deviation if normMethod STDDEV (Default value 1.0). Min value if normMethod RANGE (Default value 0.0)."/>
                    <param name="param2" type="float" multiplicity="?" desc="Mean value if normMethod STDDEV (Default value 0.0). Max value if normMethod RANGE (Default value 1.0)."/>
                    <return name="result" type="object" multiplicity="[?*]" alias="Profile" desc="The normalized Profile(s)."/>
                </function>
                <function name="normalizeInplace">
                    <trait>released</trait>
                    <keywords>transform, shift, move</keywords>
                    <links>Profile.normalize, Profile.translate, Profile.rotateInplace</links>
                    <desc>In-place version of normalize, see base function for full documentation.</desc>
                    <sample for="lua">local result = Profile.normalizeInplace(profile, normMethod, param1, param2)</sample>
                    <param name="profile" type="object" multiplicity="[1+]" alias="Profile" desc="The profile or vector of profiles."/>
                    <param name="normMethod" type="enum" ref="NormalizationMethod" desc="Normalization method. STDDEV or RANGE."/>
                    <param name="param1" type="float" multiplicity="?" desc="Standard deviation if normMethod STDDEV (Default value 1.0). Min value if normMethod RANGE (Default value 0.0)."/>
                    <param name="param2" type="float" multiplicity="?" desc="Mean value if normMethod STDDEV (Default value 0.0). Max value if normMethod RANGE (Default value 1.0)."/>
                    <return name="result" type="object" multiplicity="[?*]" alias="Profile" desc="Reference to the normalized Profile(s)."/>
                </function>
                <function name="shrink">
                    <trait>released</trait>
                    <keywords>clamp, denoise, hard thresholding, soft thresholding</keywords>
                    <links>Profile.binarize, Profile.clamp</links>
                    <desc>Sets all values within a threshold of a given level to that level. For example, with the default level zero, all values within +/- a threshold are set to zero. In denoising context, this is known as a shrinkage operation or hard thresholding.

Coordinate system handling:
The coordinate representation is copied to the output profile.

Valid flags handling:
Valid flags are copied to the output.</desc>
                    <sample for="lua">local newProfile = Profile.shrink(profile, threshold, level)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The input profile."/>
                    <param name="threshold" type="float" desc="Values within this distance of level is set to level."/>
                    <param name="level" type="float" multiplicity="?" desc="The level to shrink around, default is zero."/>
                    <return name="newProfile" type="object" multiplicity="?" alias="Profile" desc="The new profile, or nil on error."/>
                </function>
                <function name="shrinkInplace">
                    <trait>released</trait>
                    <keywords>clamp, denoise, hard thresholding, soft thresholding</keywords>
                    <links>Profile.binarize, Profile.clampInplace</links>
                    <desc>Inplace version of the shrink function that modifies the input profile. See the base function for full documentation.</desc>
                    <sample for="lua">Profile.shrinkInplace(profile, threshold, level)</sample>
                    <param name="profile" type="object" alias="Profile" desc="The profile."/>
                    <param name="threshold" type="float" desc="Values within this distance of level is set to level."/>
                    <param name="level" type="float" multiplicity="?" desc="The level to shrink around, default is zero."/>
                </function>
                <function name="threshold">
                    <trait>deprecated</trait>
                    <keywords>segmentation, region</keywords>
                    <desc>Return the indices of all valid profile values between the upper and lower threshold. Any threshold can be left out, in which case it has no influence on the selection.

Coordinate system handling:
The positions of the samples do not influence the function.

Missing data handling:
Only valid samples are included in the output.
This function is deprecated, please use Profile.segment instead.</desc>
                    <sample for="lua">local indices = Profile.threshold(profile, lowerThreshold, upperThreshold)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="Input profile."/>
                    <param name="lowerThreshold" type="float" multiplicity="?" desc="Lower threshold. Optional, default is no lower threshold (no lower limit on sample value)."/>
                    <param name="upperThreshold" type="float" multiplicity="?" desc="Upper threshold. Optional, default is no upper threshold (no upper limit on sample value)."/>
                    <return name="indices" type="int" multiplicity="*" desc="Zero-based indices to all valid samples between the upper and lower threshold."/>
                </function>
                <function name="segment">
                    <trait>released</trait>
                    <keywords>segmentation, region</keywords>
                    <desc>Return the start and stop indices of all segments of the profile that have consecutive valid values between the upper and lower threshold. Any threshold can be left out, in which case it has no influence on the selection.

Coordinate system handling:
The positions of the samples do not influence the function.

Missing data handling:
Only valid samples are included in the output.</desc>
                    <sample for="lua">local segments = Profile.segment(profile, lowerThreshold, upperThreshold)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="Input profile."/>
                    <param name="lowerThreshold" type="float" multiplicity="?" desc="Lower threshold. Optional, default is no lower threshold (no lower limit on sample value)."/>
                    <param name="upperThreshold" type="float" multiplicity="?" desc="Upper threshold. Optional, default is no upper threshold (no upper limit on sample value)."/>
                    <return name="segments" type="object" multiplicity="?" alias="Profile.IndexRegion" desc="IndexRegion with all segments with valid samples between the upper and lower threshold."/>
                </function>
                <function name="add">
                    <trait>released</trait>
                    <keywords>plus</keywords>
                    <links>Profile.addInplace, Profile.addConstant</links>
                    <desc>Adds two profiles sample-wise. The two profiles must have the same number of measurements.

Coordinate system handling:
The coordinate representation of the first input profile is copied to the output profile.

Valid flags handling:
Both input profiles must have a valid measurement to produce a valid output for an index.</desc>
                    <sample for="lua">local result = Profile.add(profile1, profile2)</sample>
                    <param name="profile1" type="const object" alias="Profile" desc="The first source profile."/>
                    <param name="profile2" type="const object" alias="Profile" desc="The second source profile."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="The resulting profile."/>
                </function>
                <function name="addInplace">
                    <trait>released</trait>
                    <keywords>plus</keywords>
                    <links>Profile.add, Profile.addConstantInplace</links>
                    <desc>In-place version of the Profile.add function that modifies the input profile. See base function for full documentation.</desc>
                    <sample for="lua">local result = Profile.addInplace(profile1, profile2)</sample>
                    <param name="profile1" type="object" alias="Profile" desc="The first source profile. This profile is overwritten with the result of the sum."/>
                    <param name="profile2" type="const object" alias="Profile" desc="The second source profile."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="Reference to the result profile."/>
                </function>
                <function name="subtract">
                    <trait>released</trait>
                    <keywords>minus</keywords>
                    <links>Profile.subtractInplace, Profile.difference</links>
                    <desc>Subtracts the second profile from the first, sample-wise. The two profiles must have the same number of samples.

Coordinate system handling:
The coordinate representation of the first input profile is copied to the output profile.

Valid flags handling:
Both input profiles must have a valid measurement to produce a valid output for an index.</desc>
                    <sample for="lua">local result = Profile.subtract(profile1, profile2)</sample>
                    <param name="profile1" type="const object" alias="Profile" desc="The first source profile."/>
                    <param name="profile2" type="const object" alias="Profile" desc="The second source profile."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="The difference profile."/>
                </function>
                <function name="subtractInplace">
                    <trait>released</trait>
                    <keywords>minus</keywords>
                    <links>Profile.subtract, Profile.differenceInplace</links>
                    <desc>In-place version of the Profile.subtract function that modifies the input profile. See base function for full documentation.</desc>
                    <sample for="lua">local result = Profile.subtractInplace(profile1, profile2)</sample>
                    <param name="profile1" type="object" alias="Profile" desc="The first source profile. This profile is overwritten with the result of the difference."/>
                    <param name="profile2" type="const object" alias="Profile" desc="The second source profile."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="Reference to the result profile."/>
                </function>
                <function name="multiply">
                    <trait>released</trait>
                    <keywords>times</keywords>
                    <links>Profile.multiplyInplace, Profile.multiplyConstant</links>
                    <desc>Multiplies two profiles sample-wise. The two profiles must have the same number of measurements.

Coordinate system handling:
The coordinate representation of the first input profile is copied to the output profile.

Valid flags handling:
Both input profiles must have a valid measurement to produce a valid output for an index.</desc>
                    <sample for="lua">local result = Profile.multiply(profile1, profile2)</sample>
                    <param name="profile1" type="const object" alias="Profile" desc="The first source profile."/>
                    <param name="profile2" type="const object" alias="Profile" desc="The second source profile."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="The product profile."/>
                </function>
                <function name="multiplyInplace">
                    <trait>released</trait>
                    <keywords>times</keywords>
                    <links>Profile.multiply, Profile.multiplyConstantInplace</links>
                    <desc>In-place version of the Profile.multiply function that modifies the input profile. See base function for full documentation.</desc>
                    <sample for="lua">local result = Profile.multiplyInplace(profile1, profile2)</sample>
                    <param name="profile1" type="object" alias="Profile" desc="The first source profile. This profile is overwritten with the result of the multiplication."/>
                    <param name="profile2" type="const object" alias="Profile" desc="The second source profile."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="Reference to the result profile."/>
                </function>
                <function name="divide">
                    <trait>released</trait>
                    <links>Profile.divideInplace</links>
                    <desc>Divides the first profile with the second, sample-wise. The two profiles must have the same number of samples. If division-by-zero occurs, the corresponding output is set to zero.

Coordinate system handling:
The coordinate representation of the first input profile is copied to the output profile.

Valid flags handling:
The valid flags of the output are enabled if any of the inputs have their flags enabled. Both input profiles must have a valid measurement to produce a valid output for an index. If output valid flags are enabled, division-by-zero sets the corresponding valid flag to false.</desc>
                    <sample for="lua">local result = Profile.divide(profile1, profile2)</sample>
                    <param name="profile1" type="const object" alias="Profile" desc="The first source profile."/>
                    <param name="profile2" type="const object" alias="Profile" desc="The second source profile."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="The resulting profile."/>
                </function>
                <function name="divideInplace">
                    <trait>released</trait>
                    <links>Profile.divide</links>
                    <desc>In-place version of the Profile.divide function that modifies the input profile. See base function for full documentation.</desc>
                    <sample for="lua">local result = Profile.divideInplace(profile1, profile2)</sample>
                    <param name="profile1" type="object" alias="Profile" desc="The first source profile. This profile is overwritten with the result of the division."/>
                    <param name="profile2" type="const object" alias="Profile" desc="The second source profile."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="Reference to the result profile."/>
                </function>
                <function name="multiplyConstant">
                    <trait>released</trait>
                    <keywords>scale</keywords>
                    <links>Profile.multiply, Profile.multiplyAddConstant, Profile.multiplyConstantInplace</links>
                    <desc>Multiplies a profile with a constant.

Coordinate system handling:
The coordinate representation of the input profile is copied to the output profile.

Valid flags handling:
The valid flags representation of the input profile is copied to the output profile.</desc>
                    <sample for="lua">local result = Profile.multiplyConstant(profile, constant)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The source profile."/>
                    <param name="constant" type="float" desc="The constant to multiply the samples with."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="The multiplied profile."/>
                </function>
                <function name="multiplyConstantInplace">
                    <trait>released</trait>
                    <keywords>scale</keywords>
                    <links>Profile.multiplyConstant, Profile.multiplyAddConstantInplace, Profile.multiplyInplace</links>
                    <desc>In-place version of the Profile.multiplyConstant function that modifies the input profile. See base function for full documentation.</desc>
                    <sample for="lua">local result = Profile.multiplyConstantInplace(profile1, constant)</sample>
                    <param name="profile1" type="object" alias="Profile" desc="The first source profile. This profile is overwritten with the result of the multiplication."/>
                    <param name="constant" type="float" desc="The constant to multiply the samples with."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="Reference to the result profile."/>
                </function>
                <function name="multiplyAddConstant">
                    <trait>released</trait>
                    <links>Profile.multiplyAddConstantInplace, Profile.multiplyAdd</links>
                    <desc>Multiplies one profile with alpha, thereafter the constant beta is added. If the multiplication underflows/overflows, the result is underflow/overflow, regardless of the addition.

Coordinate system handling:
The coordinate representation of the input profile is copied to the output profile.

Valid flags handling:
The valid flags representation of the input profile is copied to the output profile.</desc>
                    <sample for="lua">local result = Profile.multiplyAddConstant(profile, alpha, beta)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The source profile."/>
                    <param name="alpha" type="float" desc="The constant to multiply with."/>
                    <param name="beta" type="float" desc="The constant to add."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="The resulting profile."/>
                </function>
                <function name="multiplyAddConstantInplace">
                    <trait>released</trait>
                    <links>Profile.multiplyAddConstant, Profile.multiplyAddInplace</links>
                    <desc>In-place version of the Profile.multiplyAddConstant function that modifies the input profile. See base function for full documentation.</desc>
                    <sample for="lua">local result = Profile.multiplyAddConstantInplace(profile1, alpha, beta)</sample>
                    <param name="profile1" type="object" alias="Profile" desc="The first source profile. This profile is overwritten with the result of the multiplication and sum."/>
                    <param name="alpha" type="float" desc="The constant to multiply with."/>
                    <param name="beta" type="float" desc="The constant to add."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="Reference to the result profile."/>
                </function>
                <function name="addConstant">
                    <trait>released</trait>
                    <keywords>shift, translate</keywords>
                    <links>Profile.addConstantInplace</links>
                    <desc>Adds a constant to the measurements of the profile.

Coordinate system handling:
The coordinate representation of the input profile is copied to the output profile.

Valid flags handling:
The valid flags representation of the input profile is copied to the output profile.</desc>
                    <sample for="lua">local result = Profile.addConstant(profile, constant)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The source profile."/>
                    <param name="constant" type="float" desc="The constant to add."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="The resulting profile."/>
                </function>
                <function name="addConstantInplace">
                    <trait>released</trait>
                    <keywords>shift, translate</keywords>
                    <links>Profile.addConstant</links>
                    <desc>In-place version of the Profile.addConstant function that modifies the input profile. See base function for full documentation.</desc>
                    <sample for="lua">local result = Profile.addConstantInplace(profile, constant)</sample>
                    <param name="profile" type="object" alias="Profile" desc="The source profile. This profile is overwritten with the result of the sum."/>
                    <param name="constant" type="float" desc="The constant to add."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="Reference to the result profile."/>
                </function>
                <function name="abs">
                    <trait>released</trait>
                    <keywords>absolute</keywords>
                    <links>Profile.absInplace</links>
                    <desc>Computes the absolute value of each measurement in the profile.

Coordinate system handling:
The coordinate representation of the input profile is copied to the output profile.

Valid flags handling:
The valid flags representation of the input profile is copied to the output profile.</desc>
                    <sample for="lua">local result = Profile.abs(profile)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The source profile."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="The resulting profile."/>
                </function>
                <function name="absInplace">
                    <trait>released</trait>
                    <keywords>absolute</keywords>
                    <links>Profile.abs</links>
                    <desc>In-place version of the Profile.abs function that modifies the input profile. See base function for full documentation.</desc>
                    <sample for="lua">local result = Profile.absInplace(profile)</sample>
                    <param name="profile" type="object" alias="Profile" desc="The source profile. This profile is overwritten with the result of the abs."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="Reference to the result profile."/>
                </function>
                <function name="pow">
                    <trait>released</trait>
                    <keywords>power, square, squared, exponential</keywords>
                    <links>Profile.powInplace</links>
                    <desc>Raises each measurement value to the power of an exponent.

Coordinate system handling:
The coordinate representation of the input profile is copied to the output profile.

Valid flags handling:
The valid flags representation of the input profile is copied to the output profile.</desc>
                    <sample for="lua">local result = Profile.pow(profile, exponent)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The source profile."/>
                    <param name="exponent" type="float" desc="The exponent."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="The resulting profile."/>
                </function>
                <function name="powInplace">
                    <trait>released</trait>
                    <keywords>power, square, squared, exponential</keywords>
                    <links>Profile.pow</links>
                    <desc>In-place version of the Profile.pow function that modifies the input profile. See base function for full documentation.</desc>
                    <sample for="lua">local result = Profile.powInplace(profile, exponent)</sample>
                    <param name="profile" type="object" alias="Profile" desc="The source profile. This profile is overwritten with the result of the pow."/>
                    <param name="exponent" type="float" desc="The exponent."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="Reference to the result profile."/>
                </function>
                <function name="difference">
                    <trait>released</trait>
                    <keywords>sad, ssd</keywords>
                    <links>Profile.differenceInplace, Profile.subtract</links>
                    <desc>Calculates the absolute or squared difference between two profiles, sample-wise. The two profiles must have the same number of samples.

Coordinate system handling:
The coordinate representation of the first input profile is copied to the output profile.

Valid flags handling:
Both input profiles must have a valid measurement to produce a valid output for an index.</desc>
                    <sample for="lua">local result = Profile.difference(profile1, profile2, mode)</sample>
                    <param name="profile1" type="const object" alias="Profile" desc="The first source profile."/>
                    <param name="profile2" type="const object" alias="Profile" desc="The second source profile."/>
                    <param name="mode" type="enum" ref="DifferenceMode" desc="Absolute or squared difference (ABS or SQUARE)."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="The difference profile."/>
                </function>
                <function name="differenceInplace">
                    <trait>released</trait>
                    <keywords>sad, ssd</keywords>
                    <links>Profile.difference, Profile.subtractInplace</links>
                    <desc>In-place version of the Profile.difference function that modifies the input profile. See base function for full documentation.</desc>
                    <sample for="lua">local result = Profile.differenceInplace(profile1, profile2, mode)</sample>
                    <param name="profile1" type="object" alias="Profile" desc="The first source profile. This profile is overwritten with the result of the difference."/>
                    <param name="profile2" type="const object" alias="Profile" desc="The second source profile."/>
                    <param name="mode" type="enum" ref="DifferenceMode" desc="Absolute or squared difference (ABS or SQUARE)."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="Reference to the result profile."/>
                </function>
                <function name="clamp">
                    <trait>released</trait>
                    <keywords>limit, threshold</keywords>
                    <links>Profile.clampInplace, Profile.shrink</links>
                    <desc>Clamps each measurement value to an interval (minValue, maxValue).

Coordinate system handling:
The coordinate representation of the input profile is copied to the output profile.

Valid flags handling:
The valid flags representation of the input profile is copied to the output profile.</desc>
                    <sample for="lua">local result = Profile.clamp(profile, minValue, maxValue)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The source profile."/>
                    <param name="minValue" type="float" desc="The minimum value to clamp to."/>
                    <param name="maxValue" type="float" desc="The maximum value to clamp to."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="The clamped profile."/>
                </function>
                <function name="clampInplace">
                    <trait>released</trait>
                    <keywords>limit, threshold</keywords>
                    <links>Profile.clamp, Profile.shrinkInplace</links>
                    <desc>In-place version of the Profile.clamp function that modifies the input profile. See base function for full documentation.</desc>
                    <sample for="lua">local result = Profile.clampInplace(profile, minValue, maxValue)</sample>
                    <param name="profile" type="object" alias="Profile" desc="The source profile. This profile is overwritten with the clapped result."/>
                    <param name="minValue" type="float" desc="The minimum value to clamp to."/>
                    <param name="maxValue" type="float" desc="The maximum value to clamp to."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="Reference to the result profile."/>
                </function>
                <function name="isEqual">
                    <trait>hidden</trait>
                    <desc>Checks if two profiles are equal, both in terms of size and sample content. In case there are missing data, two options are available, selectable by the checkMissing switch. Either only values which are valid in both profiles are compared, or the profiles are considered unequal if one specific sample is missing in one profile while valid in the other. Samples invalid in both profiles are ignored in either case.</desc>
                    <sample for="lua">local result = Profile.isEqual(profile1, profile2, checkMissing, epsilon)</sample>
                    <param name="profile1" type="const object" alias="Profile" desc="The first source profile."/>
                    <param name="profile2" type="const object" alias="Profile" desc="The second source profile."/>
                    <param name="checkMissing" type="bool" multiplicity="?" desc="If set to true (default), the missing samples in each profile must be at the same locations for the profiles to be considered equal."/>
                    <param name="epsilon" type="float" multiplicity="?" desc="Tolerance for comparing floating point values, values that differ less than this are considered equal. Default: 1e-5."/>
                    <return name="result" type="bool" multiplicity="?" desc="True if the profiles are equal at each non-missing sample and meta data matches."/>
                </function>
                <function name="getMin">
                    <trait>released</trait>
                    <keywords>minimum</keywords>
                    <desc>Returns the minimum value of a profile. In addition, the (first) index and the number of valid measurements are also returned. The function is vectorized so that it is possible to operate on a vector of profiles. For empty profiles or profiles without valid data, zero is returned for both minValue and validCount. Index is set to -1.

An IndexRegion can be used to select where to calculate the minimum. Default is to use the entire profile.

Coordinate system handling:
The coordinate representation is not considered in this operation.

Valid flags handling:
Only the valid measurements are considered in the calculation.</desc>
                    <sample for="lua">local minValue, index, validCount = Profile.getMin(profile, region)</sample>
                    <param name="profile" type="const object" multiplicity="[1+]" alias="Profile" desc="The source profile or vector of profiles."/>
                    <param name="region" type="auto" multiplicity="?" desc="IndexRegion to search within. Optional, default is the entire profile. A start index may also be provided for backward compatibility (deprecated)."/>
                    <param name="stopIndex" type="int" multiplicity="?" desc="Deprecated, stop index of search range, used in combination with start index. Use an IndexRegion instead."/>
                    <return name="minValue" type="float" multiplicity="[?*]" desc="The minimum value for each input profile."/>
                    <return name="index" type="int" multiplicity="[?*]" desc="The (first) index at which the minimum value is located. Vector output if a vector of profiles is given as input."/>
                    <return name="validCount" type="int" multiplicity="[?*]" desc="The number of valid measurements per input profile."/>
                </function>
                <function name="getMax">
                    <trait>released</trait>
                    <keywords>maximum</keywords>
                    <desc>Returns the maximum value of a profile. In addition, the (first) index and the number of valid measurements are also returned. The function is vectorized so that it is possible to operate on a vector of profiles.  For empty profiles or profiles without valid data, zero is returned for both maxValue and validCount. Index is set to -1.

An IndexRegion can be used to select where to calculate the maximum. Default is to use the entire profile.

Coordinate system handling:
The coordinate representation is not considered in this operation.

Valid flags handling:
Only the valid measurements are considered in the calculation.</desc>
                    <sample for="lua">local maxValue, index, validCount = Profile.getMax(profile)</sample>
                    <param name="profile" type="const object" multiplicity="[1+]" alias="Profile" desc="The source profile or vector of profiles."/>
                    <param name="region" type="auto" multiplicity="?" desc="IndexRegion to search within. Optional, default is the entire profile. A start index may also be provided for backward compatibility (deprecated)."/>
                    <param name="stopIndex" type="int" multiplicity="?" desc="Deprecated, stop index of search range, used in combination with start index. Use an IndexRegion instead."/>
                    <return name="maxValue" type="float" multiplicity="[?*]" desc="The maximum value for each input profile."/>
                    <return name="index" type="int" multiplicity="[?*]" desc="The (first) index at which the maximum value is located. Vector output if a vector of profiles is given as input."/>
                    <return name="validCount" type="int" multiplicity="[?*]" desc="The number of valid measurements per input profile."/>
                </function>
                <function name="getMean">
                    <trait>released</trait>
                    <keywords>average, statistics</keywords>
                    <desc>Returns the mean value of a profile. In addition, the number of valid measurements is also returned. The function is vectorized so that it is possible to operate on a vector of profiles.  For empty profiles or profiles without valid data, zero is returned for both meanValue and validCount.

An IndexRegion can be used to select over which samples to calculate the mean. Default is to use the entire profile.

Coordinate system handling:
The coordinate representation is not considered in this operation.

Valid flags handling:
Only the valid measurements are considered in the calculation.</desc>
                    <sample for="lua">local meanValue, validCount = Profile.getMean(profile)</sample>
                    <param name="profile" type="const object" multiplicity="[1+]" alias="Profile" desc="The source profile or vector of profiles."/>
                    <param name="region" type="auto" multiplicity="?" desc="IndexRegion to search within. Optional, default is the entire profile. A start index may also be provided for backward compatibility (deprecated)."/>
                    <param name="stopIndex" type="int" multiplicity="?" desc="Deprecated, stop index of search range, used in combination with start index. Use an IndexRegion instead."/>
                    <return name="meanValue" type="float" multiplicity="[?*]" desc="The mean value, one value for each profile."/>
                    <return name="validCount" type="int" multiplicity="[?*]" desc="The number of valid elements per profile."/>
                </function>
                <function name="getMedian">
                    <trait>released</trait>
                    <keywords>percentile, statistics</keywords>
                    <desc>Returns the median value of a profile. In addition, the number of valid measurements is also returned. The function is vectorized so that it is possible to operate on a vector of profiles.  For empty profiles or profiles without valid data, zero is returned for both medianValue and validCount.

An IndexRegion can be used to select over wich samples to calculate the median. Default is to use the entire profile.

Coordinate system handling:
The coordinate representation is not considered in this operation.

Valid flags handling:
Only the valid measurements are considered in the calculation.</desc>
                    <sample for="lua">local medianValue, validCount = Profile.getMedian(profile)</sample>
                    <param name="profile" type="const object" multiplicity="[1+]" alias="Profile" desc="The source profile or vector of profiles."/>
                    <param name="region" type="auto" multiplicity="?" desc="IndexRegion to search within. Optional, default is the entire profile. A start index may also be provided for backward compatibility (deprecated)."/>
                    <param name="stopIndex" type="int" multiplicity="?" desc="Deprecated, stop index of search range, used in combination with start index. Use an IndexRegion instead."/>
                    <return name="medianValue" type="float" multiplicity="[?*]" desc="The median value, one value for each profile."/>
                    <return name="validCount" type="int" multiplicity="[?*]" desc="The number of valid measurements per profile."/>
                </function>
                <function name="getSum">
                    <trait>released</trait>
                    <keywords>total, summation, integral, statistics</keywords>
                    <links>Profile.getArea</links>
                    <desc>Returns the sum of the measurement of a profile. In addition, the number of valid measurements is also returned. The function is vectorized so that it is possible to operate on a vector of profiles.  Zero is returned for profiles without valid data. Index regions can be used to calculate the sum within a region or regions.

If one profile is given and one region, the function returns the profile sum in that region.
If one profile and a list of regions are given, the function returns a list of profile sums, one for each region.
If a list of profiles and one region are given, the function returns a list with the sum in that region in each profile.
If a list of profiles and a list of regions are given, the function returns a list of profile sums so that the first sum is over the first region in the first profile, the second sum is over the second region in the second profile, and so on. The lists must be the same length.
The region is optional, the default is to use the entire profile.

Valid flags handling:
Only the valid measurements are considered in the calculation.</desc>
                    <sample for="lua">local sumValue, validCount = Profile.getSum(profile, region)</sample>
                    <param name="profile" type="const object" multiplicity="[1+]" alias="Profile" desc="The source profile or vector of profiles."/>
                    <param name="region" type="const object" multiplicity="[?*]" alias="Profile.IndexRegion" desc="The region or regions to sum over, default is the entire profile."/>
                    <return name="sum" type="float" multiplicity="[?*]" desc="The sum, one sum for each profile or region."/>
                    <return name="validCount" type="int" multiplicity="[?*]" desc="The number of valid measurements per profile or region."/>
                </function>
                <function name="getStandardDeviation">
                    <trait>deprecated</trait>
                    <keywords>variance, statistics</keywords>
                    <desc>This function is deprecated, please use Profile.getStdDev instead.
Returns both the mean and standard deviation of the measurements in a profile.  In addition, the number of valid measurements is also returned. The function is vectorized so that it is possible to operate on a vector of profiles.  For empty profiles or profiles without valid data, zero is returned for meanValue, stdDev and validCount.

An IndexRegion can be used to select over wich samples to calculate the standard deviation. Default is to use the entire profile.

Coordinate system handling:
The coordinate representation is not considered in this operation.

Valid flags handling:
Only the valid measurements are considered in the calculation.</desc>
                    <sample for="lua">local meanValue, stdDev, validCount = Profile.getStandardDeviation(profile)</sample>
                    <param name="profiles" type="const object" multiplicity="[1+]" alias="Profile" desc="The source profile or vector of profiles."/>
                    <param name="region" type="auto" multiplicity="?" desc="IndexRegion to search within. Optional, default is the entire profile. A start index may also be provided for backward compatibility (deprecated)."/>
                    <param name="stopIndex" type="int" multiplicity="?" desc="Deprecated, stop index of search range, used in combination with start index. Use an IndexRegion instead."/>
                    <return name="meanValue" type="float" multiplicity="[?*]" desc="The mean value for each profile."/>
                    <return name="stdDev" type="float" multiplicity="[?*]" desc="The standard deviation (maximum likelihood estimate), for each profile."/>
                    <return name="validCount" type="int" multiplicity="[?*]" desc="The number of valid measurements per profile."/>
                </function>
                <function name="getStdDev">
                    <trait>released</trait>
                    <keywords>variance, statistics</keywords>
                    <desc>Returns both the standard deviation and the mean of the measurements in a profile.  In addition, the number of valid measurements is also returned. The function is vectorized so that it is possible to operate on a vector of profiles.  For empty profiles or profiles without valid data, zero is returned for stdDev, meanValue and validCount.

An IndexRegion can be used to select over wich samples to calculate the standard deviation. Default is to use the entire profile.

Coordinate system handling:
The coordinate representation is not considered in this operation.

Valid flags handling:
Only the valid measurements are considered in the calculation.</desc>
                    <sample for="lua">local stdDev, meanValue, validCount = Profile.getStdDev(profile)</sample>
                    <param name="profiles" type="const object" multiplicity="[1+]" alias="Profile" desc="The source profile or vector of profiles."/>
                    <param name="region" type="auto" multiplicity="?" desc="IndexRegion to search within. Optional, default is the entire profile. A start index may also be provided for backward compatibility (deprecated)."/>
                    <param name="stopIndex" type="int" multiplicity="?" desc="Deprecated, stop index of search range, used in combination with start index. Use an IndexRegion instead."/>
                    <return name="stdDev" type="float" multiplicity="[?*]" desc="The standard deviation (maximum likelihood estimate), for each profile."/>
                    <return name="meanValue" type="float" multiplicity="[?*]" desc="The mean value for each profile."/>
                    <return name="validCount" type="int" multiplicity="[?*]" desc="The number of valid measurements per profile."/>
                </function>
                <function name="getArea">
                    <trait>released</trait>
                    <keywords>integral, riemann</keywords>
                    <links>Profile.getSum</links>
                    <desc>Returns a signed area estimation of the profile measurements. In addition, the number of valid measurements is returned. The function is vectorized so that it is possible to operate on a vector of profiles.

The area is calculated as the signed area between the coordinate axis and the linearly interpolated profile, similarly to the way the profile is drawn in a plot. Areas where the profile is negative is counted as negative area. The first sample in the profile is handled as if there was a sample with value zero before the first, at the same distance as between the first and second sample. The last sample is handled in a similar fashion. Areas of partial regions are calculated as if all samples outside the region were zero.

A region can be provided in order to calculate the area on a part of the profile(s).
For closed profiles the region may wrap the end of the profile.

Signed area:
Negative values contribute with negative area.

Valid flags handling:
Only the valid measurements are considered in the calculation.</desc>
                    <sample for="lua">local area, validCount = Profile.getArea(profile)</sample>
                    <param name="profile" type="const object" multiplicity="[1+]" alias="Profile" desc="The source profile or vector of profiles."/>
                    <param name="region" type="const object" multiplicity="?" alias="Profile.IndexRegion" desc="Region over which to calculate the area. Optional, default is the entire profile."/>
                    <return name="area" type="float" multiplicity="[?*]" desc="The estimated area."/>
                    <return name="validCount" type="int" multiplicity="[?*]" desc="The number of valid measurements per profile."/>
                </function>
                <function name="getCenterOfGravity">
                    <trait>released</trait>
                    <keywords>statistics, moment, integral</keywords>
                    <links>Profile.getArea</links>
                    <desc>Returns an estimate of the center of gravity (CoG) of the measurements in the profile. The values in the profile are considered to be point masses at the coordinate positions. In addition, the number of valid measurements is also returned. Closed profiles are not allowed. The function is vectorized so that it is possible to operate on a vector of profiles.

Negative values:
Negative values contribute with negative weight. CoG = sum(v*x)/sum(v), where v is the value and x is the coordinate.

Valid flags handling:
Only the valid measurements are considered in the calculation.</desc>
                    <sample for="lua">local cog, validCount = Profile.getCenterOfGravity(profile)</sample>
                    <param name="profile" type="const object" multiplicity="[1+]" alias="Profile" desc="The source profile or vector of profiles."/>
                    <return name="cog" type="auto" multiplicity="[?*]" desc="The estimated CoG(s). A (vector of) floating point number(s) for 1D profile(s) and a (vector of) 2D point(s) for 2D Profile(s)."/>
                    <return name="validCount" type="int" multiplicity="[?*]" desc="The number of valid measurements per profile."/>
                </function>
                <function name="aggregate">
                    <trait>released</trait>
                    <keywords>sum, mean, min, max, median</keywords>
                    <desc>Aggregate a set of profiles into one profile. Different aggregation operations are available such as sum, mean, min, max and median. All profiles must have the same number of measurements. All or none of the profiles must use the valid data flags.

Coordinate system handling:
The coordinate representation of the first input profile is copied to the output profile.

Valid flags handling:
Invalid values are excluded from the aggregation, e.g. the mean value is the mean of the valid values at a given position in the profiles. If no profile has a valid value at a particular index, the output profile will have an invalid value at that index. A profile containing the number of valid samples used in the aggregation at each index is returned. If no profile has invalid values, the valid samples profile will be constant and equal to the number of input profiles.</desc>
                    <sample for="lua">local aggregateProfile, validValuesProfile = Profile.aggregate(profiles, operation)</sample>
                    <param name="profiles" type="const object" multiplicity="+" alias="Profile" desc="The source profiles."/>
                    <param name="operation" type="enum" ref="AggregateOperation" desc="The type of operation used to generate the aggregate."/>
                    <return name="aggregateProfile" type="object" multiplicity="?" alias="Profile" desc="The aggregated profile."/>
                    <return name="validValuesProfile" type="object" multiplicity="?" alias="Profile" desc="The number of entries used for each aggregated sample."/>
                </function>
                <function name="getHistogram">
                    <trait>released</trait>
                    <keywords>statistics, distribution</keywords>
                    <desc>Returns the histogram of the values in a profile or a set of profiles. The bin centers are returned as the coordinates in the result profile. Values outside the bins (minValue,maxValue) are discarded.

Valid flags handling:
Only the valid measurements are considered in the calculation.</desc>
                    <sample for="lua">local histogram = Profile.getHistogram(profiles, binCount, minValue, maxValue)</sample>
                    <param name="profiles" type="const object" multiplicity="[1+]" alias="Profile" desc="The source profiles."/>
                    <param name="binCount" type="int" multiplicity="?" desc="The number of bins to be used in the histogram. If no value is specified the default number of bins (32) is used."/>
                    <param name="minValue" type="float" multiplicity="?" desc="The minimum value of the histogram. If no value is specified an automatic value based on the minimum value of all profiles will be used."/>
                    <param name="maxValue" type="float" multiplicity="?" desc="The maximum value of the histogram. If no value is specified an automatic value based on the maximum value of all profiles will be used."/>
                    <return name="histogram" type="object" multiplicity="?" alias="Profile" desc="Histogram, represented as a profile. The profile coordinates is the center of each histogram bin."/>
                </function>
                <function name="fillInvalidValues">
                    <trait>released</trait>
                    <keywords>missing data, interpolation</keywords>
                    <links>Profile.fillInvalidValuesWithReference</links>
                    <desc>Fills in invalid values in a profile using neighboring valid values. A number of different ways interpolation methods are available:

LINEAR:                Fills invalid values using linear interpolation. Maximum length of invalid value region can be specified with fillParam.
N invalid in a row is filled if N is smaller or equal to fillParam. All invalid are filled if fillParam is unspecified.
NEIGHBOR_MIN:          Fills invalid values with the min value of the two neighboring valid values.
NEIGHBOR_MAX:          Fills invalid values with the max value of the two neighboring valid values.
NEIGHBOR_MEAN:         Fills invalid values with the mean value of the two neighboring valid values.

Valid flags handling:
If no maximum length of invalid regions is specified all invalid values are filled and UseValidFlag is set to false.</desc>
                    <sample for="lua">local result = Profile.fillInvalidValues(profile, fillMethod, maxGap)</sample>
                    <param name="profile" type="const object" multiplicity="[1+]" alias="Profile" desc="The source profile."/>
                    <param name="fillMethod" type="enum" ref="FillInvalidMethod" desc="Method to use when filling invalid values."/>
                    <param name="maxGap" type="int" multiplicity="?" desc="Maximum gap of invalid samples to fill. Default: infinite."/>
                    <return name="result" type="object" multiplicity="[?*]" alias="Profile" desc="The filled profile."/>
                </function>
                <function name="fillInvalidValuesWithReference">
                    <trait>released</trait>
                    <keywords>missing data, interpolation</keywords>
                    <links>Profile.fillInvalidValues</links>
                    <desc>Fills invalid values with corresponding values in a reference profile.

Valid flags handling:
All samples in the reference profile is assumed to be valid. Thus, a invalid sample in the input profile is always replaced with corresponding value in the reference profile. UseValidFlag is set to false in result profile.</desc>
                    <sample for="lua">local result = Profile.fillInvalidValuesWithReference(profile, referenceProfile)</sample>
                    <param name="profile" type="const object" multiplicity="[1+]" alias="Profile" desc="The source profile."/>
                    <param name="referenceProfile" type="const object" alias="Profile" desc="The reference profile of equal length as the source profile."/>
                    <return name="result" type="object" multiplicity="[?*]" alias="Profile" desc="The filled profile."/>
                </function>
                <function name="findEqual">
                    <trait>released</trait>
                    <keywords>search, value</keywords>
                    <desc>Finds elements in a profile equal to a given value, within a give tolerance.

Valid flags handling:
Only the valid measurements are considered in the calculation.</desc>
                    <sample for="lua">local indices = Profile.findEqual(profile, value, epsilon)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The source profile."/>
                    <param name="value" type="float" desc="Value to find."/>
                    <param name="epsilon" type="float" multiplicity="?" desc="Tolerance interval. Default: eps of float32"/>
                    <return name="indices" type="int" multiplicity="[?*]" desc="Indices of found elements."/>
                </function>
                <function name="blur">
                    <trait>released</trait>
                    <keywords>smooth, low pass, gauss, lp, filter, box</keywords>
                    <links>Profile.gauss, Profile.median</links>
                    <desc>Smooths a profile using a constant normalized box filter kernel of the given size.

Coordinate system handling:
The coordinate representation is not considered in this operation. The filter operation wraps around if the isClosed-flag is on.

Valid flags handling:
Only the valid measurements are considered in the calculation. By default, all invalid measurements will be marked as invalid also in the output. If the fill flag is set to true, invalid measurements will be filled with filtered neighbor values where possible.</desc>
                    <sample for="lua">local smoothProfile = Profile.blur(profile, kernelSize)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="Input profile."/>
                    <param name="kernelSize" type="int" desc="Size of the kernel, must be positive, odd and smaller than the profile length."/>
                    <param name="fillInvalid" type="bool" multiplicity="?" desc="Optional flag to also fill in invalid values while filtering. Default is false."/>
                    <return name="smoothProfile" type="object" multiplicity="?" alias="Profile" desc="Output profile, smoothed by the blur filter."/>
                </function>
                <function name="gauss">
                    <trait>released</trait>
                    <keywords>smooth, low pass, lp, filter</keywords>
                    <links>Profile.blur, Profile.median</links>
                    <desc>Smooths a profile using a Gauss filter kernel.

Coordinate system handling:
The coordinate representation is not considered in this operation. The filter operation wraps around if the isClosed-flag is on.

Valid flags handling:
Only the valid measurements are considered in the calculation. By default, all invalid measurements will be marked as invalid also in the output. If the fill flag is set to true, invalid measurements will be filled with filtered neighbor values where possible.</desc>
                    <sample for="lua">local smoothProfile = Profile.gauss(profile, kernelSize)</sample>
                    <param name="profile" type="const object" multiplicity="[1+]" alias="Profile" desc="Input profile."/>
                    <param name="kernelSize" type="int" desc="Size of the kernel, must be positive, odd and smaller than the profile length."/>
                    <param name="fillInvalid" type="bool" multiplicity="?" desc="Optional flag to also fill in invalid values while filtering. Default is false."/>
                    <return name="smoothProfile" type="object" multiplicity="[?*]" alias="Profile" desc="Output profile, smoothed by the Gauss filter."/>
                </function>
                <function name="median">
                    <trait>released</trait>
                    <keywords>smooth, filter</keywords>
                    <links>Profile.blur, Profile.gauss</links>
                    <desc>Smooths a profile using a median filter.

Coordinate system handling:
The coordinate representation is not considered in this operation. The filter operation wraps around if the isClosed-flag is on.

Valid flags handling:
Only the valid measurements are considered in the calculation. There is an option to fill in invalid values in the filter operation.</desc>
                    <sample for="lua">local smoothProfile = Profile.median(profile, kernelSize)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="Input profile."/>
                    <param name="kernelSize" type="int" desc="Size of the kernel, must be positive, odd and smaller than the profile length."/>
                    <param name="fillInvalid" type="bool" multiplicity="?" desc="Optional flag to also fill in invalid values while filtering. Default is false."/>
                    <return name="smoothProfile" type="object" multiplicity="?" alias="Profile" desc="Output profile, filtered by the median filter."/>
                </function>
                <function name="centralDifference">
                    <trait>released</trait>
                    <keywords>derivative, slope, first, second, gradient</keywords>
                    <links>Profile.gaussDerivative</links>
                    <desc>Differentiate a profile using a first- or second-order central finite difference filter kernel. A step parameter determines how far from the center the difference is taken:

First order difference:
Step 1: [1 0 -1]
Step 2: [1 0 0 0 -1] and so on.

Second order difference:
Step 1: [1 -2 1]
Step 2: [1 0 -2 0 1] and so on.

The output is set to zero in the beginning and end of the output profile, where the entire filter does not fit within the profile.

Coordinate system handling:
The coordinate representation is not considered in this operation. The filter operation wraps around if the isClosed-flag is on.

Valid flags handling:
If the valid data flags are enabled, the output is set as invalid if any non-zero filter coefficient hits an invalid input value or is out of bounds. For example, if differenceStep=1, the first and last output values is always set as invalid, since the 1 and -1 filter coefficients are out of bounds of the input profile.</desc>
                    <sample for="lua">local diffProfile = Profile.centralDifference(profile, differenceStep, order)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="Input profile."/>
                    <param name="differenceStep" type="int" desc="How far from the center the kernel weights are placed, must be strictly positive."/>
                    <param name="order" type="enum" ref="DifferentiationOrder" desc="FIRST gives first order derivative and SECOND gives second order derivative."/>
                    <return name="diffProfile" type="object" multiplicity="?" alias="Profile" desc="Output profile created by the central difference filter."/>
                </function>
                <function name="derivative">
                    <trait>hidden</trait>
                    <desc>Derives a profile using a smoothed central difference filter kernel. Supported kernel sizes are 3, 5, 7 and 9. The used kernel weights are:
First order derivative:
3: [1 0 -1]/2
5: [1 -8 8 -1]/12
7: [-1 9 -45 45 -9 1]/60
9: [3 -32 168 -672 672 -168 32 -3]/840
Second order derivative:
3: [1 -2 1]
5: [-1 16 -30 16 -1]/12
7: [2 -27 270 -490 270 -27 2]/180
9: [-9 128 -1008 8064 -14350 8064 -1008 128 -9]/5040</desc>
                    <sample for="lua">local derivProfile = Profile.derivative(profile, kernelSizeSamples, order)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="Input profile."/>
                    <param name="kernelSizeSamples" type="int" desc="Size of the kernel, must be positive and odd."/>
                    <param name="order" type="enum" ref="DifferentiationOrder" desc="FIRST gives first order derivative and SECOND gives second order derivative."/>
                    <return name="derivProfile" type="object" multiplicity="?" alias="Profile" desc="Output profile, derived by the smoothed derivative filter."/>
                </function>
                <function name="gaussDerivative">
                    <trait>released</trait>
                    <keywords>slope, first</keywords>
                    <links>Profile.centralDifference</links>
                    <desc>Differentiates a profile using a Gaussian derivative filter kernel. The filter is normalized such that the overall magnitude of the output is independent of the filter size.

Coordinate system handling:
The coordinate representation is not considered in this operation. The filter operation wraps around if the isClosed-flag is on.

Valid flags handling:
Invalid flags are not allowed in this operation.</desc>
                    <sample for="lua">local derivativeProfile = Profile.gaussDerivative(profile, kernelSizeSamples, order)</sample>
                    <param name="profile" type="const object" multiplicity="[1+]" alias="Profile" desc="Input profile."/>
                    <param name="kernelSizeSamples" type="int" desc="Size of the kernel, must be positive and odd."/>
                    <param name="order" type="enum" ref="DifferentiationOrder" desc="FIRST gives first order derivative and SECOND gives second order derivative."/>
                    <return name="derivativeProfile" type="object" multiplicity="[?*]" alias="Profile" desc="Output profile, differentiated by the Gaussian derivative filter."/>
                </function>
                <function name="convolve">
                    <trait>released</trait>
                    <keywords>filter</keywords>
                    <desc>Convolves a profile with a given filter kernel.

Coordinate system handling:
The coordinate representation is not considered in this operation. The filter operation wraps around if the isClosed-flag is on.

Valid flags handling:
Invalid flags are not allowed in this operation.</desc>
                    <sample for="lua">local filteredProfile = Profile.convolve(profile, kernel)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="Input profile."/>
                    <param name="kernel" type="float" multiplicity="+" desc="Filter kernel. Must be shorter than the profile."/>
                    <return name="filteredProfile" type="object" multiplicity="?" alias="Profile" desc="Output profile, filtered with the kernel."/>
                </function>
                <function name="removeDivergentValues">
                    <trait>released</trait>
                    <keywords>noise, filter, smooth, outlier, spike</keywords>
                    <links>Profile.blur, Profile.gauss, Profile.median</links>
                    <desc>Removes samples (sets the samples valid flag to zero) with diverging values. A sample is diverging if the sample deviates more than distanceThreshold, to both the sample kernelSize/2 (samples) to the left and the sample kernelSize/2 to the right. All samples with valid flag set to zero are considered to be divering. For example, if the left sample is invalid (diverging) and the right is deviating more than distanceThreshold (also diverging), the sample is removed.

Coordinate system handling:
The coordinate representation is not considered in this operation. The filter operation wraps around if the isClosed-flag is on.</desc>
                    <sample for="lua">local filteredProfile = Profile.removeDivergentValues(profile, distanceThreshold, kernelSize)</sample>
                    <param name="profile" type="const object" multiplicity="[1+]" alias="Profile" desc="Input profile(s)."/>
                    <param name="distanceThreshold" type="float" desc="Maximum absolute deviation from neighbours."/>
                    <param name="kernelSize" type="int" multiplicity="?" desc="Size of the kernel, must be positive and odd. Optional, default 3."/>
                    <return name="filteredProfile" type="object" multiplicity="[?*]" alias="Profile" desc="Output profile."/>
                </function>
                <function name="binarize">
                    <trait>released</trait>
                    <keywords>threshold</keywords>
                    <links>Profile.binarizeInplace</links>
                    <desc>Applies a threshold interval (lowerThreshold, upperThreshold) to the profile to create a binary profile. Measurement values outside the interval have the value 0 in the output profile, and values within the interval have a user-specified value.

Coordinate system handling:
The coordinate representation is not considered in this operation.

Valid flags handling:
If a measurement is invalid in the input profile it is invalid in the output profile.</desc>
                    <sample for="lua">local binarizedProfile = Profile.binarize(profile, lowerThreshold, upperThreshold, outputValue)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The source profile."/>
                    <param name="lowerThreshold" type="float" desc="Lower threshold for the binarization."/>
                    <param name="upperThreshold" type="float" multiplicity="?" desc="Upper threshold for the binarization."/>
                    <param name="outputValue" type="float" multiplicity="?" desc="Value assigned to the measurements within the threshold interval. Optional, default value is 1."/>
                    <return name="binarizedProfile" type="object" multiplicity="?" alias="Profile" desc="Binarized profile."/>
                </function>
                <function name="binarizeInplace">
                    <trait>released</trait>
                    <keywords>threshold</keywords>
                    <links>Profile.binarize</links>
                    <desc>In-place version of the Profile.binarize function that modifies the input profile. See base function for full documentation.</desc>
                    <sample for="lua">local binarizedProfile = Profile.binarizeInplace(profile, lowerThreshold, upperThreshold, outputValue)</sample>
                    <param name="profile" type="object" alias="Profile" desc="The source profile. This profile is overwritten with the binarized result."/>
                    <param name="lowerThreshold" type="float" desc="Lower threshold for the binarization."/>
                    <param name="upperThreshold" type="float" multiplicity="?" desc="Upper threshold for the binarization."/>
                    <param name="outputValue" type="float" multiplicity="?" desc="Value assigned to the measurements within the threshold interval. Optional, default value is 1."/>
                    <return name="binarizedProfile" type="object" multiplicity="?" alias="Profile" desc="Reference to the result profile."/>
                </function>
                <function name="findLocalExtrema">
                    <trait>released</trait>
                    <keywords>peak, valley, extreme, local maximum, local minimum</keywords>
                    <links>Profile.findKnees</links>
                    <desc>Finds local extreme points (minima or maxima) of a Profile. A point is a local maximum if it is larger than all points within a neighborhood of the specified size. An optional contrast threshold level can be defined that sets a required value difference between the local maximum and the values on each side of the maximum, within the neighborhood. For locally maximal plateaus, where several measurements in the profile have the exact same value, only the leftmost value is reported. An optional absolute threshold can be specified, if so, point values must be equal to or exceed the absolute threshold to be reported. Local minima are detected in a similar way.
If contrastDifferenceMode ONE is selected (default), there must be at least one valid value on each side that is at least as far away from the extremal point as set by contrastThreshold.
If contrastDifferenceMode ALL is selected, there must be at least one valid value on each side, and all valid values must be further from the extremal point than contrastThreshold.

For non-closed profiles, the entire neighborhood must fit within the profile. E.g., if neighborhoodSize = 5, no extreme points will be detected at the first and last 2 measurements. Closed profiles are handled by wrap-around of the neighborhood.

Coordinate system handling:
The coordinate representation is not considered in this operation, the indices of the extremal points are returned.

Valid flags handling:
A maxima or minima can never be reported at positions with invalid data, but invalid data can be contained in the local neighborhood around a reported extreme point. When determining if a point is an extreme point, invalid data points within the local neighborhood are ignored. There must be at least one valid data point, within the neighborhood, on each side of the extrema.</desc>
                    <sample for="lua">local extremaPositions = Profile.findLocalExtrema(profile, extremaType, neighborhoodSize, contrastThreshold, contrastDifferenceMode, absoluteThreshold)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The source profile."/>
                    <param name="extremaType" type="enum" ref="ExtremaType" desc="Which type of extrema to look for. MIN or MAX."/>
                    <param name="neighborhoodSize" type="int" multiplicity="?" desc="The neighborhood size, expressed as number of samples. Must be odd and &gt;= 3. Default is 3."/>
                    <param name="contrastThreshold" type="float" multiplicity="?" desc="Required height of the peak/valley (value difference between the extreme point and surrounding points). Set to zero to disable (default)."/>
                    <param name="contrastDifferenceMode" type="enum" multiplicity="?" ref="ContrastDifferenceMode" desc="Determines how the difference between the extreme point and the surrounding points is calculated. Default is ONE, there must be at least one valid value on each side that is further from the extremal point than contrastThreshold."/>
                    <param name="absoluteThreshold" type="float" multiplicity="?" desc="Absolute threshold, extremal points must be beyond this value to be included in the output. By default, this threshold is not used."/>
                    <return name="extremaPositions" type="int" multiplicity="*" desc="Positions of the detected min or max points expressed as sample indices (zero-based). Nil if invalid parameters are provided."/>
                    <return name="extremaValues" type="float" multiplicity="*" desc="Values at the detected min or max points. Nil if invalid parameters are provided."/>
                    <return name="valueOrder" type="int" multiplicity="*" desc="The order of the extremas based on value. If extremaType is MAX the index of the strongest extrema comes first, if MIN the smallest comes first."/>
                    <return name="extremaContrast" type="float" multiplicity="*" desc="Contrast values at the detected min or max points. The contrastThreshold is applied to this value. Note that different contrastDifferenceMode gives different values. Nil if invalid parameters are provided."/>
                </function>
                <function name="findRangeEdges">
                    <trait>released</trait>
                    <keywords>step, corner, discontinuity</keywords>
                    <links>Profile.findKnees, Profile.findSlopes</links>
                    <desc>Finds points in a range data profile that are likely to correspond to edges of physical objects. Although this function can be run on profiles from any source, it is developed with range data from laser devices in mind. The algorithm looks for points where the profile has a sharp knee near a discontinuity or fast transition between a low and a high level. A differenceStep parameter determines the width over which the value transition is measured, i.e.,
Step 1: [1 0 -1], Step 2: [1 0 0 0 -1], and so on. This parameter should be tuned such that the filter spans the entire low-high transition.

Coordinate system handling:
The coordinate representation is not considered in this operation.

Valid flags handling:
If side = HIGH, this function reports edge points at transitions between valid and invalid measurements. This is because the low side of a physical 3D edge often contains invalid measurements due to shadowing of the laser line. For edges detected at such transitions between valid and invalid measurements, the minStrength parameter is ignored.
If side = LOW, edges are only reported where the non-zero filter coefficients hit valid measurements.</desc>
                    <sample for="lua">local subsampleIdx = Profile.findRangeEdges(profile, differenceStep, polarity, minStrength, side)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The source profile."/>
                    <param name="differenceStep" type="int" desc="The central difference step."/>
                    <param name="polarity" type="enum" ref="SlopePolarity" desc="Slope polarity. POSITIVE (rising slope) or NEGATIVE (falling slope)."/>
                    <param name="minStrength" type="float" desc="Threshold on the magnitude central difference filter response. Only slopes with a strength larger than this threshold are reported."/>
                    <param name="side" type="enum" ref="EdgeSide" desc="Side of the range edge (HIGH or LOW side)."/>
                    <return name="subsampleIndex" type="float" multiplicity="*" desc="Index with subsample (float) precision of the found edge points. Nil if invalid parameters are provided."/>
                </function>
                <function name="findDropOff">
                    <trait>released</trait>
                    <keywords>edges, discontinuity, width</keywords>
                    <links>Profile.findRangeEdges, Profile.findKnees</links>
                    <desc>Finds the first position to the left and to the right of a start position, where the amplitude have increased (if positive threshold) or decreased (if negative threshold) more than specified amount (threshold). So if the start is for example on a peak the threshold should be negative. In this case, the index of the first sample in the profile when the value is smaller than the value in the profile at the start position plus the threshold is returned. Both to the left and to the right of the start position. Closed profiles are allowed.

Coordinate system handling:
The coordinate representation is not considered in this operation.

Valid flags handling:
Only valid values from the input profiles are used.</desc>
                    <sample for="lua">local left, right = Profile.findDropOff(profile, startIndex, differenceThreshold)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The source profile."/>
                    <param name="startIndex" type="int" multiplicity="[1+]" desc="Index(s) to start the search in."/>
                    <param name="differenceThreshold" type="float" desc="Difference threshold. "/>
                    <return name="left" type="int" multiplicity="[?*]" desc="Left drop off index(s). Same as start index if not found. Nil on error."/>
                    <return name="right" type="int" multiplicity="[?*]" desc="Right drop off index(s). Same as start index if not found. Nil on error."/>
                </function>
                <function name="getIntersectionAngle">
                    <trait>released</trait>
                    <links>Profile.findKnees, Profile.Curve, Profile.CurveFitter</links>
                    <desc>Measures angle between two lines fitted around a given position in the input profile. One line is fitted to samples to the left of the given position and the other to the right using a robust RANSAC least squares fitting. The measured angle is between 0 and 2*PI, and is measured above the profile. Thus, a valley ( \/ ) gives an angle smaller than PI and a peak ( /\ ) an angle larger than PI (if \/ = a then /\ = 2*PI - a).

Coordinate system handling:
The coordinate are considered in the line fitting operation. The coordinate system of the profile must be 1D.

Valid flags handling:
Only valid values from the input profiles are used.</desc>
                    <sample for="lua">local angleRad, intersectionPoint, leftLine, rightLine = Profile.getIntersectionAngle(profile, position, regionSize, skipSize, iterations)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The source profile."/>
                    <param name="position" type="int" desc="Position to estimate lines around expressed as a sample index."/>
                    <param name="regionSize" type="int" multiplicity="[1+]" desc="Size of region(s), expressed in samples, to the left and right of the given position to use for line fitting. With a scalar input the left and right regions are of equal size. If vector the first value is the size of the left region and the second the size of the right region."/>
                    <param name="skipSize" type="int" multiplicity="[1+]" desc="Skip samples before the region start to produce a gap to the given position for the line fitting. With a vector input, a different number of samples can be skipped to the left and right respectively."/>
                    <param name="iterations" type="int" multiplicity="?" desc="Number of iterations in the RANSAC loop in the line fitting. Default value is 200. Can be reduced if there are few or no outliers."/>
                    <return name="angleRad" type="float" multiplicity="?" desc="Intersection angle, in radians."/>
                    <return name="intersectionPoint" type="object" multiplicity="?" alias="Point" desc="Intersection point of the lines, expressed as a 2D Point using (coordinate, value) as components."/>
                    <return name="leftLine" type="object" multiplicity="?" alias="Profile.Curve" desc="Left line."/>
                    <return name="rightLine" type="object" multiplicity="?" alias="Profile.Curve" desc="Right line."/>
                </function>
                <function name="rotate">
                    <trait>released</trait>
                    <keywords>transform</keywords>
                    <links>Profile.rotateInplace, Profile.translate</links>
                    <desc>Rotates a profile in the value-coordinate plane. Only 1D coordinates are supported. Result is always in EXPLICIT_1D coordinates.</desc>
                    <sample for="lua">local result = Profile.rotate(profile, rotationRad, coordinateOrigin, valueOrigin)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The source profile."/>
                    <param name="rotationRad" type="float" desc="Rotation in radians. A positive rotation is in the counterclockwise direction."/>
                    <param name="coordinateOrigin" type="float" multiplicity="?" desc="Optional origin of rotation in the coordinate dimension. Default: 0.0"/>
                    <param name="valueOrigin" type="float" multiplicity="?" desc="Optional origin of rotation in the value dimension. Default: 0.0"/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="Rotated profile. EXPLICIT_1D coordinates."/>
                </function>
                <function name="rotateInplace">
                    <trait>released</trait>
                    <keywords>transform</keywords>
                    <links>Profile.rotate, Profile.translateInplace</links>
                    <desc>In-place version of rotate. Only 1D coordinates are supported. Result is always in EXPLICIT_1D coordinates.</desc>
                    <sample for="lua">local result = Profile.rotateInplace(profile, rotationRad, coordinateOrigin, valueOrigin)</sample>
                    <param name="profile" type="object" alias="Profile" desc="The profile to rotate. This profile is overwritten with the result of the rotation."/>
                    <param name="rotationRad" type="float" desc="Rotation in radians. A positive rotation is in the counter clockwise direction."/>
                    <param name="coordinateOrigin" type="float" multiplicity="?" desc="Optional origin of rotation in the coordinate dimension. Default: 0.0"/>
                    <param name="valueOrigin" type="float" multiplicity="?" desc="Optional origin of rotation in the value dimension. Default: 0.0"/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="Reference to the rotated profile. EXPLICIT_1D coordinates."/>
                </function>
                <function name="translate">
                    <trait>released</trait>
                    <keywords>transform, shift, move</keywords>
                    <links>Profile.rotate, Profile.translateInplace</links>
                    <desc>Translates a profile in the coordinate dimension and/or in the value dimension. Only 1D coordinates are supported.</desc>
                    <sample for="lua">local result = Profile.translate(profile, coordinateTranslation, valueTranslation)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The source profile."/>
                    <param name="coordinateTranslation" type="float" desc="Translation of coordinates."/>
                    <param name="valueTranslation" type="float" desc="Translation of values."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="Translated profile."/>
                </function>
                <function name="translateInplace">
                    <trait>released</trait>
                    <keywords>transform, shift, move</keywords>
                    <links>Profile.translate, Profile.rotateInplace</links>
                    <desc>In-place version of translate, see base function for full documentation.</desc>
                    <sample for="lua">local result = Profile.translateInplace(profile, coordinateTranslation, valueTranslation)</sample>
                    <param name="profile" type="object" alias="Profile" desc="The profile to translate. This profile is overwritten with the translated profile."/>
                    <param name="coordinateTranslation" type="float" desc="Translation of coordinates."/>
                    <param name="valueTranslation" type="float" desc="Translation of values."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="Reference to the translated profile."/>
                </function>
                <function name="fourierTransform">
                    <trait>released</trait>
                    <keywords>fft, dft, spectrum, frequency</keywords>
                    <links>Profile.fourierTransformInverse</links>
                    <desc>Calculates the Fourier transform of a profile.
A sampled Fourier transform is returned distributed over one profile with magnitude values and one profile with phase values. The coordinates of the output profiles are adjusted to fit the input profile coordinates. E.g. if the input coordinates are in seconds, the output profile coordinates are in Hertz. If the input coordinates are in meters, the output coordinates are in cycles per meter and so on. The input profile coordinates must be of type implicit 1D (see Profile.setImplicitCoordinates). Missing values are not supported. The input profile can be zero-padded to a given length to increase the apparent frequency resolution of the output. If the transformLength parameter is smaller than the length of the input profile, the full input profile is used and no padding occurs. Set the smoothWindow flag true to apply a smooth window function to the profile prior to transformation. Using a smooth window makes the side lobes decay faster but also makes the main lobe wider and lower, i.e. low amplitude components become easier to detect but frequencies close to each other may merge into the same peak in the amplitude spectrum.
Only the positive-frequency half spectrum is returned as the input is a real signal. The output frequency range is from zero to half the sampling frequency 0.5 * 1/T, where T is the sample distance of the input profile (for even size input profiles). N/2 + 1 output samples are created, where N is the number of input samples. If the first sample of the input profile is not at coordinate zero, the output phase is adjusted to match the translation of the input. Magnitude values are normalized to match the DC-level and half the amplitude of pure sinusoidal inputs, i.e. the transform of the profile a + b*sin(2*pi*f*t) will have a magnitude profile with value a at zero and value b/2 at f.

Valid flags handling:
Only profiles with disabled validity flags are allowed.

Raw DFT mode:
By setting the rawDFT flag true, most checks of the input and all scaling of the output are removed and a DFT is performed directly on all the values in the input profile. The transformLength parameter is ignored and no smoothed window is used. Coordinates and validity flags are ignored and the output coordinate system is not related to frequencies. The result is returned in Cartesian form, the first profile with the real part and the second profile contains the imaginary part. The full spectrum is returned, the first sample is the DC-component.</desc>
                    <sample for="lua">local magnitude, phase = Profile.fourierTransform(profile, smoothWindow, transformLength, rawDFT)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The source profile."/>
                    <param name="smoothWindow" type="bool" multiplicity="?" desc="If set, a smooth window function (Hann window) is applied to the profile prior to transformation. Default is false, i.e. a box window is used. Ignored in raw mode."/>
                    <param name="transformLength" type="int" multiplicity="?" desc="The target transform length, if the input profile is shorter it is zero padded. Ignored in raw mode."/>
                    <param name="rawDFT" type="bool" multiplicity="?" desc="Set to true to use raw DFT mode, default is false."/>
                    <return name="magnitude" type="object" multiplicity="?" alias="Profile" desc="The magnitude profile. The real part in raw mode."/>
                    <return name="phase" type="object" multiplicity="?" alias="Profile" desc="The phase profile. The imaginary part in raw mode."/>
                </function>
                <function name="fourierTransformInverse">
                    <trait>released</trait>
                    <keywords>ifft, idft, spectrum, frequency</keywords>
                    <links>Profile.fourierTransform</links>
                    <desc>Calculates the inverse Fourier transform.
This function is the inverse of fourierTransform(), taking one magnitude profile and one phase profile and calculating the corresponding profile. The input profiles should have the first frequency sample at 0 and the last frequency sample at half the time domain sampling frequency, as created by fourierTransform(). The output is always calculated starting at zero offset and will have 2*(N-1) samples, where N is the number of samples in the input. The output coordinate system matches the input coordinate system, e.g. if the input coordinates are in hertz, the output coordinates are in seconds. If the coordinate systems specified in the magnitude profile and phase profile differ, the magnitude coordinate system is used. Note that this means that the returned profile will always have an even number of samples even if the originally transformed profile had an odd number of samples. Further, this function always recreates the part of the signal starting at time/position zero, which may not be where the original profile was sampled.

Valid flags handling:
Only profiles with disabled validity flags are allowed.

Raw DFT mode:
By setting the rawDFT flag true, most checks of the input and all scaling of the output are removed and an IDFT is performed directly on all the values in the input profile. In raw mode, input is expected to be in Cartesian form (first profile is the real part, second profile is the imaginary part) and the full spectrum is expected, starting with the DC component at the first sample. Coordinates and validity flags are ignored and the output coordinate system is not related to the input. The result is returned in Cartesian form, the first profile with the real part and the second profile contains the imaginary part.</desc>
                    <sample for="lua">local profile, imaginaryPart = Profile.fourierTransformInverse(magnitude, phase, rawDFT)</sample>
                    <param name="magnitude" type="const object" alias="Profile" desc="The input magnitude profile. The real part in raw mode."/>
                    <param name="phase" type="const object" alias="Profile" desc="The input phase profile. The imaginary part in raw mode."/>
                    <param name="rawDFT" type="bool" multiplicity="?" desc="Set to true to use raw DFT mode, default is false."/>
                    <return name="profile" type="object" multiplicity="?" alias="Profile" desc="The resulting profile. The real part of the result in raw mode."/>
                    <return name="imaginaryPart" type="object" multiplicity="?" alias="Profile" desc="Only used in raw mode, the imaginary part of the result."/>
                </function>
                <function name="concatenate">
                    <trait>released</trait>
                    <keywords>join, merge</keywords>
                    <links>Profile.concatenateInplace</links>
                    <desc>Concatenates two profiles. The profiles must have the same coordinate type. Periodic flag and implicit coordinates are copied from the first profile. If any of the two profiles uses valid flags the result also does so.</desc>
                    <sample for="lua">local result = Profile.concatenate(profile1, profile2)</sample>
                    <param name="profile1" type="const object" alias="Profile" desc="The source profile 1."/>
                    <param name="profile2" type="const object" alias="Profile" desc="The source profile 2."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="Concatenated profile."/>
                </function>
                <function name="concatenateInplace">
                    <trait>released</trait>
                    <keywords>join, merge</keywords>
                    <links>Profile.concatenate</links>
                    <desc>In-place version of concatenate that modifies the first input profile. See base function for full documentation.</desc>
                    <sample for="lua">local result = Profile.concatenateInplace(profile1, profile2)</sample>
                    <param name="profile1" type="object" alias="Profile" desc="The source profile 1 and result profile."/>
                    <param name="profile2" type="const object" alias="Profile" desc="The source profile 2."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="Reference to the concatenated profile."/>
                </function>
                <function name="mirror">
                    <trait>released</trait>
                    <keywords>flip</keywords>
                    <links>Profile.mirrorInplace</links>
                    <desc>Mirrors the values and valid flags in the profile, so that the first sample is placed last and last sample placed first in the output profile. Note that the coordinates are not mirrored.</desc>
                    <sample for="lua">local result = Profile.mirror(profile)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The source profile."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="Mirrored profile."/>
                </function>
                <function name="mirrorInplace">
                    <trait>released</trait>
                    <keywords>flip</keywords>
                    <links>Profile.mirror</links>
                    <desc>In-place version of mirror that modifies the input profile. See base function for full documentation.</desc>
                    <sample for="lua">local result = Profile.mirrorInplace(profile)</sample>
                    <param name="profile" type="object" alias="Profile" desc="The source profile and result profile."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="Reference to the mirrored profile."/>
                </function>
                <function name="addNoise">
                    <trait>released</trait>
                    <desc>Adds noise to profile values. Noise with normal or uniform distribution can be selected.

noiseType NORMAL:
param1: standard deviation.
param2: mean.

noiseType UNIFORM:
param1: Minimum value.
param2: Maximum value.</desc>
                    <sample for="lua">local result = Profile.addNoise(profile, noiseType, param1, param2, randSeed)</sample>
                    <param name="profile" type="const object" alias="Profile" desc="The source profile."/>
                    <param name="noiseType" type="enum" ref="NoiseType" desc="Distribution of noise. NORMAL or UNIFORM."/>
                    <param name="param1" type="float" multiplicity="?" desc="Standard deviation if noiseType NORMAL (Default value 1.0). Min value if noiseType UNIFORM (Default value -1.0)."/>
                    <param name="param2" type="float" multiplicity="?" desc="Mean value if noiseType NORMAL (Default value 0.0). Max value if noiseType UNIFORM (Default value 1.0)."/>
                    <param name="randSeed" type="int" multiplicity="?" desc="Random seed, optional. No new seed is set if negative. Default: 0"/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="Profile with noise added."/>
                </function>
                <function name="addNoiseInplace">
                    <trait>released</trait>
                    <desc>In-place version of addNoise. See base function for full documentation.</desc>
                    <sample for="lua">local result = Profile.addNoiseInplace(profile, noiseType, param1, param2, randSeed)</sample>
                    <param name="profile" type="object" alias="Profile" desc="The profile to add noise to."/>
                    <param name="noiseType" type="enum" ref="NoiseType" desc="Distribution of noise. NORMAL or UNIFORM."/>
                    <param name="param1" type="float" multiplicity="?" desc="Standard deviation if noiseType NORMAL (Default value 1.0). Min value if noiseType UNIFORM (Default value -1.0)."/>
                    <param name="param2" type="float" multiplicity="?" desc="Mean value if noiseType NORMAL (Default value 0.0). Max value if noiseType UNIFORM (Default value 1.0)."/>
                    <param name="randSeed" type="int" multiplicity="?" desc="Random seed, optional. No new seed is set if negative. Default: 0"/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="Reference to the profile with noise added."/>
                </function>
                <function name="toImage">
                    <trait>released</trait>
                    <desc>Convert a vector of profiles to an image, stacked vertically. The coordinates in the profiles are not used.

Valid flags handling:
If any of the input profiles has valid flags enabled, the resulting image will have missing data enabled. In that case, any pixel corresponding to an invalid sample in the profile will be stored as missing data in the image.</desc>
                    <sample for="lua">local result = Profile.toImage(profile, type, pixelSizeZ, minZ)</sample>
                    <param name="profile" type="const object" multiplicity="[1+]" alias="Profile" desc="The source profile or vector of profiles."/>
                    <param name="type" type="enum" ref="ImageType" desc="The pixel type of the resulting image."/>
                    <param name="pixelSizeZ" type="float" multiplicity="?" desc="The pixel size in the z-dimension in world coordinates, e.g., the number of millimeters each pixel value integer increment corresponds to. (Default value: 1.0). By selecting 0.0 the scale will be automatically selected."/>
                    <param name="minZ" type="float" multiplicity="?" desc="The smallest value that is represented in the output image. (Default value: 0.0)."/>
                    <return name="result" type="object" multiplicity="?" alias="Image" desc="Resulting image."/>
                </function>
                <function name="sort">
                    <trait>released</trait>
                    <desc>Sort a profile with respect to sample values or coordinates. The validity flags and explicit coordinates follow the samples while sorting. Implicit coordinates are unaffected by sorting. When sorting by coordinates, explicit 1D coordinates must be used.
A stable sorting algorithm is used, such that samples with equal value do not change order internally. Invalid values are sorted as if marked as valid, but their invalidity flag is kept.</desc>
                    <sample for="lua">local result, index = Profile.sort(profile, ascending, key)</sample>
                    <param name="profile" type="const object" multiplicity="1" alias="Profile" desc="The source profile."/>
                    <param name="ascending" type="bool" multiplicity="?" desc="True if profile is to be sorted in ascending order. Optional, default is true."/>
                    <param name="key" type="enum" multiplicity="?" ref="SortKey" desc="Indicates if samples are to be sorted by value or by coordinate. Optional, default is sorting by value."/>
                    <return name="result" type="object" multiplicity="?" alias="Profile" desc="Sorted profile."/>
                    <return name="index" type="int" multiplicity="*" desc="Vector of indices indicating the effect of the sorting operation. The first entry indicates what sample in the input that ended up first in the output. Indices are zero-based."/>
                </function>
            </serves>
            <uses/>
            <crown name="IndexRegion">
                <trait>released</trait>
                <desc>An IndexRegion represents a collection of samples in a profile. A common use-case is to represent regions or masks. The underlying
representation is run-length coded as a list of connected index segments. This makes the representation computationally
efficient to work with. The indices in an IndexRegion does not need to be connected, but can consist of isolated segments. One segment may also wrap around from the end to the beginning of a profile, primarily used for closed profiles.

It is assumed that an IndexRegion is used together with a Profile object in which it defines a collection of indices.
The IndexRegion therefore knows only about sample indices and is not aware of the sample positions of the Profile object.</desc>
                <serves>
                    <function name="createEmpty">
                        <trait>released</trait>
                        <links>Profile.IndexRegion.createEntire, Profile.IndexRegion.createSegment</links>
                        <desc>Create an empty region.</desc>
                        <sample for="lua">region = Profile.IndexRegion.createEmpty()</sample>
                        <return name="region" type="object" alias="Profile.IndexRegion" desc="The created empty index region."/>
                    </function>
                    <function name="createSegment">
                        <trait>released</trait>
                        <links>Profile.IndexRegion.createEmpty</links>
                        <desc>Create an index region containing all indices from start index to the stop index (both included). If the start index is larger than the stop index, the segment wraps around from the end of the profile to the beginning. If start and stop are vectors, they should have equal length and the union of all segments is returned.</desc>
                        <sample for="lua">region = Profile.IndexRegion.createSegment(start, stop)</sample>
                        <param name="start" type="int" multiplicity="[1+]" desc="First index in region. Can also be a vector to create a region with several segments."/>
                        <param name="stop" type="int" multiplicity="[1+]" desc="Last index in region. Can also be a vector to create a region with several segments."/>
                        <return name="region" type="object" multiplicity="[?*]" alias="Profile.IndexRegion" desc="The created index region."/>
                    </function>
                    <function name="createEntire">
                        <trait>released</trait>
                        <links>Profile.IndexRegion.createEmpty</links>
                        <desc>Create an index region containing all indices.</desc>
                        <sample for="lua">region = Profile.IndexRegion.createEntire()</sample>
                        <return name="region" type="object" alias="Profile.IndexRegion" desc="The created index region."/>
                    </function>
                    <function name="isEmpty">
                        <trait>released</trait>
                        <desc>Check if the region contains zero indices. If a vector of index regions is provided the output is a vector of the same length.</desc>
                        <sample for="lua">isEmpty = Profile.IndexRegion.isEmpty(region)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Profile.IndexRegion" desc="Input index region. Can also be a vector of index regions."/>
                        <return name="isEmpty" type="bool" multiplicity="[1+]" desc="True if the region is empty. Can also be a vector of booleans."/>
                    </function>
                    <function name="toStartStop">
                        <trait>released</trait>
                        <desc>Return two vectors containing the start and stop indices for all segments in the region.</desc>
                        <sample for="lua">starts, stops = Profile.IndexRegion.toStartStop(region))</sample>
                        <param name="region" type="const object" multiplicity="1" alias="Profile.IndexRegion" desc="Input index region."/>
                        <return name="starts" type="int" multiplicity="*" desc="Start indices for all segments in the region."/>
                        <return name="stops" type="int" multiplicity="*" desc="Stop indices for all segments in the region."/>
                    </function>
                    <function name="toString">
                        <trait>released</trait>
                        <keywords>print, help, description</keywords>
                        <desc>Get a brief string description of the index region. This is equal to the text shown in the debugger to describe the region. Can also be called with a vector of index regions.</desc>
                        <sample for="lua">str = Profile.IndexRegion.toString(region)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Profile.IndexRegion" desc="Input index region. Can also be a vector of index regions."/>
                        <return name="str" type="string" multiplicity="[1+]" desc="Description of the region. If the input is a vector the output is a vector of strings."/>
                    </function>
                    <function name="clone">
                        <trait>released</trait>
                        <desc>Create an independent copy of an index region in new allocated memory. Can also be called with a vector of index regions.</desc>
                        <sample for="lua">local clonedRegion = Profile.IndexRegion.clone(region)</sample>
                        <param name="region" type="const object" multiplicity="[1+]" alias="Profile.IndexRegion" desc="The source index region to clone. Can also be a vector of index regions."/>
                        <return name="clonedRegion" type="object" multiplicity="[1+]" alias="Profile.IndexRegion" desc="Copy of the input index region in new allocated memory. If the input is a vector the output is a vector of index regions."/>
                    </function>
                    <function name="getUnion">
                        <trait>released</trait>
                        <desc>Get the set union of two or more index regions. The first argument can be a vector of regions.</desc>
                        <sample for="lua">local outputRegion = Profile.IndexRegion.getUnion(region1, region2)</sample>
                        <param name="region1" type="const object" multiplicity="[1+]" alias="Profile.IndexRegion" desc="First input region, or a vector of regions."/>
                        <param name="region2" type="const object" multiplicity="?" alias="Profile.IndexRegion" desc="Second input region, optional."/>
                        <return name="outputRegion" type="object" multiplicity="?" alias="Profile.IndexRegion" desc="Resulting region."/>
                    </function>
                    <function name="getIntersection">
                        <trait>released</trait>
                        <desc>Get the set intersection of two index regions.</desc>
                        <sample for="lua">local outputRegion = Profile.IndexRegion.getIntersection(region1, region2)</sample>
                        <param name="region1" type="const object" multiplicity="1" alias="Profile.IndexRegion" desc="First input region."/>
                        <param name="region2" type="const object" multiplicity="1" alias="Profile.IndexRegion" desc="Second input region."/>
                        <return name="outputRegion" type="object" multiplicity="?" alias="Profile.IndexRegion" desc="Resulting region."/>
                    </function>
                    <function name="split">
                        <trait>released</trait>
                        <desc>Split an index region into several regions with one segment in each.</desc>
                        <sample for="lua">local outputRegions = Profile.IndexRegion.split(region)</sample>
                        <param name="region" type="const object" alias="Profile.IndexRegion" desc="Input region."/>
                        <return name="outputRegions" type="object" multiplicity="+" alias="Profile.IndexRegion" desc="Vector of regions with one segment in each."/>
                    </function>
                    <function name="crop">
                        <trait>released</trait>
                        <desc>Crop an index region such that it only contains indices within a given Profile. If the profile is open, any wrapping segment in the region will be split into non-wrapping parts. An optional offset can be provided, such that the region is taken from index 'offset' to 'offset+profileLength-1' in the index region. The output region is shifted such that index 'offset' in the input becomes index zero in the output. The input index region is interpreted as belonging to an infinitely long profile, i.e. large offsets can never go outside the input index region. However, it is possible to crop a part of an index region where there are no segments, resulting in an empty output region. The default offset is zero.</desc>
                        <sample for="lua">local outputRegion = Profile.IndexRegion.crop(region, profile, offset)</sample>
                        <param name="region" type="const object" alias="Profile.IndexRegion" desc="Input region."/>
                        <param name="profile" type="const object" alias="Profile" desc="The profile the region should be cropped to fit."/>
                        <param name="offset" type="int" multiplicity="?" desc="Optional offset in the input region. Index 'offset' in the input region will be mapped to index zero in the output region. Default is zero."/>
                        <return name="outputRegion" type="object" multiplicity="?" alias="Profile.IndexRegion" desc="Region cropped to fit the profile."/>
                    </function>
                </serves>
            </crown>
            <crown name="Log">
                <trait>released</trait>
                <keywords>statistics, timeseries, time series, mean, average, standard deviation, std, logging, record, analytics, historic, infinite, incremental, histogram</keywords>
                <desc>Object for incremental logging and statistics of measurements, typically in form of timeseries. Measurements are added one-by-one and statistical properties such as mean, standard deviation, min, max and histogram are updated incrementally. Thus, statistics over infinitely long timeseries can be recorded. There is an option to keep a vector of the most recently added values, for example for plotting reasons. There is also an option to maintain vectors of historic statistics (mean, min, max, std) over time intervals that is dynamically compressed (downsampled) when the vectors get full, so as to be able to calculate statistics over intervals in very long timeseries.

Some properties are off by default, such as histogram updating and recent and historic value logging. These options need to be enabled explicitly using the dedicated functions for this, e.g., enableHistogram().

It is possible to save and load Profile.Log instances using the Object.save() and Object.load() functions.</desc>
                <serves>
                    <function name="create">
                        <desc>Create new Log object</desc>
                        <return name="log" type="object" alias="Profile.Log" desc="The Log object."/>
                    </function>
                    <function name="addValue">
                        <desc>Add value(s). Values can be added one-by-one, in vector form to add several values at once, or in Profile form.</desc>
                        <param name="log" type="object" desc="The log object."/>
                        <param name="value" type="const auto" multiplicity="[1+]" desc="Value(s) to add. Can be a single float, a vector of floats, or a Profile object."/>
                        <param name="coordinate" type="const auto" multiplicity="[?*]" desc="Optional coordinate of the added value(s), length and type must match the value input."/>
                    </function>
                    <function name="getCount">
                        <desc>Get total number of values added to the log.</desc>
                        <param name="log" type="const object" desc="The log object."/>
                        <return name="count" type="int" desc="Number of added values."/>
                    </function>
                    <function name="enableRecentValues">
                        <desc>Enables storage of recent values. The size of the vector to maintain needs to be specified.</desc>
                        <param name="log" type="object" desc="The log object."/>
                        <param name="count" type="int" desc="The number of stored values."/>
                    </function>
                    <function name="getRecentValues">
                        <desc>Get the vector of recent values as a Profile object. Recent values must be enabled.</desc>
                        <param name="log" type="const object" desc="The log object."/>
                        <return name="recent" type="object" multiplicity="?" alias="Profile" desc="Profile with the latest values and coordinates."/>
                    </function>
                    <function name="getMin">
                        <desc>Get the minimum value and its coordinate over all values added to the log.</desc>
                        <param name="log" type="const object" desc="The log object."/>
                        <return name="min" type="float" multiplicity="?" desc="Minimum value."/>
                        <return name="coord" type="float" multiplicity="?" desc="Coordinate of minumum value."/>
                    </function>
                    <function name="getMax">
                        <desc>Get the minimum value and its coordinate over all values added to the log.</desc>
                        <param name="log" type="const object" desc="The log object."/>
                        <return name="max" type="float" multiplicity="?" desc="Maximum value."/>
                        <return name="coord" type="float" multiplicity="?" desc="Coordinate of maximum value."/>
                    </function>
                    <function name="getMean">
                        <desc>Get the mean/average over all values added to the log.</desc>
                        <param name="log" type="const object" desc="The log object."/>
                        <return name="mean" type="float" multiplicity="?" desc="Mean value."/>
                    </function>
                    <function name="getStdDev">
                        <desc>Get the standard deviation over all values added to the log.</desc>
                        <param name="log" type="const object" desc="The log object."/>
                        <return name="stddev" type="float" multiplicity="?" desc="Standard deviation."/>
                    </function>
                    <function name="enableHistogram">
                        <desc>Enables the histogram feature to incrementally maintain a histogram of all logged values.</desc>
                        <param name="log" type="object" desc="The log object."/>
                        <param name="minValue" type="float" desc="Center coordinate of the lowest bin."/>
                        <param name="maxValue" type="float" desc="Center coordinate of the highest bin."/>
                        <param name="binsCount" type="int" desc="Number of bins."/>
                    </function>
                    <function name="getHistogram">
                        <desc>Get the histogram represented as a Profile object. The histogram feature must be enabled.</desc>
                        <param name="log" type="const object" desc="The log object."/>
                        <return name="recent" type="object" multiplicity="?" alias="Profile" desc="Histogram with the frequency in the values and bin centers as coordinates."/>
                    </function>
                    <function name="enableHistoricStatistics">
                        <desc>Enables the historic statistics feature. Vectors of historic statistics (mean, max, min, std) over time periods are maintained. When the vectors gets full they are compressed (downsampled) a factor 2, and thus the time period represented also increases a factor 2. With this feature one can gather statistics over intervals in very long time series.</desc>
                        <param name="log" type="object" desc="The log object."/>
                        <param name="periodCount" type="int" desc="Number of periods to keep. This is also the maximum size of the periods. Must be equal or larger than 10."/>
                    </function>
                    <function name="getHistoricPeriod">
                        <desc>Get number of values in each historic period.</desc>
                        <param name="log" type="const object" desc="The log object."/>
                        <return name="count" type="int" desc="Number of stored values per historic period."/>
                    </function>
                    <function name="getHistoricMin">
                        <desc>Get the minimum of the values in each historic period.</desc>
                        <param name="log" type="const object" desc="The log object."/>
                        <return name="min" type="object" multiplicity="?" alias="Profile" desc="Profile with the minimum of the values in the periods."/>
                    </function>
                    <function name="getHistoricMax">
                        <desc>Get the maximum of the values in each historic period.</desc>
                        <param name="log" type="const object" desc="The log object."/>
                        <return name="max" type="object" multiplicity="?" alias="Profile" desc="Profile with the maximum of the values in the periods."/>
                    </function>
                    <function name="getHistoricMean">
                        <desc>Get the mean of the values in each historic period.</desc>
                        <param name="log" type="const object" desc="The log object."/>
                        <return name="mean" type="object" multiplicity="?" alias="Profile" desc="Profile with the mean of the values in the periods."/>
                    </function>
                    <function name="getHistoricStdDev">
                        <desc>Get the standard deviation in each historic period.</desc>
                        <param name="log" type="const object" desc="The log object."/>
                        <return name="stddev" type="object" multiplicity="?" alias="Profile" desc="Profile with the standard deviations of the values in the periods."/>
                    </function>
                    <function name="toString">
                        <keywords>description, print</keywords>
                        <desc>Get a string describing the log.</desc>
                        <sample for="lua">print(Profile.Log.toString(curve))</sample>
                        <param name="curve" type="const object" alias="Profile.Log" desc="Input log."/>
                        <return name="str" type="string" desc="String description of the log."/>
                    </function>
                </serves>
            </crown>
            <crown name="Matching">
                <trait>released</trait>
                <keywords>localization, pattern, feature, detection</keywords>
                <desc>Functions for matching and locating patterns in profiles based on different shape models such as sample pattern models.</desc>
                <crown name="PatternMatcher">
                    <trait>released</trait>
                    <desc>Finds patterns in a profile based on template matching. Teach a pattern from a reference profile and call match to find the location of the same shape in a live profile.</desc>
                    <enum name="ComparisonMode">
                        <item name="xCorrNorm" desc="Cross correlation with normalization.">XCORRNORM</item>
                        <item name="sad" desc="Sum of absolute difference.">SAD</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <desc>Creates a new matcher for 1D pattern localization in profiles.</desc>
                            <sample for="lua">locator = Profile.Matching.PatternMatcher.create()</sample>
                            <return name="locator" type="handle" alias="Profile.Matching.PatternMatcher" desc="The new instance."/>
                        </function>
                        <function name="teach">
                            <keywords>pattern, template</keywords>
                            <desc>Teaches a pattern model from a template profile. The template profile is typically shorter than the profile later used for matching in, e.g., it is a cropped version of a reference profile containing just the pattern of interest. Samples can be excluded from the teach model by setting the valid flags of the corresponding samples to invalid. Note that the teach profile must contain atleast 5 valid samples.

There are two modes later used in the match call to determine how the teach pattern is compared to a profile to match in:
SAD:       Sum of absolute differences. A match score is calculated based on the sum of the absolute differences between the teach  profile and the match profile.
XCORRNORM: Cross correlation with normalization. A match score is calculated based on a cross-correlation operation. This mode is insensitive to different scalings and mean levels between the teach and match profiles.</desc>
                            <sample for="lua"> success = Profile.Matching.PatternMatcher.teach(locator, teachProfile, matchMode)</sample>
                            <param name="locator" type="handle" alias="Profile.Matching.PatternMatcher" desc="The instance to use."/>
                            <param name="teachProfile" type="const object" alias="Profile" desc="The teach profile."/>
                            <param name="comparisonMode" type="enum" multiplicity="?" ref="ComparisonMode" desc="Comparison method XCORRNORM or SAD. Default: XCORRNORM."/>
                            <return name="success" type="bool" desc="True if teach succeeded."/>
                        </function>
                        <function name="match">
                            <keywords>find, locate</keywords>
                            <links>Profile.Matching.PatternMatcher.getAllFoundMatches</links>
                            <desc>Finds a pattern in a live profile by matching with the teach model. A teach call must be made first. The output is the position (index) of the best found match, with the origin for the template in the first element. Only one instance of a pattern is returned, the one with the strongest match score. However, after a match call, a vector of all match candidates can be obtained using the getAllFoundMatches function.

A match score in the range [0.0, 1.0] is returned indicating the score strength. Depending on the comparison mode (selected in teach call), the score is calculated as follows:

SAD: The best (lowest) SAD_min difference is found. The score is calculated as max(1.0 - SAD_min/(max_value - min_value), 0.0), where max value and min_value are the maximum and minimum values within the teach profile. This gives a score value that is 1.0 if the teach and live are identical, and 0.0 if for example all samples in the live profile deviates with at least the teach range.

XCORRNORM: The best (highest) correlation coefficient XCORRNORM_max is found. The score is calculated as max(XCORRNORM_max, 0.0) to give as score 1.0 if the teach and match profiles correlate perfectly.

Coordinate system handling:
The coordinates are not considered in this function.

Invalid flag usage:
Invalid samples are excluded from the matching but can affect the score measure.</desc>
                            <sample for="lua">position, matchScore = Profile.Matching.PatternMatcher.match(locator, liveProfile)</sample>
                            <param name="locator" type="handle" alias="Profile.Matching.PatternMatcher" desc="The matcher instance to use."/>
                            <param name="liveProfile" type="const object" alias="Profile" desc="The live profile to find the shape in."/>
                            <return name="position" type="float" multiplicity="?" desc="Position (index) of the start of detected pattern in the live profile. Nil is returned if the match process failed."/>
                            <return name="matchScore" type="float" multiplicity="?" desc="A score between 0.0 and 1.0 for the best detected pattern. High score means good match."/>
                        </function>
                        <function name="setMaximumInvalidValues">
                            <desc>Set maximum number of invalid samples in the live profile, which overlaps the teach profile. Thus, matches where the teach profile overlaps with too many invalid samples in the live profile are discarded. The default value if this parameter is to allow any number of invalid values.</desc>
                            <sample for="lua"> Profile.Matching.PatternMatcher.setMaximumInvalidValues(locator, maxInvalidValues)</sample>
                            <param name="locator" type="handle" alias="Profile.Matching.PatternMatcher" desc="The instance to use."/>
                            <param name="maxInvalidValues" type="int" desc="Maximum number of invalid samples."/>
                        </function>
                        <function name="getAllFoundMatches">
                            <links>Profile.Matching.PatternMatcher.match</links>
                            <desc>Get vector with all found matches sorted with descending score. A match is a local maximum in the comparison mode evaluation.</desc>
                            <sample for="lua"> positions, scores = Profile.Matching.PatternMatcher.getAllFoundMatches(locator)</sample>
                            <param name="locator" type="handle" alias="Profile.Matching.PatternMatcher" desc="The instance to use."/>
                            <return name="positions" type="float" multiplicity="*" desc="Positions (indices) of found matches."/>
                            <return name="scores" type="float" multiplicity="*" desc="scores."/>
                        </function>
                        <function name="toString">
                            <keywords>description, print</keywords>
                            <desc>Get a human-readable string describing the pattern matcher.</desc>
                            <sample for="lua">print(Profile.Matching.PatternMatcher.toString(patternMatcher))</sample>
                            <param name="locator" type="const object" alias="Profile.Matching.PatternMatcher" desc="Input pattern matcher."/>
                            <return name="str" type="string" desc="String description of the pattern matcher."/>
                        </function>
                    </serves>
                </crown>
            </crown>
            <crown name="Curve">
                <trait>released</trait>
                <keywords>polynomial, exponential, line, function, parametric, fitting, trend, gauss, analytic</keywords>
                <links>Profile.CurveFitter</links>
                <desc>A data type for representing parametric curves and functions such as polynomial and exponential functions. Different families of functions are available.</desc>
                <enum name="CurveType">
                    <item name="Polynomial" desc="Polynomial function.">POLYNOMIAL</item>
                    <item name="Exponential" desc="Exponential function.">EXPONENTIAL</item>
                    <item name="Gaussian" desc="Gaussian function.">GAUSSIAN</item>
                </enum>
                <serves>
                    <function name="createLine">
                        <trait>released</trait>
                        <links>Profile.Curve.createPolynomial</links>
                        <desc>Create a line f(x) = offset + slope*x with the specified offset and slope. This is equivalent to creating a first order polynomial.</desc>
                        <sample for="lua">line = Profile.Curve.createLine(offset, slope)</sample>
                        <param name="offset" type="float" desc="Offset of line, value at x = 0."/>
                        <param name="slope" type="float" desc="Slope of line, dy/dx."/>
                        <return name="line" type="object" multiplicity="?" alias="Profile.Curve" desc="The created line."/>
                    </function>
                    <function name="getLineParameters">
                        <trait>released</trait>
                        <links>Profile.CurveFitter.fitLine</links>
                        <desc>Returns the offset and slope of a line.</desc>
                        <sample for="lua">offset, slope = Profile.Curve.getLineParameters(line)</sample>
                        <param name="line" type="const object" alias="Profile.Curve" desc="The line."/>
                        <return name="offset" type="float" multiplicity="?" desc="Offset of line, value at x = 0."/>
                        <return name="slope" type="float" multiplicity="?" desc="Slope of line, dy/dx."/>
                    </function>
                    <function name="createPolynomial">
                        <trait>released</trait>
                        <links>Profile.Curve.createLine</links>
                        <desc>Create a polynomial curve with the specified coefficients. The first coefficient is the constant term, the second is for the linear term and so on.</desc>
                        <sample for="lua">polyCurve = Profile.Curve.createPolynomial(coefficients)</sample>
                        <param name="coefficients" type="float" multiplicity="+" desc="Coefficients a, b, c, ... in a + b*x + c*x^2 + ..."/>
                        <return name="polyCurve" type="object" multiplicity="?" alias="Profile.Curve" desc="The created polynomial curve."/>
                    </function>
                    <function name="getPolynomialParameters">
                        <trait>released</trait>
                        <links>Profile.CurveFitter.fitPolynomial</links>
                        <desc>Returns the coefficients of a polynomial curve. The first coefficient is the constant term, the second is for the linear term and so on.</desc>
                        <sample for="lua">coefficients = Profile.Curve.getPolynomialParameters(polyCurve)</sample>
                        <param name="polyCurve" type="const object" alias="Profile.Curve" desc="The polynomial curve."/>
                        <return name="coefficients" type="float" multiplicity="*" desc="Coefficients a, b, c, ... in a + b*x + c*x^2 + ..."/>
                    </function>
                    <function name="createExponential">
                        <trait>released</trait>
                        <desc>Create an exponential curve. f(x) = scale*exp(exponent*x) + offset.</desc>
                        <sample for="lua">expCurve = Profile.Curve.createExponential(scale, exponent, offset)</sample>
                        <param name="scale" type="float" desc="Linear scaling of the curve."/>
                        <param name="exponent" type="float" desc="Exponent."/>
                        <param name="offset" type="float" desc="Constant offset of the curve."/>
                        <return name="expCurve" type="object" multiplicity="?" alias="Profile.Curve" desc="The created exponential curve."/>
                    </function>
                    <function name="getExponentialParameters">
                        <trait>released</trait>
                        <links>Profile.CurveFitter.fitExponential</links>
                        <desc>Returns the parameters of an exponential curve, f(x) = scale*exp(exponent*x) + offset.</desc>
                        <sample for="lua">scale, exponent, offset = Profile.Curve.getExponentialParameters(expCurve)</sample>
                        <param name="expCurve" type="const object" alias="Profile.Curve" desc="The exponential curve."/>
                        <return name="scale" type="float" multiplicity="?" desc="Linear scaling of the curve."/>
                        <return name="exponent" type="float" multiplicity="?" desc="Exponent."/>
                        <return name="offset" type="float" multiplicity="?" desc="Constant offset of the curve."/>
                    </function>
                    <function name="createGaussian">
                        <trait>released</trait>
                        <desc>Create a Gaussian curve. f(x) = scale*exp(-((x-mean)^2) / (2*sigma^2)) + offset.</desc>
                        <sample for="lua">gaussCurve = Profile.Curve.createGaussian(scale, mean, sigma, offset)</sample>
                        <param name="scale" type="float" desc="Linear scaling of the curve."/>
                        <param name="mean" type="float" desc="Mean (symmetry axis of generated function)."/>
                        <param name="sigma" type="float" desc="Standard deviation (width of lobe)."/>
                        <param name="offset" type="float" desc="Constant offset of the curve."/>
                        <return name="gaussCurve" type="object" multiplicity="?" alias="Profile.Curve" desc="The created Gaussian curve."/>
                    </function>
                    <function name="getGaussianParameters">
                        <trait>released</trait>
                        <links>Profile.CurveFitter.fitGaussian</links>
                        <desc>Returns the parameters of a Gaussian curve, f(x) = scale*exp(-((x-mean)^2) / (2*sigma^2)) + offset.</desc>
                        <sample for="lua">scale, mean, sigma, offset = Profile.Curve.getGaussianParameters(gaussCurve)</sample>
                        <param name="gaussCurve" type="const object" alias="Profile.Curve" desc="The Gaussian curve."/>
                        <return name="scale" type="float" multiplicity="?" desc="Linear scaling of the curve."/>
                        <return name="mean" type="float" multiplicity="?" desc="Mean (symmetry axis of generated function)."/>
                        <return name="sigma" type="float" multiplicity="?" desc="Standard deviation (width of lobe)."/>
                        <return name="offset" type="float" multiplicity="?" desc="Constant offset of the curve."/>
                    </function>
                    <function name="getDerivative">
                        <trait>released</trait>
                        <desc>Return the derivative of the curve if it can be expressed by any available curve type.</desc>
                        <sample for="lua">derivativeCurve = Profile.Curve.getDerivative(curve)</sample>
                        <param name="curve" type="const object" alias="Profile.Curve" desc="The curve to take the derivative of."/>
                        <return name="derivativeCurve" type="object" multiplicity="?" alias="Profile.Curve" desc="The derivative of the curve."/>
                    </function>
                    <function name="getType">
                        <trait>released</trait>
                        <desc>Return the type of function that represents the curve.</desc>
                        <sample for="lua">curveType = Profile.Curve.getType(curve)</sample>
                        <param name="curve" type="const object" alias="Profile.Curve" desc="The curve to check."/>
                        <return name="curveType" type="enum" ref="CurveType" desc="The curve type."/>
                    </function>
                    <function name="clone">
                        <trait>released</trait>
                        <keywords>copy</keywords>
                        <desc>Create an independent copy of this curve.</desc>
                        <sample for="lua">outputCurve = Profile.Curve.clone(inputCurve)</sample>
                        <param name="inputCurve" type="const object" alias="Profile.Curve" desc="The curve to clone."/>
                        <return name="outputCurve" type="object" alias="Profile.Curve" desc="The new copy."/>
                    </function>
                    <function name="translate">
                        <trait>released</trait>
                        <keywords>transform, shift, move</keywords>
                        <links>Profile.Curve.scale, Profile.Curve.translateInplace</links>
                        <desc>Translates a curve in the coordinate dimension and/or in the value dimension by recalculating curve parameters. A nil value indicates no translation in the corresponding dimension.</desc>
                        <sample for="lua">local result = Profile.Curve.translate(curve, coordinateTranslation, valueTranslation)</sample>
                        <param name="curve" type="const object" alias="Profile.Curve" desc="The source curve."/>
                        <param name="coordinateTranslation" type="float" multiplicity="?" desc="Translation of coordinates."/>
                        <param name="valueTranslation" type="float" multiplicity="?" desc="Translation of values."/>
                        <return name="result" type="object" multiplicity="?" alias="Profile.Curve" desc="Translated curve."/>
                    </function>
                    <function name="translateInplace">
                        <trait>released</trait>
                        <keywords>transform, shift, move</keywords>
                        <links>Profile.Curve.scaleInplace, Profile.Curve.translate</links>
                        <desc>In-place version of translate, see base function for full documentation.</desc>
                        <sample for="lua">local result = Profile.Curve.translateInplace(curve, coordinateTranslation, valueTranslation)</sample>
                        <param name="curve" type="object" alias="Profile.Curve" desc="The curve to translate and the translated curve."/>
                        <param name="coordinateTranslation" type="float" multiplicity="?" desc="Translation of coordinates."/>
                        <param name="valueTranslation" type="float" multiplicity="?" desc="Translation of values."/>
                        <return name="result" type="object" multiplicity="?" alias="Profile.Curve" desc="Reference to the translated profile."/>
                    </function>
                    <function name="scale">
                        <trait>released</trait>
                        <keywords>transform, multiply, resize</keywords>
                        <links>Profile.Curve.scaleInplace, Profile.Curve.translate</links>
                        <desc>Scales a curve in the coordinate dimension and/or in the value dimension by recalculating curve parameters, centered around the origin. A nil value indicates unit scaling in the corresponding dimension.</desc>
                        <sample for="lua">local result = Profile.Curve.scale(curve, coordinateScale, valueScale)</sample>
                        <param name="curve" type="const object" alias="Profile.Curve" desc="The source curve."/>
                        <param name="coordinateScale" type="float" multiplicity="?" desc="Scale factor of coordinates."/>
                        <param name="valueScale" type="float" multiplicity="?" desc="Scale factor of values."/>
                        <return name="result" type="object" multiplicity="?" alias="Profile.Curve" desc="Scaled curve."/>
                    </function>
                    <function name="scaleInplace">
                        <trait>released</trait>
                        <keywords>transform, multiply, resize</keywords>
                        <links>Profile.Curve.scale, Profile.Curve.translateInplace</links>
                        <desc>In-place version of scale, see base function for full documentation.</desc>
                        <sample for="lua">local result = Profile.Curve.scaleInplace(curve, coordinateScale, valueScale)</sample>
                        <param name="curve" type="object" alias="Profile.Curve" desc="The curve to scale and the scaled curve."/>
                        <param name="coordinateScale" type="float" multiplicity="?" desc="Scale factor of coordinates."/>
                        <param name="valueScale" type="float" multiplicity="?" desc="Scale factor of values."/>
                        <return name="result" type="object" multiplicity="?" alias="Profile.Curve" desc="Reference to the scaled profile."/>
                    </function>
                    <function name="toProfile">
                        <trait>released</trait>
                        <desc>Evaluate the curve at all points in the reference profile and return as a new profile. The reference profile must have 1D sampling coordinates. For a smoother plot, extra samples may be inserted between the samples of the reference profile. This is controlled by the optional parameter extraSamples.</desc>
                        <sample for="lua">curveProfile = Profile.Curve.toProfile(curve, referenceProfile, extraSamples)</sample>
                        <param name="curve" type="const object" alias="Profile.Curve" desc="Input curve."/>
                        <param name="referenceProfile" type="const object" alias="Profile" desc="Reference profile."/>
                        <param name="extraSamples" type="int" multiplicity="?" desc="This many samples are inserted in the output profile between each two samples of the reference profile. Default is zero."/>
                        <return name="curveProfile" type="object" multiplicity="?" alias="Profile" desc="The sampled curve as a profile."/>
                    </function>
                    <function name="evaluate">
                        <trait>released</trait>
                        <links>Profile.Curve.toProfile</links>
                        <desc>Evaluate the curve at all the input coordinates and return the evaluated values as a vector.</desc>
                        <sample for="lua">curveValues = Profile.Curve.evaluate(curve, inputCoordinates)</sample>
                        <param name="curve" type="const object" alias="Profile.Curve" desc="Input curve."/>
                        <param name="inputCoordinates" type="float" multiplicity="+" desc="Vector of coordinates to evaluate the curve at."/>
                        <return name="curveValues" type="float" multiplicity="*" desc="The evaluated values at the input coordinates."/>
                    </function>
                    <function name="toString">
                        <trait>released</trait>
                        <keywords>description, print</keywords>
                        <desc>Get a human-readable string describing the curve.</desc>
                        <sample for="lua">print(Profile.Curve.toString(curve))</sample>
                        <param name="curve" type="const object" alias="Profile.Curve" desc="Input curve."/>
                        <return name="str" type="string" desc="String description of the curve."/>
                    </function>
                </serves>
            </crown>
            <crown name="CurveFitter">
                <trait>released</trait>
                <keywords>fitting, least squares, ransac, curve, function, trend</keywords>
                <links>Profile.Curve</links>
                <desc>For fitting parametric curves and functions to measurements stored in a profile object. Both ordinary least squares fitting (default) and robust fitting using RANSAC are possible.</desc>
                <enum name="CurveFitMode">
                    <item name="least_squares" desc="Ordinary least squares.">LEAST_SQUARES</item>
                    <item name="ransac" desc="Ransac (random sampling with outlier rejection).">RANSAC</item>
                </enum>
                <enum name="CurveOutlierMarginType">
                    <item name="rank" desc="Rank-based margin, defines the rate of points to include. For example, A rank margin of 0.7 means that the best 70% of all points are included and the rest are ignored.">RANK</item>
                    <item name="absolute" desc="Absolute outlier margin.">ABSOLUTE</item>
                </enum>
                <serves>
                    <function name="create">
                        <desc>Create a curve fitter with default settings.</desc>
                        <sample for="lua">curveFitter = Profile.CurveFitter.create()</sample>
                        <return name="curveFitter" type="handle" alias="Profile.CurveFitter" desc="Created curve fitter."/>
                    </function>
                    <function name="fitLine">
                        <links>Profile.Curve.getLineParameters</links>
                        <desc>Fit a line to the valid points in a profile. Equivalent to fitting a first order polynomial. The coordinate system of the profile must be 1D.</desc>
                        <sample for="lua">line = Profile.CurveFitter.fitLine(curveFitter, inputProfile)</sample>
                        <param name="curveFitter" type="handle" alias="Profile.CurveFitter" desc="Curve fitter to use."/>
                        <param name="inputProfile" type="object" alias="Profile" desc="The profile to fit the curve to."/>
                        <return name="line" type="object" multiplicity="?" alias="Profile.Curve" desc="The fitted line."/>
                    </function>
                    <function name="fitPolynomial">
                        <links>Profile.Curve.getPolynomialParameters</links>
                        <desc>Fit a polynomial curve to the valid points in a profile. Set the order parameter to zero for a constant function, one for a line, two for a quadratic function and so on. The coordinate system of the profile must be 1D.</desc>
                        <sample for="lua">polyCurve = Profile.CurveFitter.fitPolynomial(curveFitter, inputProfile, order)</sample>
                        <param name="curveFitter" type="handle" alias="Profile.CurveFitter" desc="Curve fitter to use."/>
                        <param name="inputProfile" type="object" alias="Profile" desc="The profile to fit the curve to."/>
                        <param name="order" type="int" desc="Order of the polynomial to fit."/>
                        <return name="polyCurve" type="object" multiplicity="?" alias="Profile.Curve" desc="The fitted polynomial curve, or nil if fitting failed."/>
                    </function>
                    <function name="fitExponential">
                        <links>Profile.Curve.getExponentialParameters</links>
                        <desc>Fit an exponential curve to the valid points in a profile.</desc>
                        <sample for="lua">expCurve = Profile.CurveFitter.fitExponential(curveFitter, inputProfile)</sample>
                        <param name="curveFitter" type="handle" alias="Profile.CurveFitter" desc="Curve fitter to use."/>
                        <param name="inputProfile" type="object" alias="Profile" desc="The profile to fit the curve to."/>
                        <return name="expCurve" type="object" multiplicity="?" alias="Profile.Curve" desc="The fitted exponential curve, or nil if fitting failed."/>
                    </function>
                    <function name="fitGaussian">
                        <links>Profile.Curve.getGaussianParameters</links>
                        <desc>Fit a Gaussian curve to the valid points in a profile. Fitting a Gaussian is quite sensitive to noise and degenerate cases, where the points do not come from a Gaussian function. Using RANSAC robust fitting is recommended as it is much less likely to fail.</desc>
                        <sample for="lua">gaussCurve = Profile.CurveFitter.fitGaussian(curveFitter, inputProfile)</sample>
                        <param name="curveFitter" type="handle" alias="Profile.CurveFitter" desc="Curve fitter to use."/>
                        <param name="inputProfile" type="object" alias="Profile" desc="The profile to fit the curve to."/>
                        <return name="gaussCurve" type="object" multiplicity="?" alias="Profile.Curve" desc="The fitted Gaussian curve, or nil if fitting failed."/>
                    </function>
                    <function name="getPoints">
                        <desc>Get the edge points used in the last call to any of the fitting functions. Intended for visualization, parameter tuning and debugging. Two lists are returned, the first contains all points that were used to fit the final curve. The second list contains all valid points in the profile not used for fitting the shape. For the least squares method, all points are always in the first list.</desc>
                        <sample for="lua">inlierPoints, outlierPoints = Profile.CurveFitter.getPoints(curveFitter)</sample>
                        <param name="curveFitter" type="handle" alias="Profile.CurveFitter" desc="Curve fitter to use."/>
                        <return name="inlierPoints" type="object" multiplicity="*" alias="Point" desc="Points used for the final fitting of the curve, a subset of the valid points in the profile."/>
                        <return name="outlierPoints" type="object" multiplicity="*" alias="Point" desc="Points not used for the final fitting, the remainder of the valid points."/>
                    </function>
                    <function name="getResiduals">
                        <desc>Get fitting information from the last successful curve fit. Values are related to the inliers as can be obtained from getPoints.</desc>
                        <sample for="lua">rmsError, inlierRatio, inlierResiduals, outlierResiduals = Profile.CurveFitter.getResiduals(curveFitter)</sample>
                        <param name="curveFitter" type="handle" alias="Profile.CurveFitter" desc="Curve fitter to use."/>
                        <return name="rmsError" type="float" multiplicity="?" desc="The root mean squared error among the inliers."/>
                        <return name="inlierRatio" type="float" multiplicity="?" desc="Ratio of inlier points to the total number of points, between 0 and 1."/>
                        <return name="inlierResiduals" type="float" multiplicity="*" desc="Signed residuals for all inliers, the difference between the curve value and the profile value at each position."/>
                        <return name="outlierResiduals" type="float" multiplicity="*" desc="Signed residuals for all outliers, the difference between the curve value and the profile value at each position."/>
                    </function>
                    <function name="setFitMode">
                        <keywords>least squares, ransac, robust</keywords>
                        <links>Profile.CurveFitter.getFitMode</links>
                        <desc>Set the fitting mode. The following modes are supported:
- LEASTSQUARES uses all points. This is fast and easy, but can produce poor results if there are points that do not belong to the curve to be fitted (default).
- RANSAC is a robust method with outlier rejection. Using this method, outlier points can be ignored. This mode requires an outlier margin to be set by setOutlierMargin. The number of iterations can be set by setIterations.</desc>
                        <sample for="lua">Profile.CurveFitter.setFitMode(curveFitter, fitMode)</sample>
                        <param name="curveFitter" type="handle" alias="Profile.CurveFitter" desc="Curve fitter to use."/>
                        <param name="fitMode" type="enum" ref="Profile.CurveFitter.CurveFitMode" desc="Fitting mode to use."/>
                    </function>
                    <function name="getFitMode">
                        <trait>hidden</trait>
                        <keywords>least squares, ransac</keywords>
                        <links>Profile.CurveFitter.setFitMode</links>
                        <desc>Get the fitting mode.</desc>
                        <sample for="lua">fitMode = Profile.CurveFitter.getFitMode(curveFitter)</sample>
                        <param name="curveFitter" type="handle" alias="Profile.CurveFitter" desc="Curve fitter to use."/>
                        <return name="fitMode" type="enum" ref="Profile.CurveFitter.CurveFitMode" desc="Fitting mode used."/>
                    </function>
                    <function name="setIterations">
                        <links>Profile.CurveFitter.getIterations</links>
                        <desc>Set the maximum number of iterations in the fitting step. A higher value makes the fitting more accurate, but consumes more computation time. The default is 1000 iterations.</desc>
                        <sample for="lua">Profile.CurveFitter.setIterations(curveFitter, iterations)</sample>
                        <param name="curveFitter" type="handle" alias="Profile.CurveFitter" desc="Curve fitter to use."/>
                        <param name="iterations" type="int" desc="Number of iterations."/>
                    </function>
                    <function name="getIterations">
                        <trait>hidden</trait>
                        <links>Profile.CurveFitter.setIterations</links>
                        <desc>Get the maximum number of iterations in the fitting step.</desc>
                        <sample for="lua">iterations = Profile.CurveFitter.getIterations(curveFitter)</sample>
                        <param name="curveFitter" type="handle" alias="Profile.CurveFitter" desc="Curve fitter to use."/>
                        <return name="iterations" type="int" desc="Number of iterations."/>
                    </function>
                    <function name="setOutlierMargin">
                        <links>Profile.CurveFitter.getOutlierMargin, Profile.CurveFitter.getPoints</links>
                        <desc>Set the outlier margin when using RANSAC robust fitting mode.
The interpretation of the margin parameter depends on the fitting mode parameter:
- RANK: the outlier margin is interpreted as a rank measure, defining the rate of points to include. In this case, the margin must be in the range (0.0, 1.0). A rank margin of 0.7 means that only the best fitting 70% of all points will be included, and the rest ignored.
- ABSOLUTE: the outlier margin is defined in absolute world units. Any points further away from the fitted curve than this margin will be ignored.
In general a larger value means that more points are included in the fitting, which can improve the accuracy as long as all included points are valid. A smaller value makes the algorithm reject more points, which can increases robustness against single erroneous points. The default is an RANK margin of 0.5.</desc>
                        <sample for="lua">Profile.CurveFitter.setOutlierMargin(curveFitter, margin, marginType)</sample>
                        <param name="curveFitter" type="handle" alias="Profile.CurveFitter" desc="Curve fitter to use."/>
                        <param name="margin" type="float" desc="Outlier margin, expressed in world coordinate units or as a rank measure, depending on the marginType."/>
                        <param name="marginType" type="enum" ref="Profile.CurveFitter.CurveOutlierMarginType" desc="Outlier margin type."/>
                    </function>
                    <function name="getOutlierMargin">
                        <trait>hidden</trait>
                        <links>Profile.CurveFitter.setOutlierMargin, Profile.CurveFitter.getPoints</links>
                        <desc>Get the outlier margin and margin type.</desc>
                        <sample for="lua">margin, marginType = Profile.CurveFitter.getOutlierMargin(curveFitter)</sample>
                        <param name="curveFitter" type="handle" alias="Profile.CurveFitter" desc="Curve fitter to use."/>
                        <return name="margin" type="float" desc="Outlier margin, expressed in world coordinate units or as a rank measure, depending on the marginType."/>
                        <return name="marginType" type="enum" ref="Profile.CurveFitter.CurveOutlierMarginType" desc="Outlier margin type."/>
                    </function>
                    <function name="toString">
                        <keywords>description, print</keywords>
                        <desc>Get a human-readable string describing the curve fitter.</desc>
                        <sample for="lua">print(Profile.CurveFitter.toString(curve))</sample>
                        <param name="curve" type="const object" alias="Profile.CurveFitter" desc="Input curve fitter."/>
                        <return name="str" type="string" desc="String description of the curve."/>
                    </function>
                </serves>
            </crown>
            <crown name="Provider">
                <trait>released</trait>
                <desc>Provides distance data from different sources.</desc>
                <crown name="RemoteDistanceSensor">
                    <trait>released</trait>
                    <desc>A RemoteDistanceSensor can be used as provider for different types of SICK distance sensors. Use first the set functions to configure the provider.</desc>
                    <enum name="SensorType">
                        <item desc="Default standard OD5000. To receive the user data from the sensor, the destination port and the destination IP address must be pre-adjusted in the OD5000 (e.g. via SOPAS-Air). The driver listens to a specific UDP port and processes the received data.">OD5000</item>
                    </enum>
                    <serves>
                        <event name="OnNewData">
                            <desc>The event which is thrown for available data. Contains distance data in [mm]. The timestamp in SensorData is the timestamp of the first distance value in the corresponding Profile in [ns]. The timestamp is reset to zero every second!</desc>
                            <param name="handle" type="handle" alias="Profile.Provider.RemoteDistanceSensor" desc="The instance handle to use"/>
                            <param name="profile" type="object" multiplicity="[1+]" alias="Profile" desc="Profile filled with the distance measurement data of the device in [mm]."/>
                            <param name="sensordata" type="object" multiplicity="[1+]" alias="SensorData" desc="The sensor data including encoder data which was received along with the profile. The timestamp in SensorData is the timestamp of the first distance value in the corresponding profile in [ns]. The timestamp is reset to zero every second!"/>
                            <param name="timestamp" type="int" multiplicity="[1+]" desc="The receive timestamp in microseconds"/>
                        </event>
                        <function name="create">
                            <desc>Creates a new instance.</desc>
                            <sample for="lua">local handle = Profile.Provider.RemoteDistanceSensor.create()</sample>
                            <return name="handle" type="handle" alias="Profile.Provider.RemoteDistanceSensor" desc="Handle to the new instance"/>
                        </function>
                        <function name="setPort">
                            <desc>Sets the TCP/IP or UDP port for communication with the connected sensor.</desc>
                            <sample for="lua">Profile.Provider.RemoteDistanceSensor.setPort(handle, 2111)</sample>
                            <param name="handle" type="handle" alias="Profile.Provider.RemoteDistanceSensor" desc="The instance handle to use"/>
                            <param name="port" type="int" desc="TCP/IP or UDP port number."/>
                        </function>
                        <function name="setSensorType">
                            <desc>Sets the Sensor type. Default is "OD5000".</desc>
                            <sample for="lua">Profile.Provider.RemoteDistanceSensor.setSensorType(handle, "OD5000")</sample>
                            <param name="handle" type="handle" alias="Profile.Provider.RemoteDistanceSensor" desc="The instance handle to use"/>
                            <param name="sensorType" type="enum" ref="SensorType" desc="The sensor type to use."/>
                        </function>
                        <function name="register">
                            <desc>This function is used to register for any event of the crown. The event name is specified as parameter. The register function does automatically call the start function. Parameter changes are applied with a call to the register function.</desc>
                            <sample for="lua">Profile.Provider.RemoteDistanceSensor.register(handle, "OnNewData", "handleOnNewData")</sample>
                            <param name="handle" type="handle" alias="Profile.Provider.RemoteDistanceSensor" desc="The instance handle to use"/>
                            <param name="eventname" type="string" desc="The event to register to"/>
                            <param name="callback" type="string" alias="function" desc="Function name to call on the event"/>
                            <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                        </function>
                        <function name="deregister">
                            <desc>This function is used to deregister from any registered event of the handle.</desc>
                            <sample for="lua">Profile.Provider.RemoteDistanceSensor.deregister(handle, "OnNewData", "handleOnNewData")</sample>
                            <param name="handle" type="handle" alias="Profile.Provider.RemoteDistanceSensor" desc="The instance handle to use"/>
                            <param name="eventname" type="string" desc="The event to deregister from"/>
                            <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                            <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                        </function>
                        <function name="setBlockSize">
                            <desc>Sets the number of Datablock lines that get collected before OnNewData event gets triggered.</desc>
                            <sample for="lua">Profile.Provider.RemoteDistanceSensor.setBlockSize(handle, 10)</sample>
                            <param name="handle" type="handle" alias="Profile.Provider.RemoteDistanceSensor" desc="The instance handle to use"/>
                            <param name="blockSize" type="int" desc="The block size for each data block"/>
                        </function>
                        <function name="connect">
                            <desc>The device connects to the distance sensor with the settings that are previously made.</desc>
                            <sample for="lua">Profile.Provider.RemoteDistanceSensor.connect(handle)</sample>
                            <param name="handle" type="handle" alias="Profile.Provider.RemoteDistanceSensor" desc="The instance handle to use"/>
                        </function>
                        <function name="disconnect">
                            <desc>The device disconnects with the distance sensor.</desc>
                            <sample for="lua">Profile.Provider.RemoteDistanceSensor.disconnect(handle)</sample>
                            <param name="handle" type="handle" alias="Profile.Provider.RemoteDistanceSensor" desc="The instance handle to use"/>
                        </function>
                    </serves>
                </crown>
            </crown>
        </crown>
        <crown name="PointCloud">
            <trait>released</trait>
            <desc>Iconic object for points in a 3D Cartesian coordinate system.</desc>
            <enum name="ColorMode">
                <item name="Intensity" desc="Intensity values from 0.0 to 1.0">INTENSITY</item>
                <item name="RGBA" desc="Red, Green, Blue, Alpha values from 0 to 255">RGBA</item>
            </enum>
            <enum name="toImageMode" trait="released">
                <item name="topmost" desc="Resolve point ambiguities by picking the upper point, i.e, prioritize points with higher z coordinate.">TOPMOST</item>
                <item name="bottommost" desc="Resolve point ambiguities by picking the lower point,i.e, prioritize points with a lower z coordinate.">BOTTOMMOST</item>
            </enum>
            <enum name="SampleMethod">
                <item name="Uniform" desc="Applies a sampling with uniform index increments">UNIFORM</item>
                <item name="Random" desc="Applies a sampling with random index increments">RANDOM</item>
            </enum>
            <enum name="SearchMethod">
                <item name="k-NN" desc="Search the k-nearest neighbors of a point">KNN_SEARCH</item>
                <item name="Radius" desc="Search in a sphere of the given radius around a point">RADIUS_SEARCH</item>
            </enum>
            <enum name="HarrisResponseMethod">
                <item name="Harris" desc="Harris response method">HARRIS</item>
                <item name="Noble" desc="Noble response method">NOBLE</item>
                <item name="Tomasi" desc="Tomasi response method">TOMASI</item>
                <item name="Lowe" desc="Lowe response method">LOWE</item>
                <item name="Curvature" desc="Curvature response method">CURVATURE</item>
            </enum>
            <serves>
                <function name="create">
                    <desc>Creates a new empty point cloud object</desc>
                    <sample for="lua">local newCloud = PointCloud.create()</sample>
                    <param name="colorMode" type="enum" multiplicity="?" ref="ColorMode" desc="The color mode of this point cloud. Defaults to &quot;INTENSITY&quot;."/>
                    <return name="newCloud" type="object" alias="PointCloud" desc="The newly created cloud"/>
                </function>
                <function name="createFromVector">
                    <desc>Creates a point cloud from vectors of x, y, z and intensity values.</desc>
                    <sample for="lua">local pointcloud = PointCloud.createFromVector(x, y, z, intensity)</sample>
                    <param name="x" type="float" multiplicity="+" desc="X values in [mm]"/>
                    <param name="y" type="float" multiplicity="+" desc="Y values in [mm]"/>
                    <param name="z" type="float" multiplicity="+" desc="Z values in [mm]"/>
                    <param name="intensity" type="float" multiplicity="+" desc="Intensity values"/>
                    <return name="pointcloud" type="object" multiplicity="?" alias="PointCloud" desc="The resulting point cloud."/>
                </function>
                <function name="createFromPoints">
                    <desc>Creates a point cloud from a vector of Point objects containing the Cartesian coordinates and an optional intensity value or vector of intensity values.
If the input points are only 2D, the z-coordinate of all points in the point cloud is set to 0.</desc>
                    <sample for="lua">local pointcloud = PointCloud.createFromPoints(points, intensity)</sample>
                    <param name="points" type="const object" multiplicity="+" alias="Point" desc="Vector of Point objects containing the coordinates."/>
                    <param name="intensity" type="float" multiplicity="[?*]" desc="Select an intensity between 0 and 1 for the points in the point cloud. Input can be either a single value or one value per point. Default is 1.0."/>
                    <return name="pointcloud" type="object" multiplicity="?" alias="PointCloud" desc="The resulting point cloud."/>
                </function>
                <function name="clone">
                    <desc>Returns a duplicated instance of the input cloud. This is a full copy and might be very slow dependent on the cloud size.</desc>
                    <sample for="lua">local clone = PointCloud.clone(inputCloud)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The cloud to clone"/>
                    <return name="clone" type="object" alias="PointCloud" desc="The new cloned cloud object"/>
                </function>
                <function name="isDense">
                    <desc>Returns true if all the points in this point cloud have valid coordinates (i.e. not Inf/NaN).
Clouds provided by a sensor may contain invalid points.
This is typically used to ignore points with low confidence and at the same time keep the organized matrix structure of the cloud.</desc>
                    <sample for="lua">local isDense = PointCloud.isDense(inputCloud)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The point cloud to get the attribute from"/>
                    <return name="isDense" type="bool" desc="True if all the points in this point cloud have valid coordinates"/>
                </function>
                <function name="isOrganized">
                    <desc>Returns true if the points in this point cloud are organized in rows and columns (i.e. height &gt; 1).
This is typically the case when the data has been created by a matrix sensor, e.g. in a time-of-flight camera.</desc>
                    <sample for="lua">local isOrganized = PointCloud.isOrganized(inputCloud)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The point cloud to get the attribute from"/>
                    <return name="isOrganized" type="bool" desc="True if the points in this point cloud are organized in rows and columns"/>
                </function>
                <function name="getSize">
                    <desc>Returns the dimensions of the point cloud.</desc>
                    <sample for="lua">local size,width,height = PointCloud.getSize(inputCloud)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The point cloud to get the size from"/>
                    <return name="size" type="int" desc="The number of points in this cloud"/>
                    <return name="width" type="int" desc="The width of the cloud if organized, total size if not"/>
                    <return name="height" type="int" desc="The height of the cloud if organized, 1 if not"/>
                </function>
                <function name="getColorMode">
                    <desc>Returns the color mode of the point cloud.</desc>
                    <sample for="lua">local colorMode = PointCloud.getColorMode(inputCloud)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud"/>
                    <return name="colorMode" type="enum" ref="ColorMode" desc="The color mode of this cloud"/>
                </function>
                <function name="setID">
                    <trait>hidden</trait>
                    <desc>Sets an application specific identifier (e.g. object ID or sequence number).</desc>
                    <sample for="lua">PointCloud.setID(inputCloud, id)</sample>
                    <param name="inputCloud" type="object" alias="PointCloud" desc="Handle to the instance"/>
                    <param name="id" type="int" desc="The ID to set"/>
                </function>
                <function name="getID">
                    <trait>hidden</trait>
                    <desc>Returns an application specific identifier (e.g. object ID or sequence number).</desc>
                    <sample for="lua">local id = PointCloud.getID(inputCloud)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="Handle to the instance"/>
                    <return name="id" type="int" desc="Returns the ID"/>
                </function>
                <function name="getPoint">
                    <links>PointCloud.getPoint3D, PointCloud.toPoints</links>
                    <desc>Returns the x, y, z and intensity value of the specified point in the point cloud as single float values.</desc>
                    <sample for="lua">local x,y,z,intensity = PointCloud.getPoint(inputCloud, index)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The point cloud to get the point from"/>
                    <param name="index" type="int" desc="Point index starting from 0"/>
                    <return name="x" type="float" multiplicity="?" desc="X value in [mm]"/>
                    <return name="y" type="float" multiplicity="?" desc="Y value in [mm]"/>
                    <return name="z" type="float" multiplicity="?" desc="Z value in [mm]"/>
                    <return name="intensity" type="float" multiplicity="?" desc="Intensity value"/>
                </function>
                <function name="getPoint3D">
                    <links>PointCloud.getPoint, PointCloud.toPoints</links>
                    <desc>Returns the 3D coordinates of the specified point in the point cloud as Point object and the intensity as float value.</desc>
                    <sample for="lua">local point, intensity = PointCloud.getPoint3D(inputCloud, index)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The point cloud to get the point from"/>
                    <param name="index" type="int" multiplicity="?" desc="Optional point index starting from 0"/>
                    <return name="point" type="object" multiplicity="?" alias="Point" desc="The 3D coordinates as Point object."/>
                    <return name="intensity" type="float" multiplicity="?" desc="Intensity value"/>
                </function>
                <function name="getPoints">
                    <trait>deprecated</trait>
                    <links>PointCloud.getPoint, PointCloud.getPoint3D</links>
                    <desc>Returns the x, y, z and intensity value of all points in the point cloud as vectors of float values.
This function is deprecated, please use PointCloud.toVector instead.</desc>
                    <sample for="lua">local x,y,z,intensity = PointCloud.getPoints(inputCloud)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="Point cloud to get the points from"/>
                    <return name="x" type="float" multiplicity="+" desc="X values in [mm]"/>
                    <return name="y" type="float" multiplicity="+" desc="Y values in [mm]"/>
                    <return name="z" type="float" multiplicity="+" desc="Z values in [mm]"/>
                    <return name="intensity" type="float" multiplicity="+" desc="Intensity values"/>
                </function>
                <function name="toVector">
                    <desc>Returns the x, y, z and intensity value of all points in the point cloud as vectors of float values.</desc>
                    <sample for="lua">local x,y,z,intensity = PointCloud.toVector(inputCloud)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="Point cloud to get the points from"/>
                    <return name="x" type="float" multiplicity="+" desc="X values in [mm]"/>
                    <return name="y" type="float" multiplicity="+" desc="Y values in [mm]"/>
                    <return name="z" type="float" multiplicity="+" desc="Z values in [mm]"/>
                    <return name="intensity" type="float" multiplicity="+" desc="Intensity values"/>
                </function>
                <function name="toPoints">
                    <links>PointCloud.getPoint3D, PointCloud.getPoint</links>
                    <desc>Returns the 3D coordinates of all points in the point cloud as vector of Point objects and the intensities as vector of float values.</desc>
                    <sample for="lua">local points, intensities = PointCloud.toPoints(inputCloud)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="Point cloud to get the points from"/>
                    <return name="points" type="object" multiplicity="+" alias="Point" desc="3D coordinates as vector of Point objects."/>
                    <return name="intensities" type="float" multiplicity="+" desc="Intensities as vector of float values"/>
                </function>
                <function name="setPoint">
                    <desc>Sets the x, y, z and intensity value of the specified point in the point cloud.</desc>
                    <sample for="lua">PointCloud.setPoint(inputCloud, index, x, y, z, intensity)</sample>
                    <param name="inputCloud" type="object" alias="PointCloud" desc="Point cloud to set the point to"/>
                    <param name="index" type="int" desc="Point index starting from 0"/>
                    <param name="x" type="float" desc="X value in [mm]"/>
                    <param name="y" type="float" desc="Y value in [mm]"/>
                    <param name="z" type="float" desc="Z value in [mm]"/>
                    <param name="intensity" type="float" multiplicity="?" desc="Intensity value, optional"/>
                </function>
                <function name="setIntensity">
                    <links>PointCloud.getIntensity, PointCloud.setColor</links>
                    <desc>Set the intensity value of the specified points in the point cloud.
Works only if the point cloud's color mode is "INTENSITY".</desc>
                    <sample for="lua">PointCloud.setIntensity(inputCloud, indices, intensity)</sample>
                    <param name="inputCloud" type="object" alias="PointCloud" desc="The input point cloud"/>
                    <param name="indices" type="int" multiplicity="[1+]" desc="Indices of the points to set the intensity for"/>
                    <param name="intensity" type="float" multiplicity="[1+]" desc="Intensity value to set. Must be either a single value or vector of same length as indices."/>
                    <return name="success" type="bool" desc="Returns true on success."/>
                </function>
                <function name="getIntensity">
                    <links>PointCloud.setIntensity</links>
                    <desc>Get the intensity value of the specified points in the point cloud.
Works only if the point cloud's color mode is "INTENSITY".</desc>
                    <sample for="lua">local intensity = PointCloud.getIntensity(inputCloud, indices)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud"/>
                    <param name="indices" type="int" multiplicity="[1+]" desc="Indices of the points to get the intensity from"/>
                    <return name="intensity" type="float" multiplicity="[?*]" desc="Intensity (single value or vector of same length as indices) or nil"/>
                </function>
                <function name="setColor">
                    <links>PointCloud.setIntensity, PointCloud.getColor</links>
                    <desc>Set the RGBA color values of the specified points in the point cloud.
Works only if the point cloud's color mode is "RGBA".</desc>
                    <sample for="lua">PointCloud.setColor(inputCloud, indices, red, green, blue)</sample>
                    <param name="inputCloud" type="object" alias="PointCloud" desc="The input point cloud"/>
                    <param name="indices" type="int" multiplicity="[1+]" desc="Indices of the points to set the color for"/>
                    <param name="red" type="int" multiplicity="[1+]" desc="Red color component in range [0-255]. Must be either a single value or vector of same length as indices."/>
                    <param name="green" type="int" multiplicity="[1+]" desc="Green color component in range [0-255]. Must be either a single value or vector of same length as indices."/>
                    <param name="blue" type="int" multiplicity="[1+]" desc="Blue color component in range [0-255]. Must be either a single value or vector of same length as indices."/>
                    <param name="alpha" type="int" multiplicity="[?*]" desc="Alpha/opacity component in range [0-255] (optional). Must be either a single value or vector of same length as indices or empty. Defaults to 255."/>
                    <return name="success" type="bool" desc="Returns true on success."/>
                </function>
                <function name="getColor">
                    <links>PointCloud.setColor</links>
                    <desc>Get the RGBA color values of the specified points in the point cloud.
Works only if the point cloud's color mode is "RGBA".</desc>
                    <sample for="lua">local red, green, blue, alpha = PointCloud.getColor(inputCloud, indices)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud"/>
                    <param name="indices" type="int" multiplicity="[1+]" desc="Indices of the points to get the color from"/>
                    <return name="red" type="int" multiplicity="[?*]" desc="Red color component (single value or vector of same length as indices) or nil"/>
                    <return name="green" type="int" multiplicity="[?*]" desc="Green color component (single value or vector of same length as indices) or nil"/>
                    <return name="blue" type="int" multiplicity="[?*]" desc="Blue color component (single value or vector of same length as indices) or nil"/>
                    <return name="alpha" type="int" multiplicity="[?*]" desc="Alpha/opacity component (single value or vector of same length as indices) or nil"/>
                </function>
                <function name="appendPoint">
                    <desc>Appends a new point to the specified point cloud.</desc>
                    <sample for="lua">PointCloud.appendPoint(inputCloud, x, y, z, intensity)</sample>
                    <param name="inputCloud" type="object" alias="PointCloud" desc="Point cloud to append the point to"/>
                    <param name="x" type="float" desc="X value in [mm]"/>
                    <param name="y" type="float" desc="Y value in [mm]"/>
                    <param name="z" type="float" desc="Z value in [mm]"/>
                    <param name="intensity" type="float" multiplicity="?" desc="Intensity value"/>
                </function>
                <function name="load">
                    <links>Object.load, File</links>
                    <desc>Load a point cloud from the specified file path.
The format is defined by the file extension:
.ply: Polygon File Format ("ascii" mode only)
.pcd: Point Cloud Data File Format ("ascii", "binary" or "binary_compressed" mode)
.ssr: SICK Sensor Record
.json:    JSON
.msgpack: MessagePack</desc>
                    <sample for="lua">local loadedCloud = PointCloud.load("resources/cloud.pcd")</sample>
                    <param name="filepath" type="string" desc="The path and name of the file to load the point cloud from."/>
                    <return name="loadedCloud" type="object" multiplicity="?" alias="PointCloud" desc="The PointCloud object which is loaded."/>
                </function>
                <function name="save">
                    <links>Object.save, File</links>
                    <desc>Save a point cloud to the specified file path.
Overwrites the file if it already exists.
The format is defined by the file extension:
.ply: Polygon File Format ("ascii" mode only)
.pcd: Point Cloud Data File Format ("ascii" or "binary" mode)
.ssr: SICK Sensor Record
.json:    JSON (Optional useBinaryPCD parameter not supported).
.msgpack: MessagePack (Optional useBinaryPCD parameter not supported).</desc>
                    <sample for="lua">local success = PointCloud.save(inputCloud, "private/cloud.pcd")</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The PointCloud object which is saved."/>
                    <param name="filepath" type="string" desc="The path and name of the file to save the point cloud to."/>
                    <param name="useBinaryPCD" type="bool" multiplicity="?" desc="Only applies for .pcd file format. If true write coordinates in binary mode instead of ASCII. Default is false."/>
                    <return name="success" type="bool" desc="Returns true if the point cloud has been successfully saved."/>
                </function>
                <function name="resample">
                    <desc>Resample a point cloud using a 3D voxel grid.
All points in one voxel are merged to their centroid by averaging their x, y, z and intensity values.
It's possible to specify a minimum number of points inside a voxel to ignore scattered points.</desc>
                    <sample for="lua">local resampledCloud = PointCloud.resample(inputCloud, 5.0, 5.0, 5.0, 10)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                    <param name="voxelSizeX" type="float" desc="Voxel size in x-direction."/>
                    <param name="voxelSizeY" type="float" multiplicity="?" desc="Voxel size in y-direction (uses voxelSizeX if not set)."/>
                    <param name="voxelSizeZ" type="float" multiplicity="?" desc="Voxel size in z-direction (uses voxelSizeX if not set)."/>
                    <param name="minNumPoints" type="int" multiplicity="?" desc="Minimum number of points inside a voxel for creating a point in the output cloud, default is 1."/>
                    <return name="resampledCloud" type="object" multiplicity="?" alias="PointCloud" desc="The resampled point cloud."/>
                </function>
                <function name="extractIndices">
                    <desc>Extract a number of points referenced by indices from a point cloud.</desc>
                    <sample for="lua">local outputCloud = PointCloud.extractIndices(inputCloud, indices, negative)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                    <param name="indices" type="int" multiplicity="[1+]" desc="Indices of the points which will be copied to the output cloud."/>
                    <param name="negative" type="bool" multiplicity="?" desc="Set to true to invert the filter behavior (copy all points not in the indices vector), default is false."/>
                    <return name="outputCloud" type="object" multiplicity="?" alias="PointCloud" desc="The extracted point cloud or nil, if the input point cloud is empty."/>
                </function>
                <function name="getCentroid">
                    <desc>Compute the centroid (or geometric center) as the arithmetic mean position of all points in this cloud.</desc>
                    <sample for="lua">local centroid = PointCloud.getCentroid(inputCloud)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                    <return name="centroid" type="object" multiplicity="?" alias="Point" desc="The centroid or nil, if the input point cloud is empty."/>
                </function>
                <function name="getBoundingBox">
                    <links>PointCloud.getBounds</links>
                    <desc>Compute the axis-aligned bounding box of all points in this cloud and return a Shape3D object.</desc>
                    <sample for="lua">local box = PointCloud.getBoundingBox(inputCloud)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                    <return name="box" type="object" multiplicity="?" alias="Shape3D" desc="The bounding box or nil, if the input point cloud is empty."/>
                </function>
                <function name="getBounds">
                    <links>PointCloud.getBoundingBox</links>
                    <desc>Compute the axis-aligned bounding box of all points in this cloud and return the float values.</desc>
                    <sample for="lua">local minX, minY, minZ, maxX, maxY, maxZ = PointCloud.getBounds(inputCloud)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud"/>
                    <return name="minX" type="float" multiplicity="?" desc="X-value of minimum point [mm]"/>
                    <return name="minY" type="float" multiplicity="?" desc="Y-value of minimum point [mm]"/>
                    <return name="minZ" type="float" multiplicity="?" desc="Z-value of minimum point [mm]"/>
                    <return name="maxX" type="float" multiplicity="?" desc="X-value of maximum point [mm]"/>
                    <return name="maxY" type="float" multiplicity="?" desc="Y-value of maximum point [mm]"/>
                    <return name="maxZ" type="float" multiplicity="?" desc="Z-value of maximum point [mm]"/>
                </function>
                <function name="merge">
                    <links>PointCloud.mergeInplace</links>
                    <desc>Merge two point clouds by creating a new cloud and appending the points of both clouds to it.
The color mode of both point clouds must be identical.</desc>
                    <sample for="lua">local mergedCloud = PointCloud.merge(inputCloud1, inputCloud2)</sample>
                    <param name="inputCloud1" type="const object" alias="PointCloud" desc="The first point cloud."/>
                    <param name="inputCloud2" type="const object" alias="PointCloud" desc="The second point cloud."/>
                    <return name="mergedCloud" type="object" multiplicity="?" alias="PointCloud" desc="The merged point cloud."/>
                </function>
                <function name="mergeInplace">
                    <links>PointCloud.merge</links>
                    <desc>In-place version of the PointCloud.merge function that modifies the input point cloud. See base function for full documentation.
The color mode of both point clouds must be identical.</desc>
                    <sample for="lua">local result = PointCloud.mergeInplace(inputCloud1, inputCloud2)</sample>
                    <param name="inputCloud1" type="object" alias="PointCloud" desc="The first point cloud. This point cloud is overwritten with the merged point cloud."/>
                    <param name="inputCloud2" type="const object" alias="PointCloud" desc="The second point cloud."/>
                    <return name="result" type="object" multiplicity="?" alias="PointCloud" desc="Reference to the result point cloud."/>
                </function>
                <function name="toString">
                    <desc>Gets a user-friendly string description of the point cloud, containing important properties.</desc>
                    <sample for="lua">str = PointCloud.toString(inputCloud)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The point cloud to describe."/>
                    <return name="str" type="string" desc="User-friendly description of the point cloud."/>
                </function>
                <function name="transform">
                    <links>PointCloud.transformInplace</links>
                    <desc>Transform a point cloud. Fails if the transform is not a 3D transform.</desc>
                    <sample for="lua">local transformedCloud = PointCloud.transform(inputCloud, transform)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                    <param name="transform" type="const object" alias="Transform" desc="Transform to apply."/>
                    <return name="transformedCloud" type="object" multiplicity="?" alias="PointCloud" desc="Transformed point cloud or nil on error"/>
                </function>
                <function name="transformInplace">
                    <links>PointCloud.transform</links>
                    <desc>In-place version of the PointCloud.transform function that modifies the input point cloud. See base function for full documentation.</desc>
                    <sample for="lua">local result = PointCloud.transformInplace(inputCloud, transform)</sample>
                    <param name="inputCloud" type="object" alias="PointCloud" desc="The input point cloud. This point cloud is overwritten with the transformed point cloud."/>
                    <param name="transform" type="const object" alias="Transform" desc="Transform to apply."/>
                    <return name="result" type="object" multiplicity="?" alias="PointCloud" desc="Reference to the result point cloud or nil on error."/>
                </function>
                <function name="toImage">
                    <trait>released</trait>
                    <keywords>splat, convert, project, heightmap</keywords>
                    <links>Image.toPointCloud</links>
                    <desc>Create a range image from a pointcloud. The image is formed by projection of the point in the pointcloud onto the z-zero plane with normal (0, 0, 1). The x and y axes of the pointcloud are aligned with the x and y axes of the resulting image. The employed method is sometimes referred to as splatting, i.e., each point in the pointcloud is splatted onto the plane, writing its z-distance to a splat area given in pixels. Pixels which are not hit by any splats are marked as missing data. If such holes appear in the generated image try increasing the splat sizes, make the pixel sizes larger or use methods to fill missing data. The function can return two images, one with the z-distance in each pixel and one with the intensity value from the pointcloud.
The output image is of type UINT16 and the size of the image is calculated based on the input parameters.

Image world coordinate system handling:
The world coordinate settings, e.g., origin in x,y,z and pixel sizes are set based on the input parameters to the function.

Missing data handling:
Pixels in the output range image and intensity image will be zero (missing data) if no point in the pointcloud had effect over that pixel. Missing data can be reduced by increasing the splat size or by post processing.</desc>
                    <sample for="lua">rangeImageReference, intensityImage = PointCloud.toImage(pointcloud, boundingBox, {0.2})</sample>
                    <param name="pointcloud" type="const object" alias="PointCloud" desc="The input pointcloud."/>
                    <param name="box" type="const object" alias="Shape3D" desc="An axis-aligned box. All pointcloud points within this box are used for creating the image. Can for example be the bounding box of the pointcloud to include all points. The coordinate system origin of the resulting image is defined by the box."/>
                    <param name="pixelSizes" type="float" multiplicity="+" desc="Vector defining the pixel sizes of the output image {x, y, z}. At least one value must be set and will then affect the x and y resolution. The z-resolution will be automatically estimated if unset."/>
                    <param name="splatSizes" type="int" multiplicity="*" desc="Optional vector of splat kernel sizes in the x and y dimensions. To select a splat size of 5 use {5}, for anisotropic splatting use for example {3, 5}. Default is {3}."/>
                    <param name="mode" type="enum" multiplicity="?" ref="PointCloud.toImageMode" desc="If several points in the pointcloud splat onto the same pixel, it must be choosen if the TOPMOST or BOTTOMMOST value is written to the result pixel. Default is TOPMOST."/>
                    <param name="generateIntensity" type="bool" multiplicity="?" desc="Select if an intensity image is to be generated also from the intensity part of the pointcloud. Defaults to true."/>
                    <return name="rangeImage" type="object" multiplicity="?" alias="Image" desc="Output range image of UINT16 type."/>
                    <return name="intensityImage" type="object" multiplicity="?" alias="Image" desc="Intensity image of UINT8 type, if generated."/>
                </function>
                <function name="toImageInplace">
                    <trait>released</trait>
                    <keywords>splat, convert, project, heightmap</keywords>
                    <links>Image.toPointCloud</links>
                    <desc>Create a range image from a pointcloud. The image is formed by projection of the point in the point cloud onto the plane with normal (0, 0, 1). The x and y axes of the point cloud are aligned with the x and y axes of the resulting image. The employed method is sometimes referred to as splatting, i.e., each point in the pointcloud is splatted onto the plane, writing its z-distance to an splat area given in pixels. Pixels which are not hit by any splats are marked as missing data. If such holes appear in the generated image try increasing the splat sizes, make the pixel sizes larger or use methods to fill missing data. The operation is performed inplace for the input image, that is, the content of image will change inside the function. The function returns two images, one with the z-distance in each pixel and one with the intensity value from the pointcloud.

Supported rangeImageReference types are unsigned integer images, i.e., UINT8, UINT16, UINT32 and UINT64.

Image world coordinate system handling:
The input image defines the world coordinate system and this image is updated and returned inplace. Make sure to set pixel sizes and origin to appropriate values before calling this function to achieve the desired result.

Missing data handling:
Pixels in the output range image and intensity image will be zero (missing data) if no point in the pointcloud had effect over that pixel. Missing data can be reduced by increasing the splat sizes or by post processing.</desc>
                    <sample for="lua">rangeImageReference, intensityImage = PointCloud.toImageInplace(pointcloud, rangeImageReference, {3}, "TOPMOST", true)</sample>
                    <param name="pointcloud" type="const object" alias="PointCloud" desc="The input pointcloud"/>
                    <param name="rangeImageReference" type="object" alias="Image" desc="Both input and output image into which to render the result. Make sure to set pixel sizes and origin of this image to appropriate values before calling this function to achieve the desired result."/>
                    <param name="splatSizes" type="int" multiplicity="*" desc="Optional vector of splat kernel sizes in the x and y dimensions. To select a splat size of 5 use {5}, for anisotropic splatting use for example {3, 5}. Default is {3}."/>
                    <param name="mode" type="enum" multiplicity="?" ref="PointCloud.toImageMode" desc="If several points in the pointcloud splat onto the same pixel, it must be choosen if the TOPMOST or BOTTOMMOST value is written to the result pixel. Default is true."/>
                    <param name="includeIntensity" type="bool" multiplicity="?" desc="Select if an intensity image should also be generated. Defaults to true."/>
                    <return name="rangeImageReference" type="object" multiplicity="?" alias="Image" desc="Reference to the output range image."/>
                    <return name="intensityImage" type="object" multiplicity="?" alias="Image" desc="The resulting intensity image, if generated."/>
                </function>
                <function name="identity">
                    <trait>hidden</trait>
                    <desc>BENCHMARKING_TOOL: Convert CmnAlg to PCL point cloud and back without any processing.</desc>
                    <sample for="lua">local outputCloud = PointCloud.identity(inputCloud)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                    <return name="outputCloud" type="object" alias="PointCloud" desc="The twice converted point cloud."/>
                </function>
                <function name="sample">
                    <desc>Sample a point cloud by choosing points with uniform or random index increments.
The random method is based on Algorithm A from the paper "Faster Methods for Random Sampling" by Jeffrey Scott Vitter.</desc>
                    <sample for="lua">local outputCloud = PointCloud.sample(inputCloud, numPoints)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                    <param name="numPoints" type="int" desc="The number of points to be sampled (desired size of the output cloud)."/>
                    <param name="method" type="enum" multiplicity="?" ref="SampleMethod" desc="The sample method which should be used, default is UNIFORM."/>
                    <return name="outputCloud" type="object" multiplicity="?" alias="PointCloud" desc="The sampled point cloud."/>
                </function>
                <function name="getKeypointsHarris">
                    <desc>Computes Harris corner points in 3D, using surface normals instead of image gradients.
References:
C.G. Harris and M.J. Stephens, "A combined corner and edge detector", Proceedings Fourth Alvey Vision Conference, Manchester, pp 147-151, 1988.
Alison Noble, "Descriptions of Image Surfaces", PhD thesis, Department of Engineering Science, Oxford University 1989, p45.</desc>
                    <sample for="lua">local indices = PointCloud.getKeypointsHarris(inputCloud, normals, method, radius, threshold)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                    <param name="normals" type="const object" alias="Matrix" desc="The n x 4 matrix containing the surface normals and the local curvature."/>
                    <param name="method" type="enum" multiplicity="?" ref="HarrisResponseMethod" desc="The response method. Defaults to HARRIS."/>
                    <param name="radius" type="float" multiplicity="?" desc="Set the radius for normal estimation and non maxima suppression. Defaults to 10"/>
                    <param name="threshold" type="float" multiplicity="?" desc="Set the threshold value for detecting corners. Defaults to 0.001."/>
                    <return name="indices" type="int" multiplicity="*" desc="The indices of the keypoints in the input point cloud"/>
                </function>
                <function name="getKeypointsIntrinsicShapeSignature">
                    <desc>Computes the intrinsic shape signature keypoints for a given point cloud.
Described in "Intrinsic shape signatures: A shape descriptor for 3D object recognition" (Yu Zhong, 2009 IEEE 12th International Conference on Computer Vision Workshops).
The parameters of the algorithm are chosen under consideration of the estimated measurement resolution.</desc>
                    <sample for="lua">local indices = PointCloud.getKeypointsIntrinsicShapeSignature(inputCloud, normals, salientRadius, borderRadius, thr21, thr32)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                    <param name="normals" type="const object" alias="Matrix" desc="The n x 4 matrix containing the surface normals and the local curvature."/>
                    <param name="resolution" type="float" multiplicity="?" desc="The estimated measurement resolution. Defaults to 10."/>
                    <param name="minNeighbours" type="int" multiplicity="?" desc="The minimum number of neighbors that has to be found while applying the non maxima suppression algorithm. Defaults to 5."/>
                    <return name="indices" type="int" multiplicity="*" desc="The indices of the keypoints in the input point cloud"/>
                </function>
                <function name="getKeypointsBoundary">
                    <desc>Estimates the set of points of the surface boundary using an angle criterion.</desc>
                    <sample for="lua">local indices = PointCloud.getKeypointsBoundary(inputCloud, normals, k, angle)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud with n points."/>
                    <param name="normals" type="const object" alias="Matrix" desc="The n x 4 matrix containing the normals and the local curvature"/>
                    <param name="k" type="int" multiplicity="?" desc="The number of neighbors to analyze for each point. Defaults to 10."/>
                    <param name="angle" type="float" multiplicity="?" desc="The angle criterion in radians. Defaults to pi/2."/>
                    <return name="indices" type="int" multiplicity="*" desc="The indices of the estimated boundary points in the input point cloud"/>
                </function>
                <function name="filterStatisticalOutliers">
                    <desc>Analyze the k-nearest neighbor distances of each point and remove points which are considered as outliers.</desc>
                    <sample for="lua">local outputCloud = PointCloud.filterStatisticalOutliers(inputCloud, k, threshold)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                    <param name="k" type="int" multiplicity="?" desc="The number of neighbors to analyze for each point, default is 10."/>
                    <param name="threshold" type="float" multiplicity="?" desc="The standard deviation multiplier threshold, default is 1.0."/>
                    <param name="negative" type="bool" multiplicity="?" desc="Set to true to invert the filter behavior, default is false."/>
                    <return name="outputCloud" type="object" alias="PointCloud" desc="The filtered point cloud."/>
                </function>
                <function name="filterRadiusOutliers">
                    <desc>Analyze the neighborhood of each point defined by a sphere of the configured radius and remove points which have less neighbors than specified.</desc>
                    <sample for="lua">local outputCloud = PointCloud.filterRadiusOutliers(inputCloud, radius, minNeighborsInRadius)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                    <param name="radius" type="float" multiplicity="?" desc="The radius of the sphere that will determine which points are neighbors, default is 5."/>
                    <param name="minNeighborsInRadius" type="int" multiplicity="?" desc="The number of neighbors that need to be present in order to be classified as an inlier, default is 5."/>
                    <param name="negative" type="bool" multiplicity="?" desc="Set to true to invert the filter behavior, default is false."/>
                    <return name="outputCloud" type="object" alias="PointCloud" desc="The filtered point cloud."/>
                </function>
                <function name="filterMovingLeastSquares">
                    <desc>Apply the moving least squares surface reconstruction method to smooth noisy point cloud data.
The surface is approximated by projecting each point on a reference plane defined by a local neighborhood of points (size depends on the 'radius' parameter).
If polynomial filtering is enabled, the result is refined with a bivariate polynomial height function on this surface patch.
The intensity values are not affected.</desc>
                    <sample for="lua">local outputCloud = PointCloud.filterMovingLeastSquares(inputCloud, 25, true)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                    <param name="radius" type="float" multiplicity="?" desc="The radius of the sphere to search in, defaults to 10."/>
                    <param name="usePolynomialFiltering" type="bool" multiplicity="?" desc="Enables polynomial filtering (higher run time, but more accurate), defaults to false."/>
                    <return name="outputCloud" type="object" alias="PointCloud" desc="The filtered point cloud."/>
                </function>
                <function name="computePCA">
                    <desc>Compute the principal component analysis for an input cloud.
The function computes the eigenvectors and eigenvalues of the sample covariance matrix.
The output is given in the order of descending eigenvalues.</desc>
                    <sample for="lua">
            eigenvectors, eigenvalues = PointCloud.computePCA(inputCloud)
          </sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                    <return name="eigenvectors" type="object" alias="Matrix" desc="The normalized covariance matrix eigenvectors forming the columns of a 3 x 3 matrix in descending order of corresponding eigenvalues, identity matrix if point cloud is empty."/>
                    <return name="eigenvalues" type="float" multiplicity="+" desc="The covariance matrix eigenvalues corresponding to the eigenvectors in descending order of magnitude, all zero eigenvalues if point cloud is empty."/>
                </function>
                <function name="featureNormals">
                    <desc>Compute the surface normals and curvature for the input cloud in a k-neighborhood point surface patch.
The output is a Matrix where the first three columns describe the normal estimate for each point and the fourth column describes the local curvature estimate.</desc>
                    <sample for="lua">local normals = PointCloud.featureNormals(inputCloud, 7.5, "RADIUS_SEARCH")</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud with n points."/>
                    <param name="value" type="float" multiplicity="?" desc="The number of neighbors or the radius of the sphere to search in (depends on selected method), default is 10."/>
                    <param name="method" type="enum" multiplicity="?" ref="SearchMethod" desc="The search method to use, default is &quot;KNN_SEARCH&quot;."/>
                    <return name="normals" type="object" multiplicity="?" alias="Matrix" desc="The n x 4 matrix containing the normals and the local curvature"/>
                </function>
                <function name="featureFPFH">
                    <desc>Compute the Fast Point Feature Histogram (FPFH) descriptor for the input cloud.
Described in "Fast Point Feature Histograms (FPFH) for 3D Registration" (Rusu, Blodow and Beetz, 2009 IEEE International Conference on Robotics and Automation).</desc>
                    <sample for="lua">
            local normals = PointCloud.featureNormals(inputCloud, 7.5, "RADIUS_SEARCH")
            local features = PointCloud.featureFPFH(inputCloud, normals, 7.5, "RADIUS_SEARCH")
          </sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud with n points."/>
                    <param name="normals" type="const object" alias="Matrix" desc="The n x 4 matrix containing the surface normals and the local curvature."/>
                    <param name="value" type="float" multiplicity="?" desc="The number of neighbors or the radius of the sphere to search in (depends on selected method), default is 10."/>
                    <param name="method" type="enum" multiplicity="?" ref="SearchMethod" desc="The search method to use, default is &quot;KNN_SEARCH&quot;."/>
                    <return name="features" type="object" alias="Matrix" desc="The feature matrix of size n x 33."/>
                </function>
                <function name="featureDifferenceOfNormals">
                    <desc>Computes the Difference of Normals (DoN) descriptor.
This provides a scale-based feature by computing the difference of two normals estimated with differing search radius for each point.
Described in "Automatic Urban Modelling using Mobile Urban LIDAR Data" (Thesis by Yani Ioannou, Queen's University, March 2010)"</desc>
                    <sample for="lua">local features = PointCloud.featureDifferenceOfNormals(inputCloud, normalSmallScale, normalLargeScale)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud with n points."/>
                    <param name="normalSmallScale" type="const object" alias="Matrix" desc="The n x 4 matrix containing the small scale surface normals and the local curvature"/>
                    <param name="normalLargeScale" type="const object" alias="Matrix" desc="The n x 4 matrix containing the large scale surface normals and the local curvature"/>
                    <return name="features" type="object" alias="Matrix" desc="The n x 4 matrix containing the difference of normals and the local curvature"/>
                </function>
                <function name="featureIntensityGradient">
                    <desc>Computes the intensity gradient over the local neighborhood for each point.
The gradient is orthogonal to the surface normal and points in the direction of the greatest intensity increase.
The magnitude of the vector relates to the rate of the intensity change.</desc>
                    <sample for="lua">local features = PointCloud.featureIntensityGradient(inputCloud, normals, k)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud with n points."/>
                    <param name="normals" type="const object" alias="Matrix" desc="The n x 4 matrix containing the normals and the local curvature."/>
                    <param name="k" type="int" multiplicity="?" desc="The number of neighbors to analyze for each point, default is 10."/>
                    <return name="features" type="object" alias="Matrix" desc="The n x 3 matrix containing the intensity gradient [grad_x, grad_y, grad_z] for each point"/>
                </function>
                <function name="projectOntoPlane">
                    <desc>Project a point cloud onto a plane, given as Shape3D.</desc>
                    <sample for="lua">pointsOnPlane = PointCloud.projectOntoPlane(inputCloud, plane)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                    <param name="plane" type="const object" alias="Shape3D" desc="The target plane"/>
                    <return name="outputCloud" type="object" alias="PointCloud" desc="The projected point cloud."/>
                </function>
                <function name="rotateX">
                    <desc>Rotates a point cloud by a specified angle in radians using a unit vector in x direction as rotation axis. If a center point is given, the rotation is performed with respect to this. If the center point argument is omitted, the point cloud's centroid is used.</desc>
                    <sample for="lua">
            cloudOut = PointCloud.rotateX(inputCloud, math.pi/2, Point.create(0,0,0))
          </sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                    <param name="angleRad" type="float" desc="The rotation angle in radians."/>
                    <param name="centerpoint" type="const object" multiplicity="?" alias="Point" desc="Optional: the rotation offset. If omitted, the point cloud's centroid is used."/>
                    <return name="outputCloud" type="object" alias="PointCloud" desc="The rotated point cloud."/>
                </function>
                <function name="rotateY">
                    <desc>Rotates a point cloud by a specified angle in radians using a unit vector in y direction as rotation axis. If a center point is given, the rotation is performed with respect to this. If the center point argument is omitted, the point cloud's centroid is used.</desc>
                    <sample for="lua">
            cloudOut = PointCloud.rotateY(inputCloud, math.pi/2, Point.create(0,0,0))
          </sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                    <param name="angleRad" type="float" desc="The rotation angle in radians."/>
                    <param name="centerpoint" type="const object" multiplicity="?" alias="Point" desc="Optional: the rotation offset. If omitted, the point cloud's centroid is used."/>
                    <return name="outputCloud" type="object" alias="PointCloud" desc="The rotated point cloud."/>
                </function>
                <function name="rotateZ">
                    <desc>Rotates a point cloud by a specified angle in radians using a unit vector in z direction as rotation axis. If a center point is given, the rotation is performed with respect to this. If the center point argument is omitted, the point cloud's centroid is used.</desc>
                    <sample for="lua">
            cloudOut = PointCloud.rotateZ(inputCloud, math.pi/2, Point.create(0,0,0))
          </sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                    <param name="angleRad" type="float" desc="The rotation angle in radians."/>
                    <param name="centerpoint" type="const object" multiplicity="?" alias="Point" desc="Optional: the rotation offset. If omitted, the point cloud's centroid is used."/>
                    <return name="outputCloud" type="object" alias="PointCloud" desc="The rotated point cloud."/>
                </function>
                <function name="translate">
                    <desc>Translate the point cloud, i.e., shift it along the x,y,z directions.</desc>
                    <sample for="lua">cloudOut = PointCloud.translate(inputCloud, translationX, translationY, translationZ)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                    <param name="translationX" type="float" desc="The translation along the X-axis."/>
                    <param name="translationY" type="float" desc="The translation along the Y-axis."/>
                    <param name="translationZ" type="float" desc="The translation along the Z-axis."/>
                    <return name="outputCloud" type="object" alias="PointCloud" desc="The translated point cloud."/>
                </function>
                <function name="findClosestPoint">
                    <desc>Finds the closest point in a point cloud given a reference point.</desc>
                    <sample for="lua">pointOut, indOut = PointCloud.findClosestPoint(inputCloud, Point.create(0,0,0))</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                    <param name="referencePoint" type="const object" multiplicity="?" alias="Point" desc="Optional: the reference point to which the closest point should be found. Defaults to origin if argument is omitted."/>
                    <return name="pointOut" type="object" multiplicity="?" alias="Point" desc="Closest point in point cloud, nil if point cloud is empty."/>
                    <return name="index" type="int" multiplicity="?" desc="Index of closest point in point cloud, nil if point cloud is empty."/>
                </function>
                <function name="findNearbyPoints">
                    <desc>Find points from inputCloud within maxDistance to targetCloud and return their indices together with the indices from the closest match in targetCloud</desc>
                    <sample for="lua">local indicesInput, indicesTarget = PointCloud.findNearbyPoints(inputCloud, targetCloud, 20)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                    <param name="targetCloud" type="const object" alias="PointCloud" desc="The target point cloud."/>
                    <param name="maxDistance" type="float" multiplicity="?" desc="The maximum distance between corresponding points in both clouds. Defaults to 10 mm."/>
                    <return name="indicesInput" type="int" multiplicity="*" desc="Indices of the points from inputCloud within maxDistance to targetCloud."/>
                    <return name="indicesTarget" type="int" multiplicity="*" desc="Indices of the matching points from targetCloud."/>
                </function>
                <function name="findMaxDistancePointPair">
                    <desc>Finds the two points p1 and p2 that are the furthest from each other in the point cloud.</desc>
                    <sample for="lua">p1Out, p2Out, p1IndOut, p2IndOut = PointCloud.findMaxDistancePointPair(inputCloud)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                    <return name="p1Out" type="object" multiplicity="?" alias="Point" desc="Point p1 in point cloud, nil if point cloud is empty."/>
                    <return name="p2Out" type="object" multiplicity="?" alias="Point" desc="Point p2 in point cloud, nil if point cloud is empty."/>
                    <return name="p1Ind" type="int" multiplicity="?" desc="Index of point p1 in point cloud, nil if point cloud is empty."/>
                    <return name="p2Ind" type="int" multiplicity="?" desc="Index of point p2 in point cloud, nil if point cloud is empty."/>
                </function>
                <function name="cropShape">
                    <desc>Returns indices of all points inside a Shape3D.
This works only for shapes with a volume, e.g. box, sphere, cylinder, cone.</desc>
                    <sample for="lua">inliers = PointCloud.cropShape(pointCloud, shape3d)</sample>
                    <param name="pointCloud" type="const object" alias="PointCloud" desc="The point cloud to probe."/>
                    <param name="shape3d" type="const object" alias="Shape3D" desc="3D shape input."/>
                    <return name="inliers" type="int" multiplicity="+" desc="The indices of the inlier points."/>
                </function>
                <function name="cropShapeDistance">
                    <desc>Returns indices of all points within a certain distance to a Shape3D.
This works only for planes and lines.</desc>
                    <sample for="lua">inliers = PointCloud.cropShapeDistance(pointCloud, shape3d, distance)</sample>
                    <param name="pointCloud" type="const object" alias="PointCloud" desc="The point cloud to probe."/>
                    <param name="shape3d" type="const object" alias="Shape3D" desc="3D shape input (plane, line)."/>
                    <param name="distance" type="float" desc="The maximum distance to the shape."/>
                    <return name="inliers" type="int" multiplicity="+" desc="The indices of the inlier points."/>
                </function>
                <function name="segmentEuclideanClusters">
                    <desc>Segment a point cloud by dividing it into clusters using the Euclidean distance between points.</desc>
                    <sample for="lua">local clusters = PointCloud.segmentEuclideanClusters(cloud, 20, 250)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                    <param name="maxDistance" type="float" multiplicity="?" desc="The maximum distance between points inside a cluster. Defaults to 10 mm."/>
                    <param name="minClusterSize" type="int" multiplicity="?" desc="The minimum number of points in a cluster. Defaults to 1."/>
                    <param name="maxClusterSize" type="int" multiplicity="?" desc="The maximum number of points in a cluster. Defaults to 1000000."/>
                    <return name="clusters" type="object" multiplicity="*" alias="PointCloud" desc="Vector of point clouds representing the Euclidean clusters, nil if parameters are invalid."/>
                </function>
                <function name="segmentSmoothSurfacePatches">
                    <desc>Segment a point cloud by dividing it into a set of smooth surface patches.
Described in "Rabbani, T., van den Heuvel, F. A., Vosselman, G. (2006). Segmentation of point clouds using smoothness constraints"</desc>
                    <sample for="lua">local patches = PointCloud.segmentSmoothSurfacePatches(cloud, normals, 20, 0.1, 1.5, 20, 250)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                    <param name="normals" type="const object" alias="Matrix" desc="The n x 4 matrix containing the surface normals and the local curvature."/>
                    <param name="k" type="int" multiplicity="?" desc="The number of neighbors to analyze for each point, default is 10."/>
                    <param name="smoothnessThreshold" type="float" multiplicity="?" desc="The maximum angle between the normals of the seed point and added points in radians. A value that is too small can lead to oversegmentation. Defaults to 0.05."/>
                    <param name="curvatureThreshold" type="float" multiplicity="?" desc="The maximum allowed curvature of the surface patch. Set this to a value close to zero, if you want to segment only planar surfaces. Defaults to 1.0."/>
                    <param name="minSize" type="int" multiplicity="?" desc="The minimum number of points in a surface patch. Defaults to 1."/>
                    <param name="maxSize" type="int" multiplicity="?" desc="The maximum number of points in a surface patch. Defaults to 1000000."/>
                    <return name="patches" type="object" multiplicity="*" alias="PointCloud" desc="Vector of point clouds representing the surface patches, nil if parameters are invalid."/>
                </function>
                <function name="segmentDifference">
                    <desc>Obtain the difference between two aligned point clouds as another point cloud (outputCloud = inputCloud - targetCloud).
This can be used to remove background points, e.g. from a conveyor belt or a floor/wall.</desc>
                    <sample for="lua">local difference = PointCloud.segmentDifference(inputCloud, targetCloud, 20)</sample>
                    <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud (the minuend)."/>
                    <param name="targetCloud" type="const object" alias="PointCloud" desc="The target point cloud (the subtrahend)."/>
                    <param name="maxDistance" type="float" multiplicity="?" desc="The maximum distance between corresponding points in both clouds. Defaults to 10 mm."/>
                    <return name="outputCloud" type="object" alias="PointCloud" desc="The point cloud representing points present in the input cloud, but not in the target cloud."/>
                </function>
            </serves>
            <uses/>
            <crown name="Transform">
                <trait>deprecated</trait>
                <desc>This API is deprecated, please use PointCloud.transform instead.</desc>
                <serves>
                    <function name="create">
                        <desc>Create a handle for the transform</desc>
                        <sample for="lua">handle = PointCloud.Transform.create()</sample>
                        <return name="handle" type="handle" alias="PointCloud.Transform" desc="The coordinate transform handle."/>
                    </function>
                    <function name="transformRigid">
                        <desc>Transform a point cloud using the defined transform</desc>
                        <sample for="lua">local cloudTransformed = PointCloud.Transform.transformRigid(handle, inputCloud)</sample>
                        <param name="transform" type="handle" alias="PointCloud.Transform" desc="The handle."/>
                        <param name="inputCloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                        <return name="cloudTransformed" type="object" alias="PointCloud" desc="The transformed point cloud."/>
                    </function>
                    <function name="setAlphaBetaGamma">
                        <trait>hidden</trait>
                        <desc>Sets the rotation matrix using the SICK angle definition</desc>
                        <sample for="lua">PointCloud.Transform.setAlphaBetaGamma(handle, 0, math.pi/2, 0)</sample>
                        <param name="transform" type="handle" alias="PointCloud.Transform" desc="The handle."/>
                        <param name="alpha" type="float" desc="The alpha angle in radians"/>
                        <param name="beta" type="float" desc="The beta angle in radians"/>
                        <param name="gamma" type="float" desc="The gamma angle in radians"/>
                    </function>
                    <function name="setYawPitchRoll">
                        <desc>Sets the rotation matrix using the Yaw-Pitch-Roll definition</desc>
                        <sample for="lua">PointCloud.Transform.setYawPitchRoll(handle, 0, math.pi/2, 0)</sample>
                        <param name="transform" type="handle" alias="PointCloud.Transform" desc="The handle."/>
                        <param name="roll" type="float" desc="The roll angle in radians"/>
                        <param name="pitch" type="float" desc="The pitch angle in radians"/>
                        <param name="yaw" type="float" desc="The yaw angle in radians"/>
                    </function>
                    <function name="setMirrorAxis">
                        <desc>Set axis to be mirrored before translation</desc>
                        <sample for="lua">PointCloud.Transform.setMirrorAxis(handle, false, true, false)</sample>
                        <param name="transform" type="handle" alias="PointCloud.Transform" desc="The handle."/>
                        <param name="mirrorX" type="bool" desc="Mirror X axis"/>
                        <param name="mirrorY" type="bool" desc="Mirror Y axis"/>
                        <param name="mirrorZ" type="bool" desc="Mirror Z axis"/>
                    </function>
                    <function name="setTranslation">
                        <desc>Set the translation vector</desc>
                        <sample for="lua">PointCloud.Transform.setTranslation(handle, -3, 2, 0)</sample>
                        <param name="transform" type="handle" alias="PointCloud.Transform" desc="The handle."/>
                        <param name="x" type="float" desc="Translation in positive x direction"/>
                        <param name="y" type="float" desc="Translation in positive y direction"/>
                        <param name="z" type="float" desc="Translation in positive z direction"/>
                    </function>
                </serves>
            </crown>
            <crown name="MinimumBoundingBox">
                <trait>deprecated</trait>
                <desc>Calculates the axis-aligned minimum bounding box of the input point cloud.
This function is deprecated, please use PointCloud.getBoundingBox or PointCloud.getBounds instead.</desc>
                <serves>
                    <function name="calculate">
                        <desc>Returns the axis-aligned minimum bounding box.
This function is deprecated, please use PointCloud.getBoundingBox or PointCloud.getBounds instead.</desc>
                        <sample for="lua">local minX, minY, minZ, maxX, maxY, maxZ = PointCloud.MinimumBoundingBox.calculate(cloud)</sample>
                        <param name="cloud" type="const object" alias="PointCloud" desc="The input point cloud"/>
                        <return name="minX" type="float" desc="X-value of minimum point [mm]"/>
                        <return name="minY" type="float" desc="Y-value of minimum point [mm]"/>
                        <return name="minZ" type="float" desc="Z-value of minimum point [mm]"/>
                        <return name="maxX" type="float" desc="X-value of maximum point [mm]"/>
                        <return name="maxY" type="float" desc="Y-value of maximum point [mm]"/>
                        <return name="maxZ" type="float" desc="Z-value of maximum point [mm]"/>
                    </function>
                </serves>
            </crown>
            <crown name="Collector">
                <trait>released</trait>
                <desc>Collects 3D scan points during trigger-on and outputs them all at trigger-off.
The points from each incoming scan (during trigger on) are stored and combined to one point cloud. At trigger-off the combined point cloud is output. At next trigger-on a new point cloud is created.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">local handle = PointCloud.Collector.create()</sample>
                        <return name="handle" type="handle" alias="PointCloud.Collector" desc="Handle to the new instance"/>
                    </function>
                    <function name="setCollectTriggerCycles">
                        <desc>Will collect data over multiple trigger cycles.
Data is still output at every trigger-off but the cloud is only cleared when this number of cycles is reached.
Set to 0 to deactivate.</desc>
                        <sample for="lua">PointCloud.Collector.setCollectTriggerCycles(handle, 0)</sample>
                        <param name="handle" type="handle" alias="PointCloud.Collector" desc="The instance handle to use"/>
                        <param name="collectTriggerCycles" type="int" desc="Will collect data for given trigger cycles. Set to 0 to deactivate"/>
                    </function>
                    <function name="setInitialPointCount">
                        <desc>Set the number of points to initialize outgoing scan. Will be the expected size of the point cloud.
May improve performance if magnitude is known.</desc>
                        <sample for="lua">PointCloud.Collector.setInitialPointCount(handle, 10000)</sample>
                        <param name="handle" type="handle" alias="PointCloud.Collector" desc="The instance handle to use"/>
                        <param name="initialPointCount" type="int" desc="Number of points to initialize outgoing scan."/>
                    </function>
                    <function name="collect">
                        <include>data-flow</include>
                        <desc>Collects 3D scan points during trigger-on and outputs them all in one point cloud at trigger-off.
At trigger-off the combined point cloud is output. At next trigger-on a new point cloud is created.
Without the trigger flag, the collector directly outputs the input point cloud or collects them with the number of collect trigger cycles value.</desc>
                        <sample for="lua">local objCloud = PointCloud.Collector.collect(handle, scanCloud, trigger)</sample>
                        <param name="handle" type="handle" alias="PointCloud.Collector" desc="The instance handle to use"/>
                        <param name="cloud" type="const object" alias="PointCloud" desc="PointCloud input data"/>
                        <param name="trigger" type="bool" multiplicity="?" desc="Trigger input. If omitted, then the point cloud is directly output or collected until CollectTriggerCycles is reached"/>
                        <return name="cloud" type="object" multiplicity="?" alias="PointCloud" desc="The collected PointCloud object"/>
                    </function>
                </serves>
            </crown>
            <crown name="RangeFilter">
                <trait>released</trait>
                <desc>Removes points outside of the defined attribute range (or inside, if the behavior is inverted with setNegative(true)).
By default, the filter does not remove any points.</desc>
                <serves>
                    <function name="create">
                        <desc>Create a new instance.</desc>
                        <sample for="lua">local handle = PointCloud.RangeFilter.create()</sample>
                        <return name="handle" type="handle" alias="PointCloud.RangeFilter" desc="Handle to the new instance"/>
                    </function>
                    <function name="filter">
                        <include>data-flow</include>
                        <desc>Return the area filtered PointCloud.</desc>
                        <sample for="lua">local areaCloud = PointCloud.RangeFilter.filter(handle, cloud)</sample>
                        <param name="handle" type="handle" alias="PointCloud.RangeFilter" desc="The instance handle to use"/>
                        <param name="inputCloud" type="const object" multiplicity="[1+]" alias="PointCloud" desc="The PointCloud object which is filtered"/>
                        <return name="filteredCloud" type="object" multiplicity="[?*]" alias="PointCloud" desc="The area filtered PointCloud"/>
                    </function>
                    <function name="setXRange">
                        <desc>Set the filter range in x-direction. Points outside of this range are filtered out. If both parameters are 0 (default), the filter is disabled.</desc>
                        <sample for="lua">PointCloud.RangeFilter.setXRange(handle, -10.5, 15.0)</sample>
                        <param name="handle" type="handle" alias="PointCloud.RangeFilter" desc="The instance handle to use"/>
                        <param name="minX" type="float" desc="Minimum x value"/>
                        <param name="maxX" type="float" desc="Maximum x value"/>
                    </function>
                    <function name="setYRange">
                        <desc>Set the filter range in y-direction. Points outside of this range are filtered out. If both parameters are 0 (default), the filter is disabled.</desc>
                        <sample for="lua">PointCloud.RangeFilter.setYRange(handle, -10.5, 15.0)</sample>
                        <param name="handle" type="handle" alias="PointCloud.RangeFilter" desc="The instance handle to use"/>
                        <param name="minY" type="float" desc="Minimum y value"/>
                        <param name="maxY" type="float" desc="Maximum y value"/>
                    </function>
                    <function name="setZRange">
                        <desc>Set the filter range in z-direction. Points outside of this range are filtered out. If both parameters are 0 (default), the filter is disabled.</desc>
                        <sample for="lua">PointCloud.RangeFilter.setZRange(handle, -10.5, 15.0)</sample>
                        <param name="handle" type="handle" alias="PointCloud.RangeFilter" desc="The instance handle to use"/>
                        <param name="minZ" type="float" desc="Minimum z value"/>
                        <param name="maxZ" type="float" desc="Maximum z value"/>
                    </function>
                    <function name="setIntensityRange">
                        <desc>Set the filter range for intensity values. Points outside of this range are filtered out. If both parameters are 0 (default), the filter is disabled.</desc>
                        <sample for="lua">PointCloud.RangeFilter.setIntensityRange(handle, 0.8, 1.0)</sample>
                        <param name="handle" type="handle" alias="PointCloud.RangeFilter" desc="The instance handle to use"/>
                        <param name="minIntensity" type="float" desc="Minimum intensity value in range [0.0-1.0]"/>
                        <param name="maxIntensity" type="float" desc="Maximum intensity value in range [0.0-1.0]"/>
                    </function>
                    <function name="setNegative">
                        <desc>Set to true to invert the filter behavior (return points outside of range).</desc>
                        <sample for="lua">PointCloud.RangeFilter.setNegative(handle, true)</sample>
                        <param name="handle" type="handle" alias="PointCloud.RangeFilter" desc="The instance handle to use"/>
                        <param name="behavior" type="bool" desc="Invert filter behavior, default is false"/>
                    </function>
                </serves>
            </crown>
            <crown name="Format">
                <trait>released</trait>
                <desc>PointCloud file formats/encodings.</desc>
                <crown name="PCD">
                    <trait>released</trait>
                    <desc>PCD encoding functionality</desc>
                    <serves>
                        <function name="create">
                            <desc>Creates a new instance of the PCD encoder.</desc>
                            <sample for="lua">local handle = PointCloud.Format.PCD.create()</sample>
                            <return name="handle" type="handle" alias="PointCloud.Format.PCD" desc="Handle to the instance."/>
                        </function>
                        <function name="encode">
                            <desc>Create a binary buffer with the PCD encoded point cloud data.</desc>
                            <sample for="lua">local pcdBuffer = PointCloud.Format.PCD.encode(handle, pointcloud)</sample>
                            <param name="handle" type="handle" alias="PointCloud.Format.PCD" desc="Handle to the instance"/>
                            <param name="cloud" type="const object" alias="PointCloud" desc="Point cloud to encode"/>
                            <param name="useBinaryPCD" type="bool" multiplicity="?" desc="If true write coordinates in binary instead of ASCII. Default is false."/>
                            <return name="pcdBuffer" type="binary" multiplicity="?" desc="Binary buffer containing the PCD encoded point cloud or nil"/>
                        </function>
                    </serves>
                </crown>
            </crown>
            <crown name="Registration">
                <trait>released</trait>
                <desc>Algorithms for the registration of multiple PointCloud objects, that is finding a rigid transformation that aligns them.</desc>
                <serves>
                    <function name="estimateTransformSVD">
                        <desc>Estimates a transform between the corresponding points in the given point clouds that minimizes the point to point distances based on singular value decomposition.</desc>
                        <sample for="lua">local transform = PointCloud.Registration.estimateTransformSVD(cloudReference, cloudTarget, indicesReference, indicesTarget, distances)</sample>
                        <param name="cloudReference" type="const object" alias="PointCloud" desc="The reference point cloud."/>
                        <param name="cloudTarget" type="const object" alias="PointCloud" desc="The target point cloud."/>
                        <param name="indicesReference" type="int" multiplicity="*" desc="The indices of the corresponding points in the reference point cloud."/>
                        <param name="indicesTarget" type="int" multiplicity="*" desc="The indices of the corresponding points in the target point cloud."/>
                        <param name="distances" type="float" multiplicity="*" desc="The distance of the corresponding point pairs in the reference and target point cloud."/>
                        <return name="transform" type="object" multiplicity="?" alias="Transform" desc="Transformation estimate"/>
                    </function>
                    <function name="estimateTransformPointToPlane">
                        <desc>Estimates a transform between the corresponding points in the given point clouds that minimizes the point to plane distances using the Levenberg-Marquardt method for non-linear least-squares optimization.</desc>
                        <sample for="lua">local transform = PointCloud.Registration.estimateTransformPointToPlane(cloudReference, cloudTarget, normalsReference, normalsTarget, indicesReference, indicesTarget, distances)</sample>
                        <param name="cloudReference" type="const object" alias="PointCloud" desc="The reference point cloud with n points."/>
                        <param name="cloudTarget" type="const object" alias="PointCloud" desc="The target point cloud with m points."/>
                        <param name="normalsReference" type="const object" alias="Matrix" desc="The n x 4 matrix containing the normals and the local curvature for the reference cloud."/>
                        <param name="normalsTarget" type="const object" alias="Matrix" desc="The m x 4 matrix containing the normals and the local curvature for the reference cloud."/>
                        <param name="indicesReference" type="int" multiplicity="*" desc="The indices of the corresponding points in the reference point cloud."/>
                        <param name="indicesTarget" type="int" multiplicity="*" desc="The indices of the corresponding points in the target point cloud."/>
                        <param name="distances" type="float" multiplicity="*" desc="The distance of the corresponding point pairs in the reference and target point cloud."/>
                        <return name="transform" type="object" multiplicity="?" alias="Transform" desc="Transformation estimate"/>
                    </function>
                    <function name="estimateCorrespondencesFPFH">
                        <desc>Correspondence estimation based on Fast Point Feature Histogram (FPFH) features.</desc>
                        <sample for="lua">local indicesReference, indicesTarget, distances = PointCloud.Registration.estimateCorrespondencesFPFH(featuresReference, featuresTarget, maximumDistance)</sample>
                        <param name="featuresReference" type="const object" alias="Matrix" desc="The matrix representing the FPFH features for n points from the reference cloud of size n x 33."/>
                        <param name="featuresTarget" type="const object" alias="Matrix" desc="The matrix representing the FPFH features for m points from the target cloud of size m x 33."/>
                        <param name="maximumDistance" type="float" multiplicity="?" desc="Maximum distance between corresponding points in feature space."/>
                        <return name="indicesReference" type="int" multiplicity="*" desc="The indices of the corresponding points in the reference point cloud."/>
                        <return name="indicesTarget" type="int" multiplicity="*" desc="The indices of the corresponding points in the target point cloud."/>
                        <return name="distances" type="float" multiplicity="*" desc="The distance of the corresponding point pairs in the reference and target point cloud."/>
                    </function>
                    <function name="rejectCorrespondencesOneToOne">
                        <desc>A correspondence rejection method that is based on eliminating duplicate match indices in the correspondences by selecting the pair with smallest distance.</desc>
                        <sample for="lua">local indicesReference, indicesTarget, distances = PointCloud.Registration.rejectCorrespondencesOneToOne(indicesReference, indicesTarget, distances)</sample>
                        <param name="indicesReference" type="int" multiplicity="*" desc="The indices of the corresponding points in the reference point cloud."/>
                        <param name="indicesTarget" type="int" multiplicity="*" desc="The indices of the corresponding points in the target point cloud."/>
                        <param name="distances" type="float" multiplicity="*" desc="The distance of the corresponding point pairs in the reference and target point cloud."/>
                        <return name="indicesReference" type="int" multiplicity="*" desc="The filtered indices of the corresponding points in the reference point cloud."/>
                        <return name="indicesTarget" type="int" multiplicity="*" desc="The filtered indices of the corresponding points in the target point cloud."/>
                        <return name="distances" type="float" multiplicity="*" desc="The filtered distance of the corresponding point pairs in the reference and target point cloud."/>
                    </function>
                    <function name="rejectCorrespondencesSampleConsensus">
                        <desc>Implements a correspondence rejection algorithm based on Random Sample Consensus (RANSAC).</desc>
                        <sample for="lua">local indicesReference, indicesTarget, distances = PointCloud.Registration.rejectCorrespondencesSampleConsensus(cloudReference, cloudTarget, indicesReference, indicesTarget, distances, inlierThreshold, maxIterations)</sample>
                        <param name="cloudReference" type="const object" alias="PointCloud" desc="The reference point cloud."/>
                        <param name="cloudTarget" type="const object" alias="PointCloud" desc="The target point cloud."/>
                        <param name="indicesReference" type="int" multiplicity="+" desc="The indices of the corresponding points in the reference point cloud."/>
                        <param name="indicesTarget" type="int" multiplicity="+" desc="The indices of the corresponding points in the target point cloud."/>
                        <param name="distances" type="float" multiplicity="+" desc="The distance of the corresponding point pairs in the reference and target point cloud."/>
                        <param name="inlierThreshold" type="float" desc="Maximum distance between corresponding points."/>
                        <param name="maxIterations" type="int" desc="Maximum number of iterations."/>
                        <return name="indicesReference" type="int" multiplicity="*" desc="The filtered indices of the corresponding points in the reference point cloud."/>
                        <return name="indicesTarget" type="int" multiplicity="*" desc="The filtered indices of the corresponding points in the target point cloud."/>
                        <return name="distances" type="float" multiplicity="*" desc="The filtered distance of the corresponding point pairs in the reference and target point cloud."/>
                    </function>
                </serves>
                <crown name="FastGlobal">
                    <trait>released</trait>
                    <desc>Algorithm based on the work:
Fast Global Registration
Qian-Yi Zhou, Jaesik Park, and Vladlen Koltun
ECCV 2016</desc>
                    <enum name="Scale">
                        <item name="Absolute" desc="Measure model distance in absolute scale.">ABSOLUTE</item>
                        <item name="Relative" desc="Measure model distance relative to the model diameter.">RELATIVE</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <desc>Create the handle.</desc>
                            <sample for="lua">local handle = PointCloud.Registration.FastGlobal.create()</sample>
                            <return name="handle" type="handle" alias="PointCloud.Registration.FastGlobal" desc="The handle."/>
                        </function>
                        <function name="compute">
                            <desc>Compute the rigid transform to align a point cloud to a reference. The height of the feature matrix for each cloud must match the size of the cloud. Furthermore, the width for both feature matrices must be equal.</desc>
                            <sample for="lua">
                local transform = PointCloud.Registration.FastGlobal.compute(handle, cloudRef, featuresRef, cloud, features)
                local cloudTransformed = PointCloud.transform(transform, cloud)
              </sample>
                            <param name="handle" type="handle" alias="PointCloud.Registration.FastGlobal" desc="The handle."/>
                            <param name="cloudRef" type="const object" alias="PointCloud" desc="The reference point cloud with n points."/>
                            <param name="featuresRef" type="object" alias="Matrix" desc="The feature matrix of size n x k"/>
                            <param name="cloud" type="const object" alias="PointCloud" desc="The input point cloud with m points."/>
                            <param name="features" type="const object" alias="Matrix" desc="The feature matrix of size m x k"/>
                            <return name="transform" type="object" multiplicity="?" alias="Transform" desc="On success the rigid transformation is returned, otherwise nil."/>
                        </function>
                        <function name="setGraduatedNonConvexityFactor">
                            <desc>Set the factor for increasing the non-convexity of the loss function with each iteration.</desc>
                            <sample for="lua">local success = PointCloud.Registration.FastGlobal.setGraduatedNonConvexityFactor(handle, divisionFactor)</sample>
                            <param name="handle" type="handle" alias="PointCloud.Registration.FastGlobal" desc="The handle."/>
                            <param name="divisionFactor" type="float" desc="The factor for increasing the non-convexity. Must be larger than 1, default is 1.4"/>
                            <return name="success" type="bool" desc="Return true unless input parameter is invalid."/>
                        </function>
                        <function name="setMaximumCorrespondenceDistance">
                            <desc>Set the maximum correspondence distance (using relative or absolute scale) used to stop the optimization.</desc>
                            <sample for="lua">local success = PointCloud.Registration.FastGlobal.setMaximumCorrespondenceDistance(handle, "RELATIVE", maxCorrespondenceDistance)</sample>
                            <param name="handle" type="handle" alias="PointCloud.Registration.FastGlobal" desc="The handle."/>
                            <param name="scale" type="enum" ref="Scale" desc="The scale to use, default is &quot;RELATIVE&quot;"/>
                            <param name="maxCorrespondenceDistance" type="float" desc="The value should be set close to the threshold used to determine if a pair is a match, default is 0.025"/>
                            <return name="success" type="bool" desc="Return true unless input parameter is invalid."/>
                        </function>
                        <function name="setMaxIterations">
                            <desc>Set the maximum number of iterations for increasing the graduated non-convexity term.</desc>
                            <sample for="lua">local success = PointCloud.Registration.FastGlobal.setMaxIterations(handle, maxIterations)</sample>
                            <param name="handle" type="handle" alias="PointCloud.Registration.FastGlobal" desc="The handle."/>
                            <param name="maxIterations" type="int" desc="Maximum number of iterations, default is 500."/>
                            <return name="success" type="bool" desc="Return true unless input parameter is invalid."/>
                        </function>
                        <function name="setSimilarityThreshold">
                            <desc>Set the similarity threshold for the point-pair similarity test. For a random triple check threshold &lt; |p_i - q_j|/|p_j - q_i| &lt; 1/threshold</desc>
                            <sample for="lua">local success = PointCloud.Registration.FastGlobal.setSimilarityThreshold(handle, threshold)</sample>
                            <param name="handle" type="handle" alias="PointCloud.Registration.FastGlobal" desc="The handle."/>
                            <param name="threshold" type="float" desc="Similarity threshold between zero and one, default is 0.95."/>
                            <return name="success" type="bool" desc="Return true unless input parameter is invalid."/>
                        </function>
                        <function name="setMaxTuples">
                            <desc>Set the maximum number of correspondence tuples considered by the algorithm.</desc>
                            <sample for="lua">local success = PointCloud.Registration.FastGlobal.setMaxTuples(handle, maxTuples)</sample>
                            <param name="handle" type="handle" alias="PointCloud.Registration.FastGlobal" desc="The handle."/>
                            <param name="maxTuples" type="int" desc="Maximum number of correspondence tuples, default is 1000."/>
                            <return name="success" type="bool" desc="Return true unless input parameter is invalid."/>
                        </function>
                    </serves>
                </crown>
                <crown name="IterativeClosestPoint">
                    <trait>released</trait>
                    <desc>Provides a family of iterative closest point algorithms for pairwise point cloud registration.</desc>
                    <serves>
                        <function name="create">
                            <desc>Create the handle.</desc>
                            <sample for="lua">local handle = PointCloud.Registration.IterativeClosestPoint.create()</sample>
                            <return name="handle" type="handle" alias="PointCloud.Registration.IterativeClosestPoint" desc="The handle."/>
                        </function>
                        <function name="compute">
                            <desc>Compute the rigid transform to align a point cloud to a reference. If provided, the height of the normal matrix for each cloud must match the size of the cloud.</desc>
                            <sample for="lua">
                local transform, score = PointCloud.Registration.IterativeClosestPoint.compute(handle, cloudRef, cloud, normalsRef, normals)
                local cloudTransformed = PointCloud.transform(transform, cloud)
              </sample>
                            <param name="handle" type="handle" alias="PointCloud.Registration.IterativeClosestPoint" desc="The handle."/>
                            <param name="cloudRef" type="const object" alias="PointCloud" desc="The reference point cloud with n points."/>
                            <param name="cloud" type="const object" alias="PointCloud" desc="The input point cloud with m points."/>
                            <param name="normalsRef" type="const object" multiplicity="?" alias="Matrix" desc="The n x 4 matrix containing the normals and the local curvature."/>
                            <param name="normals" type="const object" multiplicity="?" alias="Matrix" desc="The m x 4 matrix containing the normals and the local curvature."/>
                            <return name="transform" type="object" multiplicity="?" alias="Transform" desc="On success the rigid transformation is returned, otherwise nil."/>
                            <return name="score" type="float" multiplicity="?" desc="On success the score of the matching."/>
                        </function>
                        <function name="setConvergenceEpsilon">
                            <desc>Set the algorithm's convergence criteria.</desc>
                            <sample for="lua">local success = PointCloud.Registration.IterativeClosestPoint.setConvergenceEpsilon(handle, transformThreshold, squaredErrorThreshold)</sample>
                            <param name="handle" type="handle" alias="PointCloud.Registration.IterativeClosestPoint" desc="The handle."/>
                            <param name="transformThreshold" type="float" desc="The difference between the previous transformation and the current estimated transformation shall be smaller epsilon, default is 1e-8."/>
                            <param name="squaredErrorThreshold" type="float" desc="Threshold for the sum of euclidean squared errors for the correspondences, default is 1."/>
                            <return name="success" type="bool" desc="Return true unless input parameter is invalid."/>
                        </function>
                        <function name="setMaximumCorrespondenceDistance">
                            <desc>Set the maximum correspondence distance. Correspondences with higher distances will be ignored.</desc>
                            <sample for="lua">local success = PointCloud.Registration.IterativeClosestPoint.setMaximumCorrespondenceDistance(handle, maxCorrespondenceDistance)</sample>
                            <param name="handle" type="handle" alias="PointCloud.Registration.IterativeClosestPoint" desc="The handle."/>
                            <param name="maxCorrespondenceDistance" type="float" desc="The maximum correspondence distance, default is 0.05."/>
                            <return name="success" type="bool" desc="Return true unless input parameter is invalid."/>
                        </function>
                        <function name="setMaxIterations">
                            <desc>Set the maximum number of iterations performed by the algorithm.</desc>
                            <sample for="lua">local success = PointCloud.Registration.IterativeClosestPoint.setMaxIterations(handle, maxIterations)</sample>
                            <param name="handle" type="handle" alias="PointCloud.Registration.IterativeClosestPoint" desc="The handle."/>
                            <param name="maxIterations" type="int" desc="Maximum number of iterations, default is 500."/>
                            <return name="success" type="bool" desc="Return true unless input parameter is invalid."/>
                        </function>
                    </serves>
                </crown>
            </crown>
            <crown name="ShapeFitter">
                <trait>released</trait>
                <desc>Fit 3D shapes to a point cloud.</desc>
                <serves>
                    <function name="create">
                        <desc>Create the handle.</desc>
                        <sample for="lua">local handle = PointCloud.ShapeFitter.create()</sample>
                        <return name="handle" type="handle" alias="PointCloud.ShapeFitter" desc="The handle"/>
                    </function>
                    <function name="setDistanceThreshold">
                        <desc>Set the distance from the shape up to which a point is considered an inlier.</desc>
                        <sample for="lua">PointCloud.ShapeFitter.setDistanceThreshold(handle, threshold)</sample>
                        <param name="handle" type="handle" alias="PointCloud.ShapeFitter" desc="The handle"/>
                        <param name="threshold" type="float" desc="Distance threshold in mm, default is 1.0."/>
                    </function>
                    <function name="setMaxIterations">
                        <desc>Set the maximum number of attempts to find an adequate sample.</desc>
                        <sample for="lua">PointCloud.ShapeFitter.setMaxIterations(handle, maxIterations)</sample>
                        <param name="handle" type="handle" alias="PointCloud.ShapeFitter" desc="The handle"/>
                        <param name="maxIterations" type="int" desc="Maximum number of iterations, default is 100."/>
                    </function>
                    <function name="setProbability">
                        <desc>Set the probability of choosing at least one sample that is free of outliers, i.e. the expected ratio of inliers / (inliers + outliers).
This parameter has an influence on the termination criterion of the underlying algorithm (higher value -&gt; higher run time).</desc>
                        <sample for="lua">PointCloud.ShapeFitter.setProbability(handle, probability)</sample>
                        <param name="handle" type="handle" alias="PointCloud.ShapeFitter" desc="The handle"/>
                        <param name="probability" type="float" desc="Probability, default is 0.9."/>
                    </function>
                    <function name="setAxis">
                        <desc>Set the expected direction of the central axis for the Cone and Cylinder models.
This is an optional parameter, if not set, any direction is allowed.</desc>
                        <sample for="lua">PointCloud.ShapeFitter.setAxis(handle, 0.0, 0.0, 1.0, 0.1)</sample>
                        <param name="handle" type="handle" alias="PointCloud.ShapeFitter" desc="The handle"/>
                        <param name="x" type="float" desc="x component of direction vector."/>
                        <param name="y" type="float" desc="y component of direction vector."/>
                        <param name="z" type="float" desc="z component of direction vector."/>
                        <param name="epsilon" type="float" desc="Allowed deviation (in radians)."/>
                    </function>
                    <function name="setRadiusLimits">
                        <desc>Set the minimum and maximum allowed radius for the Sphere and Cylinder models.
This is an optional parameter, if not set, any radius is allowed.</desc>
                        <sample for="lua">PointCloud.ShapeFitter.setRadiusLimits(handle, 200.0, 250.0)</sample>
                        <param name="handle" type="handle" alias="PointCloud.ShapeFitter" desc="The handle"/>
                        <param name="minRadius" type="float" desc="Minimum radius."/>
                        <param name="maxRadius" type="float" desc="Maximum radius."/>
                    </function>
                    <function name="setAngleLimits">
                        <desc>Set the minimum and maximum opening angle for the Cone model.
This is an optional parameter, if not set, any angle is allowed.</desc>
                        <sample for="lua">PointCloud.ShapeFitter.setAngleLimits(handle, math.pi/4 - 0.1, math.pi/4 + 0.1)</sample>
                        <param name="handle" type="handle" alias="PointCloud.ShapeFitter" desc="The handle"/>
                        <param name="minAngle" type="float" desc="Minimum angle (in radians)."/>
                        <param name="maxAngle" type="float" desc="Maximum angle (in radians)."/>
                    </function>
                    <function name="setOptimizeCoefficients">
                        <desc>Optimize the coefficients of the 3D shape after settling for a sample.
This will increase the run time of the shape fitting to some extent.
The used optimization method depends on the shape type.</desc>
                        <sample for="lua">PointCloud.ShapeFitter.setOptimizeCoefficients(handle, doOptimizations)</sample>
                        <param name="handle" type="handle" alias="PointCloud.ShapeFitter" desc="The handle"/>
                        <param name="doOptimize" type="bool" desc="Enables optimization, default is false."/>
                    </function>
                    <function name="fitPlane">
                        <desc>Fit a plane to a point cloud and get the indices of all inliers.</desc>
                        <sample for="lua">local plane, inliers = PointCloud.ShapeFitter.fitPlane(handle, cloud)</sample>
                        <param name="handle" type="handle" alias="PointCloud.ShapeFitter" desc="The handle"/>
                        <param name="cloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                        <return name="plane" type="object" multiplicity="?" alias="Shape3D" desc="The 3D plane or nil."/>
                        <return name="inliers" type="int" multiplicity="*" desc="The indices vector of all inliers or nil."/>
                    </function>
                    <function name="fitLine">
                        <desc>Fit a line to a point cloud and get the indices of all inliers.</desc>
                        <sample for="lua">local line, inliers = PointCloud.ShapeFitter.fitLine(handle, cloud)</sample>
                        <param name="handle" type="handle" alias="PointCloud.ShapeFitter" desc="The handle"/>
                        <param name="cloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                        <return name="line" type="object" multiplicity="?" alias="Shape3D" desc="The 3D line or nil."/>
                        <return name="inliers" type="int" multiplicity="*" desc="The indices vector of all inliers or nil."/>
                    </function>
                    <function name="fitSphere">
                        <desc>Fit a sphere to a point cloud and get the indices of all inliers.</desc>
                        <sample for="lua">local sphere, inliers = PointCloud.ShapeFitter.fitSphere(handle, cloud)</sample>
                        <param name="handle" type="handle" alias="PointCloud.ShapeFitter" desc="The handle"/>
                        <param name="cloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                        <return name="sphere" type="object" multiplicity="?" alias="Shape3D" desc="The 3D sphere or nil."/>
                        <return name="inliers" type="int" multiplicity="*" desc="The indices vector of all inliers or nil."/>
                    </function>
                    <function name="fitCylinder">
                        <desc>Fit a cylinder (defined by a central axis and a radius) to a point cloud and get the indices of all inliers.
If the point cloud normals are not passed to the function, they will be calculated inside with default settings.</desc>
                        <sample for="lua">local axis, radius, inliers = PointCloud.ShapeFitter.fitCylinder(handle, cloud, normals)</sample>
                        <param name="handle" type="handle" alias="PointCloud.ShapeFitter" desc="The handle"/>
                        <param name="cloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                        <param name="normals" type="const object" multiplicity="?" alias="Matrix" desc="The n x 4 matrix containing the normals and the local curvature"/>
                        <return name="axis" type="object" multiplicity="?" alias="Shape3D" desc="The central axis of the cylinder or nil."/>
                        <return name="radius" type="float" multiplicity="?" desc="The radius of the cylinder or nil."/>
                        <return name="inliers" type="int" multiplicity="*" desc="The indices vector of all inliers or nil."/>
                    </function>
                    <function name="fitCone">
                        <desc>Fit a right circular cone (defined by a central axis, an apex and an opening angle) to a point cloud and get the indices of all inliers.
If the point cloud normals are not passed to the function, they will be calculated inside with default settings.</desc>
                        <sample for="lua">local axis, apex, angle, inliers = PointCloud.ShapeFitter.fitCone(handle, cloud, normals)</sample>
                        <param name="handle" type="handle" alias="PointCloud.ShapeFitter" desc="The handle"/>
                        <param name="cloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                        <param name="normals" type="const object" multiplicity="?" alias="Matrix" desc="The n x 4 matrix containing the normals and the local curvature"/>
                        <return name="axis" type="object" multiplicity="?" alias="Shape3D" desc="The central axis of the cone or nil."/>
                        <return name="apex" type="object" multiplicity="?" alias="Point" desc="The apex (top point) of the cone or nil."/>
                        <return name="angle" type="float" multiplicity="?" desc="The opening angle (in radians) of the cone or nil."/>
                        <return name="inliers" type="int" multiplicity="*" desc="The indices vector of all inliers or nil."/>
                    </function>
                </serves>
            </crown>
            <crown name="Provider">
                <trait>released</trait>
                <desc>Provides access to various point cloud providers.</desc>
                <crown name="Directory">
                    <trait>released</trait>
                    <serves>
                        <event name="OnNewPointCloud">
                            <desc>This event is thrown for every PointCloud.</desc>
                            <param name="handle" type="handle" alias="PointCloud.Provider.Directory" desc="The instance handle to use"/>
                            <param name="pointCloud" type="object" alias="PointCloud" desc="The loaded point cloud."/>
                            <param name="sensorData" type="object" alias="SensorData" desc="Supplementary data which belongs to the point cloud"/>
                        </event>
                        <function name="create">
                            <desc>Creates an instance of the PointCloud provider, which provides PointClouds asynchronously from file-system.</desc>
                            <sample for="lua">handle = PointCloud.Provider.Directory.create()</sample>
                            <return name="handle" type="handle" alias="PointCloud.Provider.Directory" desc="PointCloud provider exists as long as this handle exists."/>
                        </function>
                        <function name="setPath">
                            <desc>Sets the directory and file extension(s) for the PointCloud provider from which it reads PointClouds.</desc>
                            <sample for="lua">PointCloud.Provider.Directory.setPath(handle, ImageInputPath)</sample>
                            <param name="handle" type="handle" alias="PointCloud.Provider.Directory" desc="Handle returned by create"/>
                            <param name="path" type="string" desc="Path to the file-system"/>
                            <param name="fileextensions" type="string" multiplicity="?" desc="Supported file extensions (comma separated)."/>
                            <param name="recursive" type="bool" multiplicity="?" desc="An optional flag whether to run through subdriectories also."/>
                        </function>
                        <function name="setCycleTime">
                            <desc>Sets the pause between taking PointClouds in milli seconds.</desc>
                            <sample for="lua">PointCloud.Provider.Directory.setCycleTime(handle, 500)</sample>
                            <param name="handle" type="handle" alias="PointCloud.Provider.Directory" desc="Handle returned by create"/>
                            <param name="periodMs" type="int" desc="Period in [ms] between PointClouds."/>
                        </function>
                        <function name="setAutoDeleteActive">
                            <desc>Sets auto-delete active. This means the point cloud is deleted from the directory after load.</desc>
                            <sample for="lua">PointCloud.Provider.Directory.setAutoDeleteActive(handle,true)</sample>
                            <param name="handle" type="handle" alias="PointCloud.Provider.Directory" desc="Handle returned by create"/>
                            <param name="state" type="bool" desc="If true the PointCloud file will be deleted after being loaded."/>
                        </function>
                        <function name="setCyclicModeActive">
                            <desc>Sets cyclic-mode active.</desc>
                            <sample for="lua">PointCloud.Provider.setCyclicModeActive(handle,true)</sample>
                            <param name="handle" type="handle" alias="PointCloud.Provider.Directory" desc="Handle returned by create"/>
                            <param name="state" type="bool" desc="If true driver stops taking PointClouds if end of directory is reached."/>
                        </function>
                        <function name="setImagePoolSizeMB">
                            <desc>Limits the number of mega bytes which can be acquired by capturing images and used at the same time. Default is 20.</desc>
                            <sample for="lua">PointCloud.Provider.Directory.setImagePoolSizeMB(cam, 20)</sample>
                            <param name="handle" type="handle" alias="PointCloud.Provider.Directory" desc="Instance handle of the provider."/>
                            <param name="size" type="int" desc="Size of the internal image pool in mega byte."/>
                        </function>
                        <function name="start">
                            <desc>Starts taking PointClouds.</desc>
                            <sample for="lua">local success = PointCloud.Provider.Directory.start(handle)</sample>
                            <param name="handle" type="handle" alias="PointCloud.Provider.Directory" desc="Handle returned by create"/>
                            <param name="burst" type="int" multiplicity="?" desc="Leave empty or '0' for continuous acquisition. &gt;0:=enable burst-mode with provided number of PointClouds."/>
                            <return name="success" type="bool" desc="Returns true if function call was successful, otherwise false"/>
                        </function>
                        <function name="stop">
                            <desc>Stops taking PointClouds.</desc>
                            <sample for="lua">local stopped = PointCloud.Provider.Directory.stop(handle)</sample>
                            <param name="handle" type="handle" alias="PointCloud.Provider.Directory" desc="Handle returned by create"/>
                            <return name="success" type="bool" desc="Returns true if function call was successful, otherwise false"/>
                        </function>
                        <function name="register">
                            <desc>This function is used to register for any event of the PointCloud provider. The event name is specified as parameter.</desc>
                            <sample for="lua">PointCloud.Provider.Directory.register(handle, "OnNewPointCloud", "handleNewPointCloud")</sample>
                            <param name="handle" type="handle" alias="PointCloud.Provider.Directory" desc="Handle returned by create"/>
                            <param name="eventname" type="string" desc="The event to register to"/>
                            <param name="callback" type="string" alias="function" desc="function name to call on the event"/>
                            <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                        </function>
                        <function name="deregister">
                            <desc>This function is used to deregister from any registered event of the handle.</desc>
                            <param name="handle" type="handle" alias="PointCloud.Provider.Directory" desc="The instance handle to use"/>
                            <param name="eventname" type="string" desc="The event to deregister from"/>
                            <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                            <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                        </function>
                    </serves>
                </crown>
            </crown>
        </crown>
        <crown name="Mesh">
            <trait>released</trait>
            <desc>Object for a 3D surface represented by a triangle mesh. The mesh consists of a vector of vertices (3D points) and vector of triplets defining the 3 vertex indices of each triangle. For each vertex, there can also be a 3D normal and an intensity or RGBA color component.
There are two types of triangle representations indexed triangles or separated triangles. In the case of indexed triangles a vertex can be used by several triangles, and in the case of separated triangles a vertex can only be used by a single triangle. In some cases a combination of both representations is also possible. Unless known it might be unclear what representation the mesh has. The representation has consequences in how algorithms perform; an example is the connected components algorithm, with separated triangles none of the triangles share vertex indices so only single connections (1 triangle) can be found. In this case a search radius must be specified to search for nearby vertices.</desc>
            <serves>
                <function name="create">
                    <desc>Creates a new empty mesh object</desc>
                    <sample for="lua">local newMesh = Mesh.create()</sample>
                    <return name="newMesh" type="object" alias="Mesh" desc="The newly created mesh"/>
                </function>
                <function name="load">
                    <links>Object.load, File</links>
                    <desc>Loads a mesh from the specified file path.
The format is defined by the file extension:
.ply:     Polygon File Format
.json:    JSON
.msgpack: MessagePack</desc>
                    <sample for="lua">mesh = Mesh.load("private/mesh.ply")</sample>
                    <param name="filePath" type="string" desc="The path and name of the file to load the mesh from."/>
                    <return name="mesh" type="object" alias="Mesh" desc="The mesh object."/>
                </function>
                <function name="save">
                    <links>Object.save, File</links>
                    <desc>Saves a mesh to the specified file path.
Overwrites the file if it already exists.
The format is defined by the file extension:
.ply:     Polygon File Format (Optional useBinary parameter is supported).
.json:    JSON (Optional useBinary parameter not supported).
.msgpack: MessagePack (Optional useBinary parameter not supported).</desc>
                    <sample for="lua">local success = Mesh.save(mesh, "private/mesh.ply", useBinary)</sample>
                    <param name="mesh" type="const object" alias="Mesh" desc="The Mesh object which is saved."/>
                    <param name="filepath" type="string" desc="The path and name of the file to save the mesh to."/>
                    <param name="useBinary" type="bool" multiplicity="?" desc="Optional parameter that can only be used when saving to .ply format. If true write the ply data (except the header) in binary instead of ASCII. Default is true."/>
                    <return name="success" type="bool" desc="Returns true if the mesh has been successfully saved."/>
                </function>
                <function name="clone">
                    <desc>Returns a duplicated instance of the input mesh. This is a full copy and might be very slow dependent on the mesh size.</desc>
                    <sample for="lua">local clone = Mesh.clone(inputMesh)</sample>
                    <param name="inputMesh" type="const object" alias="Mesh" desc="The mesh to clone."/>
                    <return name="clone" type="object" alias="Mesh" desc="The new cloned mesh object."/>
                </function>
                <function name="getTriangleCount">
                    <links>Mesh.getVertexCount</links>
                    <desc>Returns the number of triangles in the mesh.</desc>
                    <sample for="lua">local triangleCount = Mesh.getTriangleCount(mesh)</sample>
                    <param name="mesh" type="const object" alias="Mesh" desc="The mesh."/>
                    <return name="triangleCount" type="int" desc="The mesh number of triangles."/>
                </function>
                <function name="getVertexCount">
                    <links>Mesh.getTriangleCount</links>
                    <desc>Returns the number of vertices in the mesh.</desc>
                    <sample for="lua">local vertexCount = Mesh.getVertexCount(mesh)</sample>
                    <param name="mesh" type="const object" alias="Mesh" desc="The mesh."/>
                    <return name="vertexCount" type="int" desc="The mesh number of vertices."/>
                </function>
                <function name="hasNormals">
                    <desc>Check if the mesh contains normals.</desc>
                    <sample for="lua">local foundNormals = Mesh.hasNormals(mesh)</sample>
                    <param name="mesh" type="const object" alias="Mesh" desc="The mesh."/>
                    <return name="foundNormals" type="bool" desc="True if the mesh contains normals."/>
                </function>
                <function name="hasColor">
                    <desc>Check if the mesh contains colors.</desc>
                    <sample for="lua">local foundColor = Mesh.hasColor(mesh)</sample>
                    <param name="mesh" type="const object" alias="Mesh" desc="The mesh."/>
                    <return name="foundColor" type="bool" desc="True if the mesh contains colors."/>
                </function>
                <function name="hasIntensity">
                    <desc>Check if the mesh contains intensities.</desc>
                    <sample for="lua">local foundIntensity = Mesh.hasIntensity(mesh)</sample>
                    <param name="mesh" type="const object" alias="Mesh" desc="The mesh."/>
                    <return name="foundIntensity" type="bool" desc="True if the mesh contains intensities."/>
                </function>
                <function name="hasTextureCoordinates">
                    <desc>Check if the mesh contains texture coordinates.</desc>
                    <sample for="lua">local foundTextureCoordinates = Mesh.hasTextureCoordinates(mesh)</sample>
                    <param name="mesh" type="const object" alias="Mesh" desc="The mesh."/>
                    <return name="foundTextureCoordinates" type="bool" desc="True if the mesh contains texture coordinates."/>
                </function>
                <function name="toString">
                    <desc>Gets a user-friendly string description of the mesh, containing important properties.</desc>
                    <sample for="lua">str = Mesh.toString(mesh)</sample>
                    <param name="mesh" type="const object" alias="Mesh" desc="The mesh to describe."/>
                    <return name="str" type="string" desc="User-friendly description of the mesh."/>
                </function>
                <function name="createFromPolynomial">
                    <trait>released</trait>
                    <desc>Constructs a mesh from a polynomial description. The polynomial consists of 6 coefficients that can either be manually specified or retrieved from the Image.SurfaceFitter.

The polynomial is a 2nd order polynomial on the following form
z = Ac + Ax*x + Ay*y + Axx*x*x + Axy*x*y + Ayy*y*y
where Ac, Ax, Ay, Axx, Axy, Ayy are the coefficients.</desc>
                    <sample for="lua">local mesh = Mesh.createFromPolynomial(polynomial, bounds)</sample>
                    <param name="polynomial" type="float" multiplicity="+" desc="A polynomial on the described form."/>
                    <param name="bounds" type="const object" alias="Shape" desc="A 2D shape of type rectangle that defines the constructed mesh bounds."/>
                    <param name="samples" type="int" multiplicity="[?*]" desc="A vector with one or two values that selects the number of samples within the bounds rectangle. If one value is provided it is used for both dimensions. Minimum is 2 which produces 2x2 mesh vertices. Default is 10."/>
                    <param name="calculateNormals" type="bool" multiplicity="?" desc="Select if normals should be calculated. Default is false."/>
                    <param name="colorize" type="bool" multiplicity="?" desc="Select if mesh colors should be generated based on the sample position. Default is false."/>
                    <return name="mesh" type="object" multiplicity="?" alias="Mesh" desc="The constructed mesh. Nil on failure."/>
                </function>
                <function name="createFromPointCloud">
                    <desc>Surface reconstruction algorithm that uses a PointCloud object as input and outputs a Mesh object, based on the work:
Three-dimensional alpha shapes.
Herbert Edelsbrunner and Ernst P. Mucke
ACM Transactions on Graphics, vol. 13. No.1, January 1994, pages 43-72

Note that the algorithm is sensitive to outliers. Please, remove all of these before making the reconstruction.</desc>
                    <sample for="lua">local mesh = Mesh.createFromPointCloud(cloud, alpha, estimateColors)</sample>
                    <param name="cloud" type="const object" alias="PointCloud" desc="The input point cloud."/>
                    <param name="alpha" type="float" multiplicity="?" desc="The alpha value of the reconstruction, default is 8."/>
                    <param name="estimateColors" type="bool" multiplicity="?" desc="If true colors/intensities are estimated using the original point cloud. The nearest color/intensity of the point cloud point to the vertex is used."/>
                    <return name="mesh" type="object" multiplicity="?" alias="Mesh" desc="On success a mesh is returned, otherwise nil."/>
                </function>
                <function name="transform">
                    <desc>Transforms a mesh. A 3D transformation is used.</desc>
                    <sample for="lua">local transformedMesh = Mesh.transform(mesh, transform)</sample>
                    <param name="mesh" type="const object" alias="Mesh" desc="The input mesh."/>
                    <param name="transform" type="const object" alias="Transform" desc="3D transformation to apply."/>
                    <return name="transformedMesh" type="object" multiplicity="?" alias="Mesh" desc="Transformed mesh or nil on error"/>
                </function>
                <function name="transformInplace">
                    <desc>In-place version of the Mesh.transform function that modifies the input mesh. See base function for full documentation.</desc>
                    <sample for="lua">local transformedMesh = Mesh.transformInplace(mesh, transform)</sample>
                    <param name="mesh" type="object" alias="Mesh" desc="The input mesh. This mesh is overwritten with the transformed mesh."/>
                    <param name="transform" type="const object" alias="Transform" desc="Transform to apply."/>
                    <return name="transformedMesh" type="object" multiplicity="?" alias="Mesh" desc="Reference to the input mesh or nil on error."/>
                </function>
                <function name="findConnected">
                    <desc>Find the connected components of an input mesh, i.e., splits a Mesh object into a list of separated meshes. Only keeps meshes with a size (counted in number of vertices) within the range [minVerticesCount, maxVerticesCount]. If a search radius is not specified the connectivity is only tested using the triangle vertices indexes i.e. two triangles are connected if they share at least one vertex index. If a search radius is specified the neighbor triangles that have vertices within the search sphere will also be connected. The method is slower if a search radius is specified but it is useful in cases were the mesh contains separated triangles with approximately the same vertex positions.</desc>
                    <sample for="lua">result = Mesh.findConnected(mesh, 10)</sample>
                    <param name="mesh" type="const object" alias="Mesh" desc="Input mesh."/>
                    <param name="minVerticesCount" type="int" multiplicity="?" desc="Minimum output number of connected vertices (default is 0)."/>
                    <param name="maxVerticesCount" type="int" multiplicity="?" desc="Maximum output number of connected vertices (default is 2147483647)."/>
                    <param name="maxComponentsCount" type="int" multiplicity="?" desc="Maximum number of output components (meshes) to return (default is 10). Used to limit the memory requirements of the algorithm. If set to zero all the possible components will be returned."/>
                    <param name="searchRadius" type="float" multiplicity="?" desc="The search radius."/>
                    <return name="result" type="object" multiplicity="*" alias="Mesh" desc="List of connected components represented as meshes with connected vertices, sorted by decreasing size."/>
                </function>
                <function name="projectOntoMesh">
                    <desc>Projects a list of 3D points to their closest position on a mesh surface.

There are two approaches to project the points onto a mesh. The approximation approach (default) and the brute force approach. The first method is faster, but may produce incorrect results, especially if large and small triangles are mixed.

The approximation approach uses the triangle vertices to first obtain the closest vertex to a point and then use the triangles connected to that vertex to find the closest projection in that subset.
The brute force method extensively searches all triangles for the closest projection.

If speed is a factor to consider it's recommended to use the approximation approach and if necessary precompute a new mesh were all triangles have approximately the same size.</desc>
                    <sample for="lua">pointsOnMesh = Mesh.projectOntoMesh(mesh, inputPoints)</sample>
                    <param name="mesh" type="const object" alias="Mesh" desc="Input mesh."/>
                    <param name="inputPoints" type="const object" multiplicity="+" alias="Point" desc="The 3D input points."/>
                    <param name="approximation" type="bool" multiplicity="?" desc="Set to false to use brute force search. Default is true."/>
                    <return name="pointsOnMesh" type="object" multiplicity="+" alias="Point" desc="The 3D points on the mesh."/>
                </function>
                <function name="toPointCloud">
                    <desc>Creates a new point cloud object using the mesh vertices as the points of the new point cloud.</desc>
                    <sample for="lua">local pointCloud = Mesh.toPointCloud(mesh)</sample>
                    <param name="mesh" type="const object" alias="Mesh" desc="The input mesh."/>
                    <return name="pointCloud" type="object" multiplicity="?" alias="PointCloud" desc="The new point cloud. If the mesh is empty (zero vertices) then an empty pointCloud will be generated."/>
                </function>
                <function name="toPolygons">
                    <desc>Creates a vector of Shape3D polygons using the mesh triangles.</desc>
                    <sample for="lua">local polygons = Mesh.toPolygons(mesh)</sample>
                    <param name="mesh" type="const object" alias="Mesh" desc="The input mesh."/>
                    <return name="polygons" type="object" multiplicity="+" alias="Shape3D" desc="The new vector of polygons (the polygons are triangles). If the mesh is empty (zero triangles) then an empty vector will be generated."/>
                </function>
                <function name="createSphere">
                    <desc>Creates a mesh object with a spherical shape. It uses a Shape3D sphere to obtain the parameters needed for tessellation.

The tessellation makes use of an icosahedron (12 vertices, 20 triangles). If the subdivision level is equal to zero no subdivision of the icosahedron triangles are performed, if it is larger subdivisions are performed.

The subdivision works by splitting each triangle edge. For level 1 each original triangle edge is divided into 2 segments with 3 vertices. For level 2 each edge will get 3 segments and 4 vertices. This means that subdivision level 1 will generate 4 triangles from each original triangle and subdivision 2 will generate 9 triangles. The vertices are not duplicated, but are shared between triangles.

The tessellation method is different to the most common subdivision scheme of an icosahedron. The traditional method subdivides each icosahedron triangle into 4 triangles iteratively. The procedure is repeated until the subdivision level is reached. This means that the most typical method would generate 16 triangles for subdivision level 2. Compare this to 9 for the implemented method. The traditional method has two main disadvantages: first, triangle vertices will be repeated and second, with only a few subdivisions spheres with a great amount of triangles are generated. Our method will not repeat vertices and a finer control of the subdivisions is possible.

If required, vertex normals can be calculated (normalized, with values in the range [0.0; 1.0]).</desc>
                    <sample for="lua">local mesh = Mesh.createSphere(sphereShape, calculateNormals, level)</sample>
                    <param name="sphereShape" type="const object" alias="Shape3D" desc="The input sphere shape."/>
                    <param name="calculateNormals" type="bool" multiplicity="?" desc="If true, vertex normals will be calculated. By default the normals are not calculated."/>
                    <param name="level" type="int" multiplicity="?" desc="The subdivision level. If not specified a subdivision level of 5 will be used. Maximum is 50."/>
                    <return name="mesh" type="object" alias="Mesh" desc="The newly created mesh"/>
                </function>
                <function name="createBox">
                    <desc>Creates a mesh object with a box shape. It uses a Shape3D box to obtain the parameters needed for the tessellation.

To support separate normals for corner points a total of 24 vertices are generated that form a total of 12 triangles.

If required, vertex normals can be calculated (normalized, with values in the range [0.0; 1.0]) and these will be perpendicular to the triangle planes.</desc>
                    <sample for="lua">local mesh = Mesh.createBox(boxShape, calculateNormals)</sample>
                    <param name="boxShape" type="const object" alias="Shape3D" desc="The input box shape."/>
                    <param name="calculateNormals" type="bool" multiplicity="?" desc="If true, vertex normals will be calculated. By default the normals are not calculated."/>
                    <return name="mesh" type="object" alias="Mesh" desc="The newly created mesh"/>
                </function>
                <function name="createCircle">
                    <desc>Creates a mesh object with a circular shape. It uses a Shape3D circle to obtain the parameters needed for the tessellation.

The circle boundary is sampled at equal intervals and triangles are formed using two adjacent boundary points and the circle center. The number of generated triangles is tuned by triangleCount.

If required, vertex normals can be calculated (normalized, with values in the range [0.0; 1.0]).</desc>
                    <sample for="lua">local mesh = Mesh.createCircle(circle3DShape, calculateNormals, triangleCount)</sample>
                    <param name="circle3DShape" type="const object" alias="Shape3D" desc="The input circle shape."/>
                    <param name="calculateNormals" type="bool" multiplicity="?" desc="If true, vertex normals will be calculated. By default the normals are not calculated."/>
                    <param name="triangleCount" type="int" multiplicity="?" desc="The number of output triangles. Min 3, Max 10000. Default is 100."/>
                    <return name="mesh" type="object" alias="Mesh" desc="The newly created mesh"/>
                </function>
                <function name="createRectangle">
                    <desc>Creates a mesh object with a rectangular shape. It uses a Shape3D rectangle to obtain the rectangle parameters needed for the tessellation (2 triangles).

If required, vertex normals can be calculated (normalized, with values in the range [0.0; 1.0]). These normals will be orthogonal to the rectangle plane.</desc>
                    <sample for="lua">local mesh = Mesh.createRectangle(rectangle3DShape, calculateNormals)</sample>
                    <param name="rectangle3DShape" type="const object" alias="Shape3D" desc="The input rectangle shape."/>
                    <param name="calculateNormals" type="bool" multiplicity="?" desc="If true, vertex normals will be calculated. By default the normals are not calculated."/>
                    <return name="mesh" type="object" alias="Mesh" desc="The newly created mesh"/>
                </function>
                <function name="createCone">
                    <desc>Creates a mesh object with a conical shape. It uses a Shape3D cone to obtain the cone parameters needed for the tessellation.

According to the level, the cone base boundary is sampled at equal intervals and triangles formed using two adjacent boundary points and the base center. For the lateral surface a similar procedure is performed but instead of the circle center the cone apex is used. A level of zero produces 6 triangles, the maximum allowed value is 10000. The total number of triangles can be calculated according to (levels + 3)*2.

If required, vertex normals can be calculated (normalized, with values in the range [0.0; 1.0]).</desc>
                    <sample for="lua">local mesh = Mesh.createCone(coneShape, calculateNormals, level)</sample>
                    <param name="coneShape" type="const object" alias="Shape3D" desc="The input cone shape."/>
                    <param name="calculateNormals" type="bool" multiplicity="?" desc="If true, vertex normals will be calculated. By default the normals are not calculated."/>
                    <param name="level" type="int" multiplicity="?" desc="The complexity level. Min 0, Max 10000. Default is 100."/>
                    <return name="mesh" type="object" alias="Mesh" desc="The newly created mesh"/>
                </function>
                <function name="createCylinder">
                    <desc>Creates a mesh object with a cylindrical shape. It uses a Shape3D cylinder to obtain the cylinder parameters needed for the tessellation.

According to the level, the cylinder bases boundaries are sampled at equal intervals and triangles formed using two adjacent boundary points and the base center. For the lateral surface the vertices of both base boundaries are used. A level of zero produces 12 triangles, the maximum allowed value is 10000. The total number of triangles can be calculated according to (levels + 3)*4.

If required, vertex normals can be calculated (normalized, with values in the range [0.0; 1.0]).</desc>
                    <sample for="lua">local mesh = Mesh.createCylinder(cylinderShape, calculateNormals, level)</sample>
                    <param name="cylinderShape" type="const object" alias="Shape3D" desc="The input cylinder shape."/>
                    <param name="calculateNormals" type="bool" multiplicity="?" desc="If true, vertex normals will be calculated. By default the normals are not calculated."/>
                    <param name="level" type="int" multiplicity="?" desc="The complexity level. Min 0, Max 10000. Default is 100."/>
                    <return name="mesh" type="object" alias="Mesh" desc="The newly created mesh"/>
                </function>
                <function name="createEllipse">
                    <desc>Creates a mesh object with a elliptical (planar) shape. It uses a Shape3D ellipse to obtain the parameters needed for the tessellation.

The ellipse boundary is sampled at equal intervals and triangles are formed using two adjacent boundary points and the ellipse center. The number of generated triangles is tuned by triangleCount.

If required, vertex normals can be calculated (normalized, with values in the range [0.0; 1.0]).</desc>
                    <sample for="lua">local mesh = Mesh.createEllipse(ellipse3DShape, calculateNormals, triangleCount)</sample>
                    <param name="ellipse3DShape" type="const object" alias="Shape3D" desc="The input ellipse shape."/>
                    <param name="calculateNormals" type="bool" multiplicity="?" desc="If true, vertex normals will be calculated. By default the normals are not calculated."/>
                    <param name="triangleCount" type="int" multiplicity="?" desc="The number of output triangles. Min 3, Max 10000. Default is 100."/>
                    <return name="mesh" type="object" alias="Mesh" desc="The newly created mesh"/>
                </function>
                <function name="createEllipticCylinder">
                    <desc>Creates a mesh object with a elliptic cylindrical shape. It uses a Shape3D elliptic cylinder to obtain the parameters needed for the tessellation.

According to the level, the elliptic cylinder bases boundaries are sampled at equal intervals and triangles formed using two adjacent boundary points and the base center. For the lateral surface the vertices of both base boundaries are used. A level of zero produces 12 triangles, the maximum allowed value is 10000. The total number of triangles can be calculated according to (levels + 3)*4.

If required, vertex normals can be calculated (normalized, with values in the range [0.0; 1.0]).</desc>
                    <sample for="lua">local mesh = Mesh.createEllipticCylinder(ellipticCylinderShape, calculateNormals, level)</sample>
                    <param name="ellipticCylinderShape" type="const object" alias="Shape3D" desc="The input elliptic cylinder shape."/>
                    <param name="calculateNormals" type="bool" multiplicity="?" desc="If true, vertex normals will be calculated. By default the normals are not calculated."/>
                    <param name="level" type="int" multiplicity="?" desc="The subdivision level. If not specified a subdivision level of 100 will be used."/>
                    <return name="mesh" type="object" alias="Mesh" desc="The newly created mesh"/>
                </function>
            </serves>
            <uses/>
        </crown>
        <crown name="SensorData">
            <trait>released</trait>
            <desc>Provides access to additional sensor data information like origin and time stamp that is sent along with the actual measurement data.</desc>
            <serves>
                <function name="getName">
                    <desc>Returns the component name of the corresponding data object (e.g. DepthImage or GreyImage).</desc>
                    <sample for="lua">local name = SensorData.getName(theSensorData)</sample>
                    <param name="sensordata" type="const object" alias="SensorData" desc="Handle to the instance."/>
                    <return name="name" type="string" desc="The component name of the corresponding data object."/>
                </function>
                <function name="getEncoderData">
                    <trait>hidden</trait>
                    <desc>Get the EncoderData object.</desc>
                    <sample for="lua">local encoderData = SensorData.getEncoderData(theSensorData)</sample>
                    <param name="sensordata" type="const object" alias="SensorData" desc="Handle to the instance."/>
                    <return name="encoderdata" type="object" alias="EncoderData" desc="The EncoderData object."/>
                </function>
                <function name="getTimestamp">
                    <desc>Returns the time stamp (in microseconds).</desc>
                    <sample for="lua">local timeStamp = SensorData.getTimestamp(theSensorData)</sample>
                    <param name="sensordata" type="const object" alias="SensorData" desc="Handle to the instance."/>
                    <return name="timestamp" type="int" desc="The time stamp value (in microseconds)."/>
                </function>
                <function name="getFrameNumber">
                    <desc>Returns the frame number (incremented by one for each measurement).</desc>
                    <sample for="lua">local frameNumber = SensorData.getFrameNumber(theSensorData)</sample>
                    <param name="sensordata" type="const object" alias="SensorData" desc="Handle to the instance."/>
                    <return name="frameno" type="int" desc="The frame number."/>
                </function>
                <function name="getOrigin">
                    <desc>Returns the origin (e.g. device name).</desc>
                    <sample for="lua">local origin = SensorData.getOrigin(theSensorData)</sample>
                    <param name="sensordata" type="const object" alias="SensorData" desc="Handle to the instance."/>
                    <return name="origin" type="string" desc="Returns the data origin."/>
                </function>
                <function name="getID">
                    <desc>Returns an application specific ID (e.g. object ID).</desc>
                    <sample for="lua">local id = SensorData.getID(theSensorData)</sample>
                    <param name="sensordata" type="const object" alias="SensorData" desc="Handle to the instance."/>
                    <return name="id" type="int" desc="Returns the ID."/>
                </function>
                <function name="getMetaData">
                    <desc>Get the MetaData which is associated with the SensorData object. The MetaData object is optional and can contain dynamically configurable additional SensorData. The 'getMetaData' function returns an object of the type Container. The content can be accessed via the Container API.</desc>
                    <sample for="lua">local metaData = SensorData.getMetaData(theSensorData)</sample>
                    <param name="sensordata" type="const object" alias="SensorData" desc="Input data to get the MetaData from."/>
                    <return name="metadata" type="object" multiplicity="?" alias="Container" desc="Optional MetaData object."/>
                </function>
                <function name="toString">
                    <desc>Get a string representation of the SensorData.</desc>
                    <sample for="lua">print("SensorData: " .. SensorData.toString(theSensorData))</sample>
                    <param name="sensordata" type="const object" alias="SensorData" desc="Input data to get the string representation."/>
                    <return name="str" type="string" desc="String representation of the SensorData"/>
                </function>
            </serves>
        </crown>
        <crown name="EncoderData">
            <trait>released</trait>
            <desc>Provides access to encoder data information like increment, local increment, time stamp and speed.
Local increment could contain e.g. the value of a high resolution encoder which is connected directly to a sensor.</desc>
            <serves>
                <function name="create">
                    <desc>Creates a new instance of the EncoderData object.</desc>
                    <sample for="lua">local handle = EncoderData.create()</sample>
                    <return name="handle" type="handle" alias="EncoderData" desc="Handle to the instance."/>
                </function>
                <function name="getLocalIncrement">
                    <desc>Get the local encoder position value from the EncoderData object. This could be e.g. the value of a high resolution encoder which is connected directly to a sensor.</desc>
                    <sample for="lua">local localincrement = EncoderData.getLocalIncrement(theEncoderData)</sample>
                    <param name="encoderdata" type="const object" alias="EncoderData" desc="Input data to get the encoder position from."/>
                    <return name="localincrement" type="int" desc="Returns the local encoder position value."/>
                </function>
                <function name="setLocalIncrement">
                    <desc>Sets the local encoder position value of the EncoderData object. This could be e.g. the value of a high resolution encoder which is connected directly to a sensor.</desc>
                    <sample for="lua">EncoderData.setLocalIncrement(theEncoderData, localincrement)</sample>
                    <param name="encoderdata" type="object" alias="EncoderData" desc="Input data to get the encoder position from."/>
                    <param name="localincrement" type="int" desc="Local encoder position value."/>
                </function>
                <function name="getIncrement">
                    <desc>Get the system increment value from the EncoderData object.</desc>
                    <sample for="lua">local increment = EncoderData.getIncrement(theEncoderData)</sample>
                    <param name="encoderdata" type="const object" alias="EncoderData" desc="Input data to get the system increment from."/>
                    <return name="increment" type="int" desc="Returns the system increment value."/>
                </function>
                <function name="setIncrement">
                    <desc>Sets the system increment value of the EncoderData object.</desc>
                    <sample for="lua">EncoderData.setIncrement(theEncoderData, increment)</sample>
                    <param name="encoderdata" type="object" alias="EncoderData" desc="Input data to get the system increment from."/>
                    <param name="increment" type="int" desc="System increment value."/>
                </function>
                <function name="getTimestamp">
                    <desc>Returns the time stamp in [us] from the EncoderData object.</desc>
                    <sample for="lua">local timestamp = EncoderData.getTimestamp(theEncoderData)</sample>
                    <param name="encoderdata" type="const object" alias="EncoderData" desc="Input data to get the time stamp from."/>
                    <return name="timestamp" type="int" desc="Returns the time stamp value (in microseconds)."/>
                </function>
                <function name="setTimestamp">
                    <desc>Sets the time stamp in [us] of the EncoderData object.</desc>
                    <sample for="lua">EncoderData.setTimestamp(theEncoderData, timestamp)</sample>
                    <param name="encoderdata" type="object" alias="EncoderData" desc="Input data to get the time stamp from."/>
                    <param name="timestamp" type="int" desc="Time stamp value (in microseconds)."/>
                </function>
                <function name="getSpeed">
                    <desc>Returns the speed in [m/s] from the EncoderData object.</desc>
                    <sample for="lua">local speed = EncoderData.getSpeed(theEncoderData)</sample>
                    <param name="encoderdata" type="const object" alias="EncoderData" desc="Input data to get the speed value from."/>
                    <return name="speed" type="float" desc="Returns the speed value in [m/s]."/>
                </function>
                <function name="setSpeed">
                    <desc>Sets the speed in [m/s] of the EncoderData object.</desc>
                    <sample for="lua">EncoderData.setSpeed(theEncoderData, speed)</sample>
                    <param name="encoderdata" type="object" alias="EncoderData" desc="Input data to get the speed value from."/>
                    <param name="speed" type="float" desc="Speed value in [m/s]."/>
                </function>
                <function name="toString">
                    <desc>Get a string representation of the EncoderData.</desc>
                    <sample for="lua">print("EncoderData: " .. EncoderData.toString(theEncoderData))</sample>
                    <param name="encoderdata" type="const object" alias="EncoderData" desc="Input data to get the origin from."/>
                    <return name="str" type="string" desc="String representation of the EncoderData"/>
                </function>
            </serves>
        </crown>
        <crown name="Transform">
            <trait>released</trait>
            <desc>Object representing a linear transform in 2D or 3D space.</desc>
            <enum name="TransformType">
                <item name="Identity" desc="Identity transform">IDENTITY</item>
                <item name="Translation" desc="A translation transform shifts an object along the x, y and z axes">TRANSLATION</item>
                <item name="Rigid" desc="A rigid transform rotates and translates an object">RIGID</item>
                <item name="Similarity" desc="A similarity transform scales, rotates and translates an object">SIMILARITY</item>
                <item name="Affine" desc="An affine transform shears, scales, rotates and translates and object">AFFINE</item>
                <item name="Homography" desc="A homography transform, also known as a projective transform, is the most general linear transform. It includes affine, similarity and rigid transforms as special cases.">HOMOGRAPHY</item>
            </enum>
            <enum name="RotationOrder" trait="released">
                <item name="XYZ" desc="Rotation first around the world x-axis, then the world y-axis and last the world z-axis.">XYZ</item>
                <item name="ZYX" desc="Rotation first around the world z-axis, then the world y-axis and last the world x-axis.">ZYX</item>
                <item name="ZYZ" desc="Rotation first around the world z-axis, then the world y-axis and last the world z-axis.">ZYZ</item>
            </enum>
            <serves>
                <function name="clone">
                    <desc>Duplicates the transform.</desc>
                    <sample for="lua">local clonedTransform = Transform.clone(transform)</sample>
                    <param name="transform" type="const object" alias="Transform" desc="The instance to use"/>
                    <return name="clone" type="object" alias="Transform" desc="The duplicated transform"/>
                </function>
                <function name="createIdentity2D">
                    <links>Transform.createIdentity3D</links>
                    <desc>Creates a new 2D transform with no rotation, scale or translation.</desc>
                    <sample for="lua">local transform = Transform.createIdentity2D()</sample>
                    <return name="transform" type="object" alias="Transform" desc="The new 2D identity transform"/>
                </function>
                <function name="createIdentity3D">
                    <links>Transform.createIdentity2D</links>
                    <desc>Creates a new 3D transform with no rotation, scale or translation.</desc>
                    <sample for="lua">local transform = Transform.createIdentity3D()</sample>
                    <return name="transform" type="object" alias="Transform" desc="The new 3D identity transform"/>
                </function>
                <function name="createTranslation2D">
                    <links>Transform.translate2D, Transform.createRigid2D, Transform.createTranslation3D</links>
                    <desc>Creates a 2D translational transform.</desc>
                    <sample for="lua">local transform = Transform.createTranslation2D(xTrans, yTrans)</sample>
                    <param name="xTrans" type="float" desc="Translation in the x direction"/>
                    <param name="yTrans" type="float" desc="Translation in the y direction"/>
                    <return name="transform" type="object" alias="Transform" desc="The new 2D translational transform"/>
                </function>
                <function name="createTranslation3D">
                    <links>Transform.translate3D, Transform.createRigid3D, Transform.createTranslation2D</links>
                    <desc>Creates a 3D translational transform.</desc>
                    <sample for="lua">local transform = Transform.createTranslation3D(xTrans, yTrans, zTrans)</sample>
                    <param name="xTrans" type="float" desc="Translation in the x direction"/>
                    <param name="yTrans" type="float" desc="Translation in the y direction"/>
                    <param name="zTrans" type="float" desc="Translation in the z direction"/>
                    <return name="transform" type="object" alias="Transform" desc="The new 3D translational transform"/>
                </function>
                <function name="createScaling2D">
                    <links>Transform.scale2D, Transform.createSimilarity2D</links>
                    <desc>Creates a 2D scaling transform which scales in the x- and y-dimensions.</desc>
                    <sample for="lua">local transform = Transform.createScaling2D(xScale, yScale, origin)</sample>
                    <param name="xScale" type="float" desc="Scaling in the x direction"/>
                    <param name="yScale" type="float" multiplicity="?" desc="Optional scaling in the y direction. If omitted the same scaling will be used in both x and y direction."/>
                    <param name="origin" type="const object" multiplicity="?" alias="Point" desc="Optional origin of scaling if other than (0,0)"/>
                    <return name="transform" type="object" alias="Transform" desc="The new 2D scaling transform which is of type SIMILARITY"/>
                </function>
                <function name="createScaling3D">
                    <links>Transform.scale3D, Transform.createSimilarity3D</links>
                    <desc>Creates a 3D scaling transform which scales in the x-, y-, and z-dimensions.</desc>
                    <sample for="lua">local transform = Transform.createScaling3D(xScale, yScale, zScale, origin)</sample>
                    <param name="xScale" type="float" desc="Scaling in the x direction"/>
                    <param name="yScale" type="float" multiplicity="?" desc="Optional scaling in the y direction. If omitted the scaling for the x direction will also be used in the y direction."/>
                    <param name="zScale" type="float" multiplicity="?" desc="Optional scaling in the z direction. If omitted the scaling for the x direction will also be used in the z direction."/>
                    <param name="origin" type="const object" multiplicity="?" alias="Point" desc="Optional origin of scaling if other than (0,0)"/>
                    <return name="transform" type="object" alias="Transform" desc="The new 3D scaling transform which is of type SIMILARITY"/>
                </function>
                <function name="createRigid2D">
                    <links>Transform.rotateX, Transform.rotateY, Transform.rotate2D,  Transform.createReflection2D, Transform.translate2D</links>
                    <desc>Creates a 2D rigid transform with only rotation and translation.</desc>
                    <sample for="lua">local rigidTransform = Transform.createRigid2D(math.pi/2, xTrans, yTrans, origin)</sample>
                    <param name="rotation" type="float" desc="Counter clockwise rotation (in radians)"/>
                    <param name="xTrans" type="float" desc="Translation in the x direction"/>
                    <param name="yTrans" type="float" desc="Translation in the y direction"/>
                    <param name="origin" type="const object" multiplicity="?" alias="Point" desc="Optional origin of rotation if other than (0,0)"/>
                    <return name="rigidTransform" type="object" alias="Transform" desc="The new 2D rigid transform"/>
                </function>
                <function name="createRigidEuler3D">
                    <links>Transform.decomposeRigidEuler3D, Transform.rotateX, Transform.rotateY, transform.RotateZ, Transform.scale3D, Transform.createReflection3D, , Transform.translate3D</links>
                    <desc>Creates a 3D rigid transform using Euler angles and translation. Rotations are parameterized and applied in the order specified by the rotation order. E.g. using order "XYZ", the object is first rotated alpha radians around the world x-axis, then beta radians around the world y-axis, and finally gamma radians around the world z-axis. All rotations are according to the right hand rule, positive is clockwise when looking along the direction of the rotation axis.</desc>
                    <sample for="lua">local rigidTransform = Transform.createRigidEuler3D(rotationOrder, alpha, beta, gamma, xTrans, yTrans, zTrans, origin)</sample>
                    <param name="rotationOrder" type="enum" ref="RotationOrder" desc="Order in which to apply rotations and order of rotation parameters."/>
                    <param name="alpha" type="float" desc="Rotation around the first axis (in radians)."/>
                    <param name="beta" type="float" desc="Rotation arond the second axis (in radians)."/>
                    <param name="gamma" type="float" desc="Rotation around the third axis (in radians)."/>
                    <param name="xTrans" type="float" desc="Translation in the x direction."/>
                    <param name="yTrans" type="float" desc="Translation in the y direction."/>
                    <param name="zTrans" type="float" desc="Translation in the z direction."/>
                    <param name="origin" type="const object" multiplicity="?" alias="Point" desc="Optional origin of rotation if other than (0,0,0)."/>
                    <return name="rigidTransform" type="object" alias="Transform" desc="The new 3D rigid transform"/>
                </function>
                <function name="createRigidAxisAngle3D">
                    <links>Transform.decomposeRigidEuler3D, Transform.rotateX, Transform.rotateY, transform.RotateZ, Transform.scale3D, Transform.createReflection3D</links>
                    <desc>Creates a 3D rigid transform by defining an axis, a rotation around the axis and a translation.</desc>
                    <sample for="lua">local rigidTransform = Transform.createRigidAxisAngle3D({xAxis, yAxis, zAxis}, rotation, xTrans, yTrans, zTrans, origin)</sample>
                    <param name="axis" type="float" multiplicity="+" desc="The rotation axis to rotate about."/>
                    <param name="rotation" type="float" desc="Clockwise rotation when looking along the axis (in radians)"/>
                    <param name="xTrans" type="float" desc="Translation in the x direction"/>
                    <param name="yTrans" type="float" desc="Translation in the y direction"/>
                    <param name="zTrans" type="float" desc="Translation in the z direction"/>
                    <param name="origin" type="const object" multiplicity="?" alias="Point" desc="Optional origin of rotation if other than (0,0,0)"/>
                    <return name="rigidTransform" type="object" multiplicity="?" alias="Transform" desc="The new 3D rigid transform"/>
                </function>
                <function name="createReflection2D">
                    <trait>released</trait>
                    <keywords>mirror</keywords>
                    <links>Transform.createRigid2D</links>
                    <desc>Creates a 2D rigid transform that is a reflection in the given 2D line.</desc>
                    <sample for="lua">local reflection = Transform.createReflection2D(line)</sample>
                    <param name="line" type="const object" alias="Shape" desc="The reflection 2D line."/>
                    <return name="reflection" type="object" multiplicity="?" alias="Transform" desc="The new 2D reflection transform which is of RIGID type."/>
                </function>
                <function name="createReflection3D">
                    <trait>released</trait>
                    <links>Transform.createRigid3D</links>
                    <desc>Creates a 3D rigid transform that is a reflection in the given 3D plane.</desc>
                    <sample for="lua">local reflection = Transform.createReflection3D(plane)</sample>
                    <param name="plane" type="const object" alias="Shape3D" desc="The reflection 3D plane."/>
                    <return name="reflection" type="object" multiplicity="?" alias="Transform" desc="The new 3D reflection transform which is of RIGID type."/>
                </function>
                <function name="createSimilarity2D">
                    <links>Transform.createScaling2D, Transform.createRigid2D</links>
                    <desc>Creates a 2D similarity transform with rotation, scale and translation.</desc>
                    <sample for="lua">local similarityTransform = Transform.createSimilarity2D(math.pi/2, scale, xTrans, yTrans, origin)</sample>
                    <param name="rotation" type="float" desc="Counter clockwise rotation (in radians)"/>
                    <param name="scale" type="float" desc="Scale factor"/>
                    <param name="xTrans" type="float" desc="Translation in the x direction"/>
                    <param name="yTrans" type="float" desc="Translation in the y direction"/>
                    <param name="origin" type="const object" multiplicity="?" alias="Point" desc="Optional origin of rotation if other than (0,0)"/>
                    <return name="similarityTransform" type="object" alias="Transform" desc="The new 2D similarity transform"/>
                </function>
                <function name="createSimilarityEulerXYZ3D">
                    <trait>hidden</trait>
                    <desc>Creates a 3D similarity transform using Euler angles, scale and translation.</desc>
                    <sample for="lua">local similarityTransform = Transform.createSimilarityEulerXYZ3D(alpha, beta, gamma, scale, xTrans, yTrans, zTrans, origin)</sample>
                    <param name="alpha" type="float" desc="Clockwise rotation when looking along the z-axis(in radians)"/>
                    <param name="beta" type="float" desc="Clockwise rotation when looking along the y-axis(in radians)"/>
                    <param name="gamma" type="float" desc="Clockwise rotation when looking along the x-axis(in radians)"/>
                    <param name="scale" type="float" desc="Scale factor"/>
                    <param name="xTrans" type="float" desc="Translation in the x direction"/>
                    <param name="yTrans" type="float" desc="Translation in the y direction"/>
                    <param name="zTrans" type="float" desc="Translation in the z direction"/>
                    <param name="origin" type="const object" multiplicity="?" alias="Point" desc="Optional origin of rotation if other than (0,0,0)"/>
                    <return name="similarityTransform" type="object" multiplicity="?" alias="Transform" desc="The new 3D similarity transform"/>
                </function>
                <function name="createHomography2D">
                    <links>Transform.createHomography2DFromPoints, Transform.createHomography3D</links>
                    <desc>Creates a 2D homography/projective transform.</desc>
                    <sample for="lua">local homographyTransform = Transform.createHomography2D(matrix)</sample>
                    <param name="matrix" type="const object" alias="Matrix" desc="A 3x3 matrix with the full homography transform."/>
                    <return name="homographyTransform" type="object" alias="Transform" desc="The new 2D homography transform"/>
                </function>
                <function name="createHomography2DFromPoints">
                    <links>Transform.createHomography2D, Transform.createHomography3D</links>
                    <desc>Creates a homography/projective transform from N corresponding point pairs, source and destination points need to be of equal length. If more than 4 points are given an RANSAC estimation of the homography is performed. If either margin or iterations is set to zero all points provided will be used.</desc>
                    <sample for="lua">local homographyTransform = Transform.createHomography2DFromPoints(srcPoints, dstPoints, margin, iterations)</sample>
                    <param name="srcPoints" type="const object" multiplicity="+" alias="Point" desc="N source points."/>
                    <param name="dstPoints" type="const object" multiplicity="+" alias="Point" desc="N destination points."/>
                    <param name="margin" type="float" multiplicity="?" desc="Margin expressed in world-units. Points which after transformation is within the margin is considered as inliers. Default value is 1.0. If the certainty of the points is high the margin can be lowered to reject more outliers."/>
                    <param name="iterations" type="int" multiplicity="?" desc="Number of iterations in the RANSAC loop in the homography estimation. Default value is 100. If set to 0 a least-squares estimation is performed."/>
                    <return name="homographyTransform" type="object" alias="Transform" desc="Homography transform."/>
                </function>
                <function name="createHomography3D">
                    <links>Transform.createHomography2D</links>
                    <desc>Creates a 3D homography/projective transform.</desc>
                    <sample for="lua">local homographyTransform = Transform.createHomography3D(matrix)</sample>
                    <param name="matrix" type="const object" alias="Matrix" desc="A 4x4 matrix with the full homography transform."/>
                    <return name="homographyTransform" type="object" alias="Transform" desc="The new 3D homography transform"/>
                </function>
                <function name="createFromMatrix2D">
                    <desc>Creates a 2D transform directly from a 3x3 matrix representation.</desc>
                    <sample for="lua">local transform = Transform.createFromMatrix2D(matrix, desiredType)</sample>
                    <param name="matrix" type="const object" alias="Matrix" desc="A 3x3 matrix with the transform."/>
                    <param name="desiredType" type="enum" multiplicity="?" ref="TransformType" desc="The desired transform type. If the numerical properties of the matrix does not fit the desired type, nil is returned. Optional, if not specified, the transform type is found by a numerical evaluation of the matrix."/>
                    <return name="transform" type="object" multiplicity="?" alias="Transform" desc="The new 2D transform."/>
                </function>
                <function name="createFromMatrix3D">
                    <desc>Creates a 3D transform directly from a 4x4 matrix representation.</desc>
                    <sample for="lua">local transform = Transform.createFromMatrix3D(matrix, desiredType)</sample>
                    <param name="matrix" type="const object" alias="Matrix" desc="A 4x4 matrix with the transform."/>
                    <param name="desiredType" type="enum" multiplicity="?" ref="TransformType" desc="The desired transform type. If the numerical properties of the matrix does not fit the desired type, nil is returned. Optional, if not specified, the transform type is found by a numerical evaluation of the matrix."/>
                    <return name="transform" type="object" multiplicity="?" alias="Transform" desc="The new 3D transform."/>
                </function>
                <function name="decomposeSimilarity2D">
                    <links>Transform.decomposeRigid2D</links>
                    <desc>Decomposes a similarity transform into a rigid transform and a scale factor. The similarity transform can be reconstructed by first scaling and then applying the rigid transformation.</desc>
                    <sample for="lua">local scale, rigidTransform = Transform.decomposeSimilarity2D(similarityTransform)</sample>
                    <param name="similarityTransform" type="const object" alias="Transform" desc="The 2D similarity transform."/>
                    <return name="scale" type="float" multiplicity="?" desc="Scale factor."/>
                    <return name="rigidTransform" type="object" multiplicity="?" alias="Transform" desc="The rigid part of the transform."/>
                </function>
                <function name="decomposeSimilarity3D">
                    <links>Transform.decomposeRigidEuler3D</links>
                    <desc>Decomposes a similarity transform into a rigid transform and a scale factor. The similarity transform can be reconstructed by first scaling and then applying the rigid transformation.</desc>
                    <sample for="lua">local scale, rigidTransform = Transform.decomposeSimilarity3D(similarityTransform)</sample>
                    <param name="similarityTransform" type="const object" alias="Transform" desc="The 3D similarity transform."/>
                    <return name="scale" type="float" multiplicity="?" desc="Scale factor."/>
                    <return name="rigidTransform" type="object" multiplicity="?" alias="Transform" desc="The rigid part of the transform."/>
                </function>
                <function name="decomposeRigid2D">
                    <links>Transform.decomposeSimilarity2D, Transform.decomposeTranslation2D</links>
                    <desc>Decomposes a 2D rigid transform into rotation and translation components. The transform must not contain a reflection.</desc>
                    <sample for="lua">local rotation, xTrans, yTrans = Transform.decomposeRigid2D(rigidTransform)</sample>
                    <param name="rigidTransform" type="const object" alias="Transform" desc="The 2D rigid transform."/>
                    <return name="rotation" type="float" multiplicity="?" desc="Counter clockwise rotation (in radians)."/>
                    <return name="xTrans" type="float" multiplicity="?" desc="Translation in the x direction."/>
                    <return name="yTrans" type="float" multiplicity="?" desc="Translation in the y direction."/>
                </function>
                <function name="decomposeRigidEuler3D">
                    <links>Transform.createRigidEuler3D</links>
                    <desc>Decomposes a 3D rigid transform into Euler angles and translation. Rotations are parameterized and applied in the order specified by the rotation order. E.g. to recreate a transformation decomposed using "ZYX" rotation order, first rotate alpha around the world z-axis, then beta around the world y-axis and finally gamma around the world x-axis. All rotations are according to the right hand rule, positive is clockwise when looking along the direction of the rotation axis. The transform must not contain a reflection.</desc>
                    <sample for="lua">local alpha, beta, gamma, xTrans, yTrans, zTrans = Transform.decomposeRigidEuler3D(rigidTransform, rotationOrder)</sample>
                    <param name="rigidTransform" type="const object" alias="Transform" desc="The 3D rigid transform."/>
                    <param name="rotationOrder" type="enum" ref="RotationOrder" desc="Order in which to apply rotations and order of the returned rotation parameters."/>
                    <return name="alpha" type="float" multiplicity="?" desc="Rotation around the first axis (in radians)."/>
                    <return name="beta" type="float" multiplicity="?" desc="Rotation arond the second axis (in radians)."/>
                    <return name="gamma" type="float" multiplicity="?" desc="Rotation around the third axis (in radians)."/>
                    <return name="xTrans" type="float" multiplicity="?" desc="Translation in the x direction."/>
                    <return name="yTrans" type="float" multiplicity="?" desc="Translation in the y direction."/>
                    <return name="zTrans" type="float" multiplicity="?" desc="Translation in the z direction."/>
                </function>
                <function name="decomposeTranslation2D">
                    <links>Transform.decomposeRigid2D</links>
                    <desc>Decomposes a 2D translation transform into translation components.</desc>
                    <sample for="lua">local xTrans, yTrans = Transform.decomposeTranslation2D(translationTransform)</sample>
                    <param name="translationTransform" type="const object" alias="Transform" desc="The 2D translation transform."/>
                    <return name="xTrans" type="float" multiplicity="?" desc="Translation in the x direction."/>
                    <return name="yTrans" type="float" multiplicity="?" desc="Translation in the y direction."/>
                </function>
                <function name="decomposeTranslation3D">
                    <links>Transform.decomposeRigid3D</links>
                    <desc>Decomposes a 3D translation transform into translation components.</desc>
                    <sample for="lua">local xTrans, yTrans, zTrans = Transform.decomposeTranslation3D(translationTransform)</sample>
                    <param name="translationTransform" type="const object" alias="Transform" desc="The 3D translation transform."/>
                    <return name="xTrans" type="float" multiplicity="?" desc="Translation in the x direction."/>
                    <return name="yTrans" type="float" multiplicity="?" desc="Translation in the y direction."/>
                    <return name="zTrans" type="float" multiplicity="?" desc="Translation in the z direction."/>
                </function>
                <function name="getMatrix">
                    <links>Transform.createFromMatrix2D, Transform.createFromMatrix3D</links>
                    <desc>Returns the transform matrix.</desc>
                    <sample for="lua">local matrix = Transform.getMatrix(transform)</sample>
                    <param name="transform" type="const object" alias="Transform" desc="The instance to use"/>
                    <return name="matrix" type="object" alias="Matrix" desc="The full 3x3 or 4x4 matrix of this transform."/>
                </function>
                <function name="compose">
                    <links>Transform.scale2D, Transform.scale3D, Transform.translate2D, Transform.translate3D, Transform.rotateX, Transform.rotateY, Transform.rotateZ, Transform.rotate2D</links>
                    <desc>Composes two transforms of the same dimensionality.</desc>
                    <sample for="lua">local composedTransform = Transform.compose(transformA, transformB)</sample>
                    <param name="transformA" type="const object" alias="Transform" desc="The instance to use"/>
                    <param name="transformB" type="const object" alias="Transform" desc="The instance to use"/>
                    <return name="composedTransform" type="object" alias="Transform" desc="The composed transformation matrix."/>
                </function>
                <function name="rotate2D">
                    <links>Transform.rotateX, Transform.rotateY</links>
                    <desc>Returns a 2D transform with a counter clockwise rotation appended to the input transform. The rotation center is optional. If not provided, the world origin is used.</desc>
                    <sample for="lua">outputTransform = Transform.rotate2D(inputTransform, rotationAngle, rotationCenter)</sample>
                    <param name="inputTransform" type="const object" alias="Transform" desc="Input 2D transform."/>
                    <param name="rotationAngle" type="float" desc="The rotation angle in radians."/>
                    <param name="rotationCenter" type="const object" multiplicity="?" alias="Point" desc="The rotation center. Default is the origin."/>
                    <return name="outputTransform" type="object" alias="Transform" desc="The transform with appended rotation."/>
                </function>
                <function name="rotateX">
                    <links>Transform.rotateY, Transform.rotateZ, Transform.rotate2D, Transform.createRigidEuler3D</links>
                    <desc>Returns a 3D transform with a rotation around an axis parallel to the world x-axis appended to the input transform. The rotation center is optional. If not provided, the world origin is used. Positive rotation is according to the right hand rule, clockwise when looking along the direction of the rotation axis.</desc>
                    <sample for="lua">outputTransform = Transform.rotateX(inputTransform, rotationAngle, rotationCenter)</sample>
                    <param name="inputTransform" type="const object" alias="Transform" desc="Input 3D transform."/>
                    <param name="rotationAngle" type="float" desc="The rotation angle in radians."/>
                    <param name="rotationCenter" type="const object" multiplicity="?" alias="Point" desc="The rotation center. Default is the origin."/>
                    <return name="outputTransform" type="object" alias="Transform" desc="The transform with appended rotation."/>
                </function>
                <function name="rotateY">
                    <links>Transform.rotateX, Transform.rotateZ, Transform.rotate2D, Transform.createRigidEuler3D</links>
                    <desc>Returns a 3D transform with a rotation around an axis parallel to the world y-axis appended to the input transform. The rotation center is optional. If not provided, the world origin is used. Positive rotation is according to the right hand rule, clockwise when looking along the direction of the rotation axis.</desc>
                    <sample for="lua">outputTransform = Transform.rotateY(inputTransform, rotationAngle, rotationCenter)</sample>
                    <param name="inputTransform" type="const object" alias="Transform" desc="Input 3D transform."/>
                    <param name="rotationAngle" type="float" desc="The rotation angle in radians."/>
                    <param name="rotationCenter" type="const object" multiplicity="?" alias="Point" desc="The rotation center. Default is the origin."/>
                    <return name="outputTransform" type="object" alias="Transform" desc="The transform with appended rotation."/>
                </function>
                <function name="rotateZ">
                    <links>Transform.rotateX, Transform.rotateY, Transform.rotate2D, Transform.createRigidEuler3D</links>
                    <desc>Returns a 3D transform with a rotation around an axis parallel to the world z-axis appended to the input transform. The rotation center is optional. If not provided, the world origin is used. Positive rotation is according to the right hand rule, clockwise when looking along the direction of the rotation axis.</desc>
                    <sample for="lua">outputTransform = Transform.rotateZ(inputTransform, rotationAngle, rotationCenter)</sample>
                    <param name="inputTransform" type="const object" alias="Transform" desc="Input 3D transform."/>
                    <param name="rotationAngle" type="float" desc="The rotation angle in radians."/>
                    <param name="rotationCenter" type="const object" multiplicity="?" alias="Point" desc="The rotation center. Default is the origin."/>
                    <return name="outputTransform" type="object" alias="Transform" desc="The transform with appended rotation."/>
                </function>
                <function name="translate2D">
                    <desc>Returns a 2D transform with a translation in world coordinates appended to the input transform.</desc>
                    <sample for="lua">outputTransform = Transform.translate2D(inputTransform, xTrans, yTrans)</sample>
                    <param name="inputTransform" type="const object" alias="Transform" desc="Input 2D transform."/>
                    <param name="xTrans" type="float" desc="The translation along the x-axis."/>
                    <param name="yTrans" type="float" desc="The translation along the y-axis."/>
                    <return name="outputTransform" type="object" alias="Transform" desc="The transform with appended translation."/>
                </function>
                <function name="translate3D">
                    <links>Transform.createRigidEuler3D</links>
                    <desc>Returns a 3D transform with a translation in world coordinates appended to the input transform.</desc>
                    <sample for="lua">outputTransform = Transform.translate3D(inputTransform, xTrans, yTrans, zTrans)</sample>
                    <param name="inputTransform" type="const object" alias="Transform" desc="Input 3D transform."/>
                    <param name="xTrans" type="float" desc="The translation along the x-axis."/>
                    <param name="yTrans" type="float" desc="The translation along the y-axis."/>
                    <param name="zTrans" type="float" desc="The translation along the z-axis."/>
                    <return name="outputTransform" type="object" alias="Transform" desc="The transform with appended translation."/>
                </function>
                <function name="scale2D">
                    <links>Transform.createScaling2D</links>
                    <desc>Returns a 2D transform with a scaling appended to the input transform.</desc>
                    <sample for="lua">outputTransform = Transform.scale2D(inputTransform, scaleFactor)</sample>
                    <param name="inputTransform" type="const object" alias="Transform" desc="Input 2D transform."/>
                    <param name="scaleFactor" type="float" desc="The scaling factor to apply."/>
                    <param name="scaleCenter" type="const object" multiplicity="?" alias="Point" desc="The scaling center, remains fixed during scaling. Default is the origin."/>
                    <return name="outputTransform" type="object" alias="Transform" desc="The transform with appended scaling."/>
                </function>
                <function name="scale3D">
                    <links>Transform.createScaling3D</links>
                    <desc>Returns a 3D transform with a scaling appended to the input transform.</desc>
                    <sample for="lua">outputTransform = Transform.scale3D(inputTransform, scaleFactor)</sample>
                    <param name="inputTransform" type="const object" alias="Transform" desc="Input 3D transform."/>
                    <param name="scaleFactor" type="float" desc="The scaling factor to apply."/>
                    <param name="scaleCenter" type="const object" multiplicity="?" alias="Point" desc="The scaling center, remains fixed during scaling. Default is the origin."/>
                    <return name="outputTransform" type="object" alias="Transform" desc="The transform with appended scaling."/>
                </function>
                <function name="invert">
                    <desc>Returns the inverse transform.</desc>
                    <sample for="lua">local inversedTransform = Transform.invert(transform)</sample>
                    <param name="transform" type="const object" alias="Transform" desc="The instance to use"/>
                    <return name="inversedTransform" type="object" alias="Transform" desc="The inverse transformation matrix."/>
                </function>
                <function name="getType">
                    <desc>Returns the transform type</desc>
                    <sample for="lua">
            if (Transform.getType(transform)=="IDENTITY") then
              doSomething()
            end
          </sample>
                    <param name="transform" type="const object" alias="Transform" desc="The transform to check"/>
                    <return name="result" type="enum" ref="TransformType" desc="The transform type"/>
                </function>
                <function name="toType">
                    <links>Transform.to3D</links>
                    <desc>Returns a copy of the transformation marked as desired type. If the desired type is not general enough to support the actual transformation, nil is returned. The transform itself is not changed. Converting to a more general type always succeeds.</desc>
                    <sample for="lua">local convertedTransform = Transform.toType(transform, "RIGID")</sample>
                    <param name="transform" type="const object" alias="Transform" desc="The source transform."/>
                    <param name="desiredType" type="enum" ref="TransformType" desc="The desired transform type, e.g., RIGID, SIMILARITY, AFFINE, TRANSLATION."/>
                    <return name="convertedTransform" type="object" multiplicity="?" alias="Transform" desc="The transform of the desired type, or nil if the desired type was not compatible with the actual transform."/>
                </function>
                <function name="to2D">
                    <links>Transform.toType</links>
                    <desc>Converts a 3D transform to a 2D transform. For 3D transforms of type similarity or simpler, a 2D transform is created which only uses x- and y-translation, scale and the rotation around the z-axis. Affine and homography 3D transforms are not supported, nor similarity transforms that contain a reflection. The created 2D transform applies the part of the 3D transform that transforms the x,y-coordinates and ignores the z-transformation.</desc>
                    <sample for="lua">local transform2d = Transform.to2D(transform3d) </sample>
                    <param name="transform3d" type="const object" alias="Transform" desc="The 3D source transform."/>
                    <return name="transform2d" type="object" multiplicity="?" alias="Transform" desc="The corresponding 2D transform. Nil is returned if input is invalid."/>
                </function>
                <function name="to3D">
                    <links>Transform.toType</links>
                    <desc>Converts a 2D transform to a 3D transform. The created 3D transform applies the 2D transform to the x,y-coordinates and leaves the z-coordinates unchanged. This holds up to affine transformations. For homographies, the final scaling of the points is applied also to the z-coordinate.</desc>
                    <sample for="lua">local transform3d = Transform.to3D(transform2d) </sample>
                    <param name="transform2d" type="const object" alias="Transform" desc="The 2D source transform."/>
                    <return name="transform3d" type="object" multiplicity="?" alias="Transform" desc="The corresponding 3D transform. Nil is returned if input is invalid."/>
                </function>
                <function name="toString">
                    <desc>Get a string representation of the transform. The matrix representing the transform is written row-wise.</desc>
                    <sample for="lua">print("The transform is: " .. transform:toString())</sample>
                    <param name="transform" type="const object" alias="Transform" desc="Input transform"/>
                    <return name="str" type="string" desc="String representation of the transform"/>
                </function>
            </serves>
        </crown>
        <crown name="Point">
            <trait>released</trait>
            <desc>Represents a point/vector in 2D or 3D</desc>
            <enum name="NormType">
                <item name="L-1-Norm" desc="Manhattan distance: |x|+|y|+|z|">L_1_NORM</item>
                <item name="L-2-Norm" desc="Euclidean distance: sqrt(x*x+y*y+z*z)">L_2_NORM</item>
                <item name="L-Infinity-Norm" desc="Maximum of absolute values: max(|x|,|y|,|z|)">L_INFINITY_NORM</item>
            </enum>
            <serves>
                <function name="create">
                    <desc>Create 2D or 3D point(s). The third z-coordinate input is optional, if omitted a 2D point is created, otherwise a 3D point. Vector input is allowed to create vectors of points. The input vectors must then all be of equal length.

The following input combinations are allowed:
Two scalar floats give a 2D point (x,y)
Three scalar floats give a 3D point (x,y,z)
Two vectors of equal length give a vector of 2D points
Three vectors of equal length give a vector of 3D points</desc>
                    <sample for="lua">point = Point.create({1.0, 2.0}, {3.0, 4.0})</sample>
                    <param name="x" type="float" multiplicity="[1+]" desc="X coordinate, a scalar or vector."/>
                    <param name="y" type="float" multiplicity="[1+]" desc="Y coordinate, a scalar or vector."/>
                    <param name="z" type="float" multiplicity="[?*]" desc="Z coordinate, a scalar or vector. Optional: if omitted, 2D points will be created."/>
                    <return name="point" type="object" multiplicity="[?*]" alias="Point" desc="The created point or vector of points."/>
                </function>
                <function name="clone">
                    <desc>Create an independent copy of this point. If the input is a vector of points, the output is a vector of points.</desc>
                    <sample for="lua">clonedPoint = Point.clone(point)</sample>
                    <param name="point" type="const object" multiplicity="[1+]" alias="Point" desc="Input point(s)"/>
                    <return name="clonedPoint" type="object" multiplicity="[?*]" alias="Point" desc="Copy of the input point(s)"/>
                </function>
                <function name="setX">
                    <desc>Set the X coordinate of a point.</desc>
                    <sample for="lua">Point.setX(point, x)</sample>
                    <param name="point" type="object" alias="Point" desc="Input point"/>
                    <param name="x" type="float" desc="X coordinate"/>
                </function>
                <function name="setY">
                    <desc>Set the Y coordinate of a point.</desc>
                    <sample for="lua">Point.setY(point, y)</sample>
                    <param name="point" type="object" alias="Point" desc="Input point"/>
                    <param name="y" type="float" desc="Y coordinate"/>
                </function>
                <function name="setZ">
                    <desc>Set the Z coordinate of a point (only 3D).</desc>
                    <sample for="lua">Point.setZ(point, z)</sample>
                    <param name="point" type="object" alias="Point" desc="Input point"/>
                    <param name="z" type="float" desc="Z coordinate"/>
                </function>
                <function name="setXY">
                    <desc>Set the X and Y coordinates of a point.</desc>
                    <sample for="lua">Point.setXY(point, x, y)</sample>
                    <param name="point" type="object" alias="Point" desc="Input point"/>
                    <param name="x" type="float" desc="X coordinate"/>
                    <param name="y" type="float" desc="Y coordinate"/>
                </function>
                <function name="setXYZ">
                    <desc>Set the X, Y and Z coordinates of a point (only 3D).</desc>
                    <sample for="lua">Point.setXYZ(point, x, y, z)</sample>
                    <param name="point" type="object" alias="Point" desc="Input point"/>
                    <param name="x" type="float" desc="X coordinate"/>
                    <param name="y" type="float" desc="Y coordinate"/>
                    <param name="z" type="float" desc="Z coordinate"/>
                </function>
                <function name="getX">
                    <desc>Get the X coordinate of a point.</desc>
                    <sample for="lua">x = Point.getX(point)</sample>
                    <param name="point" type="const object" alias="Point" desc="Input point"/>
                    <return name="x" type="float" desc="x coordinate of the point"/>
                </function>
                <function name="getY">
                    <desc>Get the Y coordinate of a point.</desc>
                    <sample for="lua">y = Point.getY(point)</sample>
                    <param name="point" type="const object" alias="Point" desc="Input point"/>
                    <return name="y" type="float" desc="y coordinate of the point"/>
                </function>
                <function name="getZ">
                    <desc>Get the Z coordinate of a point (only 3D).</desc>
                    <sample for="lua">z = Point.getZ(point)</sample>
                    <param name="point" type="const object" alias="Point" desc="Input point"/>
                    <return name="z" type="float" multiplicity="?" desc="z coordinate of the point"/>
                </function>
                <function name="getXY">
                    <desc>Get the X and Y coordinates of a point.</desc>
                    <sample for="lua">x,y = Point.getXY(point)</sample>
                    <param name="point" type="const object" alias="Point" desc="Input point"/>
                    <return name="x" type="float" desc="x coordinate of the point"/>
                    <return name="y" type="float" desc="y coordinate of the point"/>
                </function>
                <function name="getXYZ">
                    <desc>Get the X, Y and Z coordinates of a point (only 3D).</desc>
                    <sample for="lua">x,y,z = Point.getXYZ(point)</sample>
                    <param name="point" type="const object" alias="Point" desc="Input point"/>
                    <return name="x" type="float" multiplicity="?" desc="x coordinate of the point"/>
                    <return name="y" type="float" multiplicity="?" desc="y coordinate of the point"/>
                    <return name="z" type="float" multiplicity="?" desc="z coordinate of the point"/>
                </function>
                <function name="getDistance">
                    <desc>Compute the distance between the two points of the same dimensionality (2D or 3D).</desc>
                    <sample for="lua">distance = Point.getDistance(point1,point2)</sample>
                    <param name="point1" type="const object" alias="Point" desc="Input point"/>
                    <param name="point2" type="const object" alias="Point" desc="Input point"/>
                    <return name="distance" type="float" multiplicity="?" desc="Distance between the points"/>
                </function>
                <function name="is2D">
                    <desc>Check if a point is a 2D point.</desc>
                    <sample for="lua">ret = Point.is2D(point)</sample>
                    <param name="point" type="const object" multiplicity="[1+]" alias="Point" desc="Input point(s)"/>
                    <return name="ret" type="bool" multiplicity="[?*]" desc="True if 2D point(s), otherwise false"/>
                </function>
                <function name="is3D">
                    <desc>Check if a point is a 3D point.</desc>
                    <sample for="lua">ret = Point.is3D(point)</sample>
                    <param name="point" type="const object" alias="Point" desc="Input point"/>
                    <return name="ret" type="bool" desc="True if 3D point, otherwise false"/>
                </function>
                <function name="isFinite">
                    <desc>Check if a point is finite, i.e. none of the values is Inf/NaN.</desc>
                    <sample for="lua">ret = Point.isFinite(point)</sample>
                    <param name="point" type="const object" alias="Point" desc="Input point"/>
                    <return name="ret" type="bool" desc="True if finite point, otherwise false"/>
                </function>
                <function name="isZero">
                    <desc>Returns true if all coordinates are zero.</desc>
                    <sample for="lua">ret = Point.isZero(point)</sample>
                    <param name="point" type="const object" alias="Point" desc="Input point"/>
                    <return name="ret" type="bool" desc="True if all coordinates are zero, otherwise false"/>
                </function>
                <function name="toString">
                    <desc>Get a string representation of the point.</desc>
                    <sample for="lua">print("The point is: " .. Point.toString(point))</sample>
                    <param name="point" type="const object" multiplicity="[1+]" alias="Point" desc="Input point"/>
                    <return name="str" type="string" desc="String representation of the point"/>
                </function>
                <function name="transform">
                    <links>Transform</links>
                    <desc>Transforms point or a vector of points. For 2D points a 2D transform must be supplied, for 3D points a 3D transform.</desc>
                    <sample for="lua">transformedPoint = Point.transform(point, transform)</sample>
                    <param name="point" type="const object" multiplicity="[1+]" alias="Point" desc="Input point, or vector of points."/>
                    <param name="transform" type="const object" alias="Transform" desc="Transform to apply."/>
                    <return name="transformedPoint" type="object" multiplicity="[?*]" alias="Point" desc="Transformed point(s)."/>
                </function>
                <function name="toMatrix">
                    <desc>Converts a point or a vector of points to a matrix.</desc>
                    <sample for="lua">matrix = Point.toMatrix(point, storeInColumns)</sample>
                    <param name="point" type="const object" multiplicity="[1+]" alias="Point" desc="Input point, or vector of points to convert to a matrix."/>
                    <param name="storeInColumns" type="bool" desc="When true the points are placed in the columns of the matrix, when false in the rows of the matrix."/>
                    <return name="matrix" type="object" alias="Matrix" desc="Matrix created from the points."/>
                </function>
                <function name="cross">
                    <links>Point.dot</links>
                    <desc>Calculates the cross product of two point vectors (only 3D).
The cross product is anti-commutative: a x b = -(b x a)</desc>
                    <sample for="lua">product = Point.cross(a, b)</sample>
                    <param name="a" type="const object" alias="Point" desc="Input point"/>
                    <param name="b" type="const object" alias="Point" desc="Input point"/>
                    <return name="product" type="object" alias="Point" desc="The cross product"/>
                </function>
                <function name="dot">
                    <links>Point.cross</links>
                    <desc>Calculates the dot product of two point vectors of the same dimensionality (e.g. x1*x2+y1*y2+z1*z2).</desc>
                    <sample for="lua">product = Point.dot(point1, point2)</sample>
                    <param name="point1" type="const object" alias="Point" desc="Input point"/>
                    <param name="point2" type="const object" alias="Point" desc="Input point"/>
                    <return name="product" type="float" multiplicity="?" desc="The dot product"/>
                </function>
                <function name="negate">
                    <desc>Returns the negated point vector (every component changes its sign).</desc>
                    <sample for="lua">pointOut = Point.negate(pointIn)</sample>
                    <param name="pointIn" type="const object" alias="Point" desc="Input point"/>
                    <return name="pointOut" type="object" alias="Point" desc="The negated point"/>
                </function>
                <function name="normalize">
                    <desc>Returns the unit vector (length=1) with the same direction or nil if the input point vector has the length 0.</desc>
                    <sample for="lua">pointOut = Point.normalize(pointIn)</sample>
                    <param name="pointIn" type="const object" alias="Point" desc="Input point"/>
                    <return name="pointOut" type="object" multiplicity="?" alias="Point" desc="The normalized point vector or nil"/>
                </function>
                <function name="projectOnPlane">
                    <trait>hidden</trait>
                    <desc>Projects one or multiple points onto a plane (only 3D).
This function is deprecated, please use Point.projectOntoPlane instead.
Should be deleted before the next major version.</desc>
                    <sample for="lua">pointOut = Point.projectOnPlane(pointIn, plane)</sample>
                    <param name="pointIn" type="const object" multiplicity="[1+]" alias="Point" desc="Input point(s)"/>
                    <param name="plane" type="const object" alias="Shape3D" desc="The projection plane."/>
                    <return name="pointOut" type="object" multiplicity="[1+]" alias="Point" desc="The point(s) on the plane"/>
                </function>
                <function name="projectOntoPlane">
                    <links>Point.getDistanceToPlane</links>
                    <desc>Projects one or multiple points onto a plane (only 3D).</desc>
                    <sample for="lua">pointOut = Point.projectOntoPlane(pointIn, plane)</sample>
                    <param name="pointIn" type="const object" multiplicity="[1+]" alias="Point" desc="Input point(s)"/>
                    <param name="plane" type="const object" alias="Shape3D" desc="The projection plane."/>
                    <return name="pointOut" type="object" multiplicity="[?*]" alias="Point" desc="The point(s) on the plane"/>
                </function>
                <function name="getDistanceToPlane">
                    <links>Point.projectOntoPlane, Point.getDistanceToLine</links>
                    <desc>Calculates the distance from a point to a plane (only 3D).</desc>
                    <sample for="lua">local distance = Point.getDistanceToPlane(pointIn, plane)</sample>
                    <param name="pointIn" type="const object" alias="Point" desc="Input point"/>
                    <param name="plane" type="const object" alias="Shape3D" desc="Input plane."/>
                    <return name="distance" type="float" desc="The distance from point to plane"/>
                </function>
                <function name="getDistanceToLine">
                    <links>Point.getDistanceToPlane</links>
                    <desc>Calculates the distance from a point to a line (2D/3D).</desc>
                    <sample for="lua">local distance = Point.getDistanceToLine(pointIn, line)</sample>
                    <param name="pointIn" type="const object" alias="Point" desc="Input point"/>
                    <param name="line" type="const auto" desc="Input line (Shape/Shape3D)."/>
                    <return name="distance" type="float" multiplicity="?" desc="The distance from point to line or nil for invalid input combination"/>
                </function>
                <function name="norm">
                    <desc>Calculates different types of non-negative vector norms.
If no enumeration is provided, the "L-2-Norm" will be calculated, which represents the magnitude or length of the point vector.</desc>
                    <sample for="lua">norm = Point.norm(pointIn)</sample>
                    <param name="pointIn" type="const object" alias="Point" desc="Input point"/>
                    <param name="type" type="enum" multiplicity="?" ref="NormType" desc="Norm type enumeration"/>
                    <return name="norm" type="float" multiplicity="?" desc="The norm"/>
                </function>
                <function name="add">
                    <desc>Add the corresponding components of two points.</desc>
                    <sample for="lua">pointOut = Point.add(point1, point2)</sample>
                    <param name="point1" type="const object" alias="Point" desc="Input point 1"/>
                    <param name="point2" type="const object" alias="Point" desc="Input point 2"/>
                    <return name="pointOut" type="object" alias="Point" desc="Output point"/>
                </function>
                <function name="addConstant">
                    <desc>Add a constant to each component.</desc>
                    <sample for="lua">pointOut = Point.addConstant(pointIn, constant)</sample>
                    <param name="pointIn" type="const object" alias="Point" desc="Input point"/>
                    <param name="constant" type="float" desc="The constant"/>
                    <return name="pointOut" type="object" alias="Point" desc="Output point"/>
                </function>
                <function name="subtract">
                    <desc>Subtract the corresponding components of the second point from those of the first point.</desc>
                    <sample for="lua">pointOut = Point.subtract(point1, point2)</sample>
                    <param name="point1" type="const object" alias="Point" desc="Input point 1"/>
                    <param name="point2" type="const object" alias="Point" desc="Input point 2"/>
                    <return name="pointOut" type="object" alias="Point" desc="Output point"/>
                </function>
                <function name="subtractConstant">
                    <desc>Subtract a constant from each component.</desc>
                    <sample for="lua">pointOut = Point.subtractConstant(pointIn, constant)</sample>
                    <param name="pointIn" type="const object" alias="Point" desc="Input point"/>
                    <param name="constant" type="float" desc="The constant"/>
                    <return name="pointOut" type="object" alias="Point" desc="Output point"/>
                </function>
                <function name="multiply">
                    <desc>Multiply the corresponding components of two points.</desc>
                    <sample for="lua">pointOut = Point.multiply(point1, point2)</sample>
                    <param name="point1" type="const object" alias="Point" desc="Input point 1"/>
                    <param name="point2" type="const object" alias="Point" desc="Input point 2"/>
                    <return name="pointOut" type="object" alias="Point" desc="Output point"/>
                </function>
                <function name="multiplyConstant">
                    <desc>Multiply each component with a constant.</desc>
                    <sample for="lua">pointOut = Point.multiplyConstant(pointIn, constant)</sample>
                    <param name="pointIn" type="const object" alias="Point" desc="Input point"/>
                    <param name="constant" type="float" desc="The constant"/>
                    <return name="pointOut" type="object" alias="Point" desc="Output point"/>
                </function>
                <function name="divide">
                    <desc>Divide the components of the first point with the corresponding components of the second point.</desc>
                    <sample for="lua">pointOut = Point.divide(point1, point2)</sample>
                    <param name="point1" type="const object" alias="Point" desc="Input point 1"/>
                    <param name="point2" type="const object" alias="Point" desc="Input point 2"/>
                    <return name="pointOut" type="object" alias="Point" desc="Output point"/>
                </function>
                <function name="divideConstant">
                    <desc>Divide each component with a constant.</desc>
                    <sample for="lua">pointOut = Point.divideConstant(pointIn, constant)</sample>
                    <param name="pointIn" type="const object" alias="Point" desc="Input point"/>
                    <param name="constant" type="float" desc="The constant"/>
                    <return name="pointOut" type="object" alias="Point" desc="Output point"/>
                </function>
                <function name="mean">
                    <keywords>average, cog, midpoint</keywords>
                    <desc>Calculate the mean position of the points. Can either be used for finding the midpoint of two Points or for finding the mean position of many points.</desc>
                    <sample for="lua">local mean = Point.mean(points)</sample>
                    <param name="point1" type="const object" multiplicity="[1+]" alias="Point" desc="Input point 1 or a vector of points"/>
                    <param name="point2" type="const object" multiplicity="?" alias="Point" desc="Optional input point 2"/>
                    <return name="mean" type="object" multiplicity="?" alias="Point" desc="Output point at mean position"/>
                </function>
                <function name="arrangeOnGrid">
                    <keywords></keywords>
                    <links>Image.Calibration.Pattern.detectCheckerboard</links>
                    <desc>Sort 2D points on a grid. This task is related to checkerboard arrangement, but can be used together with other features than checkerboard corners.
The only requirement for all points in the output index vector is that the points they reference are nodes in a common grid.
The gx and gy indices are roughly aligned to the x- and y-axes. In case of severe distortion and/or a rotated grid it may be difficult to align both x and y axes over the whole image. In this case an attempt is made to align gx to the x-axis.
This function adapts to non-linear drift over the grid of points and can be used to arrange extracted features non-calibration corrected images. For checkerboard detection, see the dedicated function Image.Calibration.Pattern.detectCheckerboard, which also includes corner extraction.
The purgeThreshold input can be used to remove isolated points along the border of the found grid. If a grid is required to have at least 4 points along each side we can set this threshold to 4 and only keep the central part of the grid that fulfills this requirement. This effectively shrinks the detected grid.</desc>
                    <sample for="lua">pidx, gx, gy = Point.arrangeOnGrid(points)</sample>
                    <param name="points" type="object" multiplicity="+" alias="Point" desc="A list of 2D points."/>
                    <param name="purgeThreshold" type="int" multiplicity="?" desc="Optional purge threshold. Removes points that are along borders with less than purgeThreshold neighbors. Default is 2."/>
                    <param name="distanceThreshold" type="float" multiplicity="?" desc="Optional distance threshold. The coordinate axes in origin must have at least this length. Default is 0."/>
                    <return name="pidx" type="int" multiplicity="*" desc="The indices of points on the final grid. Nil on failure."/>
                    <return name="gx" type="int" multiplicity="*" desc="The grid position in the approximate x-direction (horizontal). Nil on failure."/>
                    <return name="gy" type="int" multiplicity="*" desc="The grid position in the approximate y-direction (vertical). Nil on failure."/>
                </function>
            </serves>
            <uses/>
            <crown name="ShapeFitter">
                <trait>released</trait>
                <keywords>fitting, least squares, RANSAC, edges, contour, model</keywords>
                <links>Image.ShapeFitter, Shape</links>
                <desc>This is a tool for fitting geometrical object like lines and circles to points.

To get started, create a ShapeFitter with the create function and then call one of the fit functions to adjust a shape object to the provided points.

For more detailed control of the fitting behavior, call the set functions before calling the fit function.</desc>
                <serves>
                    <function name="create">
                        <trait>released</trait>
                        <desc>Create a shape fitter with default settings.</desc>
                        <sample for="lua">shapeFitter = Point.ShapeFitter.create()</sample>
                        <return name="shapeFitter" type="handle" alias="Point.ShapeFitter" desc="Created shape fitter."/>
                    </function>
                    <function name="setOutlierMargin">
                        <trait>released</trait>
                        <links>Point.ShapeFitter.setFitMode</links>
                        <desc>Set the outlier margin in world units for the final geometrical fitting step. This parameter is not used if the least squares fitting method is used.
The interpretation of the parameter depends on the fitting mode parameter:
- ABSOLUTE: the outlier margin is defined in absolute world units (typically mm). Any points further away from the fitted geometrical object than this margin will be ignored.
- RANK: (default) the outlier margin is interpreted as a rank measure, defining the rate of points to include. In this case, the margin must be in the range (0.0, 1.0). A rank margin of 0.7 means that only the best fitting 70% of all points will be included, and the rest ignored.
In general a larger value means that more points are included in the fitting, which can improve the accuracy as long as all included points are valid. A smaller value makes the algorithm reject more points, which can increases robustness against single erroneous points. The default is a RANK margin of 0.7.</desc>
                        <sample for="lua">Point.ShapeFitter.setOutlierMargin(shapeFitter, margin, marginType)</sample>
                        <param name="shapeFitter" type="handle" alias="Point.ShapeFitter" desc="Shape fitter to use."/>
                        <param name="margin" type="float" desc="Outlier margin, expressed in world coordinate units or as a rank measure, depending on the marginType."/>
                        <param name="marginType" type="enum" multiplicity="?" ref="Shape.OutlierMarginType" desc="Outlier margin type. Default is RANK."/>
                    </function>
                    <function name="setFitMode">
                        <trait>released</trait>
                        <links>Point.ShapeFitter.setOutlierMargin, Point.ShapeFitter.setIterations</links>
                        <desc>Set the geometrical fitting mode.
The following modes are supported:
- LEASTSQUARES uses all points. This is fast and easy, but can produce poor results if there are many samples not belonging to the object. When using this method, the inlier rate will always be 100%.
- RANSAC is a robust method with outlier rejection (default). Using this method, spurious samples can be ignored. This mode requires an outlier margin to be set by setOutlierMargin. The number of iterations can be set by setIterations.
- TRIMMED is a two-stage least squares method, where points further away from the fitted shape in the first round than the outlier margin (set by setOutlierMargin) is removed before using least squares again to fit a new shape to the remaining points. This is faster than RANSAC but not as robust to outliers.</desc>
                        <sample for="lua">Point.ShapeFitter.setFitMode(shapeFitter, "RANSAC")</sample>
                        <param name="shapeFitter" type="handle" alias="Point.ShapeFitter" desc="Shape fitter to use."/>
                        <param name="fitMode" type="enum" ref="Shape.PointFitMode" desc="Geometrical fitting mode to use. The default is RANSAC."/>
                    </function>
                    <function name="setIterations">
                        <trait>released</trait>
                        <links>Point.ShapeFitter.setFitMode</links>
                        <desc>Set the number of iterations in the point fitting step. Only used when setFitMode specifies a robust method like RANSAC. A higher value makes the method more robust, but consumes more computation time. The default is 500 iterations.</desc>
                        <sample for="lua">Point.ShapeFitter.setIterations(shapeFitter, 50)</sample>
                        <param name="shapeFitter" type="handle" alias="Point.ShapeFitter" desc="Shape fitter to use."/>
                        <param name="iterations" type="int" desc="Number of iterations."/>
                    </function>
                    <function name="fitCircle">
                        <trait>released</trait>
                        <links></links>
                        <desc>Fit a 2D circle to a set of 2D points using the current settings. Set the min and max radius to exactly the same value to fit a circle with a fixed radius.</desc>
                        <sample for="lua">circle, quality = Point.ShapeFitter.fitCircle(shapeFitter, points, minRadius, maxRadius)</sample>
                        <param name="shapeFitter" type="handle" alias="Point.ShapeFitter" desc="Shape fitter to use."/>
                        <param name="points" type="const object" multiplicity="+" alias="Point" desc="2D points to fit circle to."/>
                        <param name="minRadius" type="float" multiplicity="?" desc="Candidates with radius smaller than this are removed. Optional, default is no minimum limit."/>
                        <param name="maxRadius" type="float" multiplicity="?" desc="Candidates with radius larger than this are removed. Optional, default is no maximum limit."/>
                        <return name="circle" type="object" multiplicity="?" alias="Shape" desc="Fitted circle."/>
                        <return name="quality" type="float" multiplicity="*" desc="Vector with fitting quality measurements [meanError, inlierRate], where meanError is the average fitting error of inlier points and inlierRate is the rate of input points that were used to fit the final circle. For the least squares method, all points are used and the inlier rate is always 100%."/>
                    </function>
                    <function name="fitLine">
                        <trait>released</trait>
                        <links></links>
                        <desc>Fit a 2D line to a set of 2D points using the current settings. The returned line is a line segment which extends to precisely cover the orthogonal projections of the inliers onto the line. The line segment can be directly converted to a line.</desc>
                        <sample for="lua">lineSegment, quality = Point.ShapeFitter.fitLine(shapeFitter, points)</sample>
                        <param name="shapeFitter" type="handle" alias="Point.ShapeFitter" desc="Shape fitter to use."/>
                        <param name="points" type="const object" multiplicity="+" alias="Point" desc="2D points to fit line to."/>
                        <return name="lineSegment" type="object" multiplicity="?" alias="Shape" desc="Fitted line segment."/>
                        <return name="quality" type="float" multiplicity="*" desc="Vector with fitting quality measurements [meanError, inlierRate], where meanError is the average fitting error of inlier points and inlierRate is the rate of input points that were used to fit the final circle. For the least squares method, all points are used and the inlier rate is always 100%."/>
                    </function>
                    <function name="getInliers">
                        <trait>released</trait>
                        <desc>Get the inlier points used in the last call to any of the fit functions. Intended for visualization, parameter tuning and debugging.</desc>
                        <sample for="lua">inlierPoints = Point.ShapeFitter.getInliers(shapeFitter)</sample>
                        <param name="shapeFitter" type="handle" alias="Point.ShapeFitter" desc="Shape fitter to use."/>
                        <return name="inlierPoints" type="object" multiplicity="*" alias="Point" desc="Points used for the final fitting of the shape."/>
                    </function>
                </serves>
            </crown>
        </crown>
        <crown name="Matrix">
            <trait>released</trait>
            <desc>A 2D matrix of floating-point values.</desc>
            <serves>
                <function name="create">
                    <desc>Creates a new matrix.</desc>
                    <sample for="lua">local matrix = Matrix.create(rows, cols)</sample>
                    <param name="rows" type="int" desc="The number of rows"/>
                    <param name="cols" type="int" desc="The number of columns"/>
                    <return name="matrix" type="object" multiplicity="?" alias="Matrix" desc="The new matrix"/>
                </function>
                <function name="createIdentity">
                    <desc>Creates a new identity matrix.</desc>
                    <sample for="lua">local matrix = Matrix.createIdentity(size)</sample>
                    <param name="size" type="int" desc="The number of rows and columns"/>
                    <return name="matrix" type="object" multiplicity="?" alias="Matrix" desc="The new identity matrix"/>
                </function>
                <function name="createFromVector">
                    <desc>Creates a new matrix from a vector in row-major order.</desc>
                    <sample for="lua">local matrix = Matrix.createFromVector(vector, rows, cols)</sample>
                    <param name="vector" type="float" multiplicity="+" desc="The vector of elements to create the matrix from"/>
                    <param name="rows" type="int" desc="The number of rows"/>
                    <param name="cols" type="int" desc="The number of columns"/>
                    <return name="matrix" type="object" multiplicity="?" alias="Matrix" desc="The new matrix"/>
                </function>
                <function name="toVector">
                    <desc>Returns all elements of the matrix as vector in row-major order.</desc>
                    <sample for="lua">local vector = Matrix.toVector(matrix)</sample>
                    <param name="matrix" type="const object" alias="Matrix" desc="The matrix"/>
                    <return name="vector" type="float" multiplicity="+" desc="Matrix elements as vector in row-major order"/>
                </function>
                <function name="add">
                    <desc>Adds two matrices of the same size.</desc>
                    <sample for="lua">local matrix = Matrix.add(m1, m2)</sample>
                    <param name="m1" type="const object" alias="Matrix" desc="The first matrix to add"/>
                    <param name="m2" type="const object" alias="Matrix" desc="The second matrix to add"/>
                    <return name="matrix" type="object" multiplicity="?" alias="Matrix" desc="The sum"/>
                </function>
                <function name="subtract">
                    <desc>Subtracts two matrices of the same size.</desc>
                    <sample for="lua">local matrix = Matrix.subtract(m1, m2)</sample>
                    <param name="m1" type="const object" alias="Matrix" desc="The first matrix"/>
                    <param name="m2" type="const object" alias="Matrix" desc="The matrix to subtract from the first"/>
                    <return name="matrix" type="object" multiplicity="?" alias="Matrix" desc="The difference"/>
                </function>
                <function name="multiply">
                    <desc>Multiplies two matrices. The first matrix must have the same number of columns as the second matrix has rows.</desc>
                    <sample for="lua">local matrix = Matrix.multiply(m1, m2)</sample>
                    <param name="m1" type="const object" alias="Matrix" desc="The first matrix to multiply"/>
                    <param name="m2" type="const object" alias="Matrix" desc="The second matrix to multiply"/>
                    <return name="matrix" type="object" multiplicity="?" alias="Matrix" desc="The matrix product"/>
                </function>
                <function name="setValue">
                    <desc>Sets the value in the indexed matrix element. The first element has index (0,0).</desc>
                    <sample for="lua">Matrix.setValue(matrix, rowIndex, colIndex, value)</sample>
                    <param name="matrix" type="object" alias="Matrix" desc="The matrix in which to set a value"/>
                    <param name="rowIndex" type="int" desc="The row index of the matrix element to change"/>
                    <param name="colIndex" type="int" desc="The column index of the matrix element to change"/>
                    <param name="value" type="float" desc="The value to set"/>
                </function>
                <function name="getValue">
                    <desc>Returns the value of the indexed matrix element. The first element has index (0,0).</desc>
                    <sample for="lua">local value = Matrix.getValue(matrix, rowIndex, colIndex)</sample>
                    <param name="matrix" type="const object" alias="Matrix" desc="The matrix in which to get a value"/>
                    <param name="rowIndex" type="int" desc="The row index of the matrix element"/>
                    <param name="colIndex" type="int" desc="The column index of the matrix element"/>
                    <return name="value" type="float" multiplicity="?" desc="The value"/>
                </function>
                <function name="transpose">
                    <desc>Returns the transposed matrix.</desc>
                    <sample for="lua">local transposedMatrix = Matrix.transpose(matrix)</sample>
                    <param name="matrix" type="const object" alias="Matrix" desc="The instance to use"/>
                    <return name="transposedMatrix" type="object" alias="Matrix" desc="The transposed matrix."/>
                </function>
                <function name="setAll">
                    <desc>Sets the whole matrix to the same value.</desc>
                    <sample for="lua">Matrix.setAll(matrix, value)</sample>
                    <param name="matrix" type="object" alias="Matrix" desc="The matrix to set"/>
                    <param name="value" type="float" desc="The value with which to set the whole matrix."/>
                </function>
                <function name="addConstant">
                    <desc>Adds the value to each matrix element.</desc>
                    <sample for="lua">Matrix.addConstant(matrix, value)</sample>
                    <param name="matrix" type="object" alias="Matrix" desc="The matrix to add to"/>
                    <param name="value" type="float" desc="The value to add to each element in the matrix."/>
                </function>
                <function name="multiplyConstant">
                    <desc>Multiplies each matrix element with the value.</desc>
                    <sample for="lua">Matrix.multiplyConstant(matrix, value)</sample>
                    <param name="matrix" type="object" alias="Matrix" desc="The matrix to multiply by constant"/>
                    <param name="value" type="float" desc="The value with which to multiply all elements in the matrix."/>
                </function>
                <function name="getSize">
                    <desc>Returns the number of rows and columns of the matrix.</desc>
                    <sample for="lua">local rows, columns= Matrix.getSize(matrix)</sample>
                    <param name="matrix" type="const object" alias="Matrix" desc="The instance to use"/>
                    <return name="rows" type="int" desc="The number of rows in the matrix"/>
                    <return name="cols" type="int" desc="The number of columns in the matrix"/>
                </function>
                <function name="clone">
                    <desc>Duplicates the matrix.</desc>
                    <sample for="lua">local clonedMatrix = Matrix.clone(matrix)</sample>
                    <param name="matrix" type="const object" alias="Matrix" desc="The instance to use"/>
                    <return name="clonedMatrix" type="object" alias="Matrix" desc="The duplicated matrix"/>
                </function>
                <function name="invert">
                    <desc>Returns the inverse matrix.</desc>
                    <sample for="lua">local inversedMatrix = Matrix.invert(matrix)</sample>
                    <param name="matrix" type="const object" alias="Matrix" desc="The instance to use"/>
                    <return name="inversedMatrix" type="object" multiplicity="?" alias="Matrix" desc="The inverse matrix."/>
                </function>
                <function name="toString">
                    <desc>Get a string representation of the matrix.</desc>
                    <sample for="lua">print("The matrix is: " .. Matrix.toString(matrix))</sample>
                    <param name="matrix" type="const object" alias="Matrix" desc="Input matrix"/>
                    <return name="str" type="string" desc="String representation of the matrix"/>
                </function>
                <function name="tile">
                    <desc>Returns an n-by-m tiling of the matrix.</desc>
                    <sample for="lua">local tileMatrix = Matrix.tile(matrix, n, m)</sample>
                    <param name="matrix" type="const object" alias="Matrix" desc="The matrix to tile"/>
                    <param name="n" type="int" desc="The number of vertical repetitions"/>
                    <param name="m" type="int" desc="The number of horizontal repetitions"/>
                    <return name="tileMatrix" type="object" multiplicity="?" alias="Matrix" desc="The new matrix"/>
                </function>
                <function name="concatenate">
                    <desc>Returns the concatenation of the two matrices.</desc>
                    <sample for="lua">local concatMatrix = Matrix.concatenate(m1, m2, concatHorizontally)</sample>
                    <param name="m1" type="const object" alias="Matrix" desc="The first matrix to concatenate"/>
                    <param name="m2" type="const object" alias="Matrix" desc="The second matrix to concatenate"/>
                    <param name="concatHorizontally" type="bool" desc="If the concatenation shall be horizontally or vertically"/>
                    <return name="concatMatrix" type="object" multiplicity="?" alias="Matrix" desc="The new matrix"/>
                </function>
                <function name="getColumn">
                    <desc>Returns one or multiple columns of the matrix. The columns are returned as a MxK matrix, where M is the number of rows of the original matrix and K is the number of column indices in colIndex.</desc>
                    <sample for="lua">local columns = Matrix.getColumn(matrix, colIndex)</sample>
                    <param name="matrix" type="const object" alias="Matrix" desc="The matrix from which to get the columns"/>
                    <param name="colIndex" type="int" multiplicity="[1+]" desc="The index of the matrix columns"/>
                    <return name="columns" type="object" multiplicity="?" alias="Matrix" desc="The wanted matrix columns"/>
                </function>
                <function name="setColumn">
                    <desc>Sets one or multiple columns of the matrix.</desc>
                    <sample for="lua">Matrix.setColumn(matrix, colIndex, newColumn)</sample>
                    <param name="matrix" type="object" alias="Matrix" desc="The matrix in which to set the columns"/>
                    <param name="colIndex" type="int" multiplicity="[1+]" desc="The indices of the matrix columns to set"/>
                    <param name="newColumn" type="const object" alias="Matrix" desc="The new matrix columns to set"/>
                    <return name="success" type="bool" desc="True is input is valid"/>
                </function>
                <function name="getRow">
                    <desc>Returns one or multiple rows of the matrix. The rows are returned as a KxN matrix, where N is the number of columns of the original matrix and K is the number of row indices in rowIndex.</desc>
                    <sample for="lua">local rows = Matrix.getRow(matrix, rowIndex)</sample>
                    <param name="matrix" type="const object" alias="Matrix" desc="The matrix from which to get the rows"/>
                    <param name="rowIndex" type="int" multiplicity="[1+]" desc="The index of the matrix rows"/>
                    <return name="rows" type="object" multiplicity="?" alias="Matrix" desc="The wanted matrix rows"/>
                </function>
                <function name="setRow">
                    <desc>Sets one or multiple rows of the matrix.</desc>
                    <sample for="lua">Matrix.setRow(matrix, rowIndex, newRow)</sample>
                    <param name="matrix" type="object" alias="Matrix" desc="The matrix in which to set the rows"/>
                    <param name="rowIndex" type="int" multiplicity="[1+]" desc="The index of the matrix rows to set"/>
                    <param name="newRow" type="const object" alias="Matrix" desc="The new matrix rows"/>
                    <return name="success" type="bool" desc="True is input is valid"/>
                </function>
                <function name="norm">
                    <desc>Returns the Frobenius norm of the matrix, the square root of the sum of the squares of its elements.</desc>
                    <sample for="lua">local norm = Matrix.norm(matrix)</sample>
                    <param name="matrix" type="const object" alias="Matrix" desc="The matrix to calculate the norm for"/>
                    <return name="norm" type="float" desc="The norm of the matrix"/>
                </function>
                <function name="sumRows">
                    <desc>Computes the sum of each row. The row sums are returned as a Mx1 column matrix.</desc>
                    <sample for="lua">local rowSums = Matrix.sumRows(matrix)</sample>
                    <param name="matrix" type="const object" alias="Matrix" desc="The matrix in which to calculate the row sums"/>
                    <return name="rowSums" type="object" alias="Matrix" desc="The row sums of the matrix"/>
                </function>
                <function name="sumColumns">
                    <desc>Computes the sum of each column. The column sums are returned as a 1xN row matrix.</desc>
                    <sample for="lua">local columnSums = Matrix.sumColumns(matrix)</sample>
                    <param name="matrix" type="const object" alias="Matrix" desc="The matrix in which to calculate the column sums"/>
                    <return name="columnSums" type="object" alias="Matrix" desc="The column sums of the matrix"/>
                </function>
                <function name="max">
                    <desc>Returns the maximum value of the matrix.</desc>
                    <sample for="lua">local max = Matrix.max(matrix)</sample>
                    <param name="matrix" type="const object" alias="Matrix" desc="The matrix in which to find the maximum value"/>
                    <return name="max" type="float" desc="The maximum value of the matrix"/>
                </function>
                <function name="min">
                    <desc>Returns the minimum value of the matrix.</desc>
                    <sample for="lua">local min = Matrix.min(matrix)</sample>
                    <param name="matrix" type="const object" alias="Matrix" desc="The matrix in which to find the minimum value"/>
                    <return name="min" type="float" desc="The minimum value of the matrix"/>
                </function>
                <function name="determinant">
                    <desc>Returns the determinant of the matrix.</desc>
                    <sample for="lua">local det = Matrix.determinant(matrix)</sample>
                    <param name="matrix" type="const object" alias="Matrix" desc="The matrix for which to calculate the determinant"/>
                    <return name="det" type="float" multiplicity="?" desc="The determinant of the matrix"/>
                </function>
                <function name="toPoints">
                    <desc>Converts a matrix to a vector of 2D or 3D points.</desc>
                    <sample for="lua">points = Matrix.toPoints(matrix, storedInColumns)</sample>
                    <param name="matrix" type="const object" alias="Matrix" desc="Matrix to convert to vector of points."/>
                    <param name="storedInColumns" type="bool" desc="True if the points are in the columns of the matrix, false if in the rows of the matrix."/>
                    <return name="points" type="object" multiplicity="[1+]" alias="Point" desc="Points created from the matrix."/>
                </function>
                <function name="toImage">
                    <desc>Converts a matrix to a float64 image.</desc>
                    <sample for="lua">image = Matrix.toImage(matrix)</sample>
                    <param name="matrix" type="const object" alias="Matrix" desc="Matrix to convert to image."/>
                    <return name="image" type="object" alias="Image" desc="Image created from the matrix."/>
                </function>
                <function name="svd">
                    <desc>Computes the singular value decomposition of an NxM matrix.
U is the left singular vectors and U the right singular vectors corresponding to singular values S.
In both U and V vectors are in the columns of each matrix such that matrix = U*diag(S)*V^T.</desc>
                    <sample for="lua">u, s, v = Matrix.svd(matrix)</sample>
                    <param name="matrix" type="const object" alias="Matrix" desc="Matrix to decompose."/>
                    <return name="u" type="object" multiplicity="?" alias="Matrix" desc="The left singular vectors with each vector in a column."/>
                    <return name="s" type="float" multiplicity="*" desc="The singular values of the input matrix."/>
                    <return name="v" type="object" multiplicity="?" alias="Matrix" desc="The right singular vectors with each vector in a column."/>
                </function>
                <function name="solve">
                    <desc>Computes the least squares solution to the equation system Ax = b.
A is an NxM matrix.
b is an Nx1 matrix.
x is an Mx1 matrix and the solution to the equation system.</desc>
                    <sample for="lua">x, residual = Matrix.solve(a, b)</sample>
                    <param name="a" type="const object" alias="Matrix" desc="NxM matrix describing the left side of the equation system."/>
                    <param name="b" type="const object" alias="Matrix" desc="Nx1 matrix describing the right side of the equation system."/>
                    <return name="x" type="object" multiplicity="?" alias="Matrix" desc="Mx1 matrix containing the solution to the equation system."/>
                    <return name="residual" type="float" multiplicity="?" desc="The average error by calculating (Ax - b).norm()/b.norm()."/>
                </function>
            </serves>
            <uses/>
        </crown>
        <crown name="Shape">
            <trait>released</trait>
            <desc>A 2D geometric primitive. A Shape can be one of the geometric types Line, LineSegment, Polyline, Rectangle, Circle, Ellipse, Arc or Sector. The Shape object is represented in mathematical analytical form. Operations such as finding intersection points, distances and transforming the Shape are for this reason efficiently computed.

Note when used in context of images: The Shapes are defined in the image world coordinate system, i.e., in world scale (typically millimeters) and not in pixel coordinates. The image world coordinate system is left handed, with the x-axis pointing rightwards and the y-axis pointing downwards, and the origin centered at the upper left pixel. In this coordinate system, positive translations along the y-axis will shift the shape downwards, and positive rotations are clockwise. Thus, this is different compared to usage in a right-handed coordinate system context.</desc>
            <enum name="ShapeType">
                <item name="Line" desc="Line shape (infinite length)">LINE</item>
                <item name="Line segment" desc="Line segment shape">LINE_SEGMENT</item>
                <item name="Polyline" desc="Polyline shape, open or closed">POLYLINE</item>
                <item name="Rectangle" desc="Rectangle shape (possibly rotated)">RECTANGLE</item>
                <item name="Circle" desc="Circle shape">CIRCLE</item>
                <item name="Ellipse" desc="Ellipse shape">ELLIPSE</item>
                <item name="Arc" desc="Arc shape, i.e. a part of a circle contour limited by two angles">ARC</item>
                <item name="Sector" desc="Sector shape enclosing a region limited by two angles, an inner and an outer radius">SECTOR</item>
            </enum>
            <enum name="PointFitMode" trait="released">
                <item name="leastsquares" desc="Ordinary least squares">LEASTSQUARES</item>
                <item name="ransac" desc="Ransac (random sampling with outlier rejection)">RANSAC</item>
                <item name="adaptive" desc="Ransac with rank-margin. This mode is deprecated and may be removed in a future version. Please use RANSAC and call setOutlierMargin with the margin type set to RANK instead." trait="deprecated">ADAPTIVE</item>
                <item name="trimmed" desc="Two-stage least squares fitting. The second stage uses only points within the margin around the fitted shape of the first stage.">TRIMMED</item>
            </enum>
            <enum name="OutlierMarginType" trait="released">
                <item name="absolute" desc="Absolute outlier margin, defined in world coordinate units (typically mm).">ABSOLUTE</item>
                <item name="rank" desc="Rank-based margin, defines the rate of points to include. For example, A rank margin of 0.7 means that the best 70% of all points are included and the rest are ignored.">RANK</item>
            </enum>
            <serves>
                <function name="appendPoint">
                    <desc>Append a point to a polyline shape.</desc>
                    <sample for="lua">Shape.appendPoint(polyline, Point.create(x, y))</sample>
                    <param name="shape" type="object" alias="Shape" desc="The shape to modify. Must be a polyline shape."/>
                    <param name="point" type="const object" alias="Point" desc="2D point to add."/>
                </function>
                <function name="createCircle">
                    <desc>Create circle shape(s). By providing vectors of centers and radii, several circles can be created. Center can be a single point or a vector. If it is a vector, radius must either be a vector of the same size of a singular value.</desc>
                    <sample for="lua">circle = Shape.createCircle(centerPoint, radius)</sample>
                    <param name="center" type="const object" multiplicity="[1+]" alias="Point" desc="A single 2D Point or a vector of points. If the input is a vector, a vector of circles is created."/>
                    <param name="radius" type="float" multiplicity="[1+]" desc="Circle radius. Must be non-negative. Can also be a vector to create several circles."/>
                    <return name="circle" type="object" multiplicity="[?*]" alias="Shape" desc="The created circle or vector of circles."/>
                </function>
                <function name="createEllipse">
                    <trait>released</trait>
                    <links>Shape3D.createEllipse, Shape.getEllipseParameters</links>
                    <desc>Create an ellipse shape. Radii must be non-negative. By providing vectors of centers, radiusX, radiusY and rotation, several ellipses can be created. All vectors must be of equal length.</desc>
                    <sample for="lua">ellipse = Shape.createEllipse(centerPoint, radiusX, radiusY, rotation)</sample>
                    <param name="center" type="const object" multiplicity="[1+]" alias="Point" desc="Center point (2D). Can also be a vector of centre points to create several ellipses."/>
                    <param name="radiusX" type="float" multiplicity="[1+]" desc="Radius along the x axis (before rotation). Can also be a vector of radii to create several ellipses."/>
                    <param name="radiusY" type="float" multiplicity="[1+]" desc="Radius along the y axis (before rotation). Can also be a vector of radii to create several ellipses."/>
                    <param name="rotation" type="float" multiplicity="[?*]" desc="Ellipse rotation in radians. Can also be a vector of rotations to create several ellipses. A positive rotation rotates the x-axis towards the y-axis. Note that when used as region for an image, the image has a left-hand system with the y-axis pointing downwards, in which a positive rotation means a clockwise direction."/>
                    <return name="ellipse" type="object" multiplicity="[?*]" alias="Shape" desc="The created ellipse, or vector of ellipses for for vector input."/>
                </function>
                <function name="createLine">
                    <trait>released</trait>
                    <links>Shape3D.createLine, Shape.getLineParameters</links>
                    <desc>Create an infinite line shape that connects (and extends beyond) two given points. The points must not be the same. By providing vectors of end-points, several infinite lines can be created. The vectors must be of equal length.</desc>
                    <sample for="lua">line = Shape.createLine(point1, point2)</sample>
                    <param name="point1" type="const object" multiplicity="[1+]" alias="Point" desc="A point (2D) on the line. Can also be a vector of points to create several lines."/>
                    <param name="point2" type="const object" multiplicity="[1+]" alias="Point" desc="Another point (2D) on the line. Can also be a vector of points to create several lines."/>
                    <return name="line" type="object" multiplicity="[?*]" alias="Shape" desc="The created line, or vector of lines for for vector input."/>
                </function>
                <function name="createLineSegment">
                    <desc>Create a finite length line segment between two given endpoints. By providing vectors of end-points, several line segments can be created.</desc>
                    <sample for="lua">lineSegment = Shape.createLineSegment(point1, point2)</sample>
                    <param name="point1" type="const object" multiplicity="[1+]" alias="Point" desc="First endpoint (2D) of the line segment. Can also be a vector of points to create several line segments."/>
                    <param name="point2" type="const object" multiplicity="[1+]" alias="Point" desc="Second endpoint (2D) of the line segment. For vector input the length of the vector must match the vector containing the first endpoints"/>
                    <return name="lineSegment" type="object" multiplicity="[?*]" alias="Shape" desc="The created line segment, or vector of line segments for for vector input."/>
                </function>
                <function name="createPolyline">
                    <desc>Create a polyline shape (sequence of line segments connected to an open contour or closed polygon).</desc>
                    <sample for="lua">polyline = Shape.createPolyline(points, true)</sample>
                    <param name="points" type="const object" multiplicity="+" alias="Point" desc="List of points (2D) to connect to a polyline"/>
                    <param name="closed" type="bool" desc="If true, the first and last points are connected to form a closed polygon. Otherwise it becomes an open contour."/>
                    <return name="polyline" type="object" multiplicity="?" alias="Shape" desc="The created polyline or polygon shape"/>
                </function>
                <function name="createRectangle">
                    <trait>released</trait>
                    <links>Shape3D.createRectangle, Shape.getRectangleParameters</links>
                    <desc>Create a rectangle shape. Width and height must be non-negative. By providing vectors of centers, width, height and rotation, several rectangles can be created. All vectors must be of equal length.</desc>
                    <sample for="lua">rectangle = Shape.createRectangle(center, width, height, rotation)</sample>
                    <param name="center" type="const object" multiplicity="[1+]" alias="Point" desc="Center point (2D) of the rectangle. Can also be a vector of center points to create several rectangles."/>
                    <param name="width" type="float" multiplicity="[1+]" desc="Rectangle width (size along the x axis before rotation). Can also be a vector of center points to create several rectangles."/>
                    <param name="height" type="float" multiplicity="[1+]" desc="Rectangle height (size along the y axis before rotation). Can also be a vector of heights to create several rectangles."/>
                    <param name="rotation" type="float" multiplicity="[?*]" desc="Optional rectangle rotation in radians, default is zero. A positive rotation rotates the x-axis towards the y-axis. Note that when used as region for an image, the image has a left-hand system with the y-axis pointing downwards, in which a positive rotation means a clockwise direction. Can also be a vector of rotations to create several rectangles."/>
                    <return name="rectangle" type="object" multiplicity="[?*]" alias="Shape" desc="The created rectangle shape, or vector of rectangles for for vector input."/>
                </function>
                <function name="createArc">
                    <trait>released</trait>
                    <links>Shape.getArcParameters</links>
                    <desc>Create an arc shape (part of a circle). Radius and deltaAngle must be non-negative. By providing vectors of centers, radii, angles and delta angle several arcs can be created. All vectors must be of equal length.</desc>
                    <sample for="lua">arc = Shape.createArc(centerPoint, radius, angle, deltaAngle)</sample>
                    <param name="center" type="const object" multiplicity="[1+]" alias="Point" desc="Center point (2D) of the arc. Can also be a vector of center points to create several arcs."/>
                    <param name="radius" type="float" multiplicity="[1+]" desc="Arc radius. Can also be a vector of radii to create several arcs."/>
                    <param name="angle" type="float" multiplicity="[1+]" desc="Angle where the arc starts, in radians. Can also be a vector of angles to create several arcs."/>
                    <param name="deltaAngle" type="float" multiplicity="[1+]" desc="The angular length of the arc, in radians. Can also be a vector of delta angles to create several sectarcsors."/>
                    <return name="arc" type="object" multiplicity="[?*]" alias="Shape" desc="The created arc, or vector of arcs for for vector input."/>
                </function>
                <function name="createSector">
                    <trait>released</trait>
                    <links>Shape.getSectorParameters</links>
                    <desc>Create a circular sector defining a region contained within two angles, an inner and an outer radius. Radii and deltaAngle must be non-negative, outerRadius must be larger than innerRadius. By providing vectors of centers, innerRadius, outerRadius, angle and deltaAngle several sectors can be created. All vectors must be of equal length.</desc>
                    <sample for="lua">sector = Shape.createSector(center, innerRadius, outerRadius, angle, deltaAngle)</sample>
                    <param name="center" type="const object" multiplicity="[1+]" alias="Point" desc="Center point of the circle from which the sector is defined. Can also be a vector of center points to create several sectors."/>
                    <param name="innerRadius" type="float" multiplicity="[1+]" desc="Inner radius of the sector. Can also be a vector of inner radii to create several sectors."/>
                    <param name="outerRadius" type="float" multiplicity="[1+]" desc="Outer radius of the sector. Can also be a vector of outer radii to create several sectors."/>
                    <param name="angle" type="float" multiplicity="[1+]" desc="Angle where the sector starts, in radians. Can also be a vector of angles to create several sectors."/>
                    <param name="deltaAngle" type="float" multiplicity="[1+]" desc="The angular length of the sector, in radians. Can also be a vector of delta angles to create several sectors."/>
                    <return name="sector" type="object" multiplicity="[?*]" alias="Shape" desc="The created sector, or vector of sectors for for vector input."/>
                </function>
                <function name="getType">
                    <desc>Return the geometric type the Shape represents.</desc>
                    <sample for="lua">shapeType = Shape.getType(shape)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape" desc="The shape or shapes to check."/>
                    <return name="shapeType" type="enum" multiplicity="[?*]" ref="ShapeType" desc="The shape type or vector with shape types."/>
                </function>
                <function name="getArcParameters">
                    <desc>Get the parameters defining the arc. Can only be called for arc shapes (returns nil otherwise). A vector of arc shapes can be provided, in which case vectors of parameters are returned.</desc>
                    <sample for="lua">center, radius, angleRad, deltaAngleRad = Shape.getArcParameters(arc)</sample>
                    <param name="arc" type="const object" multiplicity="[1+]" alias="Shape" desc="Input arc shape or vector of arc shapes."/>
                    <return name="center" type="object" multiplicity="[?*]" alias="Point" desc="Center point of the circle from which the arc is defined, or vector of center points for vector input."/>
                    <return name="radius" type="float" multiplicity="[?*]" desc="Radius of the arc, or vector of radii for vector input."/>
                    <return name="angleRad" type="float" multiplicity="[?*]" desc="Angle where the arc starts, in radians, or vector of angles for vector input."/>
                    <return name="deltaAngleRad" type="float" multiplicity="[?*]" desc="The angular length of the arc, in radians, or vector of angular lengths for vector input."/>
                </function>
                <function name="getCircleParameters">
                    <desc>Get the parameters defining the circle. Can only be called for circle shapes (returns nil otherwise). A vector of circle shapes can be provided, in which case vectors of parameters are returned.</desc>
                    <sample for="lua">center, radius = Shape.getCircleParameters(circle)</sample>
                    <param name="circle" type="const object" multiplicity="[1+]" alias="Shape" desc="Input circle shape or vector of circle shapes."/>
                    <return name="center" type="object" multiplicity="[?*]" alias="Point" desc="Center point of the circle, or vector of center points for vector input."/>
                    <return name="radius" type="float" multiplicity="[?*]" desc="Radius of the circle, or vector of radii for vector input."/>
                </function>
                <function name="getEllipseParameters">
                    <desc>Get the parameters defining the ellipse. Can only be called for ellipse shapes (returns nil otherwise). A vector of ellipse shapes can be provided, in which case vectors of parameters are returned.</desc>
                    <sample for="lua">center, radiusX, radiusY, rotationRad = Shape.getEllipseParameters(ellipse)</sample>
                    <param name="ellipse" type="const object" multiplicity="[1+]" alias="Shape" desc="Input ellipse shape or vector of ellipse shapes."/>
                    <return name="center" type="object" multiplicity="[?*]" alias="Point" desc="Center point (2D), or vector of center points for vector input."/>
                    <return name="radiusX" type="float" multiplicity="[?*]" desc="Radius along the x axis (before rotation), or vector of radii for vector input."/>
                    <return name="radiusY" type="float" multiplicity="[?*]" desc="Radius along the y axis (before rotation), or vector of radii for vector input."/>
                    <return name="rotationRad" type="float" multiplicity="[?*]" desc="Ellipse rotation, in radians. Vector of rotations for vector input."/>
                </function>
                <function name="getLineParameters">
                    <desc>Get the parameters defining the line or line segment. Can only be called for line or line segment shapes (returns nil otherwise). For line segments, the two endpoints are returned. For lines, the first point used to define the line is returned, the second point is one unit distance away from the first point along the line. A vector of line or line segment shapes can be provided, in which case two vectors of parameters are returned.</desc>
                    <sample for="lua">point1, point2 = Shape.getLineParameters(line)</sample>
                    <param name="line" type="const object" multiplicity="[1+]" alias="Shape" desc="Input line or line segment shape or vector of line or line segment shapes."/>
                    <return name="point1" type="object" multiplicity="[?*]" alias="Point" desc="First line segment endpoint or one point on the line, or vector of points for vector input."/>
                    <return name="point2" type="object" multiplicity="[?*]" alias="Point" desc="Second line segment endpoint or another point on the line, or vector of points for vector input."/>
                </function>
                <function name="getPolylineParameters">
                    <desc>Get the points defining the polyline and a flag indicating if the polyline is closed.</desc>
                    <sample for="lua">points, closed = Shape.getPolylineParameters(polyline)</sample>
                    <param name="polyline" type="const object" alias="Shape" desc="The polyline."/>
                    <return name="points" type="object" multiplicity="*" alias="Point" desc="Vertices for the polyline."/>
                    <return name="closed" type="bool" multiplicity="?" desc="If true, the first and last points are connected to form a closed polygon. Otherwise it is an open contour."/>
                </function>
                <function name="getRectangleParameters">
                    <desc>Get the parameters defining the rectangle. Can only be called for rectangle shapes (returns nil otherwise). A vector of rectangle shapes can be provided, in which case three vectors of parameters are returned.</desc>
                    <sample for="lua">center, width, height, rotationRad = Shape.getRectangleParameters(rectangle)</sample>
                    <param name="rectangle" type="const object" multiplicity="[1+]" alias="Shape" desc="Input rectangle shape or vector of rectangle shapes."/>
                    <return name="center" type="const object" multiplicity="[?*]" alias="Point" desc="Center point (2D) of the rectangle, or vector of center points for vector input."/>
                    <return name="width" type="float" multiplicity="[?*]" desc="Rectangle width (size along the x axis before rotation), or vector of widths for vector input."/>
                    <return name="height" type="float" multiplicity="[?*]" desc="Rectangle height (size along the y axis before rotation), or vector of heights for vector input."/>
                    <return name="rotation" type="float" multiplicity="[?*]" desc="Rectangle rotation in radians. Counter-clockwise rotation in an x/y coordinate system. Vector of rotations for vector input."/>
                </function>
                <function name="getSectorParameters">
                    <desc>Get the parameters defining the sector. Can only be called for sector shapes (returns nil otherwise). A vector of sector shapes can be provided, in which case vectors of parameters are returned.</desc>
                    <sample for="lua">center, innerRadius, outerRadius, angleRad, deltaAngleRad = Shape.getSectorParameters(sector)</sample>
                    <param name="sector" type="const object" multiplicity="[1+]" alias="Shape" desc="Input sector shape or vector of sector shapes."/>
                    <return name="center" type="object" multiplicity="[?*]" alias="Point" desc="Center point of the circle from which the sector is defined, or vector of center points for vector input."/>
                    <return name="innerRadius" type="float" multiplicity="[?*]" desc="Inner radius of the sector, or vector of inner radii for vector input."/>
                    <return name="outerRadius" type="float" multiplicity="[?*]" desc="Outer radius of the sector, or vector of outer radii for vector input."/>
                    <return name="angleRad" type="float" multiplicity="[?*]" desc="Angle where the sector starts, in radians, or vector of angles for vector input."/>
                    <return name="deltaAngleRad" type="float" multiplicity="[?*]" desc="The angular length of the sector, in radians. Vector of angular lengths for vector input."/>
                </function>
                <function name="clone">
                    <desc>Create an independent copy of this shape. If the input is a vector of shapes, the output is a vector of shapes.</desc>
                    <sample for="lua">outputShape = Shape.clone(inputShape)</sample>
                    <param name="inputShape" type="const object" multiplicity="[1+]" alias="Shape" desc="The shape to clone."/>
                    <return name="outputShape" type="object" multiplicity="[?*]" alias="Shape" desc="The new copy."/>
                </function>
                <function name="isClosed">
                    <desc>Check if this is a closed shape. A contour is closed if it has no endpoints and encloses an area. For example, a circle is closed while a line segment is not.</desc>
                    <sample for="lua">isClosed = Shape.isClosed(shape)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape" desc="The shape or shapes to check"/>
                    <return name="isClosed" type="bool" multiplicity="[?*]" desc="True if the shape is closed, otherwise false"/>
                </function>
                <function name="contains">
                    <desc>Check if the input point is contained within the enclosed area of the given shape. Always returns false if the shape is not closed.
If more than one shape is provided true is returned if the point is inside any of the shapes.
If more than one point is provided a vector is returned with one value for each input point.</desc>
                    <sample for="lua">isInside = Shape.contains(shape, point)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape" desc="Closed shape enclosing an area"/>
                    <param name="point" type="const object" multiplicity="[1+]" alias="Point" desc="Point (2D) to check if contained within the area"/>
                    <return name="isInside" type="bool" multiplicity="[1+]" desc="True if the point is contained within the enclosed area, false if not"/>
                </function>
                <function name="getContourPoints">
                    <desc>Get the points defining the shape contour. Only supported for shapes consisting of a finite number of points (line segments, rectangles and polylines). To get a polygon approximation of a circle or ellipse, use toPolyline.</desc>
                    <sample for="lua">points = Shape.getContourPoints(shape)</sample>
                    <param name="shape" type="const object" alias="Shape" desc="Shape to process"/>
                    <return name="points" type="object" multiplicity="+" alias="Point" desc="List of points (2D) that approximates or represents the input shape."/>
                </function>
                <function name="toLine">
                    <desc>Convert a line segment or a vector of line segments to infinite lines. Only supports line segment input.</desc>
                    <sample for="lua">line = Shape.toLine(lineSegment)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape" desc="Line segment or vector of line segments to convert."/>
                    <return name="line" type="object" multiplicity="[?*]" alias="Shape" desc="Line or vector of lines created by extending the line segment end points to infinity."/>
                </function>
                <function name="toPolyline">
                    <desc>Convert this shape to a polyline shape, approximating the true shape if needed (if the true shape is a circle, ellipse or arc).
For a shape that is already a polyline, this function can be used to approximate it with a less detailed polyline.</desc>
                    <sample for="lua">polylineShape = Shape.toPolyline(shape, epsilon)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape" desc="Shape to convert, or vector of shapes."/>
                    <param name="epsilon" type="float" desc="Maximum approximation error in the polyline approximation."/>
                    <param name="maxPoints" type="int" multiplicity="?" desc="Maximum number of points to use in the approximation (default is 1000). This is a stronger requirement than the epsilon and puts a limit on the function memory usage."/>
                    <return name="polylineShape" type="object" multiplicity="[?*]" alias="Shape" desc="The shape represented as a polyline, or vector of polylines."/>
                </function>
                <function name="cropLine">
                    <desc>Returns the part of a line within a rectangle as a new line segment. If the line does not intersect the rectangle, nil is returned. Several lines in a vector can be cropped at once, in which case all lines must be within the box for the call to succeed.</desc>
                    <sample for="lua">lineSegment = Shape.cropLine(line, rectangle)</sample>
                    <param name="line" type="const object" multiplicity="[1+]" alias="Shape" desc="The line shape to be cropped, or a vector of lines to be cropped."/>
                    <param name="rectangle" type="const object" alias="Shape" desc="The rectangle to keep the line within."/>
                    <return name="line" type="object" multiplicity="[?*]" alias="Shape" desc="The part of the line within the rectangle as a line segment, or a vector of line segments. Nil is returned if any line is outside the box."/>
                </function>
                <function name="getClosestContourPoint">
                    <desc>Get the closest point on a shape contour to a given external point. Fails if the point is not a 2D point.
If there are more than one shape provided the closest point on any shape countour is returned.
If there are more than one point provided one point is returned for each input point.</desc>
                    <sample for="lua">closestPoint = Shape.getClosestContourPoint(shape, point)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape" desc="Shape to process."/>
                    <param name="point" type="const object" multiplicity="[1+]" alias="Point" desc="Point to process."/>
                    <return name="closestPoint" type="object" multiplicity="[?*]" alias="Point" desc="Closest point on any of the shapes."/>
                    <return name="distance" type="float" multiplicity="[?*]" desc="The distance to the closest point."/>
                </function>
                <function name="getConvexHull">
                    <links>Shape.toPolyline</links>
                    <desc>Gets the convex hull of a given shape. Currently fails if the shape is something other than a polyline. Convert general shapes to polylines using Shape.toPolyline.</desc>
                    <sample for="lua">hull = Shape.getConvexHull(shape)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape" desc="Shape or shapes to process."/>
                    <return name="hull" type="object" multiplicity="[?*]" alias="Shape" desc="Resulting convex hull as a polyline, or vector for vector input."/>
                </function>
                <function name="getConvexHullSimple">
                    <trait>hidden</trait>
                    <desc>Gets the convex hull of a given simple shape. Currently fails if the shape is something other than a polyline.</desc>
                    <sample for="lua">polyline2 = Shape.getConvexHullSimple(polyline)</sample>
                    <param name="polyline" type="const object" multiplicity="[1+]" alias="Shape" desc="Shape or shapes one wants the hull of. Must be polyline."/>
                    <return name="polyline2" type="object" multiplicity="[?*]" alias="Shape" desc="Resulting convex hull as a polyline, or vector for vector input."/>
                </function>
                <function name="getConvexity">
                    <desc>Returns a measure of how convex a given shape is, as a number between 0.0 and 1.0. It is given as a quotient between the area of the shape and its convex hull. A convex object has convexity 1.0. All open shapes such as lines, arcs and open polylines return 0.</desc>
                    <sample for="lua">convexity = Shape.getConvexity(shape)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape" desc="Input shape or vector of shapes."/>
                    <return name="convexity" type="float" multiplicity="[?*]" desc="A measure of how convex the shape is, or vector of measurements for vector input."/>
                </function>
                <function name="getIntersectionPoints">
                    <desc>Get points on the intersection between two shape contours.</desc>
                    <sample for="lua">points = Shape.getIntersectionPoints(shape1, shape2)</sample>
                    <param name="shape1" type="const object" alias="Shape" desc="First shape to intersect."/>
                    <param name="shape2" type="const object" alias="Shape" desc="Second shape to intersect."/>
                    <return name="points" type="object" multiplicity="*" alias="Point" desc="List of intersection points."/>
                </function>
                <function name="getIntersectionAngle">
                    <desc>Get angle of the intersection between two lines or line segments.
If the line segments do not intersect the lines are extrapolated to calculate the intersection angle.</desc>
                    <sample for="lua">angle = Shape.getIntersectionAngle(line1, line2)</sample>
                    <param name="line1" type="const object" multiplicity="[1+]" alias="Shape" desc="First shape. Must be a line or line segment."/>
                    <param name="line2" type="const object" multiplicity="[1+]" alias="Shape" desc="Second shape. Must be a line or line segment."/>
                    <return name="angle" type="float" multiplicity="[?*]" desc="Intersection angle, in radians."/>
                </function>
                <function name="getBoundingBox">
                    <desc>Get a rectangular axis-aligned bounding box of the shape (minimum box that contains the shape). The returned box is another Shape object. To get the actual bounds as float values, call getBounds.</desc>
                    <sample for="lua">boundingBox = Shape.getBoundingBox(shape)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape" desc="Input shape or shapes"/>
                    <return name="boundingBox" type="object" multiplicity="[?*]" alias="Shape" desc="Axis-aligned bounding box as a rectangle shape, or vector for vector input."/>
                </function>
                <function name="getBoundingBoxOriented">
                    <desc>Gets a rectangular rotated bounding box of the given shape. This is the minimum area rectangle that still contains the shape. The return box is another Shape object.</desc>
                    <sample for="lua">minimumAreaRectangle = Shape.getBoundingBoxOriented(shape)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape" desc="Input shape or shapes."/>
                    <return name="minimumAreaRectangle" type="object" multiplicity="[?*]" alias="Shape" desc="The oriented minimum area bounding box, or vector for vector input."/>
                </function>
                <function name="transform">
                    <desc>Transform a shape or a vector of shapes. Fails if the transform is not a 2D transform or if the transform would change the underlying shape type.</desc>
                    <sample for="lua">outputShape = Shape.transform(shape, transform)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape" desc="Input shape or shapes."/>
                    <param name="transform" type="const object" alias="Transform" desc="Transform to apply."/>
                    <return name="outputShape" type="object" multiplicity="[?*]" alias="Shape" desc="Transformed shape or shapes, or nil on error."/>
                </function>
                <function name="rotate">
                    <desc>Rotate the shape. The rotation center is optional. If not provided, the nominal center of the shape is used. For most shapes, this is the same point as the center of gravity. For arcs and sectors, the nominal center is the center of the base circle.
Note on rotation direction: When a shape is used for defining a region in an image, it is interpreted in the left handed coordinate system of the image. In a left-handed system, a positive rotation is in the clockwise direction.</desc>
                    <sample for="lua">outputShape = Shape.rotate(shape, rotationAngle, rotationCenter)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape" desc="Input shape or shapes."/>
                    <param name="rotationAngle" type="float" desc="The rotation angle in radians"/>
                    <param name="rotationCenter" type="const object" multiplicity="?" alias="Point" desc="The rotation center. The nominal center of the shape is used if unspecified."/>
                    <return name="outputShape" type="object" multiplicity="[?*]" alias="Shape" desc="The rotated shape or shapes, or nil if the input shape is invalid."/>
                </function>
                <function name="translate">
                    <desc>Translate the shape, i.e., shift it along the x,y-axes.
Note on translation direction: When a shape is used for defining a region in an image, it is interpreted in the left handed coordinate system of the image in which the y-axis is pointing downwards. A positive translation therefore shifts the shape downwards when overlaid on top of the image.</desc>
                    <sample for="lua">outputShape = Shape.translate(shape, translationX, translationY)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape" desc="Input shape or shapes"/>
                    <param name="translationX" type="float" desc="The translation along the X-axis"/>
                    <param name="translationY" type="float" desc="The translation along the Y-axis"/>
                    <return name="outputShape" type="object" multiplicity="[?*]" alias="Shape" desc="The translated shape or shapes, or nil if the input shape is invalid"/>
                </function>
                <function name="getCompactness">
                    <desc>Gets a measure of how compact a shape is, as a number between 0.0 and 1.0. A circle has compactness 1.0. The measure is calculated as (4*pi*Area)/perimeter^2. Degenerate shapes has compactness zero.</desc>
                    <sample for="lua">compactness = Shape.getCompactness(shape)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape" desc="Input shape or vector of shapes."/>
                    <return name="compactness" type="float" multiplicity="[?*]" desc="Compactness of a shape, or vector for vector input."/>
                </function>
                <function name="getElongation">
                    <desc>Get the a measure of elongation of a shape. It is calculated as lengthAlongMajorAxis/lengthAlongMinorAxis and is therefore a number between 1.0 (e.g., a circle) and infinity (e.g., a line). For some shapes, i.e, Polyline, Arc and Sector, the elongation of the shape bounding box is returned.</desc>
                    <sample for="lua">elongation = Shape.getElongation(shape)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape" desc="Input shape or vector of shapes."/>
                    <return name="elongation" type="float" multiplicity="[?*]" desc="Elongation, or vector of elongations for vector input."/>
                </function>
                <function name="getPerimeterLength">
                    <desc>Get the length of the perimeter of a shape.</desc>
                    <sample for="lua">perimeterLength = Shape.getPerimeterLength(shape)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape" desc="Input shape or vector of shapes."/>
                    <return name="perimeterLength" type="float" multiplicity="[?*]" desc="Perimeter length, or vector of lengths for vector input."/>
                </function>
                <function name="getPrincipalAxes">
                    <trait>hidden</trait>
                    <desc>Gets the principal axes of a shape. There are two axes, and the largest, the major axis, is first in the list, and the minor axes second. These are well defined for an ellipse resulting in a major and a minor axis. An extension to this has been made so that it applies to any shape in the most consistent sense possible. A rectangle gets axes aligned with its sides, where the major axis is aligned with the two long sides.</desc>
                    <sample for="lua">axes = Shape.getPrincipalAxes(shape)</sample>
                    <param name="shape" type="const object" alias="Shape" desc="Input shape"/>
                    <return name="axes" type="object" multiplicity="*" alias="Point" desc="List with two vectors representing the principal axes"/>
                </function>
                <function name="getLineDistance">
                    <desc>Returns the minimum and maximum distance from all points on the shape to the reference line. Distances are measured orthogonal to the reference line. The query shape should have finite size.</desc>
                    <sample for="lua">minDist, maxDist = Shape.getLineDistance(shape, referenceLine)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape" desc="The shape or shapes to check distance to."/>
                    <param name="referenceLine" type="const object" alias="Shape" desc="The reference line."/>
                    <return name="minDist" type="float" multiplicity="[?*]" desc="The orthogonal distance from the line to the closest point on the shape, or nil if projection failed. Vector with distances for vector input."/>
                    <return name="maxDist" type="float" multiplicity="[?*]" desc="The orthogonal distance from the line to the point on the shape furthest away from the line, or nil if projection failed. Vector with distances for vector input."/>
                </function>
                <function name="getCenterOfGravity">
                    <desc>Get the center of gravity of the region enclosed within the shape for closed shapes. For open shapes, the center of gravity of the contour is returned. Returns nil for infinite or invalid shapes.</desc>
                    <sample for="lua">point = Shape.getCenterOfGravity(shape)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape" desc="Input shape or vector of shapes."/>
                    <return name="centerOfGravity" type="object" multiplicity="[?*]" alias="Point" desc="Center of gravity as a 2D Point, or vector of points for vector input."/>
                </function>
                <function name="getArea">
                    <desc>Get the area of the region enclosed by a 2D Shape. A vector of shapes can be provided, in which case a vector of areas is returned.</desc>
                    <sample for="lua">area = Shape.getArea(shape)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape" desc="Input shape or vector of shapes."/>
                    <return name="area" type="float" multiplicity="[?*]" desc="Area of shape, or vector of areas for vector input."/>
                </function>
                <function name="getRadius">
                    <trait>deprecated</trait>
                    <desc>Get the radius of the shape.
This function is deprecated. Use specific functions for getting the parameters of each Shape instead, for example Shape.getCircleParameters, or the bounding box functions.</desc>
                    <sample for="lua">radius = Shape.getRadius(shape)</sample>
                    <param name="shape" type="const object" alias="Shape" desc="Input shape"/>
                    <return name="radius" type="float" multiplicity="?" desc="Radius of circumscribed circle"/>
                </function>
                <function name="getBounds">
                    <desc>Get the bounds of the shape as float values. Fails for invalid and unbounded shapes.</desc>
                    <sample for="lua">xMin, yMin, xMax, yMax = Shape.getBounds(shape)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape" desc="Input shape"/>
                    <return name="xMin" type="float" multiplicity="[1+]" desc="Minimum x coordinate"/>
                    <return name="yMin" type="float" multiplicity="[1+]" desc="Minimum y coordinate"/>
                    <return name="xMax" type="float" multiplicity="[1+]" desc="Maximum x coordinate"/>
                    <return name="yMax" type="float" multiplicity="[1+]" desc="Maximum y coordinate"/>
                </function>
                <function name="toImage">
                    <desc>Convert the shape into an image, setting pixels within the shape contour to a specific value. The value is in world coordinates and is cropped to the representable range. Pixels outside are set to pixel value zero. Only closed shapes are supported. If several shapes are given, they are all drawn in the same image. Invalid shapes in a list of shapes are ignored.</desc>
                    <sample for="lua">outputImage = Shape.toImage(shape,refImage,worldValue)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape" desc="Input shape or vector of shapes."/>
                    <param name="referenceImage" type="const object" alias="Image" desc="Reference image, used to define pixel-world mapping."/>
                    <param name="worldValue" type="float" multiplicity="?" desc="World value to use within the region. Default is 255."/>
                    <return name="outputImage" type="object" multiplicity="?" alias="Image" desc="Resulting image displaying the shape or nil if not supported."/>
                </function>
                <function name="toShape3D">
                    <desc>Convert a 2D Shape into the corresponding 3D shape. An optional rigid Transform object may be provided. Without transform, the 3D shape is created in the z=0 plane. The transform is applied after creation, allowing 3D Shapes in other planes. Nil is returned if the input contains invalid shapes or shapes without a corresponding 3D shape.</desc>
                    <sample for="lua">outputShape = Shape.toShape3D(shape, transform)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape" desc="Input shape or vector of shapes."/>
                    <param name="transform" type="const object" multiplicity="?" alias="Transform" desc="Optional transform from the z=0 plane to the desired plane. Must be rigid or less general."/>
                    <return name="outputShape" type="object" multiplicity="[?*]" alias="Shape3D" desc="The corresponding Shape3D or nil if not supported, or vector of 3D shapes."/>
                </function>
                <function name="toString">
                    <desc>Get a human-readable string describing the shape.</desc>
                    <sample for="lua">print(Shape.toString(shape))</sample>
                    <param name="shape" type="const object" alias="Shape" desc="Input shape"/>
                    <return name="str" type="string" desc="String description of the shape"/>
                </function>
                <function name="toPixelRegion">
                    <trait>released</trait>
                    <keywords>rasterize, render, draw</keywords>
                    <links>Image.PixelRegion, Image.drawShape, Shape.Composite.toPixelRegion</links>
                    <desc>Rasterize a Shape object into a PixelRegion object, using a reference image to define the pixel-world mapping. A vector of shape objects generates a vector of PixelRegion objects.</desc>
                    <sample for="lua">pixelRegion = Shape.toPixelRegion(shape, referenceImage)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape" desc="Input shape or shapes."/>
                    <param name="referenceImage" type="const object" alias="Image" desc="Reference image, used to define pixel-world mapping."/>
                    <param name="fill" type="bool" multiplicity="?" desc="Set to true to generate a filled region, false to generate a border region. Non-closed shapes will always generate a border only. Default: true."/>
                    <return name="pixelRegion" type="object" multiplicity="[?*]" alias="Image.PixelRegion" desc="Pixel region representation of the shape, or a vector of pixel region representations of the shapes."/>
                </function>
                <function name="fitLine">
                    <trait>hidden</trait>
                    <desc>Fit a line shape to a set of points</desc>
                    <sample for="lua">line = Shape.fitLine(points, "RANSAC", 2.0)</sample>
                    <param name="points" type="const object" multiplicity="+" alias="Point" desc="Input points"/>
                    <param name="mode" type="enum" multiplicity="?" ref="PointFitMode" desc="Fitting mode. Default is LEASTSQUARES"/>
                    <param name="marginType" type="enum" multiplicity="?" ref="Shape.OutlierMarginType" desc="Outlier margin type (ABSOLUTE or RANK). Default is ABSOLUTE."/>
                    <param name="margin" type="float" multiplicity="?" desc="Outlier margin. The exact interpretation depends on the margin type."/>
                    <param name="iterations" type="int" multiplicity="?" desc="Number of iterations. Only used iterative fitting modes (RANSAC, TODO)"/>
                    <return name="line" type="object" multiplicity="?" alias="Shape" desc="Line with best fit"/>
                    <return name="quality" type="float" multiplicity="*" desc="Vector with fitting quality measurements [meanError, inlierRate], where meanError is the average fitting error of inlier points in world coordinates and inlierRate is the rate of input points that were accepted as belonging to the line."/>
                </function>
                <function name="fitCircle">
                    <trait>hidden</trait>
                    <desc>Fit a circle shape to a set of points.</desc>
                    <sample for="lua">circle = Shape.fitCircle(points, "RANSAC", 2.0)</sample>
                    <param name="points" type="const object" multiplicity="+" alias="Point" desc="Input points"/>
                    <param name="mode" type="enum" multiplicity="?" ref="PointFitMode" desc="Fitting mode. Default is LEASTSQUARES"/>
                    <param name="margin" type="float" multiplicity="?" desc="Outlier margin. The exact interpretation depends on the fit mode."/>
                    <param name="iterations" type="int" multiplicity="?" desc="Number of iterations. Only used iterative fitting modes (RANSAC, TODO)"/>
                    <return name="circle" type="object" multiplicity="?" alias="Shape" desc="Circle with best fit"/>
                    <return name="quality" type="float" multiplicity="*" desc="Vector with fitting quality measurements [meanError, inlierRate], where meanError is the average fitting error of inlier points in world coordinates and inlierRate is the rate of input points that were accepted as belonging to the circle."/>
                </function>
                <function name="fitEllipse">
                    <trait>hidden</trait>
                    <desc>Fit an ellipse shape to a set of points. Currently only least squares is available.</desc>
                    <sample for="lua">ellipse = Shape.fitEllipse(points, "LEASTSQUARES", 2.0)</sample>
                    <param name="points" type="const object" multiplicity="+" alias="Point" desc="Input points"/>
                    <param name="mode" type="enum" multiplicity="?" ref="PointFitMode" desc="Fitting mode. Default is LEASTSQUARES"/>
                    <param name="margin" type="float" multiplicity="?" desc="Outlier margin. The exact interpretation depends on the fit mode."/>
                    <param name="iterations" type="int" multiplicity="?" desc="Number of iterations. Only used iterative fitting modes (RANSAC)."/>
                    <return name="ellipse" type="object" multiplicity="?" alias="Shape" desc="Ellipse with best fit"/>
                    <return name="quality" type="float" multiplicity="*" desc="Vector with fitting quality measurements [meanError, inlierRate], where meanError is the average fitting error of inlier points in world coordinates and inlierRate is the rate of input points that were accepted as belonging to the circle."/>
                </function>
            </serves>
            <uses/>
            <crown name="Composite">
                <trait>released</trait>
                <keywords>rasterize,render,draw</keywords>
                <links>Shape.toPixelRegion</links>
                <desc>Composite of several individual shapes. The composite contains a set of positive shapes and an optional set of negative shapes, and the final shape is the union of all positive shapes, with the union of all negative shapes removed. The order of the shapes has no significance.</desc>
                <serves>
                    <function name="create">
                        <desc>Create an empty shape composite</desc>
                        <sample for="Lua">sc = Shape.Composite.create()</sample>
                        <return name="composite" type="object" multiplicity="?" alias="Shape.Composite" desc="The created shape composite."/>
                    </function>
                    <function name="clone">
                        <desc>Create an independent deep copy of the composite</desc>
                        <sample for="Lua">sc2 = Shape.Composite.clone(sc)</sample>
                        <param name="inputComposite" type="const object" alias="Shape.Composite" desc="Input composite"/>
                        <return name="outputComposite" type="object" multiplicity="?" alias="Shape.Composite" desc="Deep copy of the input composite"/>
                    </function>
                    <function name="addShape">
                        <desc>Add a shape to the composite</desc>
                        <sample for="lua">Shape.Composite.addShape(composite, shape, isPositive)</sample>
                        <param name="composite" type="object" alias="Shape.Composite" desc="The composite to modify"/>
                        <param name="shape" type="const object" alias="Shape" desc="The shape to add"/>
                        <param name="isPositive" type="bool" multiplicity="?" desc="True means positive shape, false means negative shape (default is positive)"/>
                    </function>
                    <function name="getShapeCount">
                        <desc>Get the number of shapes contained in this composite</desc>
                        <sample for="Lua">n = Shape.Composite.getShapeCount(composite)</sample>
                        <param name="composite" type="const object" alias="Shape.Composite" desc="Input shape composite"/>
                        <return name="count" type="int" multiplicity="?" desc="Number of shapes in the composite (positive and negative)"/>
                    </function>
                    <function name="getShape">
                        <desc>Get one of the shapes and its associated isNegative flag</desc>
                        <sample for="Lua">shape, isPositive = Shape.Composite.getShape(composite, index)</sample>
                        <param name="composite" type="const object" alias="Shape.Composite" desc="Input shape composite"/>
                        <param name="index" type="int" desc="Index of the shape to return (0-based)"/>
                        <return name="shape" type="object" multiplicity="?" alias="Shape" desc="The requested shape"/>
                        <return name="isPositive" type="bool" multiplicity="?" desc="True if the shape is positive, otherwise false"/>
                    </function>
                    <function name="contains">
                        <desc>Check if the given point is within this composite (within any of the positive shapes but not within any of the negative ones). False is returned if any invalid shape is in the composite.</desc>
                        <sample for="Lua">b = Shape.Composite.contains(composite, point)</sample>
                        <param name="composite" type="const object" alias="Shape.Composite" desc="Input composite"/>
                        <param name="point" type="const object" alias="Point" desc="Point to check"/>
                        <return name="result" type="bool" multiplicity="?" desc="True if the point is within the region, otherwise false"/>
                    </function>
                    <function name="transform">
                        <desc>Transform the composite according to a general 2D transformation. Requires that all individual shapes support the transformation. For example, if one of the shapes is a circle and the transformation is an affine transformation, the operation will fail, since circles are no longer circles after an affine transformation. For transforming any kind of composite, consider converting the composite to a polygon representation using toPolygons first.</desc>
                        <sample for="Lua">newComposite = Shape.Composite.transform(composite, transform)</sample>
                        <param name="composite" type="const object" alias="Shape.Composite" desc="Input shape composite"/>
                        <param name="transform" type="const object" alias="Transform" desc="The transform to use (must be a 2D transform)"/>
                        <return name="newComposite" type="object" multiplicity="?" alias="Shape.Composite" desc="The transformed shape composite"/>
                    </function>
                    <function name="toPolygons">
                        <desc>Convert the shape composite to a composite consisting only of polygons. All circle and ellipses in the input are approximated by polygons with a given maximum error.</desc>
                        <sample for="Lua">outputComposite = Shape.Composite.toPolygons(inputComposite, epsilon)</sample>
                        <param name="inputComposite" type="const object" alias="Shape.Composite" desc="Input composite"/>
                        <param name="epsilon" type="float" desc="Maximum approximation error. Controls the number of points used in the polygon approximation of ellipses and circles"/>
                        <param name="maxPoints" type="int" multiplicity="?" desc="Maximum number of points to use in the approximation if each polygon (default is 1000). This is a stronger requirement than the epsilon and puts a limit on the function memory usage."/>
                        <return name="outputComposite" type="object" multiplicity="?" alias="Shape.Composite" desc="Polygon composite shape."/>
                    </function>
                    <function name="toImage">
                        <desc>Convert the composite shape into an image, setting pixels within the shape contour to a specific value. The value is in world coordinates and is cropped to the representable range. Pixels outside are set to pixel value zero.</desc>
                        <sample for="Lua">image = Shape.Composite.toImage(shapeComposite, referenceImage, worldValue)</sample>
                        <param name="composite" type="const object" alias="Shape.Composite" desc="Input composite"/>
                        <param name="referenceImage" type="const object" alias="Image" desc="Image used to define world-pixel coordinate conversion and target resolution"/>
                        <param name="worldValue" type="float" multiplicity="?" desc="World value to use within the region. Default is 255."/>
                        <return name="outputImage" type="object" multiplicity="?" alias="Image" desc="The converted image"/>
                    </function>
                    <function name="toString">
                        <desc>Gets a user-friendly string description of the composite shape.</desc>
                        <sample for="lua">str = Shape.Composite.toString(composite)</sample>
                        <param name="composite" type="const object" desc="The composite shape to describe."/>
                        <return name="str" type="string" multiplicity="?" desc="User-friendly description of the composite shape ."/>
                    </function>
                    <function name="getPositiveBoundingBox">
                        <desc>Get a bounding box of all positive shapes. This box is guaranteed to contain the entire region but might not be the tightest possible box if negative regions are used.</desc>
                        <sample for="lua">box = Shape.Composite.getPositiveBoundingBox(composite)</sample>
                        <param name="composite" type="const object" alias="Shape.Composite" desc="The composite to use"/>
                        <return name="box" type="object" multiplicity="?" alias="Shape" desc="Rectangle shape representing the bounding box"/>
                    </function>
                    <function name="toPixelRegion">
                        <desc>Convert a shape composite to a pixel region. This is useful for showing the composite in a viewer, or to use the composite region as input to image processing methods.</desc>
                        <sample for="lua">pixelRegion = Shape.Composite.toPixelRegion(composite, referenceImage)</sample>
                        <param name="composite" type="const object" alias="Shape.Composite" desc="Composite shape region to convert."/>
                        <param name="referenceImage" type="const object" alias="Image" desc="Reference image, defines the image world coordinate system."/>
                        <return name="outputRegion" type="object" multiplicity="?" alias="Image.PixelRegion" desc="Input composite converted to a PixelRegion."/>
                    </function>
                </serves>
                <uses/>
            </crown>
        </crown>
        <crown name="Shape3D">
            <trait>released</trait>
            <desc>A 3D geometric primitive, e.g., Line, LineSegment, Polyline, Plane, Rectangle, Circle, Box, Sphere, Cylinder, Cone, etc. The pose (position and orientation) of most shapes is controlled by a 3D Transform. Such shapes have a defined default pose, often centered around the origin, from which the pose transform is used to move and rotate the shape into the desired pose in 3D space. When creating a shape, the pose transform is not allowed to change the size of the shape (the size is set by specific parameters), that is, the pose transform must be of rigid, rotation or translation type. Shapes can be transformed using more general transformations, however the type of transformations allowed is specific to each shape and limited to make sure the shape stays within its class. For example, a non-uniform scaling will turn a circle into an ellipse and is thus not allowed.
The Shape3D object is represented in mathematical analytical form. Operations such as finding intersection points, distances and transforming the geometric primitive are for this reason efficiently computed.</desc>
            <enum name="Shape3DType">
                <item name="Plane" desc="Plane (with infinite size)">PLANE</item>
                <item name="Line" desc="Line in 3D (infinite length)">LINE</item>
                <item name="Line segment" desc="Line segment in 3D">LINE_SEGMENT</item>
                <item name="Rectangle" desc="2D rectangle in 3D space">RECTANGLE</item>
                <item name="Circle" desc="2D circle in 3D space">CIRCLE</item>
                <item name="Ellipse" desc="2D ellipse in 3D space">ELLIPSE</item>
                <item name="Polygon" desc="A closed planar 2D polygon in 3D space">POLYGON</item>
                <item name="Box" desc="Solid 3D box">BOX</item>
                <item name="Cylinder" desc="Solid cylinder">CYLINDER</item>
                <item name="EllipticCylinder" desc="Solid elliptic cylinder (elliptic base area extended with a height)">ELLIPTIC_CYLINDER</item>
                <item name="Cone" desc="A 3D cone">CONE</item>
                <item name="Sphere" desc="Sphere">SPHERE</item>
                <item name="Polyline" desc="An open polyline in 3D">POLYLINE</item>
            </enum>
            <enum name="ShapePointFitMode" trait="released">
                <item name="leastsquares" desc="Ordinary least squares">LEASTSQUARES</item>
                <item name="ransac" desc="Ransac (random sampling with outlier rejection)">RANSAC</item>
                <item name="trimmed" desc="Two-stage least squares fitting. The second stage uses only points within the margin around the fitted shape of the first stage.">TRIMMED</item>
            </enum>
            <serves>
                <function name="createPlane">
                    <desc>Create a plane in 3D. A plane is defined by its normal vector (vector perpendicular to the plane) and a distance from the world origin (Hesse normal form). For example, an XY-aligned plane at Z = 5 is constructed using Shape3D.createPlane(0, 0, 1, 5). The distance is signed and measured from the origin along the normal. A plane where the normal points from the plane towards the origin has a negative distance.</desc>
                    <sample for="lua">plane = Shape3D.createPlane(nx, ny, nz, distance)</sample>
                    <param name="nx" type="float" desc="X component of plane normal vector."/>
                    <param name="ny" type="float" desc="Y component of plane normal vector."/>
                    <param name="nz" type="float" desc="Z component of plane normal vector."/>
                    <param name="distance" type="float" desc="Distance from the origin to the plane along the plane normal."/>
                    <return name="plane" type="object" multiplicity="?" alias="Shape3D" desc="The created plane, or nil if the normal vector was a zero vector."/>
                </function>
                <function name="createPlaneFromPoints">
                    <desc>Create a plane in 3D containing the three given 3D points. The three points must span a plane, i.e., they must not be distributed along a line.</desc>
                    <sample for="lua">plane = Shape3D.createPlaneFromPoints(point1, point2, point3)</sample>
                    <param name="point1" type="const object" alias="Point" desc="First 3D point."/>
                    <param name="point2" type="const object" alias="Point" desc="Second 3D point."/>
                    <param name="point3" type="const object" alias="Point" desc="Third 3D point."/>
                    <return name="plane" type="object" multiplicity="?" alias="Shape3D" desc="The created plane, or nil if the points are in a degenerate configuration."/>
                </function>
                <function name="getPlaneParameters">
                    <desc>Get the parameters of the plane (normal vector plus distance). The distance is signed and measured from the origin along the normal. A plane where the normal points from the plane towards the origin has a negative distance.</desc>
                    <sample for="lua">nx, ny, nz, distance = Shape3D.getPlaneParameters(plane)</sample>
                    <param name="plane" type="const object" alias="Shape3D" desc="The plane."/>
                    <return name="nx" type="float" multiplicity="?" desc="X component of plane normal vector."/>
                    <return name="ny" type="float" multiplicity="?" desc="Y component of plane normal vector."/>
                    <return name="nz" type="float" multiplicity="?" desc="Z component of plane normal vector."/>
                    <return name="distance" type="float" multiplicity="?" desc="Distance from the origin to the plane along the plane normal."/>
                </function>
                <function name="createLine">
                    <desc>Create a line in 3D, passing through the two given 3D points.</desc>
                    <sample for="lua">line = Shape3D.createLine(point1, point2)</sample>
                    <param name="point1" type="const object" alias="Point" desc="First 3D point on the line."/>
                    <param name="point2" type="const object" alias="Point" desc="Second 3D point on the line."/>
                    <return name="line" type="object" multiplicity="?" alias="Shape3D" desc="The created 3D line, or nil if the two point coincide."/>
                </function>
                <function name="getLineParameters">
                    <desc>Get two 3D points on the line. Note that these two points may not be the same points used for creating a line using the createLine() function as the line representation is normalized internally.</desc>
                    <sample for="lua">point1, point2 = Shape3D.getLineParameters(line)</sample>
                    <param name="line" type="const object" alias="Shape3D" desc="The 3D line."/>
                    <return name="point1" type="object" multiplicity="?" alias="Point" desc="First 3D point on the line."/>
                    <return name="point2" type="object" multiplicity="?" alias="Point" desc="Second 3D point on the line."/>
                </function>
                <function name="createLineSegment">
                    <desc>Create a line segment in 3D between the two given 3D points.</desc>
                    <sample for="lua">lineSegment = Shape3D.createLineSegment(point1, point2)</sample>
                    <param name="point1" type="const object" alias="Point" desc="First 3D endpoint of the line segment."/>
                    <param name="point2" type="const object" alias="Point" desc="Second 3D endpoint of the line segment."/>
                    <return name="lineSegment" type="object" multiplicity="?" alias="Shape3D" desc="The created 3D line segment, or nil if the two point coincide."/>
                </function>
                <function name="getLineSegmentParameters">
                    <desc>Get the 3D end points of the line segment.</desc>
                    <sample for="lua">point1, point2 = Shape3D.getLineSegmentParameters(lineSegment)</sample>
                    <param name="lineSegment" type="const object" alias="Shape3D" desc="The 3D line segment."/>
                    <return name="point1" type="object" multiplicity="?" alias="Point" desc="First 3D endpoint on the line segment."/>
                    <return name="point2" type="object" multiplicity="?" alias="Point" desc="Second 3D endpoint on the line segment."/>
                </function>
                <function name="createRectangle">
                    <desc>Create a 2D rectangle embedded in 3D space. Unless transformed, the rectangle is created in the xy-plane, centered on the origin.</desc>
                    <sample for="lua">rectangle = Shape3D.createRectangle(sizeX, sizeY, poseTransform)</sample>
                    <param name="sizeX" type="float" desc="Size of the rectangle in the x-direction before transformation (width)."/>
                    <param name="sizeY" type="float" desc="Size of the rectangle in the y-direction before transformation (height)."/>
                    <param name="poseTransform" type="const object" multiplicity="?" alias="Transform" desc="Transform defining the rectangle position and orientation in 3D space. Must be of type identity, translation or rigid. Optional, default is an identity transform."/>
                    <return name="rectangle" type="object" multiplicity="?" alias="Shape3D" desc="The created 3D rectangle."/>
                </function>
                <function name="getRectangleParameters">
                    <desc>Get the size and pose of the 3D rectangle.</desc>
                    <sample for="lua">sizeX, sizeY, poseTransform = Shape3D.getRectangleParameters(rectangle)</sample>
                    <param name="rectangle" type="const object" alias="Shape3D" desc="The 3D rectangle."/>
                    <return name="sizeX" type="float" multiplicity="?" desc="Size of the rectangle in the x-direction before transformation (width)."/>
                    <return name="sizeY" type="float" multiplicity="?" desc="Size of the rectangle in the y-direction before transformation (height)."/>
                    <return name="poseTransform" type="object" multiplicity="?" alias="Transform" desc="Transform defining the rectangle position and orientation in 3D space. Is of type identity, translation or rigid."/>
                </function>
                <function name="createCircle">
                    <desc>Create a 2D circle embedded in 3D space. Unless transformed, the circle is created in the xy-plane, centered on the origin.</desc>
                    <sample for="lua">circle = Shape3D.createCircle(radius, poseTransform)</sample>
                    <param name="radius" type="float" desc="Radius of the circle."/>
                    <param name="poseTransform" type="const object" multiplicity="?" alias="Transform" desc="Transform defining the circle position and orientation in 3D space. Must be of type identity, translation or rigid. Optional, default is an identity transform."/>
                    <return name="circle" type="object" multiplicity="?" alias="Shape3D" desc="The created 3D circle."/>
                </function>
                <function name="getCircleParameters">
                    <desc>Get the radius and pose of the 3D circle.</desc>
                    <sample for="lua">radius, poseTransform = Shape3D.getCircleParameters(circle)</sample>
                    <param name="circle" type="object" alias="Shape3D" desc="The 3D circle."/>
                    <return name="radius" type="float" multiplicity="?" desc="Radius of the circle."/>
                    <return name="poseTransform" type="const object" multiplicity="?" alias="Transform" desc="Transform defining the circle position and orientation in 3D space. Is of type identity, translation or rigid."/>
                </function>
                <function name="createEllipse">
                    <desc>Create a 2D ellipse embedded in 3D space. Unless transformed, the ellipse is created in the xy-plane, centered on the origin.</desc>
                    <sample for="lua">ellipse = Shape3D.createEllipse(radiusX, radiusY, poseTransform)</sample>
                    <param name="radiusX" type="float" desc="Radius of the ellipse in the x-direction before transformation."/>
                    <param name="radiusY" type="float" desc="Radius of the ellipse in the y-direction before transformation."/>
                    <param name="poseTransform" type="const object" multiplicity="?" alias="Transform" desc="Transform defining the ellipse position and orientation in 3D space. Must be of type identity, translation or rigid. Optional, default is an identity transform."/>
                    <return name="ellipse" type="object" multiplicity="?" alias="Shape3D" desc="The created 3D ellipse."/>
                </function>
                <function name="getEllipseParameters">
                    <desc>Get the radii and pose transform of the 3D ellipse.</desc>
                    <sample for="lua">radiusX, radiusY, poseTransform = Shape3D.getEllipseParameters(ellipse)</sample>
                    <param name="ellipse" type="object" alias="Shape3D" desc="The 3D ellipse."/>
                    <return name="radiusX" type="float" multiplicity="?" desc="Radius of the ellipse in the x-direction before transformation."/>
                    <return name="radiusY" type="float" multiplicity="?" desc="Radius of the ellipse in the y-direction before transformation."/>
                    <return name="poseTransform" type="const object" multiplicity="?" alias="Transform" desc="Transform defining the ellipse position and orientation in 3D space. Is of type identity, translation or rigid."/>
                </function>
                <function name="createPolygon">
                    <desc>Create a 2D closed polygon embedded in 3D space. If the points are not in a plane, the points are projected onto the best fitting plane. At least three points are required.</desc>
                    <sample for="lua">polygon = Shape3D.createPolygon(points)</sample>
                    <param name="points" type="const object" multiplicity="+" alias="Point" desc="Corner points for the polygon."/>
                    <return name="polygon" type="object" multiplicity="?" alias="Shape3D" desc="The created 2D polygon in 3D."/>
                </function>
                <function name="getPolygonParameters">
                    <desc>Get the points defining the polygon.</desc>
                    <sample for="lua">points = Shape3D.getPolygonParameters(polygon)</sample>
                    <param name="polygon" type="const object" alias="Shape3D" desc="The polygon."/>
                    <return name="points" type="object" multiplicity="*" alias="Point" desc="Corner points for the polygon."/>
                </function>
                <function name="createPolyline">
                    <desc>Create a full 3D polyline. Corners can be placed freely in 3D, however, a closed surface for a general 3D polyline would be ambiguous and thus this shape can not be closed. Use the 3D polygon for closed shapes.</desc>
                    <sample for="lua">polyline = Shape3D.createPolyline(points)</sample>
                    <param name="points" type="const object" multiplicity="+" alias="Point" desc="Corner points for the polyline."/>
                    <return name="polyline" type="object" multiplicity="?" alias="Shape3D" desc="The created polyline."/>
                </function>
                <function name="getPolylineParameters">
                    <desc>Get the points defining the polyline.</desc>
                    <sample for="lua">points = Shape3D.getPolylineParameters(polyline)</sample>
                    <param name="polyline" type="const object" alias="Shape3D" desc="The polyline."/>
                    <return name="points" type="object" multiplicity="*" alias="Point" desc="Corner points for the polyline."/>
                </function>
                <function name="createBox">
                    <desc>Create a box in 3D space. Unless transformed, the box is centered on the origin.</desc>
                    <sample for="lua">box = Shape3D.createBox(sizeX, sizeY, sizeZ, poseTransform)</sample>
                    <param name="sizeX" type="float" desc="Size of the box in the x-direction before transformation."/>
                    <param name="sizeY" type="float" desc="Size of the box in the y-direction before transformation."/>
                    <param name="sizeZ" type="float" desc="Size of the box in the z-direction before transformation."/>
                    <param name="poseTransform" type="const object" multiplicity="?" alias="Transform" desc="Transform defining the box position and orientation in 3D space. Must be of type identity, translation or rigid. Optional, default is an identity transform."/>
                    <return name="box" type="object" multiplicity="?" alias="Shape3D" desc="The created box."/>
                </function>
                <function name="getBoxParameters">
                    <desc>Get the size and pose of the 3D box.</desc>
                    <sample for="lua">sizeX, sizeY, sizeZ, poseTransform = Shape3D.getBoxParameters(box)</sample>
                    <param name="box" type="const object" alias="Shape3D" desc="The created box."/>
                    <return name="sizeX" type="float" multiplicity="?" desc="Size of the box in the x-direction before transformation."/>
                    <return name="sizeY" type="float" multiplicity="?" desc="Size of the box in the y-direction before transformation."/>
                    <return name="sizeZ" type="float" multiplicity="?" desc="Size of the box in the z-direction before transformation."/>
                    <return name="poseTransform" type="object" multiplicity="?" alias="Transform" desc="Transform defining the box position and orientation in 3D space. Is of type identity, translation or rigid."/>
                </function>
                <function name="createCylinder">
                    <desc>Create a cylinder in 3D space. Unless transformed, the cylinder is centered on the origin with the z-axis as symmetry line.</desc>
                    <sample for="lua">cylinder = Shape3D.createCylinder(radius, heightZ, poseTransform)</sample>
                    <param name="radius" type="float" desc="Radius in the xy-plane before transformation."/>
                    <param name="heightZ" type="float" desc="Height of the cylinder in the z-direction before transformation."/>
                    <param name="poseTransform" type="const object" multiplicity="?" alias="Transform" desc="Transform defining the cylinder position and orientation in 3D space. Must be of type identity, translation or rigid. Optional, default is an identity transform."/>
                    <return name="cylinder" type="object" multiplicity="?" alias="Shape3D" desc="The created cylinder."/>
                </function>
                <function name="getCylinderParameters">
                    <desc>Get the radius, height and pose of a cylinder.</desc>
                    <sample for="lua">radius, heightZ, poseTransform = Shape3D.getCylinderParameters(cylinder)</sample>
                    <param name="cylinder" type="object" alias="Shape3D" desc="The created cylinder."/>
                    <return name="radius" type="float" multiplicity="?" desc="Radius in the xy-plane before transformation."/>
                    <return name="heightZ" type="float" multiplicity="?" desc="Height of the cylinder in the z-direction before transformation."/>
                    <return name="poseTransform" type="const object" multiplicity="?" alias="Transform" desc="Transform defining the cylinder position and orientation in 3D space. Is of type identity, translation or rigid."/>
                </function>
                <function name="createEllipticCylinder">
                    <desc>Create an elliptic cylinder in 3D space. Unless transformed, the elliptic cylinder is centered on the origin centered on the z-axis.</desc>
                    <sample for="lua">ellipticCylinder = Shape3D.createEllipticCylinder(radiusX, radiusY, heightZ, poseTransform)</sample>
                    <param name="radiusX" type="float" desc="Radius in the x-direction before transformation."/>
                    <param name="radiusY" type="float" desc="Radius in the y-direction before transformation."/>
                    <param name="heightZ" type="float" desc="Height of the elliptic cylinder in the z-direction before transformation."/>
                    <param name="poseTransform" type="const object" multiplicity="?" alias="Transform" desc="Transform defining the elliptic cylinder position and orientation in 3D space. Must be of type identity, translation or rigid. Optional, default is an identity transform."/>
                    <return name="ellipticCylinder" type="object" multiplicity="?" alias="Shape3D" desc="The created elliptic cylinder."/>
                </function>
                <function name="getEllipticCylinderParameters">
                    <desc>Get the radii, height and pose of an elliptic cylinder.</desc>
                    <sample for="lua">radiusX, radiusY, heightZ, poseTransform = Shape3D.getEllipticCylinderParameters(ellipticCylinder)</sample>
                    <param name="ellipticCylinder" type="object" alias="Shape3D" desc="The elliptic cylinder."/>
                    <return name="radiusX" type="float" multiplicity="?" desc="Radius in the x-direction before transformation."/>
                    <return name="radiusY" type="float" multiplicity="?" desc="Radius in the y-direction before transformation."/>
                    <return name="heightZ" type="float" multiplicity="?" desc="Height of the elliptic cylinder in the z-direction before transformation."/>
                    <return name="poseTransform" type="const object" multiplicity="?" alias="Transform" desc="Transform defining the elliptic cylinder position and orientation in 3D space. Is of type identity, translation or rigid."/>
                </function>
                <function name="createCone">
                    <desc>Create a cone in 3D space. Unless transformed, the z-axis is the symmetry axis of the cone, the base circle is centered on the origin and the apex is at the point (0, 0, heightZ).</desc>
                    <sample for="lua">cone = Shape3D.createCone(radius, heightZ, poseTransform)</sample>
                    <param name="radius" type="float" desc="Largest radius of the cone."/>
                    <param name="heightZ" type="float" desc="Height of the cone in the z-direction before transformation."/>
                    <param name="poseTransform" type="const object" multiplicity="?" alias="Transform" desc="Transform defining the cone position and orientation in 3D space. Must be of type identity, translation or rigid. Optional, default is an identity transform."/>
                    <return name="cone" type="object" multiplicity="?" alias="Shape3D" desc="The created cone."/>
                </function>
                <function name="getConeParameters">
                    <desc>Get the radius, height and pose of a cone.</desc>
                    <sample for="lua">radius, heightZ, poseTransform = Shape3D.getConeParameters(cone)</sample>
                    <param name="cone" type="object" alias="Shape3D" desc="The cone."/>
                    <return name="radius" type="float" multiplicity="?" desc="The largest radius of the cone."/>
                    <return name="heightZ" type="float" multiplicity="?" desc="Height of the cone from the base circle to the apex."/>
                    <return name="poseTransform" type="const object" multiplicity="?" alias="Transform" desc="Transform defining the cone position and orientation in 3D space. Is of type identity, translation or rigid."/>
                </function>
                <function name="createSphere">
                    <desc>Create a sphere in 3D space. Unless transformed, the sphere is centered on the origin.</desc>
                    <sample for="lua">sphere = Shape3D.createSphere(radius, poseTransform)</sample>
                    <param name="radius" type="float" desc="Radius of the sphere."/>
                    <param name="poseTransform" type="const object" multiplicity="?" alias="Transform" desc="Transform defining the sphere position and orientation in 3D space. Must be of type identity, translation or rigid. The sphere itself is invariant to rotations however the orientation of the local coordinate system is affected. Optional, default is an identity transform."/>
                    <return name="sphere" type="object" multiplicity="?" alias="Shape3D" desc="The created sphere."/>
                </function>
                <function name="getSphereParameters">
                    <desc>Get the radius and position of the sphere.</desc>
                    <sample for="lua">radius, poseTransform = Shape3D.getSphereParameters(sphere)</sample>
                    <param name="sphere" type="const object" alias="Shape3D" desc="The sphere."/>
                    <return name="radius" type="float" multiplicity="?" desc="Radius of the sphere."/>
                    <return name="poseTransform" type="object" multiplicity="?" alias="Transform" desc="Transform defining the sphere position and orientation in 3D space. Is of type identity, translation or rigid."/>
                </function>
                <function name="clone">
                    <desc>Create an independent copy of the shape. If the input is a vector of shapes, the output is a vector of shapes.</desc>
                    <sample for="lua">outputShape = Shape3D.clone(inputShape)</sample>
                    <param name="inputShape" type="const object" multiplicity="[1+]" alias="Shape3D" desc="The shape to clone."/>
                    <return name="outputShape" type="object" multiplicity="[?*]" alias="Shape3D" desc="The new copy."/>
                </function>
                <function name="getType">
                    <desc>Get the shape type.</desc>
                    <sample for="lua">shapeType = Shape3D.getType(shape3d)</sample>
                    <param name="shape3d" type="const object" alias="Shape3D" desc="3D shape input."/>
                    <return name="shapeType" type="enum" multiplicity="?" ref="Shape3DType" desc="The shape type."/>
                </function>
                <function name="isClosed">
                    <desc>Returns true if the shape has no endpoints and encloses an area.</desc>
                    <sample for="lua">closed = Shape3D.isClosed(shape3d)</sample>
                    <param name="shape3d" type="const object" alias="Shape3D" desc="3D shape input."/>
                    <return name="closed" type="bool" multiplicity="?" desc="True if the shape is closed."/>
                </function>
                <function name="isZeroVolume">
                    <desc>Returns true if the shape type in general has no volume, such as for 2D shapes in 3D space.</desc>
                    <sample for="lua">noVolume = Shape3D.isZeroVolume(shape3d)</sample>
                    <param name="shape3d" type="const object" alias="Shape3D" desc="3D shape input."/>
                    <return name="noVolume" type="bool" multiplicity="?" desc="True if the shape has zero volume."/>
                </function>
                <function name="contains">
                    <desc>Returns true if the supplied 3D point is within the shape. Returns false for all shapes with zero volume.
If more than one shape is provided true is returned if the point is inside any of the shapes.
If more than one point is provided a vector is returned with one value for each input point.</desc>
                    <sample for="lua">isInside = Shape3D.contains(shape3d, point)</sample>
                    <param name="shape3d" type="const object" multiplicity="[1+]" alias="Shape3D" desc="3D shape input."/>
                    <param name="point" type="const object" multiplicity="[1+]" alias="Point" desc="The 3D point to probe."/>
                    <return name="isInside" type="bool" multiplicity="[1+]" desc="True if the point is inside the shape."/>
                </function>
                <function name="countInside">
                    <desc>Counts the number of points that fall within the shape.</desc>
                    <sample for="lua">count = Shape3D.countInside(shape3d, points)</sample>
                    <param name="shape3d" type="const object" alias="Shape3D" desc="3D shape input."/>
                    <param name="points" type="const object" multiplicity="+" alias="Point" desc="The 3D points to probe."/>
                    <return name="count" type="int" multiplicity="?" desc="The number of points within the shape."/>
                </function>
                <function name="getArea">
                    <desc>Returns the total surface area of the shape. For flat shapes, e.g., a rectangle, circle or ellipse in 3D space, only one side is counted.</desc>
                    <sample for="lua">area = Shape3D.getArea(shape3d)</sample>
                    <param name="shape3d" type="const object" alias="Shape3D" desc="3D shape input."/>
                    <return name="area" type="float" multiplicity="?" desc="The surface area of the shape."/>
                </function>
                <function name="getClosestSurfacePoint">
                    <desc>Returns the point on the shape surface (or edge) closest to the probe point.
If there are more than one shape provided the closest point on any shape surface is returned.
If there are more than one point provided one point is returned for each input point.</desc>
                    <sample for="lua">surfacePoint = Shape3D.getClosestSurfacePoint(shape3d, point)</sample>
                    <param name="shape3d" type="const object" multiplicity="[1+]" alias="Shape3D" desc="3D shape input."/>
                    <param name="point" type="const object" multiplicity="[1+]" alias="Point" desc="The 3D point to probe."/>
                    <return name="surfacePoint" type="object" multiplicity="[?*]" alias="Point" desc="The point on the surface closest to the probe point."/>
                    <return name="distance" type="float" multiplicity="[?*]" desc="The distance to the closest point."/>
                </function>
                <function name="getBoundingBox">
                    <desc>Returns the smallest axis aligned box that encloses the shape.</desc>
                    <sample for="lua">boundingBox = Shape3D.getBoundingBox(shape3d)</sample>
                    <param name="shape3d" type="const object" alias="Shape3D" desc="3D shape input."/>
                    <return name="boundingBox" type="object" multiplicity="?" alias="Shape3D" desc="The axis aligned bounding box of the shape."/>
                </function>
                <function name="getBounds">
                    <desc>Get the bounds of the shape as individual values.</desc>
                    <sample for="lua">xMin, yMin, zMin, xMax, yMax, zMax = Shape3D.getBounds(shape)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape3D" desc="Input shape"/>
                    <return name="xMin" type="float" multiplicity="[1+]" desc="Minimum x coordinate."/>
                    <return name="yMin" type="float" multiplicity="[1+]" desc="Minimum y coordinate."/>
                    <return name="zMin" type="float" multiplicity="[1+]" desc="Minimum z coordinate."/>
                    <return name="xMax" type="float" multiplicity="[1+]" desc="Maximum x coordinate."/>
                    <return name="yMax" type="float" multiplicity="[1+]" desc="Maximum y coordinate."/>
                    <return name="zMax" type="float" multiplicity="[1+]" desc="Maximum z coordinate."/>
                </function>
                <function name="getPlanePoints">
                    <desc>Returns the point(s) on the plane at the given x,y-coordinate(s).</desc>
                    <sample for="lua">points3d = Shape3D.getPlanePoints(shape, points2d)</sample>
                    <param name="shape" type="const object" alias="Shape" desc="Input plane."/>
                    <param name="points2d" type="const object" multiplicity="[1+]" alias="Point" desc="Query points."/>
                    <return name="points3d" type="object" multiplicity="[?*]" alias="Point" desc="Points on plane, nil if any error occurred."/>
                </function>
                <function name="toPlane">
                    <desc>Returns the plane which a flat shape span, such as rectangles, circles and polygons. Not defined for a line type shape.</desc>
                    <sample for="lua">plane = Shape3D.toPlane(shape3d)</sample>
                    <param name="shape3d" type="const object" alias="Shape3D" desc="A flat 3D shape input."/>
                    <return name="plane" type="object" multiplicity="?" alias="Shape3D" desc="The plane containing the flat 3D shape."/>
                </function>
                <function name="toLine">
                    <desc>Extends a line segment to the the infinite line type.</desc>
                    <sample for="lua">line = Shape3D.toLine(shape3d)</sample>
                    <param name="shape3d" type="const object" alias="Shape3D" desc="A line segment 3D shape."/>
                    <return name="line" type="object" multiplicity="?" alias="Shape3D" desc="The extended shape as a line."/>
                </function>
                <function name="cropLine">
                    <desc>Returns the part of a line within a box as a new line segment. If the line does not intersect the box, nil is returned.</desc>
                    <sample for="lua">lineSegment = Shape3D.cropLine(line, box)</sample>
                    <param name="line" type="const object" alias="Shape3D" desc="The line shape to be cropped."/>
                    <param name="box" type="const object" alias="Shape3D" desc="The box to crop the line with."/>
                    <return name="line" type="object" multiplicity="?" alias="Shape3D" desc="The part of the line within the box as a line segment."/>
                </function>
                <function name="transform">
                    <desc>Transforms a single shape or a vector of shapes according to the supplied transform. The transform must not change the type of the geometric primitive, e.g., it is not possible to transform a sphere using an affine transform as the result may not be a sphere anymore. The pose transform of shapes are kept as non-mirroring rigid transforms, made to always generate a right-handed orthonormal local coordinate system. Transforming a shape with a similarity transform will decompose the transform and apply the scaling component directly to the size of the shape. Similarly, a transform containing a mirroring component will be reformulated to get the mirroring aligned with a symmetry plane of the shape, where it has no effect on the shape and will be removed. Thus the shape will be correctly transformed, however fetching the pose transform of a shape may not return the transform used to transform the shape.</desc>
                    <sample for="lua">transformedShape = Shape3D.transform(shape3d, transform)</sample>
                    <param name="shape3d" type="const object" multiplicity="[1+]" alias="Shape3D" desc="3D shape input."/>
                    <param name="transform" type="const object" alias="Transform" desc="The transform to apply."/>
                    <return name="transformedShape" type="object" multiplicity="[?*]" alias="Shape3D" desc="The transformed shape."/>
                </function>
                <function name="rotateX">
                    <desc>Rotate the shape around an axis parallel to the world x-axis. The rotation center is optional. If not provided, the nominal center of the shape is used. For most shapes, this is the same point as the center of gravity. For cones, the nominal center is the center of the base circle. For lines and planes, the nominal center is the point in the shape closest to the origin.</desc>
                    <sample for="lua">outputShape = Shape3D.rotateX(shape, rotationAngle, rotationCenter)</sample>
                    <param name="shape" type="const object" alias="Shape3D" desc="Input shape"/>
                    <param name="rotationAngle" type="float" desc="The rotation angle in radians"/>
                    <param name="rotationCenter" type="const object" multiplicity="?" alias="Point" desc="The rotation center. The nominal center of the shape is used if unspecified."/>
                    <return name="outputShape" type="object" multiplicity="?" alias="Shape3D" desc="The rotated shape, or nil if the input shape is invalid."/>
                </function>
                <function name="rotateY">
                    <desc>Rotate the shape around an axis parallel to the world y-axis. The rotation center is optional. If not provided, the nominal center of the shape is used. For most shapes, this is the same point as the center of gravity. For cones, the nominal center is the center of the base circle. For lines and planes, the nominal center is the point in the shape closest to the origin.</desc>
                    <sample for="lua">outputShape = Shape3D.rotateY(shape, rotationAngle, rotationCenter)</sample>
                    <param name="shape" type="const object" alias="Shape3D" desc="Input shape"/>
                    <param name="rotationAngle" type="float" desc="The rotation angle in radians"/>
                    <param name="rotationCenter" type="const object" multiplicity="?" alias="Point" desc="The rotation center. The nominal center of the shape is used if unspecified."/>
                    <return name="outputShape" type="object" multiplicity="?" alias="Shape3D" desc="The rotated shape, or nil if the input shape is invalid."/>
                </function>
                <function name="rotateZ">
                    <desc>Rotate the shape around an axis parallel to the world z-axis. The rotation center is optional. If not provided, the nominal center of the shape is used. For most shapes, this is the same point as the center of gravity. For cones, the nominal center is the center of the base circle. For lines and planes, the nominal center is the point in the shape closest to the origin.</desc>
                    <sample for="lua">outputShape = Shape3D.rotateZ(shape, rotationAngle, rotationCenter)</sample>
                    <param name="shape" type="const object" alias="Shape3D" desc="Input shape"/>
                    <param name="rotationAngle" type="float" desc="The rotation angle in radians"/>
                    <param name="rotationCenter" type="const object" multiplicity="?" alias="Point" desc="The rotation center. The nominal center of the shape is used if unspecified."/>
                    <return name="outputShape" type="object" multiplicity="?" alias="Shape3D" desc="The rotated shape, or nil if the input shape is invalid."/>
                </function>
                <function name="translate">
                    <desc>Translate the shape, i.e., shift it along the x,y,z directions.</desc>
                    <sample for="lua">outputShape = Shape3D.translate(shape3d, translationX, translationY, translationZ)</sample>
                    <param name="shape3d" type="const object" alias="Shape3D" desc="3D shape input."/>
                    <param name="translationX" type="float" desc="The translation along the X-axis."/>
                    <param name="translationY" type="float" desc="The translation along the Y-axis."/>
                    <param name="translationZ" type="float" desc="The translation along the Z-axis."/>
                    <return name="outputShape" type="object" multiplicity="?" alias="Shape3D" desc="The translated shape, or nil if the input shape is invalid."/>
                </function>
                <function name="getCenterOfGravity">
                    <desc>Returns the center of gravity of the shape. Returns nil for invalid shapes and for shapes with infinite size.</desc>
                    <sample for="lua">center = Shape3D.getCenterOfGravity(shape3d)</sample>
                    <param name="shape3d" type="const object" alias="Shape3D" desc="3D shape input."/>
                    <return name="center" type="object" multiplicity="?" alias="Point" desc="The center of gravity of the shape."/>
                </function>
                <function name="getVolume">
                    <desc>Returns the volume of the shape.</desc>
                    <sample for="lua">volume = Shape3D.getVolume(shape3d)</sample>
                    <param name="shape3d" type="const object" alias="Shape3D" desc="3D shape input."/>
                    <return name="volume" type="float" multiplicity="?" desc="The volume of the shape."/>
                </function>
                <function name="toString">
                    <desc>Get a user-friendly string description of the 3D shape.</desc>
                    <sample for="lua">print(Shape3D.toString(shape3d))</sample>
                    <param name="shape3d" type="const object" alias="Shape3D" desc="3D shape input."/>
                    <return name="str" type="string" multiplicity="?" desc="User-friendly string description."/>
                </function>
                <function name="getIntersectionPoints">
                    <desc>Returns the intersection points of two shapes. One of the shapes must be a line or a line segment.</desc>
                    <sample for="lua">intersections = Shape3D.getIntersectionPoints(shape1, shape2)</sample>
                    <param name="shape1" type="const object" alias="Shape3D" desc="First shape."/>
                    <param name="shape2" type="const object" alias="Shape3D" desc="Second shape."/>
                    <return name="intersections" type="object" multiplicity="*" alias="Point" desc="Intersection points. If there are intersections, an empty list is returned. If the shape combination is not supported, nil is returned."/>
                </function>
                <function name="getIntersectionLine">
                    <desc>Returns the intersection line of two planes.</desc>
                    <sample for="lua">intersections = Shape3D.getIntersectionLine(shape1, shape2)</sample>
                    <param name="shape1" type="const object" alias="Shape3D" desc="First plane."/>
                    <param name="shape2" type="const object" alias="Shape3D" desc="Second plane."/>
                    <return name="intersections" type="object" multiplicity="[?*]" alias="Shape3D" desc="Intersection line. If there is no intersection, an empty list is returned. If the shape combination is not supported, nil is returned."/>
                </function>
                <function name="getPlaneDistance">
                    <desc>Returns the minimum and maximum distance from all points on the shape to the reference plane. Distances are measured orthogonal to the reference plane. The query shape should have finite size.</desc>
                    <sample for="lua">minDist, maxDist = Shape3D.getPlaneDistance(shape, referencePlane)</sample>
                    <param name="shape" type="const object" alias="Shape3D" desc="The shape to check distance to."/>
                    <param name="referencePlane" type="const object" alias="Shape3D" desc="The reference plane."/>
                    <return name="minDist" type="float" multiplicity="?" desc="The distance from the plane to the closest point on the shape, or nil if projection failed."/>
                    <return name="maxDist" type="float" multiplicity="?" desc="The orthogonal distance from the plane to the point on the shape furthest away from the plane, or nil if projection failed."/>
                </function>
                <function name="projectZ">
                    <desc>Projects one or more Shape3D orthogonally onto the plane described by z = 0. Returns the result as one or more Shape2D together with the minimum and maximum z-values encountered. Lines, line segments, circles, ellipses, boxes, rectangles, spheres, polygons and polylines are supported.</desc>
                    <sample for="lua">projectedShape, zMin, zMax = Shape3D.projectZ(shape)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape3D" desc="Shape(s) to be projected."/>
                    <return name="projectedShape" type="object" multiplicity="[1+]" alias="Shape" desc="The projected shape(s), or nil if projection failed."/>
                    <return name="zMin" type="float" multiplicity="[1+]" desc="Minimum z-value(s) of shape(s) before projection, or nil if projection failed."/>
                    <return name="zMax" type="float" multiplicity="[1+]" desc="Maximum z-value(s) of shape(s) before projection, or nil if projection failed."/>
                </function>
                <function name="getConeApex">
                    <desc>Returns the position of the tip of the cone. Together with getCenterOfGravity, two points defining the direction of the cone can be found.</desc>
                    <sample for="lua">apex = Shape3D.getConeApex(shape)</sample>
                    <param name="shape" type="const object" alias="Shape3D" desc="The cone."/>
                    <return name="apex" type="object" multiplicity="?" alias="Point" desc="The apex of the cone, or nil if any other shape is given."/>
                </function>
                <function name="toPolygon">
                    <desc>Approximates a flat closed shape in 3D as a polygon.</desc>
                    <sample for="lua">polygon = Shape3D.toPolygon(shape, epsilon, maxPoints)</sample>
                    <param name="shape" type="const object" alias="Shape3D" desc="Shape to be approximated."/>
                    <param name="epsilon" type="float" desc="Maximum approximation error in the polygon approximation."/>
                    <param name="maxPoints" type="int" multiplicity="?" desc="Maximum number of points to use in the approximation (default is 1000). This is a stronger requirement than the epsilon and puts a limit on the function memory usage."/>
                    <return name="polygon" type="object" multiplicity="?" alias="Shape3D" desc="The shape as a polygon, or nil if the shape is invalid or non-flat."/>
                </function>
                <function name="getIntersectionAngle">
                    <trait>released</trait>
                    <desc>Get the sharpest angle between two flat Shape3D shapes (circle, rectangle, ellipse in 3D space, etc.), 3D lines, 3D line segments or combination thereof. The shapes do not need to intersect. The angle is in the range 0 to pi/2 where zero indicates parallel planes or lines. Shapes lying in orthogonal planes result in the angle pi/2. Nil is returned if either argument is not a flat shape or a line.</desc>
                    <sample for="lua">angle = Shape3D.getIntersectionAngle(shape1, shape2)</sample>
                    <param name="shape1" type="const object" alias="Shape3D" desc="Shape 1, a flat shape, line or line segment."/>
                    <param name="shape2" type="const object" alias="Shape3D" desc="Shape 2, a flat shape, line or line segment."/>
                    <return name="angle" type="float" multiplicity="?" desc="Sharpest angle between shapes, or Nil if shapes are not flat."/>
                </function>
                <function name="toPixelRegion">
                    <trait>released</trait>
                    <keywords>rasterize, render, project, draw</keywords>
                    <links>Image.PixelRegion</links>
                    <desc>Projects the convex hull of a Shape3D (except polyLine) onto the plane z = 0 (in world coordinates) and creates the corresponding pixel region. The minimum and maximum world coordinate extent of the convex hull in the z-direction are returned. The reference image defines the pixel coordinate system to be used for the PixelRegion.</desc>
                    <sample for="lua">pixelRegion, zMin, zMax = Shape3D.toPixelRegion(shape, referenceImage)</sample>
                    <param name="shape" type="const object" multiplicity="[1+]" alias="Shape3D" desc="The shape used to define the pixel region."/>
                    <param name="referenceImage" type="const object" alias="Image" desc="An image defining the coordinate system used to create the PixelRegion."/>
                    <param name="fill" type="bool" multiplicity="?" desc="Set to true to generate a filled region, false to generate a border region. Non-closed shapes will always generate a border only."/>
                    <return name="pixelRegion" type="object" multiplicity="[?*]" alias="Image.PixelRegion" desc="The projected convex hull region, or nil on error."/>
                    <return name="zMin" type="float" multiplicity="[?*]" desc="The minimum z-position of any part of the shape, in image world coordinates."/>
                    <return name="zMax" type="float" multiplicity="[?*]" desc="The maximum z-position of any part of the shape, in image world coordinates."/>
                </function>
                <function name="fitPlane">
                    <trait>released</trait>
                    <links>Image.SurfaceFitter, PointCloud.ShapeFitter</links>
                    <desc>Fit a plane shape to a set of 3D-points. Different fitting and outlier handling modes are available.

Fitting mode may be any of:
LEASTSQUARES - Ordinary least squares, fast but not robust against outliers.
RANSAC - Outlier rejection by random sampling and consensus. The trade-off between speed and robustness can be adjusted using an iteration parameter.
TRIMMED - Two stages of least squares fitting with outlier rejection between the stages. Performance is in general in between RANSAC and least squares with respect to robustness and speed.

For RANSAC and trimmed modes, outliers are specified with a margin parameter in one of the following ways:
ABSOLUTE - Absolute outlier margin, points with a distance larger than the specified distance from the plane are treated as outliers.
RANK - Defines the fraction of points to treat as inlier points. For example, a rank margin of 0.7 means that the best 70% of all points are included and the rest are ignored as outliers. If there are additional points close to the margin, those will also be included such that the final inlier fraction may be higher.</desc>
                    <sample for="lua">plane, quality = Shape3D.fitPlane(points, mode, margin, iterations)</sample>
                    <param name="points" type="const object" multiplicity="+" alias="Point" desc="Input points."/>
                    <param name="mode" type="enum" multiplicity="?" ref="Shape3D.ShapePointFitMode" desc="Fitting mode. Default is LEASTSQUARES."/>
                    <param name="marginType" type="enum" multiplicity="?" ref="Shape.OutlierMarginType" desc="Outlier margin type (ABSOLUTE or RANK). Only used in fitting modes: RANSAC and TRIMMED. Default is ABSOLUTE."/>
                    <param name="margin" type="float" multiplicity="?" desc="Inlier margin, the interpretation depends on the margin type. Only used in fitting modes: RANSAC and TRIMMED. Default is 2.0 for ABSOLUTE and 0.5 for RANK."/>
                    <param name="iterations" type="int" multiplicity="?" desc="Number of iterations. Only used in iterative fitting mode: RANSAC. Default is 20."/>
                    <return name="plane" type="object" multiplicity="?" alias="Shape3D" desc="Plane with best fit."/>
                    <return name="quality" type="float" multiplicity="*" desc="Vector with fitting quality measurements [meanError, inlierRate], where meanError is the average fitting error of inlier points in world coordinates and inlierRate is the rate of input points that were accepted as belonging to the plane."/>
                </function>
                <function name="fitLine">
                    <trait>released</trait>
                    <links>Image.SurfaceFitter, PointCloud.ShapeFitter</links>
                    <desc>Fit a 3D line to a set of 3D-points. Different fitting and outlier handling modes are available.

Fitting mode may be any of:
LEASTSQUARES - Ordinary least squares, fast but not robust against outliers.
RANSAC - Outlier rejection by random sampling and consensus. The trade-off between speed and robustness can be adjusted using an iteration parameter.
TRIMMED - Two stages of least squares fitting with outlier rejection between the stages. Performance is in general in between RANSAC and least squares with respect to robustness and speed.

For RANSAC and trimmed modes, outliers are specified with a margin parameter in one of the following ways:
ABSOLUTE - Absolute outlier margin, points with a distance larger than the specified distance from the line are treated as outliers.
RANK - Defines the fraction of points to treat as inlier points. For example, a rank margin of 0.7 means that the best 70% of all points are included and the rest are ignored as outliers. If there are additional points close to the margin, those will also be included such that the final inlier fraction may be higher.</desc>
                    <sample for="lua">line3d, quality = Shape3D.fitLine(points, mode, margin, iterations)</sample>
                    <param name="points" type="const object" multiplicity="+" alias="Point" desc="Input points."/>
                    <param name="mode" type="enum" multiplicity="?" ref="Shape3D.ShapePointFitMode" desc="Fitting mode. Default is LEASTSQUARES."/>
                    <param name="marginType" type="enum" multiplicity="?" ref="Shape.OutlierMarginType" desc="Outlier margin type (ABSOLUTE or RANK). Only used in fitting modes: RANSAC and TRIMMED. Default is ABSOLUTE."/>
                    <param name="margin" type="float" multiplicity="?" desc="Inlier margin, the interpretation depends on the margin type. Only used in iterative fitting modes: RANSAC and TRIMMED. Default is 2.0 for ABSOLUTE and 0.5 for RANK."/>
                    <param name="iterations" type="int" multiplicity="?" desc="Number of iterations. Only used in iterative fitting mode: RANSAC."/>
                    <return name="line" type="object" multiplicity="?" alias="Shape3D" desc="The 3D line with best fit."/>
                    <return name="quality" type="float" multiplicity="*" desc="Vector with fitting quality measurements [meanError, inlierRate], where meanError is the average fitting error of inlier points in world coordinates and inlierRate is the rate of input points that were accepted as belonging to the line."/>
                </function>
            </serves>
            <uses/>
        </crown>
        <crown name="Scan">
            <trait>released</trait>
            <desc>Iconic for representation of a scan using polar coordinates (2D) or spherical coordinates (3D). The scanner is centered in the origin.
A scan is divided into beams. Along a beam several echo pulses can be stored.
The horizontal angle of a beam is called theta with a range of (–Pi...Pi]. The rotation direction is always mathematically positive.
The zero degree angle is in the middle of the main view direction of the device so that the scan is symmetrical. According to DIN7000 definition of the mounting position
this would be the x-axis.
The vertical angle of a beam is called phi with a range of [–Pi/2...Pi/2].
The zero degree angle is also located on the x-axis. By this definition single layer scanners always have a phi angle of zero.</desc>
            <enum name="PointLabel">
                <item name="ValidEcho" desc="echo detected, distance value of scan point is &gt;0">VALID_ECHO</item>
                <item name="NoEcho" desc="no echo detected">NO_ECHO</item>
                <item name="Glared" desc="measurement was glared">GLARED</item>
                <item name="Reflector" desc="reflector was detected">REFLECTOR</item>
                <item name="SenderOff" desc="sender was switched off during measurement">SENDER_OFF</item>
            </enum>
            <enum name="ChannelType">
                <item name="Distance" desc="channel with distance values of scan">DISTANCE</item>
                <item name="RSSI" desc="channel with RSSI values of scan">RSSI</item>
                <item name="Theta" desc="channel with theta angular values of scan">THETA</item>
                <item name="Phi" desc="channel with phi angular values of scan">PHI</item>
                <item name="Label" desc="channel with label values of scan">LABEL</item>
                <item name="Properties" desc="channel with properties values of scan">PROPERTIES</item>
            </enum>
            <serves>
                <function name="clone">
                    <desc>Returns a duplicated instance of input scan.
This is a full copy and might be very slow dependent on the scan size.</desc>
                    <sample for="lua">local scanClone = Scan.clone(scan)</sample>
                    <param name="scan" type="const object" alias="Scan" desc="The scan to clone"/>
                    <return name="clone" type="object" alias="Scan" desc="The new cloned scan object"/>
                </function>
                <function name="getSectorCount">
                    <trait>deprecated</trait>
                    <desc>Returns the number of sectors in this scan. DEPRECATED: Scan type does not support sectors anymore. Function returns always 1.</desc>
                    <sample for="lua">local sectorcount = Scan.getSectorCount(scan)</sample>
                    <param name="scan" type="const object" alias="Scan" desc="The instance handle to use"/>
                    <return name="sectorCount" type="int" desc="The number of sectors in this scan"/>
                </function>
                <function name="getPulseCount">
                    <trait>deprecated</trait>
                    <desc>Returns the number of pulses in the specified sector of this scan. DEPRECATED: Please use the function "getEchoCount" in future.</desc>
                    <sample for="lua">local pulsecount = Scan.getPulseCount(scan, sector)</sample>
                    <param name="scan" type="const object" alias="Scan" desc="The instance handle to use"/>
                    <param name="sector" type="int" multiplicity="?" desc="Sector index starting from 0, optional if only single sector (default=0)"/>
                    <return name="pulseCount" type="int" multiplicity="?" desc="The number of pulses in the specified sector of this scan or nil if sector doesn't exist"/>
                </function>
                <function name="getBeamCount">
                    <desc>Returns the number of beams in this scan.</desc>
                    <sample for="lua">local beamcount = Scan.getBeamCount(scan)</sample>
                    <param name="scan" type="const object" alias="Scan" desc="The instance handle to use"/>
                    <return name="beamCount" type="int" desc="The number of beams in this scan"/>
                </function>
                <function name="getEchoCount">
                    <desc>Returns the number of echoes in the of this scan.</desc>
                    <sample for="lua">local echocount = Scan.getEchoCount(scan)</sample>
                    <param name="scan" type="const object" alias="Scan" desc="The instance handle to use"/>
                    <return name="echoCount" type="int" desc="The number of echoes in this scan"/>
                </function>
                <function name="getPoint">
                    <desc>Returns the distance, theta angle and phi angle value of the specified scan point.</desc>
                    <sample for="lua">local distance, theta, phi = Scan.getPoint(scan, beam, echo)</sample>
                    <param name="scan" type="const object" alias="Scan" desc="The instance handle to use"/>
                    <param name="beam" type="int" desc="Beam index starting from 0"/>
                    <param name="echo" type="int" multiplicity="?" desc="Echo index starting from 0, optional if only single echo (default=0)"/>
                    <return name="distance" type="float" multiplicity="?" desc="Distance value in [mm], only distance &gt;0 is valid"/>
                    <return name="theta" type="float" multiplicity="?" desc="horizontal angle (-Pi..+Pi]"/>
                    <return name="phi" type="float" multiplicity="?" desc="vertical angle [-Pi/2..+Pi/2]"/>
                </function>
                <function name="getPointDistance">
                    <desc>Returns the distance of the specified scan point.</desc>
                    <sample for="lua">local distance = Scan.getPointDistance(scan, beam, echo)</sample>
                    <param name="scan" type="const object" alias="Scan" desc="The instance handle to use"/>
                    <param name="beam" type="int" desc="Beam index starting from 0"/>
                    <param name="echo" type="int" multiplicity="?" desc="Echo index starting from 0, optional if only single echo (default=0)"/>
                    <return name="distance" type="float" multiplicity="?" desc="Distance value in [mm], only distance &gt;0 is valid"/>
                </function>
                <function name="getPointRSSI">
                    <desc>Returns the RSSI of the specified scan point.</desc>
                    <sample for="lua">local rssi = Scan.getPointRSSI(scan, beam, echo)</sample>
                    <param name="scan" type="const object" alias="Scan" desc="The instance handle to use"/>
                    <param name="beam" type="int" desc="Beam index starting from 0"/>
                    <param name="echo" type="int" multiplicity="?" desc="Echo index starting from 0, optional if only single echo (default=0)"/>
                    <return name="rssi" type="float" multiplicity="?" desc="RSSI value between 0 and 1 of given scan point."/>
                </function>
                <function name="getPointLabel">
                    <desc>Returns the label of the specified scan point.</desc>
                    <sample for="lua">local label = Scan.getPointLabel(scan, beam, echo)</sample>
                    <param name="scan" type="const object" alias="Scan" desc="The instance handle to use"/>
                    <param name="beam" type="int" desc="Beam index starting from 0"/>
                    <param name="echo" type="int" multiplicity="?" desc="Echo index starting from 0, optional if only single echo (default=0)"/>
                    <return name="label" type="enum" multiplicity="?" ref="PointLabel" desc="Label type of given scan point (e.g.: NO_ECHO, GLARED)"/>
                </function>
                <function name="getPointTheta">
                    <desc>Returns the theta angle of the specified scan point.</desc>
                    <sample for="lua">local theta = Scan.getPointTheta(scan, beam)</sample>
                    <param name="scan" type="const object" alias="Scan" desc="The instance handle to use"/>
                    <param name="beam" type="int" desc="Beam index starting from 0"/>
                    <return name="theta" type="float" multiplicity="?" desc="horizontal angle (-Pi..+Pi]"/>
                </function>
                <function name="getPointPhi">
                    <desc>Returns the phi angle of the specified scan point.</desc>
                    <sample for="lua">local phi = Scan.getPointPhi(scan, beam)</sample>
                    <param name="scan" type="const object" alias="Scan" desc="The instance handle to use"/>
                    <param name="beam" type="int" desc="Beam index starting from 0"/>
                    <return name="phi" type="float" multiplicity="?" desc="vertical angle [-Pi/2..+Pi/2]"/>
                </function>
                <function name="setPoint">
                    <desc>Sets the distance, theta angle and phi angle of the specified scan point.</desc>
                    <sample for="lua">Scan.setPoint(scan, beam, echo, distance, theta, phi)</sample>
                    <param name="scan" type="object" alias="Scan" desc="The instance handle to use"/>
                    <param name="beam" type="int" desc="Beam index starting from 0"/>
                    <param name="echo" type="int" desc="Echo index starting from 0."/>
                    <param name="distance" type="float" desc="Distance value in [mm]"/>
                    <param name="theta" type="float" multiplicity="?" desc="horizontal angle (-Pi..+Pi]"/>
                    <param name="phi" type="float" multiplicity="?" desc="vertical angle [-Pi/2..+Pi/2]"/>
                    <return name="success" type="bool" desc="True if successful, false if nothing is written"/>
                </function>
                <function name="setPointDistance">
                    <desc>Sets the distance of the specified scan point.</desc>
                    <sample for="lua">Scan.setPointDistance(scan, beam, echo, distance)</sample>
                    <param name="scan" type="object" alias="Scan" desc="The instance handle to use"/>
                    <param name="beam" type="int" desc="Beam index starting from 0"/>
                    <param name="echo" type="int" desc="Echo index starting from 0."/>
                    <param name="distance" type="float" desc="Distance value in [mm]"/>
                    <return name="success" type="bool" desc="True if successful, false if nothing is written"/>
                </function>
                <function name="setPointRSSI">
                    <desc>Sets the RSSI of the specified scan point.</desc>
                    <sample for="lua">Scan.setPointRSSI(scan, beam, echo, rssi)</sample>
                    <param name="scan" type="object" alias="Scan" desc="The instance handle to use"/>
                    <param name="beam" type="int" desc="Beam index starting from 0"/>
                    <param name="echo" type="int" desc="Echo index starting from 0"/>
                    <param name="rssi" type="float" desc="RSSI value between 0 and 1 of given scan point."/>
                    <return name="success" type="bool" desc="True if successful, false if nothing is written"/>
                </function>
                <function name="setPointLabel">
                    <desc>Sets the label of the specified scan point.</desc>
                    <sample for="lua">Scan.setPointLabel(scan, beam, echo, label)</sample>
                    <param name="scan" type="object" alias="Scan" desc="The instance handle to use"/>
                    <param name="beam" type="int" desc="Beam index starting from 0"/>
                    <param name="echo" type="int" desc="Echo index starting from 0"/>
                    <param name="label" type="enum" ref="PointLabel" desc="Label type of given scan point (e.g.: NO_ECHO, GLARED)"/>
                    <return name="success" type="bool" desc="True if successful, false if nothing is written"/>
                </function>
                <function name="setPointProperties">
                    <trait>hidden</trait>
                    <desc>Sets the properties of the specified scan point. Properties are a 32-bit flag combination.</desc>
                    <sample for="lua">Scan.setPointProperties(scan, beam, echo, properties)</sample>
                    <param name="scan" type="object" alias="Scan" desc="The instance handle to use"/>
                    <param name="beam" type="int" desc="Beam index starting from 0"/>
                    <param name="echo" type="int" desc="Echo index starting from 0"/>
                    <param name="properties" type="int" desc="32-bit flag combination of properties"/>
                    <return name="success" type="bool" desc="True if successful, false if nothing is written"/>
                </function>
                <function name="setPointTheta">
                    <desc>Sets theta angle value of the specified scan point.</desc>
                    <sample for="lua">Scan.setPointTheta(scan, beam, theta)</sample>
                    <param name="scan" type="object" alias="Scan" desc="The instance handle to use"/>
                    <param name="beam" type="int" desc="Beam index starting from 0"/>
                    <param name="theta" type="float" desc="horizontal angle (-Pi..+Pi]"/>
                    <return name="success" type="bool" desc="True if successful, false if nothing is written"/>
                </function>
                <function name="setPointPhi">
                    <desc>Sets phi angle value of the specified scan point.</desc>
                    <sample for="lua">Scan.setPointPhi(scan, beam, phi)</sample>
                    <param name="scan" type="object" alias="Scan" desc="The instance handle to use"/>
                    <param name="beam" type="int" desc="Beam index starting from 0"/>
                    <param name="phi" type="float" desc="vertical angle [-Pi/2..+Pi/2]"/>
                    <return name="success" type="bool" desc="True if successful, false if nothing is written"/>
                </function>
                <function name="getNumber">
                    <desc>Gets the number of the scan</desc>
                    <sample for="lua">local number = Scan.getNumber(scan)</sample>
                    <param name="scan" type="const object" alias="Scan" desc="The instance handle to use"/>
                    <return name="number" type="int" desc="The scan number"/>
                </function>
                <function name="getTimeStamps">
                    <desc>Gets relative time stamps of first and last beam in microseconds</desc>
                    <sample for="lua">local startTime, stopTime = Scan.getTimeStamps(scan)</sample>
                    <param name="scan" type="const object" alias="Scan" desc="The instance handle to use"/>
                    <return name="start" type="int" desc="Time stamp of first beam (microseconds)"/>
                    <return name="stop" type="int" desc="Time stamp of last beam (microseconds)"/>
                </function>
                <function name="toVector">
                    <desc>Gets a vector of points (read only) of a certain type.</desc>
                    <sample for="lua">local vector = Scan.toVector(scan, type, echo)</sample>
                    <param name="scan" type="const object" alias="Scan" desc="The instance handle to use"/>
                    <param name="type" type="enum" ref="ChannelType" desc="Channel type ('DISTANCE', 'RSSI', 'THETA' or 'PHI')"/>
                    <param name="echo" type="int" multiplicity="?" desc="Echo index starting from 0, necessary if selected channel type can have several echoes (default=0)"/>
                    <return name="datachannel" type="auto" multiplicity="*" desc="List of points according to selected channel"/>
                </function>
                <function name="setFromVector">
                    <desc>Sets a vector of points of a certain channel type.</desc>
                    <sample for="lua">local success = Scan.setFromVector(scan, type, datachannel, echo)</sample>
                    <param name="scan" type="object" alias="Scan" desc="The instance handle to use"/>
                    <param name="type" type="enum" ref="ChannelType" desc="Channel type ('DISTANCE', 'RSSI', 'THETA' or 'PHI')"/>
                    <param name="datachannel" type="auto" multiplicity="+" desc="List of points according to selected channel. The number of points in the list must match the number of beams of the scan. Otherwise the desired channel is not set."/>
                    <param name="echo" type="int" multiplicity="?" desc="Echo index starting from 0, necessary if selected channel type can have several echoes (default=0)"/>
                    <return name="success" type="bool" desc="True if successful, false if nothing is written"/>
                </function>
                <function name="toString">
                    <desc>Gets a user-friendly string description of the scan.</desc>
                    <sample for="lua">local str = Scan.toString(scan)</sample>
                    <param name="scan" type="const object" alias="Scan" desc="The scan object."/>
                    <return name="str" type="string" desc="User-friendly description of the scan."/>
                </function>
                <function name="toProfile">
                    <desc>Converts a selected echo of a scan to a profile.</desc>
                    <sample for="lua">local profile = Scan.toProfile(scan, type, echo)</sample>
                    <param name="scan" type="object" alias="Scan" desc="The instance handle to use"/>
                    <param name="type" type="enum" ref="ChannelType" desc="Channel type ('DISTANCE' or 'RSSI') containing the data"/>
                    <param name="echo" type="int" multiplicity="?" desc="Echo index starting from 0, optional if only single echo (default=0)"/>
                    <return name="profile" type="object" desc="Profile filled with the selected channel of the scan"/>
                </function>
                <function name="importFromProfile">
                    <desc>Copies the data channel of a profile to the specified channel of an existing scan. The size of the profile must match the number of beams of the scan.
If the valid flag vector is present in the profile, a valid flag of zero will force the corresponding distance value in the scan to zero.
The coordinate vectors of the profile are ignored.</desc>
                    <sample for="lua">local scan = Scan.importFromProfile(scan, profile, channelType, echo)</sample>
                    <param name="scan" type="object" alias="Scan" desc="The scan which imports the profile data. The operation happens in place, i.e. the original channel content of the scan is lost. Clone the scan, if you want to preserve it."/>
                    <param name="profile" type="object" desc="Profile containing the data to be imported. Only the data vector is considered, the coordinates are ignored."/>
                    <param name="type" type="enum" multiplicity="?" ref="ChannelType" desc="Optional channel type ('DISTANCE' or 'RSSI') of the target channel for the import in the scan (default is 'DISTANCE')."/>
                    <param name="echo" type="int" multiplicity="?" desc="Optional echo index starting from 0 indicating the echo where the data will be imported (default=0)."/>
                    <return name="scan" type="object" multiplicity="?" alias="Scan" desc="A reference to the input scan. If the import fails, the return value will be nil."/>
                </function>
            </serves>
            <uses/>
            <crown name="Transform">
                <trait>released</trait>
                <desc>Transformation for 2D polar coordinate data (Scan type) to 3D Cartesian world coordinates (PointCloud type).
The transformation is done by converting the 2D polar coordinates into 2D Cartesian polar coordinates followed by a lifting into three dimensions. Next, a ridig transform (rotation and translation) is applied to the data in order to have all points in a common sensor world coordinate system.

To this end, the position and orientation of the sensor where the data has originated from must be specified.

For the orientation there exist two different possibilities:

1.) SICK Coordinates (alpha-beta-gamma):
The alpha-beta-gamma-system defines an origin in world coordinates. The scanner position is given relative to this position (x, y and z-coordinate). The scanner orientation is given using the three angles alpha, beta and gamma. The system was initially developed for conveyor applications.

The initial scanner orientation is defined as follows:
- The scanner is facing downwards (contrary to world-z-coordinate).
- The scan lies within the x-z-plane of the world coordinate system.
- The middle beam of the scanner lies on the z-axis.
- The scan origin (usually a rotating prism or a mirror) lies in the world coordinate origin.
- The top of the scanner is facing the rising y-values of the world coordinate system.

2.) Yaw-Pitch-Roll (DIN 70000):
The yaw-pitch-roll-system uses the well known transformations defined for vehicles in DIN 70000. The scanner position is given relative to the world coordinate origin
(x, y and z-coordinate). The scanner orientation is given using the three angles yaw, pitch and roll.

The initial scanner orientation is defined as follows:
- The scanner is looking along the x-axis.
- The scan lies within the x-y-plane of the world coordinate system.
- The middle beam (i.e. the 0° beam) of the scanner lies on the x-axis.
- The scan origin (usually a rotating prism or a mirror) lies in the world coordinate origin.
- The top of the scanner is facing the rising z-values of the world coordinate system.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">local handle = Scan.Transform.create()</sample>
                        <return name="handle" type="handle" alias="Scan.Transform" desc="Handle to the new instance"/>
                    </function>
                    <function name="transformToPointCloud">
                        <include>data-flow</include>
                        <desc>Transforms the 2D polar coordinates to 3D Cartesian world coordinates and returns a PointCloud object.</desc>
                        <sample for="lua">local pointCloud = Scan.Transform.transformToPointCloud(handle, scan)</sample>
                        <param name="handle" type="handle" alias="Scan.Transform" desc="The instance handle to use"/>
                        <param name="scan" type="const object" multiplicity="[1+]" alias="Scan" desc="The scan which is transformed"/>
                        <return name="pointCloud" type="object" multiplicity="[?*]" alias="PointCloud" desc="Transformed PointCloud"/>
                    </function>
                    <function name="setPosition">
                        <desc>Sets the sensor position in Cartesian world coordinates.</desc>
                        <sample for="lua">Scan.Transform.setPosition(handle, sensorX, sensorY, sensorZ)</sample>
                        <param name="handle" type="handle" alias="Scan.Transform" desc="The instance handle to use"/>
                        <param name="x" type="float" desc="X position of sensor in [mm]"/>
                        <param name="y" type="float" desc="Y position of sensor in [mm]"/>
                        <param name="z" type="float" desc="Z position of sensor in [mm]"/>
                    </function>
                    <function name="setX">
                        <trait>hidden</trait>
                        <desc>Sets the sensor position parameter.</desc>
                        <sample for="lua">Scan.Transform.setX(handle, 0.0)</sample>
                        <param name="handle" type="handle" alias="Scan.Transform" desc="The instance handle to use"/>
                        <param name="x" type="float" desc="X position of sensor in [mm]"/>
                    </function>
                    <function name="setY">
                        <trait>hidden</trait>
                        <desc>Sets the sensor position parameter.</desc>
                        <sample for="lua">Scan.Transform.setY(handle, 0.0)</sample>
                        <param name="handle" type="handle" alias="Scan.Transform" desc="The instance handle to use"/>
                        <param name="y" type="float" desc="Y position of sensor in [mm]"/>
                    </function>
                    <function name="setZ">
                        <trait>hidden</trait>
                        <desc>Sets the sensor position parameter.</desc>
                        <sample for="lua">Scan.Transform.setZ(handle, 0.0)</sample>
                        <param name="handle" type="handle" alias="Scan.Transform" desc="The instance handle to use"/>
                        <param name="z" type="float" desc="Z position of sensor in [mm]"/>
                    </function>
                    <function name="setYawPitchRoll">
                        <desc>Sets the standard sensor angle parameter in a yaw/pitch/roll coordinate system.</desc>
                        <sample for="lua">Scan.Transform.setYawPitchRoll(handle, yaw, pitch, roll)</sample>
                        <param name="handle" type="handle" alias="Scan.Transform" desc="The instance handle to use"/>
                        <param name="yaw" type="float" desc="Yaw angle of sensor in radian"/>
                        <param name="pitch" type="float" desc="Pitch angle of sensor in radian"/>
                        <param name="roll" type="float" desc="Roll angle of sensor in radian"/>
                    </function>
                    <function name="setYaw">
                        <trait>hidden</trait>
                        <desc>Sets the standard sensor angle parameter in a yaw/pitch/roll coordinate system.</desc>
                        <sample for="lua">Scan.Transform.setYaw(handle, 0.0)</sample>
                        <param name="handle" type="handle" alias="Scan.Transform" desc="The instance handle to use"/>
                        <param name="yaw" type="float" desc="Yaw angle of sensor in radian"/>
                    </function>
                    <function name="setPitch">
                        <trait>hidden</trait>
                        <desc>Sets the standard sensor angle parameter in a yaw/pitch/roll coordinate system.</desc>
                        <sample for="lua">Scan.Transform.setPitch(handle, 0.0)</sample>
                        <param name="handle" type="handle" alias="Scan.Transform" desc="The instance handle to use"/>
                        <param name="pitch" type="float" desc="Pitch angle of sensor in radian"/>
                    </function>
                    <function name="setRoll">
                        <trait>hidden</trait>
                        <desc>Sets the standard sensor angle parameter in a yaw/pitch/roll coordinate system.</desc>
                        <sample for="lua">Scan.Transform.setRoll(handle, 0.0)</sample>
                        <param name="handle" type="handle" alias="Scan.Transform" desc="The instance handle to use"/>
                        <param name="roll" type="float" desc="Roll angle of sensor in radian"/>
                    </function>
                    <function name="setAlpha">
                        <trait>hidden</trait>
                        <desc>Sets the SICK sensor angle parameter in a alpha/beta/gamma coordinate system.</desc>
                        <sample for="lua">Scan.Transform.setAlpha(handle, 0.0)</sample>
                        <param name="handle" type="handle" alias="Scan.Transform" desc="The instance handle to use"/>
                        <param name="alpha" type="float" desc="Alpha angle of sensor in radian"/>
                    </function>
                    <function name="setBeta">
                        <trait>hidden</trait>
                        <desc>Sets the SICK sensor angle parameter in a alpha/beta/gamma coordinate system.</desc>
                        <sample for="lua">Scan.Transform.setBeta(handle, 0.0)</sample>
                        <param name="handle" type="handle" alias="Scan.Transform" desc="The instance handle to use"/>
                        <param name="beta" type="float" desc="Beta angle of sensor in radian"/>
                    </function>
                    <function name="setGamma">
                        <trait>hidden</trait>
                        <desc>Sets the SICK sensor angle parameter in a alpha/beta/gamma coordinate system.</desc>
                        <sample for="lua">Scan.Transform.setGamma(handle, 0.0)</sample>
                        <param name="handle" type="handle" alias="Scan.Transform" desc="The instance handle to use"/>
                        <param name="gamma" type="float" desc="Gamma angle of sensor in radian"/>
                    </function>
                    <function name="setXOffset">
                        <trait>hidden</trait>
                        <desc>Sets the sensor position offset parameter. May change with every new scan data object.</desc>
                        <sample for="lua">Scan.Transform.setXOffset(handle, 0.0)</sample>
                        <param name="handle" type="handle" alias="Scan.Transform" desc="The instance handle to use"/>
                        <param name="xOffset" type="float" desc="X offset of sensor in [mm]"/>
                    </function>
                    <function name="setYOffset">
                        <trait>hidden</trait>
                        <desc>Sets the sensor position offset parameter. May change with every new scan data object.</desc>
                        <sample for="lua">Scan.Transform.setYOffset(handle, 0.0)</sample>
                        <param name="handle" type="handle" alias="Scan.Transform" desc="The instance handle to use"/>
                        <param name="yOffset" type="float" desc="Y offset of sensor in [mm]"/>
                    </function>
                    <function name="setZOffset">
                        <trait>hidden</trait>
                        <desc>Sets the sensor position offset parameter. May change with every new scan data object.</desc>
                        <sample for="lua">Scan.Transform.setZOffset(handle, 0.0)</sample>
                        <param name="handle" type="handle" alias="Scan.Transform" desc="The instance handle to use"/>
                        <param name="zOffset" type="float" desc="Z offset of sensor in [mm]"/>
                    </function>
                </serves>
            </crown>
            <crown name="BackgroundFilter">
                <trait>released</trait>
                <desc>The background filter compares the points from the input scan to a scan representing the background. If the absolute distance difference between a point of the input scan and the corresponding point of the background scan is below a threshold (defined by setThreshold) the point is invalidated (distance value set to zero). The background scan is set by passing a scan to the setBackground function. If no background is set, the first scan which is passed to the filter is used as background. Optionally, the background can be updated dynamically by setting the parameter of the function setDynamicBackgroundUpdateEnabled to true. In that case the two functions setBackgroundResetTime and setBackgroundValidationTime are used to control the update behavior. If for a certain beam angle the background criterion is violated for at least backgroundResetTime, the current background at that angle is reset. Now, there is no background for this angle anymore (i.e. no filtering is done at this angle) until the background criterion (distances do not move out of the limits defined by the threshold) is fulfilled again for at least backgroundValidationTime. With this behavior different cases can be distinguished:
* The environment changes dynamically shorter than backgroundResetTime for some angles. In that case, the original background is not changed and new/dynamic objects become visible in the scan.
* The environment changes dynamically longer that backgroundResetTime for some angles. Now the original background is reset and no filtering is done anymore for these angles. If now a static situation recurs (i.e. the background criterion is fulfilled) it takes backgroundValidationTime until a new background is set and filtering starts again.

For multilayer scanners the filtering happens separately for each layer and each layer uses a separate background scan. The setBackground function evaluates the phi angle of a scan to determine the layer for which the scan is used as background. To override the phi angle of the scan, it can be specified as optional argument of setBackground.

The filter operates only on the first echo. For multi-echo scanners it is recommended to use the echo filter prior to the background filter.

The filter operates in place, therefore make a copy of the original scan using Scan.clone() if necessary.</desc>
                <serves>
                    <function name="create">
                        <desc>This function creates a new background filter handle.</desc>
                        <sample for="lua"> handle = Scan.BackgroundFilter.create()</sample>
                        <return name="handle" type="handle" alias="Scan.BackgroundFilter" desc="Handle to the instance"/>
                    </function>
                    <function name="filter">
                        <desc>Returns the filtered scan.</desc>
                        <sample for="lua">scan = Scan.BackgroundFilter.filter(handle, scan)</sample>
                        <param name="handle" type="handle" alias="Scan.BackgroundFilter" desc="The instance handle to use"/>
                        <param name="scan" type="object" multiplicity="[1+]" alias="Scan" desc="The scan which is filtered. The filtering happens in-place, therefore the input scan is potentially modified. Clone the input scan if you want to use its original version elsewhere."/>
                        <return name="scan" type="object" multiplicity="[?*]" alias="Scan" desc="Filtered Scan"/>
                    </function>
                    <function name="setBackground">
                        <desc>Sets the background scan. To set the background for different layers call the function multiple times with scans with different phi angles or with different values for the argument phi. The value of phi is rounded to two decimal places. If the scan has no DISTANCE channel or no beams at all the scan is ignored. A previously defined background remains valid. The same happens if the PHI channel is not constant and the parameter phi is not set.</desc>
                        <sample for="lua">Scan.BackgroundFilter.setBackground(handle, backgroundScan, phi)</sample>
                        <param name="handle" type="handle" alias="Scan.BackgroundFilter" desc="The instance handle to use"/>
                        <param name="backgroundScan" type="object" desc="Background scan. The layer to apply the scan is determined using its phi angle."/>
                        <param name="phi" type="float" multiplicity="?" desc="Optional phi angle in radian to override the phi angle of the backgroundScan."/>
                    </function>
                    <function name="setThreshold">
                        <desc>Sets the threshold to decide whether a point belongs to the background or not. If the absolute distance difference between corresponding points of the current scan and the background scan is below the threshold, the point of the current scan is classified as background and otherwise as foreground.</desc>
                        <sample for="lua">Scan.BackgroundFilter.setThreshold(handle, threshold)</sample>
                        <param name="handle" type="handle" alias="Scan.BackgroundFilter" desc="The instance handle to use"/>
                        <param name="threshold" type="float" desc="Threshold value in mm. (default = 200)"/>
                    </function>
                    <function name="setDynamicBackgroundUpdateEnabled">
                        <desc>If enabled the background adapts dynamically to changes in the environment.</desc>
                        <sample for="lua">Scan.BackgroundFilter.setDynamicBackgroundUpdateEnabled(handle, dynamicBackgroundUpdate)</sample>
                        <param name="handle" type="handle" alias="Scan.BackgroundFilter" desc="The instance handle to use"/>
                        <param name="dynamicBackgroundUpdate" type="bool" desc="Set true to enable dynamic background update. (default = false)"/>
                    </function>
                    <function name="setBackgroundResetTime">
                        <desc>Defines the time in ms a point at a certain angle has to violate the background criterion until the background for that point is reset.</desc>
                        <sample for="lua">Scan.BackgroundFilter.setBackgroundResetTime(handle, backgroundResetTime)</sample>
                        <param name="handle" type="handle" alias="Scan.BackgroundFilter" desc="The instance handle to use"/>
                        <param name="backgroundResetTime" type="int" desc="backgroundResetTime in ms."/>
                    </function>
                    <function name="setBackgroundValidationTime">
                        <desc>Defines the time in ms a point at a certain angle has to fulfill the background criterion until it becomes a background point.</desc>
                        <sample for="lua">Scan.BackgroundFilter.setBackgroundValidationTime(handle, backgroundValidationTime)</sample>
                        <param name="handle" type="handle" alias="Scan.BackgroundFilter" desc="The instance handle to use"/>
                        <param name="backgroundValidationTime" type="int" desc="backgroundValidationTime in ms."/>
                    </function>
                    <function name="setEnabled">
                        <desc>Enables/Disables the filter. If disabeled, the input scan is returned without modifications. The filter keeps its parameters (background scan etc.) if it is re-enabled.</desc>
                        <sample for="lua">Scan.BackgroundFilter.setEnabled(handle, enable)</sample>
                        <param name="handle" type="handle" alias="Scan.BackgroundFilter" desc="The instance handle to use."/>
                        <param name="enable" type="bool" desc="Set to true if filter should be enabled, false otherwise. (default = true)"/>
                    </function>
                </serves>
            </crown>
            <crown name="CubicAreaFilter">
                <trait>released</trait>
                <desc>The CubicAreaFilter limits a polar scan to a axis-parallel cube defined by its extension in x-, y- and z-range. Distance values outside the cube are set to zero (such that they are ignored for a subsequent transformation to a point cloud). The extent of the cube is described in world coordinates. For that reason the sensor pose must be provided in world coordinates as well. It can be defined either in the SICK coordinate system (alpha-beta-gamma) or in the DIN 70000 coordinate system (Yaw-Pitch-Roll). The API is the same as in Scan.Transform. The filter operates in place, therefore make a copy of the original scan using Scan.clone() if necessary. The filter expects a constant vertical angle, i.e. the phi channel must either be empty or have a length of 1. The filter precomputes the beam directions once using the angle values of the first scan passed to the filter function. The beam directions are recalculated only if the length of the scan or the phi value changes. Consequently, the filtered values may slightly lay outside the defined bounding box if the theta values change from scan to scan.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">local handle = Scan.CubicAreaFilter.create()</sample>
                        <return name="handle" type="handle" alias="Scan.CubicAreaFilter" desc="Handle to the new instance."/>
                    </function>
                    <function name="setEnabled">
                        <desc>Enables/Disables the filter.</desc>
                        <sample for="lua">Scan.CubicAreaFilter.setEnabled(handle, enable)</sample>
                        <param name="handle" type="handle" alias="Scan.CubicAreaFilter" desc="The instance handle to use."/>
                        <param name="enable" type="bool" desc="Set to true if filter should be enabled, false otherwise. (default = true)"/>
                    </function>
                    <function name="filter">
                        <include>data-flow</include>
                        <desc>Returns the filtered scan.</desc>
                        <sample for="lua">local filteredScan = Scan.CubicAreaFilter.filter(handle, scan)</sample>
                        <param name="handle" type="handle" alias="Scan.CubicAreaFilter" desc="The instance handle to use."/>
                        <param name="scan" type="object" multiplicity="[1+]" alias="Scan" desc="The Scan object which is filtered. The filtering happens in-place, therefore the input scan is potentially modified. Clone the input scan if you want to use its original version elsewhere."/>
                        <return name="filteredScan" type="object" multiplicity="[?*]" alias="Scan" desc="The filtered Scan"/>
                    </function>
                    <function name="setYawPitchRoll">
                        <desc>Sets the sensor orientation in the DIN70000 coordinate system coordinate system (Yaw-Pitch-Roll).</desc>
                        <sample for="lua">Scan.CubicAreaFilter.setYawPitchRoll(handle, yaw, pitch, roll)</sample>
                        <param name="handle" type="handle" alias="Scan.CubicAreaFilter" desc="The instance handle to use"/>
                        <param name="yaw" type="float" desc="Yaw angle of sensor in radian"/>
                        <param name="pitch" type="float" desc="Pitch angle of sensor in radian"/>
                        <param name="roll" type="float" desc="Roll angle of sensor in radian"/>
                    </function>
                    <function name="setAlphaBetaGamma">
                        <desc>Sets the orientation of the sensor in the SICK coordinate system (alpha-beta-gamma).</desc>
                        <sample for="lua">Scan.CubicAreaFilter.setAlphaBetaGamma(handle, alpha, beta, gamma)</sample>
                        <param name="handle" type="handle" alias="Scan.CubicAreaFilter" desc="The instance handle to use"/>
                        <param name="alpha" type="float" desc="Alpha angle of sensor in radian"/>
                        <param name="beta" type="float" desc="Beta angle of sensor in radian"/>
                        <param name="gamma" type="float" desc="Gamma angle of sensor in radian"/>
                    </function>
                    <function name="setPosition">
                        <desc>Sets the sensor position in Cartesian world coordinates. Depending on how the orientation is set the axes are oriented as defined in the respective coordinate system.</desc>
                        <sample for="lua">Scan.CubicAreaFilter.setPosition(handle, sensorX, sensorY, sensorZ)</sample>
                        <param name="handle" type="handle" alias="Scan.CubicAreaFilter" desc="The instance handle to use"/>
                        <param name="x" type="float" desc="X position of sensor in [mm]"/>
                        <param name="y" type="float" desc="Y position of sensor in [mm]"/>
                        <param name="z" type="float" desc="Z position of sensor in [mm]"/>
                    </function>
                    <function name="setXRange">
                        <desc>Sets the filter range in x-direction. Points outside this range are filtered out.</desc>
                        <sample for="lua">Scan.CubicAreaFilter.setXRange(handle, 0, 500)</sample>
                        <param name="handle" type="handle" alias="Scan.CubicAreaFilter" desc="The instance handle to use."/>
                        <param name="minX" type="float" desc="Lower bound of the filter range in x-direction in mm."/>
                        <param name="maxX" type="float" desc="Upper bound of the filter range in x-direction in mm."/>
                    </function>
                    <function name="setYRange">
                        <desc>Sets the filter range in y-direction. Points outside this range are filtered out.</desc>
                        <sample for="lua">Scan.CubicAreaFilter.setYRange(handle, 0, 500)</sample>
                        <param name="handle" type="handle" alias="Scan.CubicAreaFilter" desc="The instance handle to use."/>
                        <param name="minY" type="float" desc="Lower bound of the filter range in y-direction in mm."/>
                        <param name="maxY" type="float" desc="Upper bound of the filter range in y-direction in mm."/>
                    </function>
                    <function name="setZRange">
                        <desc>Sets the filter range in z-direction. Points outside this range are filtered out.</desc>
                        <sample for="lua">Scan.CubicAreaFilter.setZRange(handle, 0, 500)</sample>
                        <param name="handle" type="handle" alias="Scan.CubicAreaFilter" desc="The instance handle to use."/>
                        <param name="minZ" type="float" desc="Lower bound of the filter range in z-direction in mm."/>
                        <param name="maxZ" type="float" desc="Upper bound of the filter range in z-direction in mm."/>
                    </function>
                </serves>
            </crown>
            <crown name="AngleRangeFilter">
                <trait>released</trait>
                <desc>Restriction of the input scan to a specified angle range. The output scan is created as new object. Note that the start and stop time stamps stay unchanged although the number of beams is reduced. The angles of the beams in the new scan are found in the theta channel. The scan segment to be extracted is determined by searching the theta channel for the first and the last element inside the angle range. For devices where the beam angles are not on a fixed grid this can result in a variable length of the output scans.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">local handle = Scan.AngleRangeFilter.create()</sample>
                        <return name="handle" type="handle" alias="Scan.AngleRangeFilter" desc="Handle to the new instance"/>
                    </function>
                    <function name="filter">
                        <include>data-flow</include>
                        <desc>Returns a filtered copy of the scan.</desc>
                        <sample for="lua">local filteredScan = Scan.AngleRangeFilter.filter(handle, scan)</sample>
                        <param name="handle" type="handle" alias="Scan.AngleRangeFilter" desc="The instance handle to use."/>
                        <param name="scan" type="object" multiplicity="[1+]" alias="Scan" desc="The input scan remains unchanged."/>
                        <return name="scan" type="object" multiplicity="[?*]" alias="Scan" desc="The filtered output scan. It is a new scan object with the same meta data as the input scan but the number of beams is reduced as specified by the filter parameters. The output scan always contains a theta channel with the beam angles."/>
                    </function>
                    <function name="setThetaRange">
                        <desc>Sets the angle range of the filter. All beams within the specified window range are preserved for the output scan. The beam range is obtained by searching the closest value to thetaStart and thetaStop in the theta channel of the scan. If the thetaStop is less than thetaStart the thetaStop value is set to the last value of the theta channel.</desc>
                        <sample for="lua">Scan.AngleRangeFilter.setThetaRange(handle, thetaStart, thetaStop)</sample>
                        <param name="handle" type="handle" alias="Scan.AngleRangeFilter" desc="The instance handle to use"/>
                        <param name="thetaStart" type="float" desc="Lower boundary of the angle range [rad]"/>
                        <param name="thetaStop" type="float" desc="Upper boundary of the angle range [rad]"/>
                    </function>
                    <function name="setBeamIncrement">
                        <desc>Sets the 'beamIncrement' which is used to subsample the beams within the selected angle range. With a 'beamIncrement' of n only every nth beam from the selected angle range is copied to the output scan, i.e. the angle resolution is reduced by factor n. If the beamIncrement is zero it is set to one.</desc>
                        <sample for="lua">Scan.AngleRangeFilter.setBeamIncrement(handle, 2)</sample>
                        <param name="handle" type="handle" alias="Scan.AngleRangeFilter" desc="The instance handle to use."/>
                        <param name="beamIncrement" type="int" desc="The beam increment to be used (default = 1)."/>
                    </function>
                    <function name="setEnabled">
                        <desc>Enables/Disables the filter.</desc>
                        <sample for="lua">Scan.AngleRangeFilter.setEnabled(handle, enable)</sample>
                        <param name="handle" type="handle" alias="Scan.AngleRangeFilter" desc="The instance handle to use."/>
                        <param name="enable" type="bool" desc="Set to true if filter should be enabled, false otherwise. (default = true)"/>
                    </function>
                </serves>
            </crown>
            <crown name="MedianFilter">
                <trait>released</trait>
                <desc>Noise reduction on distance values with a 1D or 2D sliding window median filter. In 1D mode the filter operates on the distances of the beams within one scan. In 2D mode scans are buffered depending on the defined filter width and the median is computed over all distance values which lie temporally (in scan direction) and spatially (in beam direction) within the filter with. No scans are returned until the buffer is filled, i.e. the filtered scan will be NIL in this case. The filter operates in-place, therefore take care that in 2D mode the buffered scans are not modified outside of the filter. The border points (i.e. up to half of the filter length) are not filtered. Instead they are assigned the distance value of 0 and the label NO_ECHO indicating that they are undefined. Only the configured echo is filtered. The maximum filter length is 7. For multilayer data, each layer is filtered separately.</desc>
                <enum name="MedianFilterType">
                    <item name="1D Filter" desc="Filter within one scan (1D)">1D</item>
                    <item name="2D Filter" desc="Filter window spans FILTERLENGTH scans (2D)">2D</item>
                </enum>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">local handle = Scan.MedianFilter.create()</sample>
                        <return name="handle" type="handle" alias="Scan.MedianFilter" desc="Handle to the new instance"/>
                    </function>
                    <function name="filter">
                        <include>data-flow</include>
                        <desc>Filters the scan and returns it also.</desc>
                        <sample for="lua">local filteredScan = Scan.MedianFilter.filter(handle, scan)</sample>
                        <param name="handle" type="handle" alias="Scan.MedianFilter" desc="The instance handle to use"/>
                        <param name="scan" type="object" multiplicity="[1+]" alias="Scan" desc="The scan which is filtered. The filtering happens in-place, therefore the input scan is potentially modified. Clone the input scan if you want to use its original version elsewhere."/>
                        <return name="scan" type="object" multiplicity="[?*]" alias="Scan" desc="Filtered polar scan data. The 1D filter always returns a scan, the 2D filter returns NIL for the first input scans after filter creation or parameter change."/>
                    </function>
                    <function name="setType">
                        <desc>Sets the type of the filter. The filter is re-initialized only if the new type differs from the current one.</desc>
                        <sample for="lua">Scan.MedianFilter.setType(handle, "2D")</sample>
                        <param name="handle" type="handle" alias="Scan.MedianFilter" desc="The instance handle to use"/>
                        <param name="filterType" type="enum" ref="MedianFilterType" desc="The type of the filter, 1D or 2D"/>
                    </function>
                    <function name="setWidth">
                        <desc>Sets the width of the filter. In 2D mode the filter is re-initialized only if the new width differs from the current one.</desc>
                        <sample for="lua">Scan.MedianFilter.setWidth(handle, 3)</sample>
                        <param name="handle" type="handle" alias="Scan.MedianFilter" desc="The instance handle to use"/>
                        <param name="filterWidth" type="int" desc="Width of the filter window. Should be uneven and at least 3 (Default). Maximum is 7, parameter is clipped accordingly. Also defines the number of scans to be filtered in 2D case."/>
                    </function>
                    <function name="setPulseNumber">
                        <trait>deprecated</trait>
                        <desc>Sets the echo number to apply the filter to. In 2D mode the filter is re-initialized only if the echo number differs from the current one.</desc>
                        <sample for="lua">Scan.MedianFilter.setPulseNumber(handle, 0)</sample>
                        <param name="handle" type="handle" alias="Scan.MedianFilter" desc="The instance handle to use"/>
                        <param name="pulseNumber" type="int" desc="Echo number to apply filter to, starting from 0 (Default = 0)"/>
                    </function>
                    <function name="setEchoNumber">
                        <desc>Sets the echo number to apply the filter to. In 2D mode the filter is re-initialized only if the echo number differs from the current one.</desc>
                        <sample for="lua">Scan.MedianFilter.setEchoNumber(handle, 0)</sample>
                        <param name="handle" type="handle" alias="Scan.MedianFilter" desc="The instance handle to use"/>
                        <param name="echoNumber" type="int" desc="Echo number to apply filter to, starting from 0 (Default = 0)"/>
                    </function>
                    <function name="setEnabled">
                        <desc>Enables/Disables the filter. In 2D mode the filter is initialized only if the state changes from enabled to disabled or vice versa.</desc>
                        <sample for="lua">Scan.MedianFilter.setEnabled(handle, enable)</sample>
                        <param name="handle" type="handle" alias="Scan.MedianFilter" desc="The instance handle to use"/>
                        <param name="enable" type="bool" desc="Set to true if filter should be enabled, false otherwise. (default = true)"/>
                    </function>
                </serves>
            </crown>
            <crown name="EdgeHitFilter">
                <trait>released</trait>
                <desc>Filters edge hits in polar scan data. An edge hit is a measurement value on an object edge where a part of the laser spot hits the object surface and another part of the object hits the background.
This results typically in a distance value between the object surface and the background and is called edge hit.
This filter removes measurement values which have no neighbor within a specified distance range. The distance range can be set by the parameter 'maxDistNeighbor'</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">local handle = Scan.EdgeHitFilter.create()</sample>
                        <return name="handle" type="handle" alias="Scan.EdgeHitFilter" desc="Handle to the new instance"/>
                    </function>
                    <function name="filter">
                        <include>data-flow</include>
                        <desc>Filters the scan and returns it also.</desc>
                        <sample for="lua">local filteredScan = Scan.EdgeHitFilter.filter(handle, scan)</sample>
                        <param name="handle" type="handle" alias="Scan.EdgeHitFilter" desc="The instance handle to use"/>
                        <param name="scan" type="object" multiplicity="[1+]" alias="Scan" desc="The scan which is filtered. The filtering happens in-place, therefore the input scan is potentially modified. Clone the input scan if you want to use its original version elsewhere."/>
                        <return name="scan" type="object" multiplicity="[?*]" alias="Scan" desc="Filtered polar scan data."/>
                    </function>
                    <function name="setMaxDistNeighbor">
                        <desc>Specifies the distance range which must be exceeded in order to identify a beam as edge hit.</desc>
                        <sample for="lua">Scan.EdgeHitFilter.setMaxDistNeighbor(handle, 10)</sample>
                        <param name="handle" type="handle" alias="Scan.EdgeHitFilter" desc="The instance handle to use"/>
                        <param name="maxDistNeighbor" type="int" desc="Specifies the distance range which must be exceeded in order to identify a beam as edge hit [mm]."/>
                    </function>
                    <function name="setEnabled">
                        <desc>Enables/Disables the filter.</desc>
                        <sample for="lua">Scan.EdgeHitFilter.setEnabled(handle, enable)</sample>
                        <param name="handle" type="handle" alias="Scan.EdgeHitFilter" desc="The instance handle to use"/>
                        <param name="enable" type="bool" desc="Set to true if filter should be enabled, false otherwise. (default = true)"/>
                    </function>
                </serves>
            </crown>
            <crown name="ParticleFilter">
                <trait>released</trait>
                <desc>The particle filter removes noise (particles) from the current scan by comparing the distance of a point from the current scan with distances from the previous and the next scan (both from the same beam and its spatial neighbours). If all differences between the current distance and the distances used for comparison exceed the specified threshold, the current point is identified as particle and its distance value is replaced with the distance from the same beam of the previous scan. Note that the threshold is also exceeded if one of the two distances used in a comparison has the value 0.
The particle filter operates only on the first echo, all other echoes are ignored. The input scans are modified in place, therefore use cloning to operate on the original scans outside the filter while the filter is running. After initialization of the filter a value of NIL is returned for the first two scans because the scan buffer is not filled yet. The filter is also re-initialized if the threshold is changed. For multilayer data, each layer is filtered separately.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">local handle = Scan.ParticleFilter.create()</sample>
                        <return name="handle" type="handle" alias="Scan.ParticleFilter" desc="Handle to the new instance"/>
                    </function>
                    <function name="filter">
                        <include>data-flow</include>
                        <desc>Filters the scan and returns the filtered scan.</desc>
                        <sample for="lua">local filteredScan = Scan.ParticleFilter.filter(handle, scan)</sample>
                        <param name="handle" type="handle" alias="Scan.ParticleFilter" desc="The instance handle to use"/>
                        <param name="scan" type="object" multiplicity="[1+]" alias="Scan" desc="The scan which is filtered. The filtering happens in-place, therefore the input scan is potentially modified. Clone the input scan if you want to use its original version elsewhere."/>
                        <return name="scan" type="object" multiplicity="[?*]" alias="Scan" desc="Filtered polar scan data. After creation or change of parameters, the filter needs three scans to return a result. The first two calls always return nil."/>
                    </function>
                    <function name="setThreshold">
                        <desc>Sets the threshold of the filter. The filter is re-initialized only if the new threshold differs from the current one.</desc>
                        <sample for="lua">Scan.ParticleFilter.setThreshold(handle, 500)</sample>
                        <param name="handle" type="handle" alias="Scan.ParticleFilter" desc="The instance handle to use"/>
                        <param name="threshold" type="float" desc="The threshold the filter should work with (default=500) [mm]."/>
                    </function>
                    <function name="setEnabled">
                        <desc>Enables/Disables the filter. The filter is initialized only if the state changes from enabled to disabled or vice versa.</desc>
                        <sample for="lua">Scan.ParticleFilter.setEnabled(handle, 1)</sample>
                        <param name="handle" type="handle" alias="Scan.ParticleFilter" desc="The instance handle to use."/>
                        <param name="enable" type="bool" desc="Set to true if filter should be enabled, false otherwise. (default = true)"/>
                    </function>
                </serves>
            </crown>
            <crown name="EchoFilter">
                <trait>released</trait>
                <desc>The EchoFilter selects either the first or the last echo of a given scan with more than one echoes and returns the input scan with one echo. Higher echoes are removed.
If the input scan has one echo only or the filter type is set to ALL the input scan is returned unchanged.</desc>
                <enum name="EchoFilterType">
                    <item name="First Echo" desc="Filter returns Scan with first echo only">FIRST</item>
                    <item name="Last Echo" desc="Filter returns Scan with last echo only">LAST</item>
                    <item name="All Echo" desc="Scan stays untouched. All echos remain in Scan.">ALL</item>
                </enum>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">local handle = Scan.EchoFilter.create()</sample>
                        <return name="handle" type="handle" alias="Scan.EchoFilter" desc="Handle to the new instance"/>
                    </function>
                    <function name="filter">
                        <include>data-flow</include>
                        <desc>Filters the scan and returns the modified input scan.</desc>
                        <sample for="lua">local filteredScan = Scan.EchoFilter.filter(handle, scan)</sample>
                        <param name="handle" type="handle" alias="Scan.EchoFilter" desc="The instance handle to use"/>
                        <param name="scan" type="object" multiplicity="[1+]" alias="Scan" desc="The scan which is filtered. The filtering happens in-place, therefore the input scan is potentially modified. Clone the input scan if you want to use its original version elsewhere."/>
                        <return name="scan" type="object" multiplicity="[?*]" alias="Scan" desc="The modified input scan."/>
                    </function>
                    <function name="setType">
                        <desc>Sets the filter type. 'FIRST' selects the first and 'LAST' the last valid (non-zero) echo. 'ALL' returns the input scan unchanged.</desc>
                        <sample for="lua">Scan.EchoFilter.setType(handle, "First")</sample>
                        <param name="handle" type="handle" alias="Scan.EchoFilter" desc="The instance handle to use"/>
                        <param name="filterType" type="enum" ref="EchoFilterType" desc="Defines which echo is supposed to be filtered. First, Last or All"/>
                    </function>
                </serves>
            </crown>
            <crown name="MeanFilter">
                <trait>released</trait>
                <desc>The filter stores 'AverageDepth' scans and calculates the average distance for each scan point. Points with zero distance are treated as missing values and are not taken into account. If all distances considered for averaging have the value 0, the result will be zero as well. This filter takes over all other point properties like RSSI, Label or Quality from the very first scan of each averaging cycle. The filter returns an output scan every 'AverageDepth' filter calls and therefore effectively reduces the scan rate by a factor of 'AverageDepth'. The input scans are modified in place, therefore use cloning to operate on the original scans outside the filter while the filter is running. For multilayer data, each layer is filtered separately.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">local handle = Scan.MeanFilter.create()</sample>
                        <return name="handle" type="handle" alias="Scan.MeanFilter" desc="Handle to the new instance"/>
                    </function>
                    <function name="filter">
                        <include>data-flow</include>
                        <desc>Processes the input scan and returns a valid scan with averaged distances after every 'AverageDepth' call otherwise nil.</desc>
                        <sample for="lua">local filteredScan = Scan.MeanFilter.filter(handle, scan)</sample>
                        <param name="handle" type="handle" alias="Scan.MeanFilter" desc="The instance handle to use"/>
                        <param name="scan" type="object" multiplicity="[1+]" alias="Scan" desc="The scan which is filtered. The filtering happens in-place, therefore the input scan is potentially modified. Clone the input scan if you want to use its original version elsewhere."/>
                        <return name="scan" type="object" multiplicity="[?*]" alias="Scan" desc="Filtered polar scan data. After creation or change of parameters, filter clears its buffers and restarts filtering."/>
                    </function>
                    <function name="setAverageDepth">
                        <desc>Sets the averaging depth of the filter. The filter is re-initialized only if the new filter depth differs from the current one.</desc>
                        <sample for="lua">Scan.MeanFilter.setAverageDepth(handle, 10)</sample>
                        <param name="handle" type="handle" alias="Scan.MeanFilter" desc="The instance handle to use"/>
                        <param name="averagedepth" type="int" desc="Number of scans which should be used for creation of average"/>
                    </function>
                    <function name="setEnabled">
                        <desc>Enables/Disables the filter.  The filter is initialized only if the state changes from enabled to disabled or vice versa.</desc>
                        <sample for="lua">Scan.MeanFilter.setEnabled(handle, 1)</sample>
                        <param name="handle" type="handle" alias="Scan.MeanFilter" desc="The instance handle to use"/>
                        <param name="enable" type="bool" desc="Set to true if filter should be enabled, false otherwise. (default = true)"/>
                    </function>
                </serves>
            </crown>
            <crown name="MovingAveragingFilter">
                <trait>released</trait>
                <desc>The filter assigns the moving average of the distances of the previous 'AverageDepth' scans (including the current scan) to the distance channel of the current scan. Points with zero distance are treated as missing values and are not taken into account for averaging. If all distances considered for averaging have the value 0, the result will be zero as well. The filter returns 'nil' until the minimum required number of scans ('AverageDepth') have been received. In contrast to the Scan.MeanFilter no data reduction is performed i.e. the scan input rate and the scan output rate are identical. The input scans are modified in place, therefore use cloning to operate on the original scans outside the filter while the filter is running. For multilayer data, each layer is filtered separately.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">local handle = Scan.MovingAveragingFilter.create()</sample>
                        <return name="handle" type="handle" alias="Scan.MovingAveragingFilter" desc="Handle to the new instance"/>
                    </function>
                    <function name="filter">
                        <include>data-flow</include>
                        <desc>Filters and returns the modified input scan.</desc>
                        <sample for="lua">local filteredScan = Scan.MovingAveragingFilter.filter(handle, scan)</sample>
                        <param name="handle" type="handle" alias="Scan.MovingAveragingFilter" desc="The instance handle to use"/>
                        <param name="scan" type="object" multiplicity="[1+]" alias="Scan" desc="The scan which is filtered. The filtering happens in-place, therefore the input scan is potentially modified. Clone the input scan if you want to use its original version elsewhere."/>
                        <return name="scan" type="object" multiplicity="[?*]" alias="Scan" desc="Filtered polar scan data. After creation or change of parameters, filter clears its buffers and restarts filtering."/>
                    </function>
                    <function name="setAverageDepth">
                        <desc>Sets the averaging depth of the filter. The filter is re-initialized only if the new filter depth differs from the current one.</desc>
                        <sample for="lua">Scan.MovingAveragingFilter.setAverageDepth(handle, 3)</sample>
                        <param name="handle" type="handle" alias="Scan.MovingAveragingFilter" desc="The instance handle to use"/>
                        <param name="averagedepth" type="int" desc="Number of scans used for averaging."/>
                    </function>
                    <function name="setEnabled">
                        <desc>Enables/Disables the filter.  The filter is initialized only if the state changes from enabled to disabled or vice versa.</desc>
                        <sample for="lua">Scan.MovingAveragingFilter.setEnabled(handle, 1)</sample>
                        <param name="handle" type="handle" alias="Scan.MovingAveragingFilter" desc="The instance handle to use"/>
                        <param name="enable" type="bool" desc="Set to true if filter should be enabled, false otherwise. (default = true)"/>
                    </function>
                </serves>
            </crown>
            <crown name="Window">
                <trait>hidden</trait>
                <desc>Scan view window</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new instance.</desc>
                        <sample for="lua">local handle = Scan.Window.create()</sample>
                        <return name="handle" type="handle" alias="Scan.Window" desc="Instance handle to the created window."/>
                    </function>
                    <function name="view">
                        <include>data-flow</include>
                        <desc>Views the scan in available views and returns the original for further usage.</desc>
                        <sample for="lua">Scan.Window.view(handle, scan)</sample>
                        <param name="handle" type="handle" alias="Scan.Window" desc="The instance handle to use"/>
                        <param name="polarScan" type="const object" alias="Scan" desc="The scan which is viewed."/>
                    </function>
                    <function name="setTitle">
                        <desc>Sets the title of the window.</desc>
                        <sample for="lua">Scan.Window.setTitle(handle, "ScanView")</sample>
                        <param name="handle" type="handle" alias="Scan.Window" desc="The instance handle to use"/>
                        <param name="title" type="string" desc="The text shown in the window title"/>
                    </function>
                    <function name="setWindowPosition">
                        <desc>Sets the position (and size) of the window.</desc>
                        <sample for="lua">Scan.Window.setWindowPosition(viewer, {0, 0, 400, 200})</sample>
                        <param name="handle" type="handle" alias="Scan.Window" desc="The instance handle to use"/>
                        <param name="val" type="int" multiplicity="+" desc="array of coordinates (x1, y1, x2, y2)"/>
                    </function>
                    <function name="setForegroundColor">
                        <desc>Sets the foreground color that is used to draw scanpoints.</desc>
                        <sample for="lua">Scan.Window.setForegroundColor(viewer, {0, 255, 0})</sample>
                        <param name="handle" type="handle" alias="Scan.Window" desc="The instance handle to use"/>
                        <param name="val" type="int" multiplicity="+" desc="array of colors from 0-255 (R, G, B)"/>
                    </function>
                    <function name="setBackgroundColor">
                        <desc>Sets the background color of the window.</desc>
                        <sample for="lua">Scan.Window.setBackgroundColor(viewer, {0, 255, 0})</sample>
                        <param name="handle" type="handle" alias="Scan.Window" desc="The instance handle to use"/>
                        <param name="val" type="int" multiplicity="+" desc="array of colors from 0-255 (R, G, B)"/>
                    </function>
                </serves>
            </crown>
            <crown name="Provider">
                <trait>released</trait>
                <desc>Provides scan data from different sources.</desc>
                <crown name="File">
                    <trait>released</trait>
                    <desc>A Scan file provider can be used as simulation provider to provide scans which were recorded into a SickRecord format.</desc>
                    <serves>
                        <event name="OnNewScan">
                            <include>data-flow</include>
                            <desc>The event which is thrown for every scan. Contains scan data and sensor data.
The content of the sensor data depends on whether an encoder was connected to the scanner or not.
The timestamp is always set in the sensor data.</desc>
                            <param name="handle" type="handle" alias="Scan.Provider.File" desc="The instance handle to use"/>
                            <param name="scan" type="object" alias="Scan" desc="The scan which was received"/>
                            <param name="sensordata" type="object" alias="SensorData" desc="The sensor data including encoder data which was received along with the scan"/>
                        </event>
                        <function name="create">
                            <desc>Creates a new instance.</desc>
                            <sample for="lua">local handle = Scan.Provider.File.create()</sample>
                            <return name="handle" type="handle" alias="Scan.Provider.File" desc="Handle to the new instance"/>
                        </function>
                        <function name="setFile">
                            <desc>Sets the file path to the XML file path which describes the scans.</desc>
                            <sample for="lua">Scan.Provider.File.setFile(handle, "resources/scans.xml")</sample>
                            <param name="handle" type="handle" alias="Scan.Provider.File" desc="The instance handle to use"/>
                            <param name="filepath" type="string" desc="The path of the file containing the scans"/>
                        </function>
                        <function name="setDataSetID">
                            <trait>hidden</trait>
                            <desc>Sets the ID of the dataset inside the SickRecord XML file which should be used. Default is 1 if not set. Currently the function only works with dataset ID = 1.
There could be several datasets inside the recorded file. A dataset is one scan view of a scanner.</desc>
                            <sample for="lua">Scan.Provider.File.setDataSetID(handle, 1)</sample>
                            <param name="handle" type="handle" alias="Scan.Provider.File" desc="The instance handle to use"/>
                            <param name="dataSetID" type="int" desc="The dataset ID"/>
                        </function>
                        <function name="setDelayMs">
                            <desc>Sets the notification delay between each scan. Default is 50ms.</desc>
                            <sample for="lua">Scan.Provider.File.setDelayMs(handle, 50)</sample>
                            <param name="handle" type="handle" alias="Scan.Provider.File" desc="The instance handle to use"/>
                            <param name="delayms" type="int" desc="Delay in milli seconds"/>
                        </function>
                        <function name="register">
                            <desc>This function is used to register for any event of the crown. The event name is specified as parameter. Playback of scan data is directly started with the call to register().</desc>
                            <sample for="lua">Scan.Provider.File.register(handle, "OnNewScan", "handleOnNewScan")</sample>
                            <param name="handle" type="handle" alias="Scan.Provider.File" desc="The instance handle to use"/>
                            <param name="eventname" type="string" desc="The event to register to"/>
                            <param name="callback" type="string" alias="function" desc="function name to call on the event"/>
                            <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                        </function>
                        <function name="deregister">
                            <desc>This function is used to deregister from any registered event of the handle.</desc>
                            <sample for="lua">Scan.Provider.File.deregister(handle, "OnNewScan", "handleOnNewScan")</sample>
                            <param name="handle" type="handle" alias="Scan.Provider.File" desc="The instance handle to use"/>
                            <param name="eventname" type="string" desc="The event to deregister from"/>
                            <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                            <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                        </function>
                        <function name="start">
                            <desc>Starts to provide the recorded scans. Playing also automatically starts if there is a new scan event. Consecutive calls of 'start' toggles between 'play' and 'pause' mode.</desc>
                            <sample for="lua">Scan.Provider.File.start(handle)</sample>
                            <param name="handle" type="handle" alias="Scan.Provider.File" desc="The instance handle to use"/>
                        </function>
                        <function name="stop">
                            <desc>Stops to provide the recorded scans.</desc>
                            <sample for="lua">Scan.Provider.File.stop(handle)</sample>
                            <param name="handle" type="handle" alias="Scan.Provider.File" desc="The instance handle to use"/>
                        </function>
                    </serves>
                </crown>
                <crown name="RemoteScanner">
                    <trait>released</trait>
                    <desc>A RemoteScanner can be used as provider for different types of SICK laser scanners (LMS100, LMS400, LMS500, TIM, ...). Use first the set functions to configure the provider.
A call to the register function applies the settings and starts the provider. The start / stop functions only controls the scan data stream, parameter changes are not applied by calling the start function.</desc>
                    <enum name="SensorType">
                        <item desc="Default standard LMS type for LMS100,LMS500,TIM">LMSX00</item>
                        <item desc="Special type for LMS400">LMS400</item>
                        <item desc="Special type for LMS4000 scanner">LMS4XXX</item>
                        <item desc="Special type for S300 and S3000">S300</item>
                        <item desc="Special type for MicroScan">MICRO_SCAN</item>
                        <item desc="Type to disable this provider">NO_SENSOR</item>
                    </enum>
                    <serves>
                        <event name="OnNewScan">
                            <include>data-flow</include>
                            <desc>The event which is thrown for every scan. Contains scan data and sensor data.
The content of the sensor data depends on whether an encoder was connected to the scanner or not.
The timestamp is always set in the sensor data.</desc>
                            <param name="handle" type="handle" alias="Scan.Provider.RemoteScanner" desc="The instance handle to use"/>
                            <param name="scan" type="object" multiplicity="[1+]" alias="Scan" desc="The scan which was received"/>
                            <param name="sensordata" type="object" multiplicity="[1+]" alias="SensorData" desc="The sensor data including encoder data which was received along with the scan"/>
                        </event>
                        <event name="OnDisconnected">
                            <trait>hidden</trait>
                            <include>data-flow</include>
                            <desc>The on disconnected event which is thrown for every disconnect.</desc>
                            <param name="handle" type="handle" alias="Scan.Provider.RemoteScanner" desc="The instance handle to use"/>
                        </event>
                        <event name="OnConnected">
                            <trait>hidden</trait>
                            <include>data-flow</include>
                            <desc>The on connected event which is thrown for every connect.</desc>
                            <param name="handle" type="handle" alias="Scan.Provider.RemoteScanner" desc="The instance handle to use"/>
                        </event>
                        <function name="create">
                            <desc>Creates a new instance.</desc>
                            <sample for="lua">local handle = Scan.Provider.RemoteScanner.create()</sample>
                            <return name="handle" type="handle" alias="Scan.Provider.RemoteScanner" desc="Handle to the new instance"/>
                        </function>
                        <function name="setIPAddress">
                            <desc>Sets the IP address of the connected sensor.</desc>
                            <sample for="lua">Scan.Provider.RemoteScanner.setIPAddress(handle, "192.168.0.1")</sample>
                            <param name="handle" type="handle" alias="Scan.Provider.RemoteScanner" desc="The instance handle to use"/>
                            <param name="ipAddress" type="string" desc="The IP address of the remote scanner"/>
                        </function>
                        <function name="setInterface">
                            <desc>Sets the interface of the connected sensor. Default is Ethernet</desc>
                            <sample for="lua">Scan.Provider.RemoteScanner.setInterface(handle, "USB")</sample>
                            <param name="handle" type="handle" alias="Scan.Provider.RemoteScanner" desc="The instance handle to use"/>
                            <param name="interface" type="enum" ref="RemoteScannerInterfaces" desc="The interface to use. Default is Ethernet."/>
                        </function>
                        <function name="setSensorType">
                            <desc>Sets the Sensor type. Default is standard LMS/TIM type "LMSX00".</desc>
                            <sample for="lua">Scan.Provider.RemoteScanner.setSensorType(handle, "LMS400")</sample>
                            <param name="handle" type="handle" alias="Scan.Provider.RemoteScanner" desc="The instance handle to use"/>
                            <param name="sensorType" type="enum" ref="SensorType" desc="The sensor type to use."/>
                        </function>
                        <function name="setSerialConfiguration">
                            <desc>Configures the serial interface.</desc>
                            <sample for="lua">Scan.Provider.RemoteScanner.setSerialConfiguration(handle, "COM1", "RS422", 500000, 8, "N", 1)</sample>
                            <param name="handle" type="handle" alias="Scan.Provider.RemoteScanner" desc="The instance handle to use"/>
                            <param name="portName" type="enum" ref="SerialPorts" desc="The (device dependent) name of the serial port which should be opened."/>
                            <param name="type" type="enum" ref="SerialComTypes" desc="Interface type"/>
                            <param name="baudRate" type="int" desc="One of 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 230400, 250000, 460800, 500000"/>
                            <param name="dataBits" type="int" desc="8 or 7"/>
                            <param name="parity" type="char" desc="One of &quot;N&quot;, &quot;O&quot;, &quot;E&quot;, &quot;M&quot;, &quot;S&quot; (None, Odd, Even, Mark, Space)"/>
                            <param name="stopBits" type="int" desc="1 or 2"/>
                        </function>
                        <function name="register">
                            <desc>This function is used to register for any event of the crown. The event name is specified as parameter. The register function does automatically call the start function.
Parameter changes are applied with a call to the register function.</desc>
                            <sample for="lua">Scan.Provider.RemoteScanner.register(handle, "OnNewScan", "handleOnNewScan")</sample>
                            <param name="handle" type="handle" alias="Scan.Provider.RemoteScanner" desc="The instance handle to use"/>
                            <param name="eventname" type="string" desc="The event to register to"/>
                            <param name="callback" type="string" alias="function" desc="Function name to call on the event"/>
                            <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                        </function>
                        <function name="deregister">
                            <desc>This function is used to deregister from any registered event of the handle.</desc>
                            <sample for="lua">Scan.Provider.RemoteScanner.deregister(handle, "OnNewScan", "handleOnNewScan")</sample>
                            <param name="handle" type="handle" alias="Scan.Provider.RemoteScanner" desc="The instance handle to use"/>
                            <param name="eventname" type="string" desc="The event to deregister from"/>
                            <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                            <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                        </function>
                        <function name="setConfig">
                            <desc>Applies the configuration to a remote scanner. Currently only used for MicroScan scanner to apply MicroScanConfig.</desc>
                            <sample for="lua">Scan.Provider.RemoteScanner.setConfig(handle, config)</sample>
                            <param name="handle" type="handle" alias="Scan.Provider.RemoteScanner" desc="The instance handle to use."/>
                            <param name="configHandle" type="handle" desc="Handle of config instance to apply."/>
                            <return name="success" type="bool" desc="true if new value could be set in configuration"/>
                        </function>
                        <function name="start">
                            <desc>Starts to provide the recorded scans.</desc>
                            <sample for="lua">Scan.Provider.RemoteScanner.start(handle)</sample>
                            <param name="handle" type="handle" alias="Scan.Provider.RemoteScanner" desc="The instance handle to use"/>
                        </function>
                        <function name="stop">
                            <desc>Stops to provide the recorded scans.</desc>
                            <sample for="lua">Scan.Provider.RemoteScanner.stop(handle)</sample>
                            <param name="handle" type="handle" alias="Scan.Provider.RemoteScanner" desc="The instance handle to use"/>
                        </function>
                        <function name="setBlockSize">
                            <desc>Sets the number of scan lines that get collected before OnNewScan event gets triggered.</desc>
                            <sample for="lua">Scan.Provider.RemoteScanner.setBlockSize(handle, 10)</sample>
                            <param name="handle" type="handle" alias="Scan.Provider.RemoteScanner" desc="The instance handle to use"/>
                            <param name="blockSize" type="int" desc="The block size for each data block"/>
                        </function>
                        <function name="isConnected">
                            <desc>Get connection status of remote scanner connection.</desc>
                            <sample for="lua">local isConnected = Scan.Provider.RemoteScanner.isConnected(handle)</sample>
                            <param name="handle" type="handle" alias="Scan.Provider.RemoteScanner" desc="The instance handle to use"/>
                            <return name="isConnected" type="bool" desc="true if remote sensor connection was established, false if no connection established."/>
                        </function>
                    </serves>
                    <crown name="MicroScanConfig">
                        <trait>released</trait>
                        <desc>Provides functionality to configure a MicroScan remote scanner. Call Scan.Provider.RemoteScanner.setConfig() to set this config.</desc>
                        <enum name="InterfaceType">
                            <item desc="EFI-pro">EFIPRO</item>
                            <item desc="Ethernet/IP">ETHERNETIP</item>
                            <item desc="Profinet">PROFINET</item>
                        </enum>
                        <serves>
                            <function name="create">
<desc>Creates an instance of a RemoteScannerConfig.</desc>
<sample for="lua">scannerConfig = Scan.Provider.RemoteScanner.MicroScanConfig.create()</sample>
<return name="config" type="object" alias="Scan.Provider.RemoteScanner.MicroScanConfig" desc="Instance of the MicroScanConfig."/>
                            </function>
                            <function name="setReceiverIPAddress">
<desc>Set the ip address of the device which shall receive the scan data.</desc>
<sample for="lua">Scan.Provider.RemoteScanner.MicroScanConfig.setReceiverIPAddress(scannerConfig, "192.168.0.1")</sample>
<param name="config" type="object" alias="Scan.Provider.RemoteScanner.MicroScanConfig" desc="Instance of the configuration."/>
<param name="ipAddress" type="string" desc="IP address of receiver of the scan data."/>
<return name="success" type="bool" desc="True if new value could be set in configuration."/>
                            </function>
                            <function name="setReceiverPort">
<desc>Set the port of the device that shall receive the scan data.</desc>
<sample for="lua">Scan.Provider.RemoteScanner.MicroScanConfig.setReceiverPort(scannerConfig, 51000)</sample>
<param name="config" type="object" alias="Scan.Provider.RemoteScanner.MicroScanConfig" desc="Instance of the configuration."/>
<param name="port" type="int" desc="Port that shall receive the scan data."/>
<return name="success" type="bool" desc="True if new value could be set in configuration."/>
                            </function>
                            <function name="setStartAngle">
<desc>Set the start angle for the scanner range. Valid range is from -47.5° to 227.5°. Default is 0°.
Currently only supported value is StartAngle = StopAngle = 0.</desc>
<sample for="lua">Scan.Provider.RemoteScanner.MicroScanConfig.setStartAngle(scannerConfig, 0.0)</sample>
<param name="config" type="object" alias="Scan.Provider.RemoteScanner.MicroScanConfig" desc="Instance of the configuration."/>
<param name="startAngle" type="float" desc="Start angle for scanner range."/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="setStopAngle">
<desc>Set the stop angle for the scanner range. Valid range is from -47.5° to 227.5°. Default is 0°.
Currently only supported value is StartAngle = StopAngle = 0.</desc>
<sample for="lua">Scan.Provider.RemoteScanner.MicroScanConfig.setStopAngle(scannerConfig, 0.0)</sample>
<param name="config" type="object" alias="Scan.Provider.RemoteScanner.MicroScanConfig" desc="Instance of the configuration."/>
<param name="stopAngle" type="float" desc="Stop angle for scanner range."/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                            <function name="setInterfaceType">
<desc>Set the interface type of the connected MicroScan3 scanner. Default value is 'EFIPRO'.</desc>
<sample for="lua">Scan.Provider.RemoteScanner.MicroScanConfig.setInterfaceType(scannerConfig, "EFIPRO")</sample>
<param name="config" type="object" alias="Scan.Provider.RemoteScanner.MicroScanConfig" desc="Instance of the configuration."/>
<param name="interfaceType" type="enum" ref="InterfaceType" desc="Interface type of the connected MicroScan3 scanner (EFIPRO, ETHERNETIP, PROFINET)."/>
<return name="success" type="bool" desc="true if new value could be set in configuration"/>
                            </function>
                        </serves>
                    </crown>
                </crown>
                <crown name="Scanner">
                    <trait>released</trait>
                    <desc>The data source of the specific device to provide scans directly, not remote.</desc>
                    <serves>
                        <event name="OnNewScan">
                            <include>data-flow</include>
                            <desc>The Scan event which is thrown for every scan or for a vector of scans.</desc>
                            <param name="handle" type="handle" alias="Scan.Provider.Scanner" desc="The instance handle to use"/>
                            <param name="scan" type="object" multiplicity="[1+]" alias="Scan" desc="The scan which was received"/>
                            <param name="sensordata" type="object" multiplicity="[1+]" alias="SensorData" desc="The sensor data including encoder data which was received along with the scan"/>
                        </event>
                        <function name="create">
                            <desc>This function creates a new scan provider.</desc>
                            <sample for="lua">driver = Scan.Provider.Scanner.create()</sample>
                            <return name="handle" type="handle" alias="Scan.Provider.Scanner" desc="Handle to the instance"/>
                        </function>
                        <function name="register">
                            <desc>This function is used to register for any event of the crown. The event name is specified as parameter</desc>
                            <sample for="lua">Scan.Provider.Scanner.register(handle, "OnNewScan", "handleOnNewScan")</sample>
                            <param name="handle" type="handle" alias="Scan.Provider.Scanner" desc="The instance handle to use"/>
                            <param name="eventname" type="string" desc="The event to register to"/>
                            <param name="callback" type="string" alias="function" desc="function name to call on the event"/>
                            <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                        </function>
                        <function name="deregister">
                            <desc>This function is used to deregister from any registered event of the handle.</desc>
                            <sample for="lua">Scan.Provider.Scanner.deregister(handle, "OnNewScan", "handleOnNewScan")</sample>
                            <param name="handle" type="handle" alias="Scan.Provider.Scanner" desc="The instance handle to use"/>
                            <param name="eventname" type="string" desc="The event to deregister from"/>
                            <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                            <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                        </function>
                        <function name="start">
                            <desc>Starts to provide the recorded scans.</desc>
                            <sample for="lua">Scan.Provider.Scanner.start(handle)</sample>
                            <param name="handle" type="handle" alias="Scan.Provider.Scanner" desc="The instance handle to use"/>
                        </function>
                        <function name="stop">
                            <desc>Stops to provide the recorded scans.</desc>
                            <sample for="lua">Scan.Provider.Scanner.stop(handle)</sample>
                            <param name="handle" type="handle" alias="Scan.Provider.Scanner" desc="The instance handle to use"/>
                        </function>
                        <function name="setBlockSize">
                            <desc>Sets the number of scan lines that get collected before OnNewScan event gets triggered.</desc>
                            <sample for="lua">Scan.Provider.Scanner.setBlockSize(handle, 10)</sample>
                            <param name="handle" type="handle" alias="Scan.Provider.Scanner" desc="The instance handle to use"/>
                            <param name="blockSize" type="int" desc="The block size for each data block"/>
                        </function>
                    </serves>
                </crown>
            </crown>
        </crown>
        <crown name="HalconEndTest">
            <trait>hidden</trait>
            <desc>Verify Halcon license status</desc>
            <serves>
                <function name="isLicenseValid">
                    <desc>Query the license status of the Halcon runtime.</desc>
                    <sample for="lua">local isValid, version = HalconEndTest.isLicenseValid()</sample>
                    <return name="isValid" type="bool" desc="Is the Halcon license valid"/>
                    <return name="version" type="string" multiplicity="?" desc="The version of the Halcon runtime. Can be nil if Halcon is not licensed."/>
                </function>
            </serves>
        </crown>
        <crown name="Licensing">
            <trait>released</trait>
            <desc>Provides functions for software licensing.</desc>
            <crown name="CodeMeter">
                <trait>released</trait>
                <desc>Provides functions for software licensing based on CodeMeter from Wibu-Systems.</desc>
                <serves>
                    <function name="getLicenseContextFile">
                        <desc>Returns a CodeMeter license context file (RaC: remote activation context) which is required for license activation in the CodeMeter License Central (both as a request and as a receipt file).</desc>
                        <param name="firmCode" type="int" desc="Unique software vendor identification code issued by Wibu-Systems"/>
                        <return name="file" type="binary" multiplicity="?" desc="License context file or nil on failure"/>
                    </function>
                    <function name="installLicenseUpdateFile">
                        <desc>Installs a CodeMeter license update file (RaU: remote activation update) which has been created in the CodeMeter License Central.</desc>
                        <param name="file" type="binary" desc="The license update file"/>
                        <return name="success" type="bool" desc="True if the license update file has been installed, false if not"/>
                        <return name="errMsg" type="string" multiplicity="?" desc="If the update fails, this string contains the error message"/>
                    </function>
                    <function name="isProductActive">
                        <desc>Checks if the software license for a certain product is active.</desc>
                        <param name="firmCode" type="int" desc="Unique software vendor identification code issued by Wibu-Systems"/>
                        <param name="productCode" type="int" desc="Unique product code issued by the software vendor"/>
                        <param name="featureCode" type="int" desc="Feature code to query bits in the feature map bitmask, set to 0 to ignore feature map"/>
                        <return name="success" type="bool" desc="True if the product with the specified features is active, false if not"/>
                    </function>
                    <function name="getActiveProducts">
                        <desc>Returns the lists of all active product codes and their feature masks in the CmContainer which belongs to the specified firm code.</desc>
                        <param name="firmCode" type="int" desc="Unique software vendor identification code issued by Wibu-Systems"/>
                        <return name="success" type="bool" desc="True if the container for the specified firm code has been found, false if not"/>
                        <return name="productCodes" type="int" multiplicity="+" desc="List of active product codes"/>
                        <return name="featureMasks" type="int" multiplicity="+" desc="List of feature masks"/>
                    </function>
                    <function name="getContainerIdentifier">
                        <desc>Returns the identifier (in the form [Mask]-[Serial]) of the CmContainer which belongs to the specified firm code.</desc>
                        <param name="firmCode" type="int" desc="Unique software vendor identification code issued by Wibu-Systems"/>
                        <return name="identifier" type="string" desc="Identifier of the container or empty string on failure"/>
                    </function>
                </serves>
            </crown>
        </crown>
        <crown name="MachineLearning">
            <trait>released</trait>
            <desc>Machine learning tools for data understanding and prediction. The Machine Learning API
trains classifiers and makes predictions on samples formed by collecting measurements of data as
rows in a matrix.

Helpers to partition data into training and evaluation set and other convenience functions
to manipulate the raw dataset are also included.

Classifiers in general support both regression and classification tasks. The selection is
made when creating the dataset.

Algorithms included
- DataSet container for labeled samples.
- Classifiers: Neural net, Random Forest, k-Nearest Neighbor, Support Vector Machines, Bayes, Fisher Linear Discriminant
- Data dimensionality reduction: Principal Component Analysis (PCA), k-Means clustering
- Methods for evaluating classifier accuracy
- Methods for data statistics, selection and preconditioning.</desc>
            <serves/>
            <uses/>
            <crown name="DataSet">
                <trait>released</trait>
                <desc>Training data container for classical machine learning applications. Stores samples and corresponding labels for input to different classifiers. It is not intended for use together with DeepNeuralNetwork applications.

Samples are always floating point values, but labels are integer values for classification tasks and floating point values for regression tasks.

It's possible to also supply weights per sample which some algorithms make use of during training.</desc>
                <enum name="LabelType" trait="released">
                    <item name="CLASSIFICATION" desc="Specify the use of discrete labels, this is what should be used when trying to separate distinct classes.">CLASSIFICATION</item>
                    <item name="REGRESSION" desc="Specify the use of floating point labels. This is useful when the labels can be sorted or meaningfully compared.">REGRESSION</item>
                </enum>
                <serves>
                    <function name="create">
                        <desc>Creates a new DataSet object</desc>
                        <sample for="lua">dataSet = MachineLearning.DataSet.create("CLASSIFICATION")</sample>
                        <param name="labelType" type="enum" ref="LabelType" desc="Create a dataset of the selected type."/>
                        <return name="dataSet" type="object" alias="MachineLearning.DataSet" desc="The new dataset."/>
                    </function>
                    <function name="getType">
                        <desc>Returns the type of the data set, either CLASSIFICATION or REGRESSION.</desc>
                        <sample for="lua">type = MachineLearning.getType(dataSet)</sample>
                        <param name="dataSet" type="const object" alias="MachineLearning.DataSet" desc="The input dataset."/>
                        <return name="type" type="enum" ref="LabelType" desc="The type of the data set"/>
                    </function>
                    <function name="append">
                        <desc>Append one or multiple samples to the internal list of samples.</desc>
                        <sample for="lua">MachineLearning.DataSet.append(dataSet, sample, label)</sample>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="The input dataset"/>
                        <param name="samples" type="object" alias="Matrix" desc="Training sample(s). Each row is considered a separate sample. To add more samples at the same time use a matrix of multiple rows."/>
                        <param name="labels" type="auto" desc="Training label(s). If all samples belong to the same class send a single label value. Otherwise there should be one sample per row in the samples matrix."/>
                        <param name="weight" type="object" multiplicity="?" alias="Matrix" desc="Optional weights for each sample. This matrix must be single column and have as many rows as samples"/>
                        <return name="success" type="bool" desc="True if data was successfully added."/>
                    </function>
                    <function name="clear">
                        <desc>Remove all internally stored samples. Clearing out samples reduces memory usage and can be useful when large datasets are used for training.</desc>
                        <sample for="lua">MachineLearning.DataSet.clear(dataSet)</sample>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="The input dataset"/>
                    </function>
                    <function name="getFeature">
                        <desc>Return a feature from the sample set.</desc>
                        <sample for="lua">feature = MachineLearning.DataSet.getFeature(dataSet, index)</sample>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="The input dataset"/>
                        <param name="index" type="int" multiplicity="?" desc="The index into the dataset. If left out all all features are returned. This is the same getSample without index."/>
                        <return name="sample" type="object" multiplicity="?" alias="Matrix" desc="The matrix corresponding to the selected feature index or in case index is left out all features. Each feature is a separate column."/>
                    </function>
                    <function name="getSample">
                        <desc>Return a sample from the sample set.</desc>
                        <sample for="lua">sample = MachineLearning.DataSet.getSample(dataSet, index)</sample>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="The input dataset"/>
                        <param name="index" type="int" multiplicity="?" desc="The index into the dataset. If left out all samples are returned. This is the same as getFeature without index."/>
                        <return name="sample" type="object" multiplicity="?" alias="Matrix" desc="The matrix corresponding to the selected sample index or in case index is left out all samples. Each sample is a separate row."/>
                    </function>
                    <function name="getLabel">
                        <desc>Return label for a sample in the loaded set.</desc>
                        <sample for="lua">label = MachineLearning.DataSet.getLabel(dataSet, index)</sample>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="The input dataset"/>
                        <param name="index" type="int" multiplicity="?" desc="The index into the dataset. If left out all labels are returned."/>
                        <return name="label" type="auto" multiplicity="?" desc="The label corresponding to the selected sample index or all labels if no index is supplied."/>
                    </function>
                    <function name="getWeight">
                        <desc>Return weight for a sample in the loaded set.</desc>
                        <sample for="lua">weight = MachineLearning.DataSet.getWeight(dataSet, index)</sample>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="The input dataset"/>
                        <param name="index" type="int" multiplicity="?" desc="The index into the dataset. If left out all weights are returned."/>
                        <return name="weight" type="auto" multiplicity="?" desc="The weight corresponding to the selected sample index or all weights if no index is supplied."/>
                    </function>
                    <function name="getSubset">
                        <desc>Return a new dataset object of a selected subset of the original dataset.</desc>
                        <sample for="lua">sample = MachineLearning.DataSet.getSubset(dataSet, start, count)</sample>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="The input dataset"/>
                        <param name="start" type="int" desc="The start index at which to start extracting samples."/>
                        <param name="count" type="int" multiplicity="?" desc="The amount of samples to extract. If left out all samples after start will be extracted."/>
                        <return name="dataSet" type="object" multiplicity="?" alias="MachineLearning.DataSet" desc="The new dataset consisting of only selected samples."/>
                    </function>
                    <function name="getSubsetLabels">
                        <desc>Return a new dataset object of a selected subset of the original dataset. This function allows the extraction of specific labels in case the LabelType is CLASSIFICATION.</desc>
                        <sample for="lua">sample = MachineLearning.DataSet.getSubsetLabels(dataSet, labels)</sample>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="The input dataset"/>
                        <param name="labels" type="int" multiplicity="+" desc="A vector of labels to keep in the output."/>
                        <return name="dataSet" type="object" multiplicity="?" alias="MachineLearning.DataSet" desc="The new dataset consisting of all samples with the selected labels."/>
                    </function>
                    <function name="getSubsetInterval">
                        <desc>Return a new dataset object of a selected subset of the original dataset. This function allows extraction of an interval of label values in case the LabelType is REGRESSION.</desc>
                        <sample for="lua">sample = MachineLearning.DataSet.getSubsetInterval(dataSet, minValue, maxValue)</sample>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="The input dataset"/>
                        <param name="minValue" type="float" desc="The smallest value of a label to keep in the output."/>
                        <param name="maxValue" type="float" desc="The largest value of a label to keep in the output."/>
                        <return name="dataSet" type="object" multiplicity="?" alias="MachineLearning.DataSet" desc="The new dataset consisting of all samples with labels in the specified region."/>
                    </function>
                    <function name="split">
                        <desc>Split a dataset object into two parts. The amount of samples in the larger set will be the same as the amount of samples in the smaller set times the input "factor".

This means if factor is set to 3 that the first dataset object will be 3 times larger than the second.
The sample selection is automatically randomized. To turn of randomization set the optional parameter "randomize" to false.</desc>
                        <sample for="lua">major, minor = MachineLearning.DataSet.split(dataSet, 3)</sample>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="The input dataset"/>
                        <param name="factor" type="int" desc="The amount of samples in the major set compared to the minor set."/>
                        <param name="randomize" type="bool" multiplicity="?" desc="Select if samples should be randomized before split. Default is true."/>
                        <return name="major" type="object" alias="MachineLearning.DataSet" desc="A new dataset containing the larger part of the samples."/>
                        <return name="minor" type="object" alias="MachineLearning.DataSet" desc="A new dataset containing the smaller part of the samples."/>
                    </function>
                    <function name="calculateStatistics">
                        <desc>Calculate and return statistics for the dataset object.</desc>
                        <sample for="lua">mean, std, min, max = MachineLearning.DataSet.calculateStatistics(dataSet)</sample>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="The input dataset"/>
                        <return name="mean" type="float" multiplicity="+" desc="A vector containing the mean for each feature."/>
                        <return name="std" type="float" multiplicity="+" desc="A vector containing the standard deviation for each feature."/>
                        <return name="min" type="float" multiplicity="+" desc="A vector containing the minimum value for each feature."/>
                        <return name="max" type="float" multiplicity="+" desc="A vector containing the maximum value for each feature."/>
                    </function>
                    <function name="calculateNormalization">
                        <desc>Calculate a matrix with the mean and standard deviation for each feature. This matrix is convenient to use as input for normalizing dataset objects as well as raw matrices for example before classification.

The matrix consist of the mean and standard deviation for each sample. Means are in the first row, standard deviations in the second.</desc>
                        <sample for="lua">normalization = MachineLearning.DataSet.calculateNormalization(dataSet)</sample>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="The input dataset"/>
                        <return name="normalization" type="object" multiplicity="?" alias="Matrix" desc="The normalization matrix."/>
                    </function>
                    <function name="calculateProjection">
                        <desc>Calculate a matrix with the means of each feature in the first row and principal component eigen vectors in the following rows.

The total height of the returned matrix minus one corresponds to the output dimension after projection.</desc>
                        <sample for="lua">projection = MachineLearning.DataSet.calculateProjection(dataSet, maxDimensions, retainVariance)</sample>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="The input dataset"/>
                        <param name="maxDimensions" type="int" multiplicity="?" desc="Set this value to determine the dimensions of the output. To keep all set to 0 or the original feature size."/>
                        <param name="retainVariance" type="float" multiplicity="?" desc="Set this to select how much of the original signal to keep. If set to 0.5 it means that at least 50% of the signal energy remains after projection."/>
                        <return name="projection" type="object" multiplicity="?" alias="Matrix" desc="The projection matrix."/>
                    </function>
                    <function name="normalize">
                        <desc>Apply a normalization matrix to a dataset object or another matrix.

In both cases the dimensions must be compatible. Eg. the feature size of the dataset object or
the amount of columns of the matrix must be equal to the columns of the normalization matrix.</desc>
                        <sample for="lua">normalized = MachineLearning.DataSet.normalize(source, normalization)</sample>
                        <param name="source" type="object" desc="Either a dataset object or a matrix."/>
                        <param name="normalization" type="object" alias="Matrix" desc="A normalization matrix. Can be created using calculateNormalization or by manual composition."/>
                        <return name="normalized" type="object" desc="A normalized version of the source input."/>
                    </function>
                    <function name="project">
                        <desc>Apply a projection matrix to a dataset object or another matrix.

In both cases the dimensions must be compatible. Eg. the feature size of the dataset object or
the amount of columns of the matrix must be equal to the columns of the projection matrix.</desc>
                        <sample for="lua">projected = MachineLearning.DataSet.project(source, projection)</sample>
                        <param name="source" type="object" desc="Either a dataset object or a matrix."/>
                        <param name="projection" type="object" alias="Matrix" desc="A projection matrix. Can be created using calculateProjection or by manual composition."/>
                        <return name="projected" type="object" desc="The projected version of the source input."/>
                    </function>
                    <function name="getFeatureCount">
                        <desc>Return the number of values stored per sample. This is the same as the number of columns in each sample that has been added.</desc>
                        <sample for="lua">featureCount = MachineLearning.DataSet.getFeatureCount(dataSet)</sample>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="The input dataset"/>
                        <return name="featureCount" type="int" desc="The amount of features"/>
                    </function>
                    <function name="getSampleCount">
                        <desc>Return the amount of samples currently stored in the dataset.</desc>
                        <sample for="lua">samplesCount = MachineLearning.DataSet.getSampleCount(dataSet)</sample>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="The input dataset"/>
                        <return name="samplesCount" type="int" desc="The amount of samples"/>
                    </function>
                    <function name="toString">
                        <desc>Get a brief string description of the dataset. This is equal to the text shown in the debugger to describe the dataset.</desc>
                        <sample for="lua">print("Description: " .. MachineLearning.DataSet.toString(dataSet))</sample>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="The input dataset"/>
                        <return name="string" type="string" desc="Description of the dataset"/>
                    </function>
                </serves>
            </crown>
            <crown name="KMeansClustering">
                <trait>released</trait>
                <desc>k-Means Clustering is a technique mainly used to find structure in unordered data. It's an iterative method which tries to group samples into clusters in a two step process. First a start solution is created by randomizing a number of cluster centers.  Then features are assigned to clusters based on the feature distance to the cluster centers and secondly the center of each cluster is updated based on its feature members. This is iterated for a selectable number of cycles.

Note that KMeansClustering in reality is a clustering algorithm and not really a classifier. It can be used for classification by checking what cluster a sample is closest to after training.

Because of the clustering nature the default behavior is that the labels of the input data is updated with the result of the clustering operation. To disable this behavior set "updateInput" to false in setParameters.</desc>
                <enum name="InitMethod" trait="released">
                    <item name="RANDOM" desc="Place start centers for clusters at random">RANDOM</item>
                    <item name="ESTIMATE" desc="Try to estimate a good starting position">ESTIMATE</item>
                </enum>
                <serves>
                    <function name="create">
                        <desc>Creates a new KMeansClustering object.</desc>
                        <sample for="lua">km = MachineLearning.KMeansClustering.create()</sample>
                        <return name="km" type="handle" alias="MachineLearning.KMeansClustering" desc="The new KMeansClustering handle"/>
                    </function>
                    <function name="load">
                        <desc>Load a KMeansClustering classifier from disk.</desc>
                        <sample for="lua">km = MachineLearning.KMeansClustering.load(path)</sample>
                        <param name="path" type="string" desc="The path to the classifier"/>
                        <return name="km" type="handle" multiplicity="?" alias="MachineLearning.KMeansClustering" desc="The KMeansClustering handle to the loaded object."/>
                    </function>
                    <function name="save">
                        <desc>Save a KMeansClustering classifier to disk.</desc>
                        <sample for="lua">success = MachineLearning.KMeansClustering.save(km, path)</sample>
                        <param name="km" type="handle" alias="MachineLearning.KMeansClustering" desc="The classifier instance to use"/>
                        <param name="path" type="string" desc="The path at which to store the classifier"/>
                        <return name="success" type="bool" multiplicity="?" desc="True if the file was successfully stored, false if storing failed."/>
                    </function>
                    <function name="setParameters">
                        <desc>Set parameters for how training should be done.</desc>
                        <sample for="lua">success = MachineLearning.KMeansClustering.setParameters(km, "RANDOM")</sample>
                        <param name="km" type="handle" alias="MachineLearning.KMeansClustering" desc="The classifier instance to use"/>
                        <param name="numberOfClusters" type="int" desc="The number of clusters to fit to data (number of classes)."/>
                        <param name="initMethod" type="enum" ref="InitMethod" desc="Select the way to initialize the algorithm."/>
                        <param name="iterations" type="int" multiplicity="?" desc="Select the number of iterations to run the algorithm. Default is 100."/>
                        <param name="updateInput" type="bool" multiplicity="?" desc="Select if the labels of the dataset should be updated. Default is true."/>
                        <return name="success" type="bool" multiplicity="?" desc="True if successful, false if combination of parameters is unsupported."/>
                    </function>
                    <function name="train">
                        <desc>Perform training on data supplied in a DataSet object.</desc>
                        <sample for="lua">success = MachineLearning.KMeansClustering.train(km, dataSet)</sample>
                        <param name="km" type="handle" alias="MachineLearning.KMeansClustering" desc="The classifier instance to use"/>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="Input dataset"/>
                        <return name="success" type="bool" multiplicity="?" desc="True if classifier was successfully trained."/>
                    </function>
                    <function name="predict">
                        <desc>Classify a sample using the trained classifier.</desc>
                        <sample for="lua">class = MachineLearning.KMeansClustering.predict(km, sample)</sample>
                        <param name="km" type="handle" alias="MachineLearning.KMeansClustering" desc="The classifier instance to use."/>
                        <param name="sample" type="object" multiplicity="[1+]" alias="Matrix" desc="A sample or a set of samples that are to be classified. Each row of the input matrix is considered one sample."/>
                        <return name="class" type="float" multiplicity="[?*]" desc="Predicted class output from the classifier. In case of a single sample input it's a single value. For multi row input it's a vector of class labels."/>
                    </function>
                    <function name="isTrained">
                        <desc>Use to check if classifier has been trained successfully. If a classifier is trained it can be used to predict.</desc>
                        <sample for="lua">trained = MachineLearning.KMeansClustering.isTrained(km)</sample>
                        <param name="km" type="handle" alias="MachineLearning.KMeansClustering" desc="The classifier instance to use."/>
                        <return name="trained" type="bool" desc="True if the classifier is trained."/>
                    </function>
                    <function name="getFeatureCount">
                        <desc>Use to check what feature size the classifier was trained on. A classifier can only be used on new data with the same amount of features.</desc>
                        <sample for="lua">trained = MachineLearning.KMeansClustering.getFeatureCount(km)</sample>
                        <param name="km" type="handle" alias="MachineLearning.KMeansClustering" desc="The classifier instance to use."/>
                        <return name="featureCount" type="int" desc="The amount of features per sample."/>
                    </function>
                    <function name="clear">
                        <desc>Clear internal data of the classifier.</desc>
                        <sample for="lua">MachineLearning.KMeansClustering.clear(km)</sample>
                        <param name="km" type="handle" alias="MachineLearning.KMeansClustering" desc="The classifier instance to use."/>
                    </function>
                    <function name="getClusterCenters">
                        <desc>Get the resulting cluster centers for evaluation of the result.</desc>
                        <sample for="lua">clusters = MachineLearning.KMeansClustering.getClusterCenters(km)</sample>
                        <param name="km" type="handle" alias="MachineLearning.KMeansClustering" desc="The classifier instance to use."/>
                        <return name="clusters" type="object" alias="Matrix" desc="The cluster centers with one position per row."/>
                    </function>
                    <function name="getCompactness">
                        <desc>Get the compactness of the clustering.

This is a measure on how well classes could be separated and is calculated as the average distance from all samples to their cluster centers.</desc>
                        <sample for="lua">compactness = MachineLearning.KMeansClustering.getCompactness(km)</sample>
                        <param name="km" type="handle" alias="MachineLearning.KMeansClustering" desc="The classifier instance to use."/>
                        <return name="compactness" type="float" desc="The compactness of the clustering."/>
                    </function>
                    <function name="toString">
                        <desc>Get a brief string description of the classifier. This is equal to the text shown in the debugger.</desc>
                        <sample for="lua">print("Description: " .. MachineLearning.KMeansClustering.toString(km))</sample>
                        <param name="km" type="object" alias="MachineLearning.KMeansClustering" desc="The input classifier data"/>
                        <return name="string" type="string" desc="Description of the classifier"/>
                    </function>
                </serves>
            </crown>
            <crown name="KNearestNeighbors">
                <trait>released</trait>
                <desc>k Nearest Neighbors or kNN for short, is basically a voting scheme based on proximity.

During training the training samples are collected and are themselves stored for later use during classification.

During classification the features of a new sample are compared to features of the k closest samples from the training dataset. The classification is given by the majority vote of these k samples.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new KNearestNeighbors handle</desc>
                        <sample for="lua">knn = MachineLearning.KNearestNeighbors.create()</sample>
                        <return name="knn" type="handle" alias="MachineLearning.KNearestNeighbors" desc="The new KNearestNeighbors handle"/>
                    </function>
                    <function name="load">
                        <desc>Load a KNearestNeighbors classifier from disk.</desc>
                        <sample for="lua">knn = MachineLearning.KNearestNeighbors.load(path)</sample>
                        <param name="path" type="string" desc="The path to the classifier"/>
                        <return name="knn" type="handle" multiplicity="?" alias="MachineLearning.KNearestNeighbors" desc="The KNearestNeighbors handle to the loaded object."/>
                    </function>
                    <function name="save">
                        <desc>Save a KNearestNeighbors classifier to disk.</desc>
                        <sample for="lua">success = MachineLearning.KNearestNeighbors.save(knn, path)</sample>
                        <param name="knn" type="handle" alias="MachineLearning.KNearestNeighbors" desc="The classifier instance to use"/>
                        <param name="path" type="string" desc="The path at which to store the classifier"/>
                        <return name="success" type="bool" multiplicity="?" desc="True if the file was successfully stored, false if storing failed."/>
                    </function>
                    <function name="setParameters">
                        <desc>Set parameters for how training should be done.</desc>
                        <sample for="lua">success = MachineLearning.KNearestNeighbors.setParameters(knn, 13)</sample>
                        <param name="handle" type="handle" alias="MachineLearning.KNearestNeighbors" desc="The classifier instance to use"/>
                        <param name="numberOfNeighbors" type="int" desc="Number of neighbors to use when calculating."/>
                        <return name="success" type="bool" multiplicity="?" desc="True if successful, false if combination of parameters is unsupported."/>
                    </function>
                    <function name="train">
                        <desc></desc>
                        <sample for="lua">MachineLearning.KNearestNeighbors.train(knn, dataSet)</sample>
                        <param name="knn" type="handle" alias="MachineLearning.KNearestNeighbors" desc="The classifier instance to use"/>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="Input dataset"/>
                        <return name="success" type="bool" multiplicity="?" desc="True if classifier was successfully trained."/>
                    </function>
                    <function name="predict">
                        <desc>Classify a sample using the trained classifier.</desc>
                        <sample for="lua">class = MachineLearning.KNearestNeighbors.predict(knn, sample)</sample>
                        <param name="knn" type="handle" alias="MachineLearning.KNearestNeighbors" desc="The classifier instance to use."/>
                        <param name="sample" type="object" multiplicity="[1+]" alias="Matrix" desc="A sample or a set of samples that are to be classified. Each row of the input matrix is considered one sample."/>
                        <return name="class" type="float" multiplicity="[?*]" desc="Predicted class output from the classifier. In case of a single sample input it's a single value. For multi row input it's a vector of class labels."/>
                    </function>
                    <function name="isTrained">
                        <desc>Use to check if classifier has been trained successfully. If a classifier is trained it can be used to predict.</desc>
                        <sample for="lua">trained = MachineLearning.KNearestNeighbors.isTrained(knn)</sample>
                        <param name="knn" type="handle" alias="MachineLearning.KNearestNeighbors" desc="The classifier instance to use."/>
                        <return name="trained" type="bool" desc="True if the classifier is trained."/>
                    </function>
                    <function name="getFeatureCount">
                        <desc>Use to check what feature size the classifier was trained on. A classifier can only be used on new data with the same amount of features.</desc>
                        <sample for="lua">trained = MachineLearning.KNearestNeighbors.getFeatureCount(knn)</sample>
                        <param name="knn" type="handle" alias="MachineLearning.KNearestNeighbors" desc="The classifier instance to use."/>
                        <return name="featureCount" type="int" desc="The amount of features per sample."/>
                    </function>
                    <function name="getAccuracy">
                        <desc>Evaluate a classifier against a DataSet object by computing the predicted class and comparing it to the label supplied in the DataSet object.

The "accuracy" returned will be the amount of correctly classified samples divided by the total amount of samples.

The second output, the "confusionMatrix", is a NxN matrix.

The final return value is a vector. This vector tells us what original label correspond to what row and column in the confusion matrix.

In the NxN confusion matrix contains classification statistics. Each row corresponds to a label input and each column to a classification output. That is, if all classes have been correctly classified, there should only be non-zero elements along the diagonal of this matrix.

For example a matrix of the following format

C = [3 1, 2 4]
labels = {1, 2}

This means that the model had labels 1 and 2. For these labels the classification was tested on a total of 3+1+2+4 = 10 samples. Out of these 3+2 = 5 were classified as label one and 1+4 = 5 as label two. However, there were actually 3+1 = 4 samples of type one and 2+4 = 6 of type two in the input. To calculate the accuracy sum the diagonal, 3 + 4 = 7 and divide by the total amount of samples 10, which in this case gives an accuracy of 70%. It can also be useful to analyze other properties of this matrix. In this case inputs of type 2 are more likely to be classified as type 1 than type 1 being classified as type 2.</desc>
                        <sample for="lua">accuracy, confusionMatrix = MachineLearning.KNearestNeighbors.getAccuracy(knn, dataSet)</sample>
                        <param name="knn" type="handle" alias="MachineLearning.KNearestNeighbors" desc="The classifier instance to use."/>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="The dataset to use"/>
                        <return name="accuracy" type="float" multiplicity="?" desc="The accuracy rate. Computed as correct classifications divided by total amount of samples."/>
                        <return name="confusionMatrix" type="object" multiplicity="?" alias="Matrix" desc="Confusion matrix for dataset and classifier."/>
                        <return name="confusionMatrixLabels" type="int" multiplicity="[?*]" desc="The label key for the confusion matrix."/>
                    </function>
                    <function name="clear">
                        <desc>Clear internal data of the classifier.</desc>
                        <sample for="lua">MachineLearning.KNearestNeighbors.clear(knn)</sample>
                        <param name="knn" type="handle" alias="MachineLearning.KNearestNeighbors" desc="The classifier instance to use."/>
                    </function>
                    <function name="toString">
                        <desc>Get a brief string description of the classifier. This is equal to the text shown in the debugger.</desc>
                        <sample for="lua">print("Description: " .. MachineLearning.KNearestNeighbors.toString(knn))</sample>
                        <param name="knn" type="object" alias="MachineLearning.KNearestNeighbors" desc="The input classifier data"/>
                        <return name="string" type="string" desc="Description of the classifier"/>
                    </function>
                </serves>
            </crown>
            <crown name="Fisher">
                <trait>released</trait>
                <desc>Fisher's linear discriminant, sometimes called Linear Discriminant Analysis (LDA) is a method to find a vector which linearly separates two classes in an optimal way.

This vector is found so that samples from different classes projected onto this vector end up as far apart a possible.

For this reason Fisher can be used to understand what features of a data set have the most discriminating effect by looking at this vector. This is useful when trying to reduce the feature size input to another classifier without loosing too much performance.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a handle for Fisher's linear discriminant.</desc>
                        <sample for="lua">lda = MachineLearning.Fisher.create()</sample>
                        <return name="fisher" type="handle" alias="MachineLearning.Fisher" desc="The new Fisher handle"/>
                    </function>
                    <function name="load">
                        <desc>Load a Fisher classifier from disk.</desc>
                        <sample for="lua">fisher = MachineLearning.Fisher.load(path)</sample>
                        <param name="path" type="string" desc="The path to the classifier"/>
                        <return name="fisher" type="handle" multiplicity="?" alias="MachineLearning.Fisher" desc="The Fisher handle to the loaded object."/>
                    </function>
                    <function name="save">
                        <desc>Save a Fisher classifier to disk.</desc>
                        <sample for="lua">success = MachineLearning.Fisher.save(fisher, path)</sample>
                        <param name="fisher" type="handle" alias="MachineLearning.Fisher" desc="The classifier instance to use"/>
                        <param name="path" type="string" desc="The path at which to store the classifier"/>
                        <return name="success" type="bool" multiplicity="?" desc="True if the file was successfully stored, false if storing failed."/>
                    </function>
                    <function name="train">
                        <desc>Perform training on data supplied in a DataSet object.</desc>
                        <sample for="lua">success = MachineLearning.Fisher.train(fisher, dataSet)</sample>
                        <param name="fisher" type="handle" alias="MachineLearning.Fisher" desc="The classifier instance to use"/>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="Input dataset"/>
                        <return name="success" type="bool" multiplicity="?" desc="True if classifier was successfully trained."/>
                    </function>
                    <function name="predict">
                        <desc>Classify a sample using the trained classifier.</desc>
                        <sample for="lua">class = MachineLearning.Fisher.predict(fisher, sample)</sample>
                        <param name="fisher" type="handle" alias="MachineLearning.Fisher" desc="The classifier instance to use."/>
                        <param name="sample" type="object" multiplicity="[1+]" alias="Matrix" desc="A sample or a set of samples that are to be classified. Each row of the input matrix is considered one sample."/>
                        <return name="class" type="float" multiplicity="[?*]" desc="Predicted class output from the classifier. In case of a single sample input it's a single value. For multi row input it's a vector of class labels."/>
                    </function>
                    <function name="isTrained">
                        <desc>Use to check if classifier has been trained successfully. If a classifier is trained it can be used to predict.</desc>
                        <sample for="lua">trained = MachineLearning.Fisher.isTrained(fisher)</sample>
                        <param name="fisher" type="handle" alias="MachineLearning.Fisher" desc="The classifier instance to use."/>
                        <return name="trained" type="bool" desc="True if the classifier is trained."/>
                    </function>
                    <function name="getFeatureCount">
                        <desc>Use to check what feature size the classifier was trained on. A classifier can only be used on new data with the same amount of features.</desc>
                        <sample for="lua">trained = MachineLearning.Fisher.getFeatureCount(fisher)</sample>
                        <param name="fisher" type="handle" alias="MachineLearning.Fisher" desc="The classifier instance to use."/>
                        <return name="featureCount" type="int" desc="The amount of features per sample."/>
                    </function>
                    <function name="getAccuracy">
                        <desc>Evaluate a classifier against a DataSet object by computing the predicted class and comparing it to the label supplied in the DataSet object.

The "accuracy" returned will be the amount of correctly classified samples divided by the total amount of samples.

The second output, the "confusionMatrix", is a NxN matrix.

The final return value is a vector. This vector tells us what original label correspond to what row and column in the confusion matrix.

In the NxN confusion matrix contains classification statistics. Each row corresponds to a label input and each column to a classification output. That is, if all classes have been correctly classified, there should only be non-zero elements along the diagonal of this matrix.

For example a matrix of the following format

C = [3 1, 2 4]
labels = {1, 2}

This means that the model had labels 1 and 2. For these labels the classification was tested on a total of 3+1+2+4 = 10 samples. Out of these 3+2 = 5 were classified as label one and 1+4 = 5 as label two. However, there were actually 3+1 = 4 samples of type one and 2+4 = 6 of type two in the input. To calculate the accuracy sum the diagonal, 3 + 4 = 7 and divide by the total amount of samples 10, which in this case gives an accuracy of 70%. It can also be useful to analyze other properties of this matrix. In this case inputs of type 2 are more likely to be classified as type 1 than type 1 being classified as type 2.</desc>
                        <sample for="lua">accuracy, confusionMatrix = MachineLearning.Fisher.getAccuracy(fisher, dataSet)</sample>
                        <param name="fisher" type="handle" alias="MachineLearning.Fisher" desc="The classifier instance to use."/>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="The dataset to use"/>
                        <return name="accuracy" type="float" multiplicity="?" desc="The accuracy rate. Computed as correct classifications divided by total amount of samples."/>
                        <return name="confusionMatrix" type="object" multiplicity="?" alias="Matrix" desc="Confusion matrix for dataset and classifier."/>
                        <return name="confusionMatrixLabels" type="int" multiplicity="[?*]" desc="The label key for the confusion matrix."/>
                    </function>
                    <function name="getProjectionVector">
                        <desc>Returns the estimated projection direction for this classifier. This can be used to better understand what features are distinguishing when separating the objects.</desc>
                        <sample for="lua">vector = MachineLearning.Fisher.getProjectionVector(fisher)</sample>
                        <param name="fisher" type="handle" alias="MachineLearning.Fisher" desc="The classifier instance to use."/>
                        <return name="vector" type="float" multiplicity="+" desc="A vector with the coefficients for projection."/>
                    </function>
                    <function name="clear">
                        <desc>Clear internal data of the classifier.</desc>
                        <sample for="lua">MachineLearning.Fisher.clear(fisher)</sample>
                        <param name="fisher" type="handle" alias="MachineLearning.Fisher" desc="The classifier instance to use."/>
                    </function>
                    <function name="toString">
                        <desc>Get a brief string description of the classifier. This is equal to the text shown in the debugger.</desc>
                        <sample for="lua">print("Description: " .. MachineLearning.Fisher.toString(fisher))</sample>
                        <param name="fisher" type="object" alias="MachineLearning.Fisher" desc="The input classifier data"/>
                        <return name="string" type="string" desc="Description of the classifier"/>
                    </function>
                </serves>
            </crown>
            <crown name="NeuralNet">
                <trait>released</trait>
                <links>MachineLearning.DeepNeuralNetwork</links>
                <desc>A neural network also known as Artificial Neural Net (ANN) or multi-layer perceptron (MLP) is a model initially created to mimic the function of neurons. Note that this is a shallow fully connected neural network model that can be trained on device. For larger Deep Neural Networks and Convolutional Networks see the DeepNeuralNetwork API.

In a neural network there is an input layer, an output layer and a number of hidden layers. The input layer typically corresponds to the input features and the output layer to the output labels.

In-between these two layers is an undecided number of hidden layers. The number of layers can be selected by the length of the "hiddenLayers" vector in the setParameters function and the amount of neurons in each layer by the value at each position in this vector. The first value corresponds to the layer closest to the input.

Each neuron can be thought of as a simple decision point in the graph. How the decision is made is determined through training by means of back propagation on training data and by the selection of the activation function prior to training.

One special feature of the neural network is that it can be trained incrementally. That is, it's possible to train on different DataSet objects in sequence and get a final model with the accumulated result. The limitation of this is that only new samples of the same format can be added, no new features can be introduced between increments. Be sure to use the "clear" function if incremental training is not intended!</desc>
                <enum name="ActivationFunction" trait="released">
                    <item name="IDENTITY" desc="Identity activation function, eg. f(x) = x.">IDENTITY</item>
                    <item name="SIGMOID" desc="Sigmoid activation function, eg. f(x) ~ tanh(x).">SIGMOID</item>
                    <item name="GAUSSIAN" desc="Gaussian activation function, eg. f(x) ~ exp(-x^2).">GAUSSIAN</item>
                </enum>
                <serves>
                    <function name="create">
                        <desc>Creates a new NeuralNet</desc>
                        <sample for="lua">nn = MachineLearning.NeuralNet.create()</sample>
                        <return name="nn" type="handle" alias="MachineLearning.NeuralNet" desc="The new NeuralNet handle"/>
                    </function>
                    <function name="load">
                        <desc>Load a NeuralNet classifier from disk.</desc>
                        <sample for="lua">nn = MachineLearning.NeuralNet.load(path)</sample>
                        <param name="path" type="string" desc="The path to the classifier"/>
                        <return name="nn" type="handle" multiplicity="?" alias="MachineLearning.NeuralNet" desc="The NeuralNet handle to the loaded object."/>
                    </function>
                    <function name="save">
                        <desc>Save a NeuralNet classifier to disk.</desc>
                        <sample for="lua">success = MachineLearning.NeuralNet.save(nn, path)</sample>
                        <param name="nn" type="handle" alias="MachineLearning.NeuralNet" desc="The classifier instance to use"/>
                        <param name="path" type="string" desc="The path at which to store the classifier"/>
                        <return name="success" type="bool" multiplicity="?" desc="True if the file was successfully stored, false if storing failed."/>
                    </function>
                    <function name="setParameters">
                        <desc>Set parameters for how training should be done.</desc>
                        <sample for="lua">success = MachineLearning.NeuralNet.setParameters(nn, {3, 4}, "SIGMOID")</sample>
                        <param name="nn" type="handle" alias="MachineLearning.NeuralNet" desc="The classifier instance to use"/>
                        <param name="hiddenLayers" type="int" multiplicity="+" desc="A vector specifying how many hidden neurons there should be in each layer. The first entry is closest to the input layer."/>
                        <param name="activationFunction" type="enum" multiplicity="?" ref="ActivationFunction" desc="Type of activation function to use in the perceptrons. If omitted SIGMOID is used."/>
                        <param name="weightScale" type="float" multiplicity="?" desc="Sets the weight scale for back propagation calculations."/>
                        <param name="momentumScale" type="float" multiplicity="?" desc="Sets the momentum scale for back propagation calculations."/>
                        <return name="success" type="bool" multiplicity="?" desc="True if successful, false if combination of parameters is unsupported."/>
                    </function>
                    <function name="setTerminationCriteria">
                        <desc>Select the number of iterations and/or the allowed residual error for the model.</desc>
                        <sample for="lua">success = MachineLearning.NeuralNet.setTerminationCriteria(nn, maxIterations, residualError)</sample>
                        <param name="nn" type="handle" alias="MachineLearning.NeuralNet" desc="The classifier instance to use"/>
                        <param name="maxIterations" type="int" multiplicity="?" desc="Select the maximum number of iterations allowed. Default is 1000."/>
                        <param name="residualError" type="float" multiplicity="?" desc="Limit to determine when to stop creating new trees. Default is 0.01."/>
                        <return name="success" type="bool" desc="True if the parameters could be set."/>
                    </function>
                    <function name="train">
                        <desc>Perform training on data supplied in a DataSet object.

Note that training is done incrementally. To start out from the beginning use "clear" or create a new NeuralNet handle.</desc>
                        <sample for="lua">success = MachineLearning.NeuralNet.train(nn, dataSet)</sample>
                        <param name="nn" type="handle" alias="MachineLearning.NeuralNet" desc="The classifier instance to use"/>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="Input dataset"/>
                        <return name="success" type="bool" multiplicity="?" desc="True if classifier was successfully trained."/>
                    </function>
                    <function name="predict">
                        <desc>Classify a sample using the trained classifier.</desc>
                        <sample for="lua">class = MachineLearning.NeuralNet.predict(nn, sample)</sample>
                        <param name="nn" type="handle" alias="MachineLearning.NeuralNet" desc="The classifier instance to use."/>
                        <param name="sample" type="object" multiplicity="[1+]" alias="Matrix" desc="A sample or a set of samples that are to be classified. Each row of the input matrix is considered one sample."/>
                        <return name="class" type="float" multiplicity="[?*]" desc="Predicted class output from the classifier. In case of a single sample input it's a single value. For multi row input it's a vector of class labels."/>
                    </function>
                    <function name="isTrained">
                        <desc>Use to check if classifier has been trained successfully. If a classifier is trained it can be used to predict.</desc>
                        <sample for="lua">trained = MachineLearning.NeuralNet.isTrained(nn)</sample>
                        <param name="nn" type="handle" alias="MachineLearning.NeuralNet" desc="The classifier instance to use."/>
                        <return name="trained" type="bool" desc="True if the classifier is trained."/>
                    </function>
                    <function name="getFeatureCount">
                        <desc>Use to check what feature size the classifier was trained on. A classifier can only be used on new data with the same amount of features.</desc>
                        <sample for="lua">trained = MachineLearning.NeuralNet.getFeatureCount(nn)</sample>
                        <param name="nn" type="handle" alias="MachineLearning.NeuralNet" desc="The classifier instance to use."/>
                        <return name="featureCount" type="int" desc="The amount of features per sample."/>
                    </function>
                    <function name="getAccuracy">
                        <desc>Evaluate a classifier against a DataSet object by computing the predicted class and comparing it to the label supplied in the DataSet object.

The "accuracy" returned will be the amount of correctly classified samples divided by the total amount of samples.

The second output, the "confusionMatrix", is a NxN matrix.

The final return value is a vector. This vector tells us what original label correspond to what row and column in the confusion matrix.

In the NxN confusion matrix contains classification statistics. Each row corresponds to a label input and each column to a classification output. That is, if all classes have been correctly classified, there should only be non-zero elements along the diagonal of this matrix.

For example a matrix of the following format

C = [3 1, 2 4]
labels = {1, 2}

This means that the model had labels 1 and 2. For these labels the classification was tested on a total of 3+1+2+4 = 10 samples. Out of these 3+2 = 5 were classified as label one and 1+4 = 5 as label two. However, there were actually 3+1 = 4 samples of type one and 2+4 = 6 of type two in the input. To calculate the accuracy sum the diagonal, 3 + 4 = 7 and divide by the total amount of samples 10, which in this case gives an accuracy of 70%. It can also be useful to analyze other properties of this matrix. In this case inputs of type 2 are more likely to be classified as type 1 than type 1 being classified as type 2.</desc>
                        <sample for="lua">accuracy, confusionMatrix = MachineLearning.NeuralNet.getAccuracy(nn, dataSet)</sample>
                        <param name="nn" type="handle" alias="MachineLearning.NeuralNet" desc="The classifier instance to use."/>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="The dataset to use"/>
                        <return name="accuracy" type="float" multiplicity="?" desc="The accuracy rate. Computed as correct classifications divided by total amount of samples."/>
                        <return name="confusionMatrix" type="object" multiplicity="?" alias="Matrix" desc="Confusion matrix for dataset and classifier."/>
                        <return name="confusionMatrixLabels" type="int" multiplicity="[?*]" desc="The label key for the confusion matrix."/>
                    </function>
                    <function name="clear">
                        <desc>Clear internal data of the classifier. Use this to forget previous samples and reset all network weights.</desc>
                        <sample for="lua">MachineLearning.NeuralNet.clear(nn)</sample>
                        <param name="nn" type="handle" alias="MachineLearning.NeuralNet" desc="The classifier instance to use."/>
                    </function>
                    <function name="toString">
                        <desc>Get a brief string description of the classifier. This is equal to the text shown in the debugger.</desc>
                        <sample for="lua">print("Description: " .. MachineLearning.NeuralNet.toString(nn))</sample>
                        <param name="nn" type="object" alias="MachineLearning.NeuralNet" desc="The input classifier data"/>
                        <return name="string" type="string" desc="Description of the classifier"/>
                    </function>
                </serves>
            </crown>
            <crown name="Bayes">
                <trait>released</trait>
                <desc>Bayes, or as it is sometimes known, Normal Bayes Classifier, is a really simple classifier. It has no parameters and tries to separate classes by assuming normal distribution within each feature. For data that is approximately Gaussian this classifier works well and is quite quick to evaluate.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new Bayes classifier.</desc>
                        <sample for="lua">bayes = MachineLearning.Bayes.create()</sample>
                        <return name="bayes" type="handle" alias="MachineLearning.Bayes" desc="The new Bayes handle"/>
                    </function>
                    <function name="load">
                        <desc>Load a Bayes classifier from disk.</desc>
                        <sample for="lua">bayes = MachineLearning.Bayes.load(path)</sample>
                        <param name="path" type="string" desc="The path to the classifier"/>
                        <return name="bayes" type="handle" multiplicity="?" alias="MachineLearning.Bayes" desc="The Bayes handle to the loaded object."/>
                    </function>
                    <function name="save">
                        <desc>Save a Bayes classifier to disk.</desc>
                        <sample for="lua">success = MachineLearning.Bayes.save(bayes, path)</sample>
                        <param name="bayes" type="handle" alias="MachineLearning.Bayes" desc="The classifier instance to use"/>
                        <param name="path" type="string" desc="The path at which to store the classifier"/>
                        <return name="success" type="bool" multiplicity="?" desc="True if the file was successfully stored, false if storing failed."/>
                    </function>
                    <function name="train">
                        <desc>Perform training on data supplied in a DataSet object.</desc>
                        <sample for="lua">success = MachineLearning.Bayes.train(bayes, dataSet)</sample>
                        <param name="bayes" type="handle" alias="MachineLearning.Bayes" desc="The classifier instance to use"/>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="Input dataset"/>
                        <return name="success" type="bool" multiplicity="?" desc="True if classifier was successfully trained."/>
                    </function>
                    <function name="predict">
                        <desc>Classify a sample using the trained classifier.</desc>
                        <sample for="lua">class = MachineLearning.Bayes.predict(bayes, sample)</sample>
                        <param name="bayes" type="handle" alias="MachineLearning.Bayes" desc="The classifier instance to use."/>
                        <param name="sample" type="object" multiplicity="[1+]" alias="Matrix" desc="A sample or a set of samples that are to be classified. Each row of the input matrix is considered one sample."/>
                        <return name="class" type="float" multiplicity="[?*]" desc="Predicted class output from the classifier. In case of a single sample input it's a single value. For multi row input it's a vector of class labels."/>
                    </function>
                    <function name="isTrained">
                        <desc>Use to check if classifier has been trained successfully. If a classifier is trained it can be used to predict.</desc>
                        <sample for="lua">trained = MachineLearning.Bayes.isTrained(bayes)</sample>
                        <param name="bayes" type="handle" alias="MachineLearning.Bayes" desc="The classifier instance to use."/>
                        <return name="trained" type="bool" desc="True if the classifier is trained."/>
                    </function>
                    <function name="getFeatureCount">
                        <desc>Use to check what feature size the classifier was trained on. A classifier can only be used on new data with the same amount of features.</desc>
                        <sample for="lua">trained = MachineLearning.Bayes.getFeatureCount(bayes)</sample>
                        <param name="bayes" type="handle" alias="MachineLearning.Bayes" desc="The classifier instance to use."/>
                        <return name="featureCount" type="int" desc="The amount of features per sample."/>
                    </function>
                    <function name="getAccuracy">
                        <desc>Evaluate a classifier against a DataSet object by computing the predicted class and comparing it to the label supplied in the DataSet object.

The "accuracy" returned will be the amount of correctly classified samples divided by the total amount of samples.

The second output, the "confusionMatrix", is a NxN matrix.

The final return value is a vector. This vector tells us what original label correspond to what row and column in the confusion matrix.

In the NxN confusion matrix contains classification statistics. Each row corresponds to a label input and each column to a classification output. That is, if all classes have been correctly classified, there should only be non-zero elements along the diagonal of this matrix.

For example a matrix of the following format

C = [3 1, 2 4]
labels = {1, 2}

This means that the model had labels 1 and 2. For these labels the classification was tested on a total of 3+1+2+4 = 10 samples. Out of these 3+2 = 5 were classified as label one and 1+4 = 5 as label two. However, there were actually 3+1 = 4 samples of type one and 2+4 = 6 of type two in the input. To calculate the accuracy sum the diagonal, 3 + 4 = 7 and divide by the total amount of samples 10, which in this case gives an accuracy of 70%. It can also be useful to analyze other properties of this matrix. In this case inputs of type 2 are more likely to be classified as type 1 than type 1 being classified as type 2.</desc>
                        <sample for="lua">accuracy, confusionMatrix = MachineLearning.Bayes.getAccuracy(bayes, dataSet)</sample>
                        <param name="bayes" type="handle" alias="MachineLearning.Bayes" desc="The classifier instance to use."/>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="The dataset to use"/>
                        <return name="accuracy" type="float" multiplicity="?" desc="The accuracy rate. Computed as correct classifications divided by total amount of samples."/>
                        <return name="confusionMatrix" type="object" multiplicity="?" alias="Matrix" desc="Confusion matrix for dataset and classifier."/>
                        <return name="confusionMatrixLabels" type="int" multiplicity="[?*]" desc="The label key for the confusion matrix."/>
                    </function>
                    <function name="clear">
                        <desc>Clear internal data of the classifier.</desc>
                        <sample for="lua">MachineLearning.Bayes.clear(bayes)</sample>
                        <param name="bayes" type="handle" alias="MachineLearning.Bayes" desc="The classifier instance to use."/>
                    </function>
                    <function name="toString">
                        <desc>Get a brief string description of the classifier. This is equal to the text shown in the debugger.</desc>
                        <sample for="lua">print("Description: " .. MachineLearning.Bayes.toString(bayes))</sample>
                        <param name="bayes" type="object" alias="MachineLearning.Bayes" desc="The input classifier data"/>
                        <return name="string" type="string" desc="Description of the classifier"/>
                    </function>
                </serves>
            </crown>
            <crown name="RandomForest">
                <trait>released</trait>
                <desc>The random forest method is a method based on decision trees. During training multiple decision trees are created based on subsets of the training dataset. During classification each tree is evaluated on the data and the majority vote wins.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a new RandomForest</desc>
                        <sample for="lua">rf = MachineLearning.RandomForest.create()</sample>
                        <return name="rf" type="handle" alias="MachineLearning.RandomForest" desc="The new RandomForest handle"/>
                    </function>
                    <function name="load">
                        <desc>Load a RandomForest classifier from disk.</desc>
                        <sample for="lua">rf = MachineLearning.RandomForest.load(path)</sample>
                        <param name="path" type="string" desc="The path to the classifier"/>
                        <return name="rf" type="handle" multiplicity="?" alias="MachineLearning.RandomForest" desc="The RandomForest handle to the loaded object."/>
                    </function>
                    <function name="save">
                        <desc>Save a RandomForest classifier to disk.</desc>
                        <sample for="lua">success = MachineLearning.RandomForest.save(rf, path)</sample>
                        <param name="rf" type="handle" alias="MachineLearning.RandomForest" desc="The classifier instance to use"/>
                        <param name="path" type="string" desc="The path at which to store the classifier"/>
                        <return name="success" type="bool" multiplicity="?" desc="True if the file was successfully stored, false if storing failed."/>
                    </function>
                    <function name="setParameters">
                        <desc>Set parameters for how training should be done.</desc>
                        <sample for="lua">success = MachineLearning.RandomForest.setParameters(rf, ...)</sample>
                        <param name="handle" type="handle" alias="MachineLearning.RandomForest" desc="The classifier instance to use"/>
                        <param name="minSamplesPerNode" type="int" multiplicity="?" desc=" If the number of samples in a node is less than this value the node will not be split. Default is 10."/>
                        <param name="regressionAccuracy" type="float" multiplicity="?" desc="Limit to determine when to stop splitting nodes for regression trees. Default is 0.01."/>
                        <param name="activeVarCount" type="int" multiplicity="?" desc="The size of the subset of features at each tree node that are used to find the best split(s). If set to 0 it is automatically set to the square root of the number of samples."/>
                        <param name="maxCategories" type="int" multiplicity="?" desc="In cases with more than 2 classes this limitation is used to reduce computation time at the cost of precision. Use a higher value for more precise results. Default is 10."/>
                        <param name="maxTreeDepth" type="int" multiplicity="?" desc="If no other termination criteria stops the splitting this determines the maximum allowed depth of a tree. Default is 10."/>
                        <return name="success" type="bool" multiplicity="?" desc="True if successful, false if combination of parameters is unsupported."/>
                    </function>
                    <function name="setTerminationCriteria">
                        <desc>Select the number of trees and/or the allowed residual error for the model.</desc>
                        <sample for="lua">success = MachineLearning.RandomForest.setTerminationCriteria(rf, maxTrees, residualError)</sample>
                        <param name="handle" type="handle" alias="MachineLearning.RandomForest" desc="The classifier instance to use"/>
                        <param name="maxTrees" type="int" multiplicity="?" desc="Select the maximum number of decision trees to create. Default is 10."/>
                        <param name="residualError" type="float" multiplicity="?" desc="Limit to determine when to stop creating new trees. Default is 0.1."/>
                        <return name="success" type="bool" desc="True if the parameters could be set."/>
                    </function>
                    <function name="train">
                        <desc>Perform training on data supplied in a DataSet object.</desc>
                        <sample for="lua">success = MachineLearning.RandomForest.train(rf, dataSet)</sample>
                        <param name="rf" type="handle" alias="MachineLearning.RandomForest" desc="The classifier instance to use"/>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="Input dataset"/>
                        <return name="success" type="bool" multiplicity="?" desc="True if classifier was successfully trained."/>
                    </function>
                    <function name="predict">
                        <desc>Classify a sample using the trained classifier.</desc>
                        <sample for="lua">class = MachineLearning.RandomForest.predict(rf, sample)</sample>
                        <param name="rf" type="handle" alias="MachineLearning.RandomForest" desc="The classifier instance to use."/>
                        <param name="sample" type="object" multiplicity="[1+]" alias="Matrix" desc="A sample or a set of samples that are to be classified. Each row of the input matrix is considered one sample."/>
                        <return name="class" type="float" multiplicity="[?*]" desc="Predicted class output from the classifier. In case of a single sample input it's a single value. For multi row input it's a vector of class labels."/>
                    </function>
                    <function name="isTrained">
                        <desc>Use to check if classifier has been trained successfully. If a classifier is trained it can be used to predict.</desc>
                        <sample for="lua">trained = MachineLearning.RandomForest.isTrained(rf)</sample>
                        <param name="rf" type="handle" alias="MachineLearning.RandomForest" desc="The classifier instance to use."/>
                        <return name="trained" type="bool" desc="True if the classifier is trained."/>
                    </function>
                    <function name="getFeatureCount">
                        <desc>Use to check what feature size the classifier was trained on. A classifier can only be used on new data with the same amount of features.</desc>
                        <sample for="lua">trained = MachineLearning.RandomForest.getFeatureCount(rf)</sample>
                        <param name="rf" type="handle" alias="MachineLearning.RandomForest" desc="The classifier instance to use."/>
                        <return name="featureCount" type="int" desc="The amount of features per sample."/>
                    </function>
                    <function name="getAccuracy">
                        <desc>Evaluate a classifier against a DataSet object by computing the predicted class and comparing it to the label supplied in the DataSet object.

The "accuracy" returned will be the amount of correctly classified samples divided by the total amount of samples.

The second output, the "confusionMatrix", is a NxN matrix.

The final return value is a vector. This vector tells us what original label correspond to what row and column in the confusion matrix.

In the NxN confusion matrix contains classification statistics. Each row corresponds to a label input and each column to a classification output. That is, if all classes have been correctly classified, there should only be non-zero elements along the diagonal of this matrix.

For example a matrix of the following format

C = [3 1, 2 4]
labels = {1, 2}

This means that the model had labels 1 and 2. For these labels the classification was tested on a total of 3+1+2+4 = 10 samples. Out of these 3+2 = 5 were classified as label one and 1+4 = 5 as label two. However, there were actually 3+1 = 4 samples of type one and 2+4 = 6 of type two in the input. To calculate the accuracy sum the diagonal, 3 + 4 = 7 and divide by the total amount of samples 10, which in this case gives an accuracy of 70%. It can also be useful to analyze other properties of this matrix. In this case inputs of type 2 are more likely to be classified as type 1 than type 1 being classified as type 2.</desc>
                        <sample for="lua">accuracy, confusionMatrix = MachineLearning.RandomForest.getAccuracy(rf, dataSet)</sample>
                        <param name="rf" type="handle" alias="MachineLearning.RandomForest" desc="The classifier instance to use."/>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="The data set to use"/>
                        <return name="accuracy" type="float" multiplicity="?" desc="The accuracy rate. Computed as correct classifications divided by total amount of samples."/>
                        <return name="confusionMatrix" type="object" multiplicity="?" alias="Matrix" desc="Confusion matrix for data set and classifier."/>
                        <return name="confusionMatrixLabels" type="int" multiplicity="[?*]" desc="The label key for the confusion matrix."/>
                    </function>
                    <function name="clear">
                        <desc>Clear internal data of the classifier.</desc>
                        <sample for="lua">MachineLearning.RandomForest.clear(rf)</sample>
                        <param name="rf" type="handle" alias="MachineLearning.RandomForest" desc="The classifier instance to use."/>
                    </function>
                    <function name="toString">
                        <desc>Get a brief string description of the classifier. This is equal to the text shown in the debugger.</desc>
                        <sample for="lua">print("Description: " .. MachineLearning.RandomForest.toString(rf))</sample>
                        <param name="rf" type="object" alias="MachineLearning.RandomForest" desc="The input classifier data"/>
                        <return name="string" type="string" desc="Description of the classifier"/>
                    </function>
                </serves>
            </crown>
            <crown name="SupportVectorMachine">
                <trait>released</trait>
                <desc>Support Vector Machines are used to distinguish multidimensional data by creating a decision boundary that maximizes the orthogonal distance between classes.

A Support Vector Machine can be configured to support non-linear cases by using a non-linear kernel.

A special case of the Support Vector Machine is the single class case where a classifier can be trained on samples only from one class to learn to recognize if new samples belong to this class or not. This requires training data set with only one input class.</desc>
                <enum name="KernelType" trait="released">
                    <item name="LINEAR" desc="Linear kernel. No mapping is done, linear discrimination (or regression) is done in the original feature space. It is the fastest option. K(x, y) = x^T * y.">LINEAR</item>
                    <item name="GAUSSIAN" desc="Radial basis function (RBF), a good choice in most cases. K(x, y) = e^{-||x - y||^2 / sigma^2}.">GAUSSIAN</item>
                </enum>
                <serves>
                    <function name="create">
                        <desc>Creates a new SupportVectorMachine</desc>
                        <sample for="lua">svm = MachineLearning.SupportVectorMachine.create()</sample>
                        <return name="svm" type="handle" alias="MachineLearning.SupportVectorMachine" desc="The new SupportVectorMachine"/>
                    </function>
                    <function name="load">
                        <desc>Load a SupportVectorMachine classifier from disk.</desc>
                        <sample for="lua">svm = MachineLearning.SupportVectorMachine.load(path)</sample>
                        <param name="path" type="string" desc="The path to the classifier"/>
                        <return name="svm" type="handle" multiplicity="?" alias="MachineLearning.SupportVectorMachine" desc="The SupportVectorMachine handle to the loaded object."/>
                    </function>
                    <function name="save">
                        <desc>Save a SupportVectorMachine classifier to disk.</desc>
                        <sample for="lua">success = MachineLearning.SupportVectorMachine.save(svm, path)</sample>
                        <param name="svm" type="handle" alias="MachineLearning.SupportVectorMachine" desc="The classifier instance to use"/>
                        <param name="path" type="string" desc="The path at which to store the classifier"/>
                        <return name="success" type="bool" multiplicity="?" desc="True if the file was successfully stored, false if storing failed."/>
                    </function>
                    <function name="setParameters">
                        <desc>Set parameters for how training should be done.</desc>
                        <sample for="lua">success = MachineLearning.SupportVectorMachine.setParameters(svm, nu, kernelType, gamma)</sample>
                        <param name="svm" type="handle" alias="MachineLearning.SupportVectorMachine" desc="The classifier instance to use"/>
                        <param name="nu" type="float" desc="Parameter commonly known as nu for Support Vector Machine optimization problems. It tweaks the flexibility/smoothing of the decision boundaries and the complexity of the final classifier. Should be a value in the range of 0 to 1."/>
                        <param name="kernelType" type="enum" ref="KernelType" desc="Type of kernel used in SupportVectorMachine computation."/>
                        <param name="sigma" type="float" multiplicity="?" desc="Standard deviation sigma for the GAUSSIAN kernel function. For the LINEAR KernelType this value is unused."/>
                        <param name="singleClass" type="bool" multiplicity="?" desc="Select this if only samples of one class is supplied. Learns to detect anomalies from this class. Not used in the regression case."/>
                        <param name="c" type="float" multiplicity="?" desc="SVM C parameter for regression problems. Not used in the classification case."/>
                        <return name="success" type="bool" multiplicity="?" desc="Returns true if successful."/>
                    </function>
                    <function name="setTerminationCriteria">
                        <desc>Select the number of iterations and/or the allowed residual error for the model.</desc>
                        <sample for="lua">success = MachineLearning.SupportVectorMachine.setTerminationCriteria(svm, maxIterations, residualError)</sample>
                        <param name="svm" type="handle" alias="MachineLearning.SupportVectorMachine" desc="The classifier instance to use"/>
                        <param name="maxIterations" type="int" multiplicity="?" desc="Select the maximum number of iterations allowed. Default is 100."/>
                        <param name="residualError" type="float" multiplicity="?" desc="Limit to determine when to stop creating new trees. Default is 1e-6."/>
                        <return name="success" type="bool" desc="True if the parameters could be set."/>
                    </function>
                    <function name="train">
                        <desc>Perform training on data supplied in a DataSet object.</desc>
                        <sample for="lua">MachineLearning.SupportVectorMachine.train(svm, dataSet)</sample>
                        <param name="svm" type="handle" alias="MachineLearning.SupportVectorMachine" desc="The classifier instance to use"/>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="Input data set"/>
                        <return name="success" type="bool" multiplicity="?" desc="True if classifier was successfully trained. Nil if dataSet is nil."/>
                    </function>
                    <function name="predict">
                        <desc>Classify a sample using the trained classifier.</desc>
                        <sample for="lua">class = MachineLearning.SupportVectorMachine.predict(svm, sample)</sample>
                        <param name="svm" type="handle" alias="MachineLearning.SupportVectorMachine" desc="The classifier instance to use."/>
                        <param name="sample" type="object" multiplicity="[1+]" alias="Matrix" desc="A sample or a set of samples that are to be classified. Each row of the input matrix is considered one sample."/>
                        <return name="class" type="float" multiplicity="[?*]" desc="Predicted class output from the classifier. In case of a single sample input it's a single value. For multi row input it's a vector of class labels."/>
                    </function>
                    <function name="isTrained">
                        <desc>Use to check if classifier has been trained successfully. If a classifier is trained it can be used to predict.</desc>
                        <sample for="lua">trained = MachineLearning.SupportVectorMachine.isTrained(svm)</sample>
                        <param name="svm" type="handle" alias="MachineLearning.SupportVectorMachine" desc="The classifier instance to use."/>
                        <return name="trained" type="bool" desc="True if the classifier is trained."/>
                    </function>
                    <function name="getFeatureCount">
                        <desc>Use to check what feature size the classifier was trained on. A classifier can only be used on new data with the same amount of features.</desc>
                        <sample for="lua">trained = MachineLearning.SupportVectorMachine.getFeatureCount(svm)</sample>
                        <param name="svm" type="handle" alias="MachineLearning.SupportVectorMachine" desc="The classifier instance to use."/>
                        <return name="featureCount" type="int" desc="The amount of features per sample."/>
                    </function>
                    <function name="getAccuracy">
                        <desc>Evaluate a classifier against a DataSet object by computing the predicted class and comparing it to the label supplied in the DataSet object.

The "accuracy" returned will be the amount of correctly classified samples divided by the total amount of samples.

The second output, the "confusionMatrix", is a NxN matrix.

The final return value is a vector. This vector tells us what original label correspond to what row and column in the confusion matrix.

In the NxN confusion matrix contains classification statistics. Each row corresponds to a label input and each column to a classification output. That is, if all classes have been correctly classified, there should only be non-zero elements along the diagonal of this matrix.

For example a matrix of the following format

C = [3 1, 2 4]
labels = {1, 2}

This means that the model had labels 1 and 2. For these labels the classification was tested on a total of 3+1+2+4 = 10 samples. Out of these 3+2 = 5 were classified as label one and 1+4 = 5 as label two. However, there were actually 3+1 = 4 samples of type one and 2+4 = 6 of type two in the input. To calculate the accuracy sum the diagonal, 3 + 4 = 7 and divide by the total amount of samples 10, which in this case gives an accuracy of 70%. It can also be useful to analyze other properties of this matrix. In this case inputs of type 2 are more likely to be classified as type 1 than type 1 being classified as type 2.</desc>
                        <sample for="lua">accuracy, confusionMatrix = MachineLearning.SupportVectorMachine.getAccuracy(svm, dataSet)</sample>
                        <param name="svm" type="handle" alias="MachineLearning.SupportVectorMachine" desc="The classifier instance to use."/>
                        <param name="dataSet" type="object" alias="MachineLearning.DataSet" desc="The data set to use"/>
                        <return name="accuracy" type="float" multiplicity="?" desc="The accuracy rate. Computed as correct classifications divided by total amount of samples."/>
                        <return name="confusionMatrix" type="object" multiplicity="?" alias="Matrix" desc="Confusion matrix for data set and classifier."/>
                        <return name="confusionMatrixLabels" type="int" multiplicity="[?*]" desc="The label key for the confusion matrix."/>
                    </function>
                    <function name="clear">
                        <desc>Clear internal data of the classifier.</desc>
                        <sample for="lua">MachineLearning.SupportVectorMachine.clear(svm)</sample>
                        <param name="svm" type="handle" alias="MachineLearning.SupportVectorMachine" desc="The classifier instance to use."/>
                    </function>
                    <function name="toString">
                        <desc>Get a brief string description of the classifier. This is equal to the text shown in the debugger.</desc>
                        <sample for="lua">print("Description: " .. MachineLearning.SupportVectorMachine.toString(svm))</sample>
                        <param name="svm" type="object" alias="MachineLearning.SupportVectorMachine" desc="The input classifier data"/>
                        <return name="string" type="string" desc="Description of the classifier"/>
                    </function>
                </serves>
            </crown>
            <crown name="DeepNeuralNetwork">
                <trait>released</trait>
                <keywords>cnn, convolutional, dnn, classification, ai</keywords>
                <links>MachineLearning.NeuralNet</links>
                <desc>Inference API for Deep Neural Networks.

* Networks must have been trained using dedicated software from SICK.
* This API is under special license, restrictions in its usage apply. See the function MachineLearning.DeepNeuralNetwork.getLicenseLevel to check your current license.
* It is not possible to train Deep Neural Networks through this API. Shallow Neural Networks can be trained directly under the MachineLearning.NeuralNet API.
* Currently the API supports processing of images.

The typical usage follows this pattern:

Setup:
1) Load a ready-trained network from disk using model = Object.load(neuralNetworkFilePath). This gives back a MachineLearning.DeepNeuralNetwork.Model object.
2) Create an instance of the inference engine using MachineLearning.DeepNeuralNetwork.create() and enable the loaded model through MachineLearning.DeepNeuralNetwork.setModel(model)

Inference for each new image:
3) Set a new image for processing using MachineLearning.DeepNeuralNetwork.setInputImage(im) function.
4) Call result = MachineLearning.DeepNeuralNetwork.predict() which gives back a MachineLearning.DeepNeuralNetwork.Result object.
5) From the result object the output of the Deep Neural Network can be retrieved.</desc>
                <enum name="LicenseLevel">
                    <item name="Blocked" desc="No calls to MachineLearning.DeepNeuralNetwork.predict will be possible. All other functionality for loading and managing deep neural netorks are available.">BLOCKED</item>
                    <item name="Limited" desc="A limited number of calls to MachineLearning.DeepNeuralNetwork.predict will be possible. The number of calls may be different depending on the device.">LIMITED</item>
                    <item name="Full" desc="No restrictions apply.">FULL</item>
                </enum>
                <enum name="CropMode">
                    <item name="UniformCrop" desc="Resizes to fit the inner target size and crops the remainder.">UNIFORM_RESIZE_CROP</item>
                    <item name="UniformPad" desc="Resizes to fit the outer target size and pads with black around the borders.">UNIFORM_RESIZE_PAD</item>
                    <item name="NonUniform" desc="Resizes to fit without regarding pixel uniformity.">NON_UNIFORM_RESIZE</item>
                </enum>
                <enum name="InterpolationMethod">
                    <item name="nearest" desc="Resample using a nearest-neighbor interpolation">NEAREST</item>
                    <item name="linear" desc="Resample using 2x2 bilinear interpolation">LINEAR</item>
                    <item name="area" desc="Resample area subsampling. The image is split into bins corresponding to the target size. The output is the average within each bin.">AREA</item>
                    <item name="none" desc="Disable an optional resampling step.">NONE</item>
                </enum>
                <enum name="ColorMode" trait="hidden">
                    <item name="BGR" desc="Network expects images ordered with the blue channel first. This is the AppSpace default.">BGR</item>
                    <item name="RGB" desc="Network expects images ordered with the red channel first. This requires channel swapping at the input.">RGB</item>
                </enum>
                <enum name="NetworkType" trait="hidden">
                    <item name="TENSORFLOW" desc="The underlying network implementation is of TensorFlow type.">TENSORFLOW</item>
                    <item name="CAFFE" desc="The underlying network implementation is of Caffe type.">CAFFE</item>
                    <item name="ONNX" desc="The underlying network implementation is of ONNX type.">ONNX</item>
                </enum>
                <serves>
                    <function name="create">
                        <trait>released</trait>
                        <links>MachineLearning.DeepNeuralNetwork.setModel</links>
                        <desc>Creates a new instance of the deep learning inference engine.</desc>
                        <sample for="lua">local dnn = MachineLearning.DeepNeuralNetwork.create()</sample>
                        <return name="dnn" type="handle" alias="MachineLearning.DeepNeuralNetwork" desc="Handle to the new instance."/>
                    </function>
                    <function name="setModel">
                        <trait>released</trait>
                        <links>MachineLearning.DeepNeuralNetwork.Model, MachineLearning.DeepNeuralNetwork.setInputImage</links>
                        <desc>Sets a new Deep Neural Network model.</desc>
                        <sample for="lua">local success = MachineLearning.DeepNeuralNetwork.setModel(dnn, model)</sample>
                        <param name="dnn" type="handle" alias="MachineLearning.DeepNeuralNetwork" desc="Handle to the instance."/>
                        <param name="model" type="const object" alias="MachineLearning.DeepNeuralNetwork.Model" desc="The network model object."/>
                        <return name="success" type="bool" desc="True if the model could be set."/>
                    </function>
                    <function name="getModel">
                        <trait>released</trait>
                        <desc>Returns the currently used Deep Neural Network model.</desc>
                        <sample for="lua">local model = MachineLearning.DeepNeuralNetwork.getModel(dnn)</sample>
                        <param name="dnn" type="handle" alias="MachineLearning.DeepNeuralNetwork" desc="Handle to the instance."/>
                        <return name="model" type="object" alias="MachineLearning.DeepNeuralNetwork.Model" desc="The Deep Neural Network model object."/>
                    </function>
                    <function name="getNodeNames">
                        <trait>hidden</trait>
                        <desc>Get the internal names (strings) of all input and output nodes in the currently used Deep Neural Network model.</desc>
                        <sample for="lua">local nodeNames = MachineLearning.DeepNeuralNetwork.getNodeNames(dnn)</sample>
                        <param name="dnn" type="handle" alias="MachineLearning.DeepNeuralNetwork" desc="Handle to the instance."/>
                        <return name="nodeNames" type="string" multiplicity="+" desc="Names of all nodes in the loaded network."/>
                    </function>
                    <function name="getNodeTypes">
                        <trait>hidden</trait>
                        <desc>List all node types present in currently used Deep Neural Network model.</desc>
                        <sample for="lua">local nodeTypes = MachineLearning.DeepNeuralNetwork.getNodeTypes(dnn)</sample>
                        <param name="dnn" type="handle" alias="MachineLearning.DeepNeuralNetwork" desc="Handle to the instance."/>
                        <return name="nodeTypes" type="string" multiplicity="+" desc="The node types used in the loaded network."/>
                    </function>
                    <function name="setInputResampling">
                        <trait>hidden</trait>
                        <desc>Configure custom subsampling schemes for networks that have a strong dependence on the preprocessing.</desc>
                        <sample for="lua">local success = MachineLearning.DeepNeuralNetwork.setInputResampling(dnn, "AREA", "LINEAR", 2)</sample>
                        <param name="dnn" type="handle" alias="MachineLearning.DeepNeuralNetwork" desc="Handle to the instance."/>
                        <param name="mainMethod" type="enum" multiplicity="?" ref="MachineLearning.DeepNeuralNetwork.InterpolationMethod" desc="Select the interpolation to use for the final resampling step. Default is AREA."/>
                        <param name="prescale" type="bool" multiplicity="?" desc="Select if a fast prescaling should be used for large subsample factors. The downside is potential aliasing artefacts in the image. Default is true."/>
                        <param name="prescaleMethod" type="enum" multiplicity="?" ref="MachineLearning.DeepNeuralNetwork.InterpolationMethod" desc="Select the interpolation method for optional prescaling. Default is NEAREST."/>
                        <param name="prescaleFactor" type="int" multiplicity="?" desc="Select what size to prescale the image to. This is a dynamic factor. Setting 2 means that the prescaled image width and height is at least 2 times the network input size. DEFAULT is 2."/>
                        <return name="success" type="bool" desc="True if resampling options could be updated."/>
                    </function>
                    <function name="setInputImage">
                        <trait>released</trait>
                        <links>MachineLearning.DeepNeuralNetwork.Model.getInputNodeNames, MachineLearning.DeepNeuralNetwork.setModel, MachineLearning.DeepNeuralNetwork.getInputImageNormalized</links>
                        <desc>Update an input image node with a new image. The image is automatically rescaled and adjusted to fit the node in the network.
Depending on the mode the image is either first rescaled and then cropped or anisotropically scaled to fit the node dimensions.
After this process the image is converted to the input type and the node mean is subtracted and value scaling is applied. Both mean and scaling is defined for the input node in the network model.
The input image must have the same number of channels (grayscale, RGB) as the network node, otherwise the operation will fail. For example, a grayscale image can only be used as input to a single channel node.</desc>
                        <sample for="lua">local success = MachineLearning.DeepNeuralNetwork.setInputImage(dnn, image)</sample>
                        <param name="dnn" type="handle" alias="MachineLearning.DeepNeuralNetwork" desc="Handle to the instance."/>
                        <param name="image" type="const object" alias="Image" desc="Input image to be processed."/>
                        <param name="nodeName" type="string" multiplicity="?" desc="The name (string) of the node in the network to set the input for. If unset the first available node is used."/>
                        <return name="success" type="bool" desc="True if the image was correctly set."/>
                    </function>
                    <function name="getInputImageNormalized">
                        <trait>released</trait>
                        <links>MachineLearning.DeepNeuralNetwork.setInputImage</links>
                        <desc>Get the input image from a node in a network. This image is the result after all pre-processing operations within the setInputImage and represents the actual data fed to the network.</desc>
                        <sample for="lua">local image = MachineLearning.DeepNeuralNetwork.getInputImageNormalized(dnn, nodeName)</sample>
                        <param name="dnn" type="handle" alias="MachineLearning.DeepNeuralNetwork" desc="Handle to the instance."/>
                        <param name="nodeName" type="string" multiplicity="?" desc="The name of the node in the network to set the input for. If unset the first available node is used as default."/>
                        <return name="image" type="object" multiplicity="[?*]" alias="Image" desc="Input image for network. Either a single image for grayscale input or a list of images. Nil on failure."/>
                    </function>
                    <function name="predict">
                        <trait>released</trait>
                        <links>MachineLearning.DeepNeuralNetwork.setInputImage, MachineLearning.DeepNeuralNetwork.Result, MachineLearning.DeepNeuralNetwork.Model.getOutputNodeNames,MachineLearning.DeepNeuralNetwork.getLicenseLevel</links>
                        <desc>Execute the Deep Neural Network using the set input image(s). The result is obtained as a MachineLearning.DeepNeuralNetwork.Result object from which the output of the network can be retrieved in various formats.

For neural network architectures with several output heads/nodes, it is possible to specify the node names for which to calculate the output.

License restrictions may apply. See the crown documentation or the MachineLearning.DeepNeuralNetwork.getLicenseLevel functions to determine your license.</desc>
                        <sample for="lua">local dnnres = MachineLearning.DeepNeuralNetwork.predict(dnn, node)</sample>
                        <param name="dnn" type="handle" alias="MachineLearning.DeepNeuralNetwork" desc="Handle to the instance."/>
                        <param name="node" type="string" multiplicity="[?*]" desc="The name(s) (string) of the node at which to compute the result for networks with several output nodes. Default is to use the last output node."/>
                        <return name="dnnres" type="object" multiplicity="[?*]" alias="MachineLearning.DeepNeuralNetwork.Result" desc="The result of the execution or nil on failure."/>
                    </function>
                    <function name="getLicenseLevel">
                        <trait>released</trait>
                        <links>MachineLearning.DeepNeuralNetwork.predict</links>
                        <desc>Check the license currently available in the device. For details about the license levels see the top level crown description or the enum descriptions.</desc>
                        <sample for="lua">local licenseLevel = MachineLearning.DeepNeuralNetwork.getLicenseLevel(dnn)</sample>
                        <param name="dnn" type="handle" alias="MachineLearning.DeepNeuralNetwork" desc="Handle to the instance."/>
                        <return name="licenseLevel" type="enum" ref="MachineLearning.DeepNeuralNetwork.LicenseLevel" desc="The license level."/>
                    </function>
                    <function name="getRemainingRuns">
                        <trait>deprecated</trait>
                        <links>MachineLearning.DeepNeuralNetwork.predict</links>
                        <desc>This function is deprecated, please use getRemainingTrialTime instead.</desc>
                        <sample for="lua">local remainingRuns = MachineLearning.DeepNeuralNetwork.getRemainingRuns(dnn)</sample>
                        <param name="dnn" type="handle" alias="MachineLearning.DeepNeuralNetwork" desc="Handle to the instance."/>
                        <return name="remainingRuns" type="int" multiplicity="?" desc="The number of runs remaining. If there's no limitation nil is returned."/>
                    </function>
                    <function name="getRemainingTrialTime">
                        <trait>released</trait>
                        <links>MachineLearning.DeepNeuralNetwork.predict</links>
                        <desc>For trial networks this function can be used to check the remaining number of seconds the network can be used.
For devices without the appropriate licenses the value returned will be zero.
For devices with appropriate licenses and networks without a run limitation nil will be returned.</desc>
                        <sample for="lua">local remainingSeconds = MachineLearning.DeepNeuralNetwork.getRemainingTrialTime(dnn)</sample>
                        <param name="dnn" type="handle" alias="MachineLearning.DeepNeuralNetwork" desc="Handle to the instance."/>
                        <return name="remainingSeconds" type="int" multiplicity="?" desc="The number of seconds remaining. If there's no limitation nil is returned."/>
                    </function>
                    <function name="toString">
                        <trait>released</trait>
                        <desc>Textual description of the inference engine instance.</desc>
                        <sample for="lua">local desc = MachineLearning.DeepNeuralNetwork.toString(dnn)</sample>
                        <param name="dnn" type="handle" alias="MachineLearning.DeepNeuralNetwork" desc="Handle to the instance."/>
                        <return name="desc" type="string" desc="The textual description."/>
                    </function>
                </serves>
                <crown name="Model">
                    <trait>released</trait>
                    <links>Object.load</links>
                    <desc>An object to represent a trained Deep Neural Network model. The model can only be created by loading a JSON file from disk using the Object.load function, i.e, call the following to instantiate a model:
model = Object.load(modelFileName)

Deep Neural Networks are created using dedicated SICK software for the purpose. Once a model has been loaded properties of the network can be obtained using various get-functions, e.g., what the loaded network expects as input and what it gives as output, string names of labels using during training of the network, etc.</desc>
                    <serves>
                        <function name="create">
                            <trait>hidden</trait>
                            <desc>Creates a new instance of a deep learning model. Note that this function is hidden as the only way to populate the model is to load a configuration file from disk, an empty network model has no use.</desc>
                            <sample for="lua">local model = MachineLearning.DeepNeuralNetwork.Model.create()</sample>
                            <return name="model" type="object" alias="MachineLearning.DeepNeuralNetwork.Model" desc="The created model"/>
                        </function>
                        <function name="getNetworkName">
                            <trait>released</trait>
                            <desc>Return the name of network.</desc>
                            <sample for="lua">local name = MachineLearning.DeepNeuralNetwork.Model.getNetworkName(model)</sample>
                            <param name="model" type="const object" alias="MachineLearning.DeepNeuralNetwork.Model" desc="Handle to the instance."/>
                            <return name="name" type="string" desc="Name of the network model instance."/>
                        </function>
                        <function name="getInputNodeNames">
                            <trait>released</trait>
                            <links>MachineLearning.DeepNeuralNetwork.Model.getInputNodeSize, MachineLearning.DeepNeuralNetwork.Model.getOutputNodeNames</links>
                            <desc>Return the names of all input nodes that must be set before a prediction using the network can be made.</desc>
                            <sample for="lua">local nodes = MachineLearning.DeepNeuralNetwork.Model.getInputNodeNames(model)</sample>
                            <param name="model" type="const object" alias="MachineLearning.DeepNeuralNetwork.Model" desc="Handle to the instance."/>
                            <return name="nodes" type="string" multiplicity="+" desc="Names of nodes that have unconnected inputs in the loaded network."/>
                        </function>
                        <function name="getInputNodeSize">
                            <trait>released</trait>
                            <links>MachineLearning.DeepNeuralNetwork.Model.getInputNodeNames</links>
                            <desc>Return the dimension sizes of a given input node.</desc>
                            <sample for="lua">local sizes = MachineLearning.DeepNeuralNetwork.Model.getInputNodeSize(model)</sample>
                            <param name="model" type="const object" alias="MachineLearning.DeepNeuralNetwork.Model" desc="Handle to the instance."/>
                            <param name="nodeName" type="string" multiplicity="?" desc="Optionally specify the node name. If not provided the first input node in the network model is used."/>
                            <return name="sizes" type="int" multiplicity="*" desc="The sizes of the input node. Normally a vector of 4 integer values consisting of height, width, channels."/>
                        </function>
                        <function name="getOutputNodeNames">
                            <trait>released</trait>
                            <links>MachineLearning.DeepNeuralNetwork.Model.getInputNodeNames, MachineLearning.DeepNeuralNetwork.Model.getOutputNodeType, MachineLearning.DeepNeuralNetwork.Model.getOutputNodeLabels</links>
                            <desc>Returns the names of all output nodes that can be retrieved as result outputs after a prediction.</desc>
                            <sample for="lua">local nodeNames = MachineLearning.DeepNeuralNetwork.Model.getOutputNodeNames(model)</sample>
                            <param name="model" type="const object" alias="MachineLearning.DeepNeuralNetwork.Model" desc="Handle to the instance."/>
                            <return name="nodeNames" type="string" multiplicity="+" desc="Names of all nodes that have unconnected outputs in the loaded network."/>
                        </function>
                        <function name="getOutputNodeType">
                            <trait>released</trait>
                            <links>MachineLearning.DeepNeuralNetwork.Model.getOutputNodeNames, MachineLearning.DeepNeuralNetwork.Model.getOutputNodeLabels, MachineLearning.DeepNeuralNetwork.Result.getType</links>
                            <desc>Returns the type of an output node. This type is decided at training time and stored in the model file.
Networks can contain a single or several outputs and can therefore be either pure classification, segmentation or detection networks or mixed versions of these. A network can for example provide multiple results such as material and shape in an object classification example by using two classification outputs.
The returned string is generated at training time and can for example be CLASSIFICATION_OUTPUT or SEGMENTATION_OUTPUT.</desc>
                            <sample for="lua">local nodeType = MachineLearning.DeepNeuralNetwork.Model.getOutputNodeType(model)</sample>
                            <param name="model" type="const object" alias="MachineLearning.DeepNeuralNetwork.Model" desc="Handle to the instance."/>
                            <param name="nodeType" type="string" multiplicity="?" desc="Optionally specify the node name. If not provided the first output node is used."/>
                            <return name="type" type="string" multiplicity="?" desc="The type string. Nil if the node cannot be found."/>
                        </function>
                        <function name="setColorMode">
                            <trait>hidden</trait>
                            <desc>Update the input color channel order. This should typically only be done for imported networks.</desc>
                            <sample for="lua">local success = MachineLearning.DeepNeuralNetwork.Model.setColorMode(model, mode)</sample>
                            <param name="model" type="object" alias="MachineLearning.DeepNeuralNetwork.Model" desc="Handle to the instance."/>
                            <param name="mode" type="enum" ref="MachineLearning.DeepNeuralNetwork.ColorMode" desc="The color order of the inputs to the network."/>
                            <return name="success" type="bool" desc="True if operation succeeded."/>
                        </function>
                        <function name="setInputNodeCropMode">
                            <trait>hidden</trait>
                            <desc>Update the way images are pre-processed at an input node in terms of resizing and cropping.</desc>
                            <sample for="lua">local success = MachineLearning.DeepNeuralNetwork.setInputNodeCropMode(model, mode)</sample>
                            <param name="model" type="object" alias="MachineLearning.DeepNeuralNetwork.Model" desc="Handle to the instance."/>
                            <param name="mode" type="enum" ref="CropMode" desc="Select how to resize the input images to fit the network."/>
                            <param name="node" type="string" multiplicity="?" desc="The name of the node in the network to set the input for. If unset the first available node is used."/>
                            <return name="success" type="bool" desc="True if operation succeeded."/>
                        </function>
                        <function name="setInputNodeNormalization">
                            <trait>hidden</trait>
                            <desc>Update the value range normalization for a given input node.</desc>
                            <sample for="lua">local success = MachineLearning.DeepNeuralNetwork.Model.setInputNodeNormalization(model, scaling, mean)</sample>
                            <param name="model" type="object" alias="MachineLearning.DeepNeuralNetwork.Model" desc="Handle to the instance."/>
                            <param name="scaling" type="float" multiplicity="?" desc="Optional value scaling of input. Defaults to 1.0 if unset."/>
                            <param name="mean" type="float" multiplicity="[?*]" desc="Optional value offset for the input. Can be either 1 or 3 values for up to 3 color channels. Defaults to 0.0 if unset."/>
                            <param name="node" type="string" multiplicity="?" desc="Optionally specify the node. If unset the first available node is used."/>
                            <return name="success" type="bool" desc="True if operation succeeded."/>
                        </function>
                        <function name="setInputNodeImageType">
                            <trait>hidden</trait>
                            <desc>Update the image type for a given input node.</desc>
                            <sample for="lua">local success = MachineLearning.DeepNeuralNetwork.Model.setInputNodeImageType(model, scaling, mean)</sample>
                            <param name="model" type="object" alias="MachineLearning.DeepNeuralNetwork.Model" desc="Handle to the instance."/>
                            <param name="type" type="enum" ref="Image.ImageType" desc="Choose a new type for the input node."/>
                            <param name="node" type="string" multiplicity="?" desc="Optionally specify the node. If unset the first available node is used."/>
                            <return name="success" type="bool" desc="True if operation succeeded."/>
                        </function>
                        <function name="setOutputNodeLabels">
                            <trait>released</trait>
                            <links>MachineLearning.DeepNeuralNetwork.Model.getOutputNodeLabels</links>
                            <desc>Update the label strings for an output node.</desc>
                            <sample for="lua">local success = MachineLearning.DeepNeuralNetwork.setOutputNodeLabels(model, labels, nodeName)</sample>
                            <param name="model" type="object" alias="MachineLearning.DeepNeuralNetwork.Model" desc="Handle to the instance."/>
                            <param name="labels" type="string" multiplicity="+" desc="The labels to assosciate with the output node."/>
                            <param name="nodeName" type="string" multiplicity="?" desc="Optionally specify the output node name. Default is the first available output node used."/>
                            <return name="success" type="bool" desc="True if operation succeeded."/>
                        </function>
                        <function name="getOutputNodeLabels">
                            <trait>released</trait>
                            <links>MachineLearning.DeepNeuralNetwork.Model.getOutputNodeNames, MachineLearning.DeepNeuralNetwork.Model.setOutputNodeLabels</links>
                            <desc>Returns all label strings for an output node. The labels are typically class names that were given at the training stage of the Deep Neural Network.</desc>
                            <sample for="lua">local labels = MachineLearning.DeepNeuralNetwork.getOutputNodeLabels(model, nodeName)</sample>
                            <param name="model" type="const object" alias="MachineLearning.DeepNeuralNetwork.Model" desc="Handle to the instance."/>
                            <param name="nodeName" type="string" multiplicity="?" desc="Optionally specify the output node name. If not provided the labels of the first node are returned."/>
                            <return name="labels" type="string" multiplicity="*" desc="The label strings to assosciate with the output node. Nil on failure."/>
                        </function>
                        <function name="getNumberOfRuns">
                            <trait>deprecated</trait>
                            <desc>This function is deprecated, please use getNetworkTimeLimit instead.</desc>
                            <sample for="lua">local numberOfRuns = MachineLearning.DeepNeuralNetwork.getNumberOfRuns(model)</sample>
                            <param name="model" type="const object" alias="MachineLearning.DeepNeuralNetwork.Model" desc="Handle to the instance."/>
                            <return name="numberOfRuns" type="int" desc="The number of runs for the loaded model. Zero means unlimited inference is allowed."/>
                        </function>
                        <function name="getNetworkTimeLimit">
                            <trait>released</trait>
                            <desc>Get the total number of seconds a trial network can be used. For unlimited networks the returned value will be zero.
Note that the device itself might override this and set it to a higher value.</desc>
                            <sample for="lua">local numberOfSeconds = MachineLearning.DeepNeuralNetwork.getNetworkTimeLimit(model)</sample>
                            <param name="model" type="const object" alias="MachineLearning.DeepNeuralNetwork.Model" desc="Handle to the instance."/>
                            <return name="numberOfSeconds" type="int" desc="The number of seconds for the loaded model. Zero means unlimited inference is allowed."/>
                        </function>
                        <function name="isUnlimited">
                            <trait>released</trait>
                            <desc>Check if the network model is a trial network with a limitation on the amount of forward predictions or unlimited.</desc>
                            <sample for="lua">local unlimited = MachineLearning.DeepNeuralNetwork.Model.isUnlimited(model)</sample>
                            <param name="model" type="const object" alias="MachineLearning.DeepNeuralNetwork.Model" desc="The model object to get the property for."/>
                            <return name="unlimited" type="bool" desc="True if the network is unlimited."/>
                        </function>
                        <function name="isEncrypted">
                            <trait>hidden</trait>
                            <desc>Check if a network is encrypted or not.</desc>
                            <sample for="lua">local encrypted = MachineLearning.DeepNeuralNetwork.Model.isEncrypted(model)</sample>
                            <param name="model" type="const object" alias="MachineLearning.DeepNeuralNetwork.Model" desc="The model object to get the property for."/>
                            <return name="encrypted" type="bool" desc="True if the network is encrypted."/>
                        </function>
                        <function name="getFileVersion">
                            <trait>hidden</trait>
                            <desc>Get a version number of the Deep Neural Network model.</desc>
                            <sample for="lua">local version = MachineLearning.DeepNeuralNetwork.Model.getFileVersion(model)</sample>
                            <param name="model" type="const object" alias="MachineLearning.DeepNeuralNetwork.Model" desc="The model object to get the version for."/>
                            <return name="version" type="string" desc="The version string."/>
                        </function>
                        <function name="toString">
                            <trait>released</trait>
                            <desc>Get a textual description of the Deep Neural Network model.</desc>
                            <sample for="lua">local str = MachineLearning.DeepNeuralNetwork.Model.toString(model)</sample>
                            <param name="model" type="const object" alias="MachineLearning.DeepNeuralNetwork.Model" desc="The model object to get the string for."/>
                            <return name="str" type="string" desc="The string representation."/>
                        </function>
                    </serves>
                </crown>
                <crown name="Result">
                    <trait>released</trait>
                    <links>MachineLearning.DeepNeuralNetwork.predict</links>
                    <desc>Result object representing the output of a Deep Neural Network execution. This object is obtained by the MachineLearning.DeepNeuralNetwork.predict() function.

Via this object the Deep Neural Network predict result can be obtained in various ways depending on the network architecture, e.g., it is possible to retrieve the output in raw matrix format, as classification label, formatted as an image heat map, as bounding box rectangles, etc.</desc>
                    <serves>
                        <function name="getAsMatrix">
                            <trait>released</trait>
                            <links>MachineLearning.DeepNeuralNetwork.Result.getSize,
              MachineLearning.DeepNeuralNetwork.Result.getAsImage, MachineLearning.DeepNeuralNetwork.Result.getAsClassification</links>
                            <desc>Returns the result as 2D Matrix object with float values. This is the raw form of the output.
If the intrinsic network output has higher dimension than 2, the output will be reshaped to fit into a 2D matrix. It is possible to specify the dimension to use as the height of the output matrix or automatically use the first dimension with a size larger than 1.

Get the intrinsic network output size with the getSize() function.

Example:
The Deep Neural Network architecture internally gives an output with dimensions 1x4x5x2. The output of the getAsMatrix are the following sizes for different values of the heightDim parameter
heightDim default: 4x10 (height becomes 4 as it is the first dimension larger than 1)
heightDim = 0: 1x40
heightDim = 1: 4x10
heightDim = 2: 5x8
heightDim = 3: 2x20</desc>
                            <sample for="lua">local matrix = MachineLearning.DeepNeuralNetwork.Result.getAsMatrix(dnnres)</sample>
                            <param name="dnnres" type="const object" alias="MachineLearning.DeepNeuralNetwork.Result" desc="The inference result object."/>
                            <param name="heightDim" type="int" multiplicity="?" desc="The dimension (0-based indexing) of the raw data to use as height in the output matrix. Default is to use the first dimension with a size larger than 1."/>
                            <return name="matrix" type="object" multiplicity="?" alias="Matrix" desc="The result matrix. Nil on failure."/>
                        </function>
                        <function name="getAsImage">
                            <trait>released</trait>
                            <links>MachineLearning.DeepNeuralNetwork.Result.getSize, MachineLearning.DeepNeuralNetwork.Result.getAsMatrix, MachineLearning.DeepNeuralNetwork.Result.getAsClassification</links>
                            <desc>Returns the result as a 2D Image of type FLOAT32.
This function interprets the Deep Neural Network result as an array of values and populates this array into Image objects. This is typically used if the network output should be interpreted as heatmaps or autoencoder reconstruction images of known size.

It is recommended to specify the width and height of the output image as input parameters for error control. If not specified the function will fall back on an automatic selection.

It is possible to format the Deep Neural Network into several output Images. In this case the getAsImage must be called several times with the index parameter set differently each time, i.e. index = 0 for the first image to retrieve, index = 1 for the second etc.
If index is 0 or unset the first width*height values in the internal network output array are returned. If index is 1 the next width*height values directly after are returned.

If a too large image is specified, or an index causes the function to reach outside of the data available in the result object, a nil image is returned.</desc>
                            <sample for="lua">local image = MachineLearning.DeepNeuralNetwork.Result.getAsImage(dnnres, width, height)</sample>
                            <param name="dnnres" type="const object" alias="MachineLearning.DeepNeuralNetwork.Result" desc="The inference result object."/>
                            <param name="width" type="int" multiplicity="?" desc="Output image width in pixels. Automatic selection is attempted if unset. Defaults to the first of the two largest dimension values returned by getSize."/>
                            <param name="height" type="int" multiplicity="?" desc="Output image height in pixels. Automatic selection is attempted if unset. Defaults to the second of the two largest dimension values returned by getSize."/>
                            <param name="index" type="int" multiplicity="?" desc="Select which image index (0-based) to extract, determining the indexing into the internal result array. This is only relevant in the case that several output images are to be retrieved. See main description for details. Defaults to zero."/>
                            <return name="image" type="object" multiplicity="?" alias="Image" desc="The result image. Nil on failure."/>
                        </function>
                        <function name="getAsClassification">
                            <trait>released</trait>
                            <links>MachineLearning.DeepNeuralNetwork.Result.getSize, MachineLearning.DeepNeuralNetwork.Result.getAsMatrix, MachineLearning.DeepNeuralNetwork.Result.getLabel</links>
                            <desc>Interprets the Deep Neural Network result of a classification task with the output encoded as a one-hot vector. That is, the output of the Deep Neural Network is a vector with length equal to a number of classes. The most likely class predicted by the network is the one with highest output value.

This function returns most likely classification as an integer index into the output vector, the output score in the vector and label string for the class as given during network training.

In most classification tasks one is interested in the most likely class, but it is possible to retrieve the N most likely classes by setting the topN parameter.

There is a boolean parameter softmax which indicates that if the output scores are to normalized so the total score sum for all classes equals 1.0, i.e., in this cases all scores will be in the range [0.0, 1.0]. Sometimes this operation is already built into the network architecture.</desc>
                            <sample for="lua">local index, score = MachineLearning.DeepNeuralNetwork.Result.getAsClassification(dnnres)</sample>
                            <param name="dnnres" type="const object" alias="MachineLearning.DeepNeuralNetwork.Result" desc="The inference result object."/>
                            <param name="topN" type="int" multiplicity="?" desc="Select how many classes to return. Always returns the N best classes. Default is 1."/>
                            <param name="softmax" type="bool" multiplicity="?" desc="Select if the score value should be normalized to the interval [0.0, 1.0] using a softmax calculation. Default is false."/>
                            <return name="index" type="int" multiplicity="[1+]" desc="The index into the one-hot vector encoding, i.e., class index. 0-based indexing. This is a vector if topN is larger than 1."/>
                            <return name="score" type="float" multiplicity="[1+]" desc="The score values. This is a vector if topN is larger than 1."/>
                            <return name="label" type="string" multiplicity="[?*]" desc="The label string. This may not be available for all networks. This is a vector if topN is larger than 1."/>
                        </function>
                        <function name="getAsRectangles">
                            <trait>hidden</trait>
                            <desc>Interprets the result as an object detection output and returns bounding boxes.
This function only supports networks that follow a typical detection network scheme. For other networks the result might have to be manually parsed by using MachineLearning.DeepNeuralNetwork.Result.getAsMatrix.
Detection networks in general produce detections in normalized image coordinates. This means that the bounding boxes provided will have coordinates between 0 and 1 for both the x and y dimension.
Some networks produce two corners, others produce a center point together with width and height.
The default behavior of this function is to interpret the network result as center point together with width and height. To use a network with corner points, set the optional input corners to true.</desc>
                            <sample for="lua">local boxes, index, score, labels = MachineLearning.DeepNeuralNetwork.Result.getAsRectangles(dnnres)</sample>
                            <param name="dnnres" type="const object" alias="MachineLearning.DeepNeuralNetwork.Result" desc="The inference result object."/>
                            <param name="minScore" type="float" multiplicity="?" desc="Ignore results with a score lower than this value. Default is to keep all results of the network."/>
                            <param name="corners" type="bool" multiplicity="?" desc="Set if the network returns two corner points instead of center, width, height. Default is false."/>
                            <return name="boxes" type="object" multiplicity="*" alias="Shape" desc="Bounding boxes for the detections. Nil on failure."/>
                            <return name="index" type="int" multiplicity="*" desc="The index of the most likely class. Nil on failure."/>
                            <return name="score" type="float" multiplicity="*" desc="The score of this detection. Nil on failure."/>
                            <return name="label" type="string" multiplicity="*" desc="The label corresponding to the class. This is not available for all networks."/>
                        </function>
                        <function name="getLabel">
                            <trait>released</trait>
                            <desc>Returns a label string for a particular class of the result object. Labels are not available for all networks and for those networks this function always return nil.</desc>
                            <sample for="lua">local index, score = MachineLearning.DeepNeuralNetwork.Result.getLabel(dnnres, index)</sample>
                            <param name="dnnres" type="const object" alias="MachineLearning.DeepNeuralNetwork.Result" desc="The inference result object."/>
                            <param name="index" type="int" desc="The zero-based class index."/>
                            <return name="label" type="string" multiplicity="?" desc="The label corresponding to the class. If unavailable nil is returned."/>
                        </function>
                        <function name="getType">
                            <trait>released</trait>
                            <links>MachineLearning.DeepNeuralNetwork.Result.getSize, MachineLearning.DeepNeuralNetwork.getOutputNodeType</links>
                            <desc>Returns the type of a result object. This type is decided at training time and stored in the model file.
Networks can contain a single or several outputs and can therefore be either pure classification, segmentation or detection networks or mixed versions of these. A network can for example provide multiple results such as material and shape in an object classification example by using two classification outputs.
The returned string is generated at training time and can for example be CLASSIFICATION_OUTPUT or SEGMENTATION_OUTPUT.</desc>
                            <sample for="lua">local type = MachineLearning.DeepNeuralNetwork.Result.getType(dnnres)</sample>
                            <param name="dnnres" type="const object" alias="MachineLearning.DeepNeuralNetwork.Result" desc="The inference result object."/>
                            <return name="type" type="string" desc="The type of result."/>
                        </function>
                        <function name="getSize">
                            <trait>released</trait>
                            <links>MachineLearning.DeepNeuralNetwork.Result.getAsMatrix,
              MachineLearning.DeepNeuralNetwork.Result.getAsImage, MachineLearning.DeepNeuralNetwork.Result.getAsClassification</links>
                            <desc>Retrieve the size of the internal Deep Neural Network output. The output can be up to 4-dimensional with various size along each dimension.</desc>
                            <sample for="lua">local size = MachineLearning.DeepNeuralNetwork.Result.getSize(dnnres)</sample>
                            <param name="dnnres" type="const object" alias="MachineLearning.DeepNeuralNetwork.Result" desc="The inference result object."/>
                            <return name="size" type="int" multiplicity="+" desc="A vector of integer values representing size in each output dimension."/>
                        </function>
                        <function name="toString">
                            <trait>released</trait>
                            <desc>Textual description of the result object.</desc>
                            <sample for="lua">local desc = MachineLearning.DeepNeuralNetwork.Result.toString(dnnres)</sample>
                            <param name="dnnres" type="const object" alias="MachineLearning.DeepNeuralNetwork.Result" desc="The inference result object."/>
                            <return name="desc" type="string" desc="The textual description."/>
                        </function>
                    </serves>
                </crown>
            </crown>
        </crown>
        <crown name="Statistics">
            <trait>released</trait>
            <links>Profile</links>
            <desc>Functions for computing statistics of 1D numeric arrays, signals, time series, histograms etc. For example mean, standard deviation, correlation, comparing histograms. More functions for 1D data analysis is under the Profile API.</desc>
            <enum name="HistogramCompareMethod" trait="released">
                <item name="L1 norm" desc="Sum of absolute differences">L1</item>
                <item name="L2 norm" desc="Euclidean norm, square root of sum of square differences">L2</item>
                <item name="Maximal difference" desc="Maximal difference between corresponding bins (L-infinity norm)">MAXDIFF</item>
                <item name="Chi-square statistic" desc="Chi-square statistic (normalized sum of squares). This is the default method and should work well in most cases.">CHI2</item>
                <item name="Kullback-Leibler divergence" desc="Kullback-Leibler divergence: sum(p[i] * log(p[i] / q[i])">KLDIV</item>
            </enum>
            <serves>
                <function name="compareHistograms">
                    <desc>Compare two histograms of equal size. If the histograms are obtained from regions of different sizes, they should be normalized first.</desc>
                    <sample for="lua">distance = Statistics.compareHistograms(histogram1, histogram2)</sample>
                    <param name="histogram1" type="float" multiplicity="+" desc="First histogram to compare"/>
                    <param name="histogram2" type="float" multiplicity="+" desc="Second histogram to compare"/>
                    <param name="method" type="enum" multiplicity="?" ref="HistogramCompareMethod" desc="Comparison method (default is Chi-squared statistic)"/>
                    <return name="distance" type="float" multiplicity="?" desc="Distance measure of the two histograms. Zero if they are equal and larger the more different the histograms are."/>
                </function>
                <function name="normalizeHistogram">
                    <desc>Normalize a histogram. If no bin centers are specified, the histogram is normalized such that the sum of all values is 1. If centers is specified, it is instead normalized such that the integral over the value domain is 1.</desc>
                    <sample for="lua">outputHistogram = Statistics.normalizeHistogram(inputHistogram)</sample>
                    <param name="inputHistogram" type="float" multiplicity="+" desc="Input histogram"/>
                    <param name="centers" type="float" multiplicity="*" desc="Optional bin centers. Must be equally spaced. Typically, the bin centers are returned from the method that produced the histogram in the first place."/>
                    <return name="outputHistogram" type="float" multiplicity="+" desc="Output histogram, normalized to unit sum"/>
                </function>
            </serves>
        </crown>
        <crown name="Modbus">
            <trait>released</trait>
            <desc>Provides Modbus TCP server functionality</desc>
            <enum name="RegisterType">
                <item name="InputRegister" desc="Modbus input register (read only for client)">INPUT</item>
                <item name="HoldingRegister" desc="Modbus holding register (read and write for client)">HOLDING</item>
            </enum>
            <crown name="Server">
                <trait>released</trait>
                <desc>Provides Modbus TCP server functionality.

Protocol Overview:
Modbus TCP is an application layer messaging protocol, positioned at level 7 of the OSI model, which provides client/server communication
between devices connected on different types of buses or networks. It is a request/reply protocol and offers services specified by function codes.
Modbus Servers are typically accessible over TCP port 502.

The protocol was invented by Gould Modicon (now a division of Schneider Electric), and is now administered by modbus.org.
Modbus TCP is standardized within IEC 61784-2 (CPF 15/1). For a detailed description of the
protocol and its memory organization please refer to reference document 1 below.

Usage note:
Be sure to use Slave ID 0 or 255 on the client! This is needed to talk directly to Modbus/TCP servers which are not a gateway. Otherwise, the requests by the client will be silently dropped.

API Overview:
This API implements all the functions that are required to realize a Modbus TCP server. It is possible to add/remove variables
of a given length and make them accessible as input or holding registers in Modbus TCP. It also provides an event that signals when variables
are changed by a Modbus client.
The provided functions can be categorized into three groups:
1. Server management: create, setInterface, setPort, start, stop
2. Mapping of variables to Modbus registers: addVariable, removeVariable, getMapping
3. Accessing values: writeVariable, readVariable, register

Supported function codes:
03   Read holding register(s)
04   Read input register(s)
06   Write single holding register
16   Write multiple holding registers

Supported error codes:
0   No error
1   Illegal function (Requested function code is not supported)
2   Illegal data address (There is no variable at the given address or out of range)
3   Illegal data value (The given length is not compatible to the requested variable)
4   Server device failure (An unrecoverable error occurred while the server was attempting to perform the requested action)

Reference Documents:
1. MODBUS Protocol Specification, Version 1.1b3, 2012, http://www.modbus.org/docs/Modbus_Application_Protocol_V1_1b3.pdf
2. MODBUS TCP Implementation Guide, Version 1.0b, 2006, http://www.modbus.org/docs/Modbus_Messaging_Implementation_Guide_V1_0b.pdf</desc>
                <serves>
                    <event name="OnWriteByClient">
                        <desc>This event is thrown when the value(s) of one or more variables have been written by the client, regardless if the value changed or not.</desc>
                        <param name="handle" type="handle" alias="Modbus.Server" desc="The Modbus server handle"/>
                        <param name="name" type="string" multiplicity="+" desc="The name of the variable"/>
                        <param name="value" type="binary" multiplicity="+" desc="The new value of the variable"/>
                    </event>
                    <function name="create">
                        <desc>Creates a new Modbus server.</desc>
                        <sample for="lua">busHandle = Modbus.Server.create()</sample>
                        <return name="handle" type="handle" alias="Modbus.Server" desc="The new Modbus server"/>
                    </function>
                    <function name="setInterface">
                        <desc>Sets the interface on which the server should listen.
This is optional. The default is to listen on all interfaces.</desc>
                        <sample for="lua">Modbus.Server.setInterface(busHandle, "ETH1")</sample>
                        <param name="handle" type="handle" alias="Modbus.Server" desc="The Modbus server handle"/>
                        <param name="ifName" type="enum" ref="EthernetInterfaces" desc="One of the available interfaces"/>
                    </function>
                    <function name="setPort">
                        <desc>Sets a port.</desc>
                        <sample for="lua">success = Modbus.Server.setPort(busHandle, 502)</sample>
                        <param name="handle" type="handle" alias="Modbus.Server" desc="The Modbus server handle"/>
                        <param name="port" type="int" desc="The port number between 1 and 65535. If this function is not called, the default value 502 will be used."/>
                    </function>
                    <function name="start">
                        <desc>Starts the Modbus server.</desc>
                        <sample for="lua">success = Modbus.Server.start(busHandle)</sample>
                        <param name="handle" type="handle" alias="Modbus.Server" desc="The Modbus server handle"/>
                        <return name="success" type="bool" desc="True if the server has been started successfully"/>
                    </function>
                    <function name="stop">
                        <desc>Stops the Modbus server.</desc>
                        <sample for="lua">success = Modbus.Server.stop(busHandle)</sample>
                        <param name="handle" type="handle" alias="Modbus.Server" desc="The Modbus server handle"/>
                        <return name="success" type="bool" desc="True if stopping was successful"/>
                    </function>
                    <function name="addVariable">
                        <desc>Adds a new variable to the Modbus server.
If the variable has length 1, a leading 0-byte will be added to store it in a 16-bit register.
If the length is odd and greater than 1, a trailing 0-byte will be added when the variable is stored in a sequence of 16-bit registers.</desc>
                        <sample for="lua">success = Modbus.Server.addVariable(busHandle, name, length, registerType, startAddress, value)</sample>
                        <param name="handle" type="handle" alias="Modbus.Server" desc="The Modbus server handle"/>
                        <param name="name" type="string" desc="The unique name of the new variable"/>
                        <param name="length" type="int" desc="The number of bytes"/>
                        <param name="registerType" type="enum" ref="RegisterType" desc="The type of Modbus register to use"/>
                        <param name="startAddress" type="int" multiplicity="?" desc="The start address, i. e. address of first Modbus register. Optional: If not specified, the first free address range that is large enough to hold the variable is used."/>
                        <param name="value" type="binary" multiplicity="?" desc="The initial value (optional)"/>
                        <return name="success" type="bool" desc="True if adding the variable was successful"/>
                    </function>
                    <function name="removeVariable">
                        <desc>Removes a variable from the Modbus server.</desc>
                        <sample for="lua">success = Modbus.Server.removeVariable(busHandle, name)</sample>
                        <param name="handle" type="handle" alias="Modbus.Server" desc="The Modbus server handle"/>
                        <param name="name" type="string" desc="The name of the variable"/>
                        <return name="success" type="bool" desc="True if removal was successful"/>
                    </function>
                    <function name="getMapping">
                        <desc>Gets the mapping of the variables from the Modbus server. If no variable is mapped, the function returns vectors of length 0.</desc>
                        <sample for="lua">(name, registerType, startAddress, nRegs) = Modbus.Server.getMapping(busHandle)</sample>
                        <param name="handle" type="handle" alias="Modbus.Server" desc="The Modbus server handle"/>
                        <return name="name" type="string" multiplicity="*" desc="The name of the variable"/>
                        <return name="registerType" type="enum" multiplicity="*" ref="RegisterType" desc="The type of the Modbus register"/>
                        <return name="startAddress" type="int" multiplicity="*" desc="The start address (address of first Modbus register)"/>
                        <return name="nRegs" type="int" multiplicity="*" desc="The number of 16-bit registers used for storing the variable"/>
                    </function>
                    <function name="writeVariable">
                        <desc>Sets the value of a variable that was added to the server before using function addVariable.
The Modbus server checks that the length of the given value does not exceed the space reserved in the 16-bit register file.</desc>
                        <sample for="lua">success = Modbus.Server.writeVariable(busHandle, name, value)</sample>
                        <param name="handle" type="handle" alias="Modbus.Server" desc="The Modbus server handle"/>
                        <param name="name" type="string" desc="The name of the variable"/>
                        <param name="value" type="binary" desc="The value to write"/>
                        <return name="success" type="bool" desc="True if write was successful"/>
                    </function>
                    <function name="readVariable">
                        <desc>Reads the value of a variable as set before or received from the client.</desc>
                        <sample for="lua">value = Modbus.Server.readVariable(busHandle, name)</sample>
                        <param name="handle" type="handle" alias="Modbus.Server" desc="The Modbus server handle"/>
                        <param name="name" type="string" desc="The name of the variable"/>
                        <return name="value" type="binary" desc="The value of the variable"/>
                    </function>
                    <function name="register">
                        <desc>This function is used to register for any event of the handle.</desc>
                        <param name="handle" type="handle" alias="Modbus.Server" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to register to"/>
                        <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                        <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                    </function>
                    <function name="deregister">
                        <desc>This function is used to deregister from any registered event of the handle.</desc>
                        <param name="handle" type="handle" alias="Modbus.Server" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to deregister from"/>
                        <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                        <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                    </function>
                </serves>
            </crown>
        </crown>
        <crown name="MQTTClient">
            <trait>released</trait>
            <desc>Provides MQTT client functionality according to MQTT version 3.1.1.</desc>
            <enum name="TLSVersion">
                <desc>TLS protocol version</desc>
                <item name="TLS_V10" desc="TLS protocol version 1.0">TLS_V10</item>
                <item name="TLS_V11" desc="TLS protocol version 1.1">TLS_V11</item>
                <item name="TLS_V12" desc="TLS protocol version 1.2">TLS_V12</item>
            </enum>
            <enum name="QOS">
                <desc>Quality of Service level</desc>
                <item name="QOS0" desc="Quality of Service level 0">QOS0</item>
                <item name="QOS1" desc="Quality of Service level 1">QOS1</item>
                <item name="QOS2" desc="Quality of Service level 2">QOS2</item>
            </enum>
            <enum name="Retain">
                <desc>Message retain type</desc>
                <item name="NO_RETAIN" desc="Do not retain message">NO_RETAIN</item>
                <item name="RETAIN" desc="Retain message">RETAIN</item>
            </enum>
            <serves>
                <event name="OnReceive">
                    <desc>The OnReceive event which is thrown if an MQTT message arrives.</desc>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance handle of the MQTTClient."/>
                    <param name="topic" type="string" desc="The topic the message was posted to"/>
                    <param name="data" type="binary" desc="The payload data that was received"/>
                    <param name="qos" type="enum" ref="QOS" desc="The Quality of Service level"/>
                    <param name="retain" type="enum" ref="Retain" desc="The message retain flag"/>
                </event>
                <event name="OnConnected">
                    <desc>The OnConnected event which is thrown if an MQTT client is connected to a server</desc>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance handle of the MQTTClient."/>
                </event>
                <event name="OnDisconnected">
                    <desc>The OnDisconnected event which is thrown if an MQTT client is disconnected from a server</desc>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance handle of the MQTTClient."/>
                </event>
                <function name="create">
                    <desc>Creates a new MQTTClient instance.</desc>
                    <sample for="lua">handle = MQTTClient.create()</sample>
                    <return name="handle" type="handle" alias="MQTTClient" desc="The instance handle of the MQTTClient."/>
                </function>
                <function name="setInterface">
                    <desc>Sets the interface to be used for connecting.</desc>
                    <sample for="lua">MQTTClient.setInterface(handle, "ETH1")</sample>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance handle of the MQTTClient."/>
                    <param name="ifName" type="enum" ref="EthernetInterfaces" desc="One of the available interfaces."/>
                </function>
                <function name="setIPAddress">
                    <desc>Sets the host name or IP address of the MQTT server you want to connect to later.
Resolving host names only works if a name server is configured for the device. The name server IP address can be set using DHCP.</desc>
                    <sample for="lua">MQTTClient.setIPAddress(handle, "127.0.0.1") </sample>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance handle of the MQTTClient."/>
                    <param name="ipAddress" type="string" desc="Name or IP Address of MQTT server"/>
                </function>
                <function name="setPort">
                    <desc>Sets the server port to connect to.</desc>
                    <sample for="lua">MQTTClient.setPort(handle, 1883) </sample>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance handle of the MQTTClient."/>
                    <param name="port" type="int" desc="The server port between 1 and 65535. Default is 1883. For secure connections via TLS, port 8883 is typically used instead."/>
                </function>
                <function name="setKeepAliveInterval">
                    <desc>Sets the keep alive interval of this MQTTClient instance (in seconds). Default is 60 seconds.</desc>
                    <sample for="lua">MQTTClient.setKeepAliveInterval(handle, 120) -- interval in seconds</sample>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance handle of the MQTTClient."/>
                    <param name="keepAliveInterval" type="int" desc="The number of seconds after which a PING message should be sent if no other messages have been exchanged in that time. Disable keep alive mechanism with 0."/>
                </function>
                <function name="setClientID">
                    <desc>Sets the Client identifier of this MQTTClient instance. The identifier is sent to the server on connect. If this function is not called, a random Client identifier is generated instead.</desc>
                    <sample for="lua">MQTTClient.setClientID(handle, "foo") </sample>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance handle of the MQTTClient."/>
                    <param name="clientID" type="string" desc="The Client identifier"/>
                </function>
                <function name="setCleanSession">
                    <desc>Sets the Clean Session flag that is sent to the server on connect. The flag is enabled by default. When this flag is disabled, the session becomes persistent, which means that the server stores subscriptions and offline messages for this client (depending on QoS level). Using persistent sessions requires to set the Client identifier. The client itsself does not store anything persistent beyond the lifetime of the MQTTClient instance.</desc>
                    <sample for="lua">MQTTClient.setCleanSession(handle, false)</sample>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance handle of the MQTTClient."/>
                    <param name="cleanSession" type="bool" desc="The Clean Session flag. Default true."/>
                </function>
                <function name="setUserCredentials">
                    <desc>Sets username and password for this MQTTClient instance.</desc>
                    <sample for="lua">MQTTClient.setUserCredentials(handle, "user", "password")</sample>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance handle of the MQTTClient."/>
                    <param name="username" type="string" desc="The username to use for this instance"/>
                    <param name="password" type="string" desc="The password to the username"/>
                </function>
                <function name="setWillMessage">
                    <desc>Sets a will message. This message will be published by the server if the connection to the client is interrupted,
unless the client has explicitly done a clean disconnect via sending a disconnect message before.
The disconnect message is sent by calling the function MQTTClient.disconnect.
By default, clients do not have a will.</desc>
                    <sample for="lua">MQTTClient.setWillMessage(handle, "client/status", "client disconnected unexpectedly.")</sample>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance handle of the MQTTClient."/>
                    <param name="topic" type="string" desc="Topic under which to publish the message"/>
                    <param name="data" type="binary" desc="The message payload to publish"/>
                    <param name="qos" type="enum" multiplicity="?" ref="QOS" desc="Quality of Service level. Default is QOS0"/>
                    <param name="retain" type="enum" multiplicity="?" ref="Retain" desc="Retaining a message means that the server stores the message and sends it to future subscribers of this topic. Default is NO_RETAIN"/>
                </function>
                <function name="setTLSEnabled">
                    <desc>Sets TLS enabled or disabled.</desc>
                    <sample for="lua">MQTTClient.setTLSEnabled(handle, true)</sample>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance handle of the MQTTClient."/>
                    <param name="enabled" type="bool" desc="If true, enable TLS. Default is disabled"/>
                </function>
                <function name="setTLSVersion">
                    <desc>Sets the TLS protocol version. Default is TLS 1.2</desc>
                    <sample for="lua">MQTTClient.setTLSVersion(handle, "TLS_V12")</sample>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance handle of the MQTTClient."/>
                    <param name="version" type="enum" ref="TLSVersion" desc="Choose a specific TLS protocol version. Default is TLS 1.2"/>
                </function>
                <function name="setClientCertificate">
                    <desc>Enables client authentication. A client certificate and a private key must be provided. The passphrase for the private key is optional. Supported file formats are PEM, DER and PKCS#12 (depending on SSL engine) for the client certificate and PEM and DER for the private key. The format is selected by inspecting the extension of the provided file. If no valid extension is specified the engine defaults to PEM format.</desc>
                    <sample for="lua">MQTTClient.setClientCertificate(handle, "private/cert.pem", "private/privateKey.pem", "mypassphrase")</sample>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance handle of the MQTTClient."/>
                    <param name="certificateFile" type="string" desc="Path to a certificate file in PEM/DER/PKCS#12 format."/>
                    <param name="keyFile" type="string" desc="Path to file containing the client's private key in PEM/DER format."/>
                    <param name="passphrase" type="string" multiplicity="?" desc="Optional passphrase for the private key."/>
                </function>
                <function name="setCABundle">
                    <desc>Configures the certificate authority bundle to be used for verifying server certificates.</desc>
                    <sample for="lua">MQTTClient.setCABundle(handle, "private/CA.pem")</sample>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance handle of the MQTTClient."/>
                    <param name="bundleFile" type="string" desc="Path to a certificate bundle in PEM format."/>
                </function>
                <function name="setPeerVerification">
                    <desc>Enables/disables peer verification. This can be useful if the site to connect to does not use a certificate signed by one of the certs in the CA bundle. Disabling this verification makes the connection A LOT LESS SECURE.</desc>
                    <sample for="lua">MQTTClient.setPeerVerification(handle, false)</sample>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance handle of the MQTTClient."/>
                    <param name="enabled" type="bool" desc="True to enable peer verification, false to disable. Default is enabled."/>
                </function>
                <function name="setHostnameVerification">
                    <desc>Enables/disables hostname verification. This can be useful if the site to connect to uses a different host name than what is mentioned in the server certificate commonName (or subjectAltName) fields. Disabling this verification makes the connection less secure.</desc>
                    <sample for="lua">MQTTClient.setHostnameVerification(handle, false)</sample>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance handle of the MQTTClient."/>
                    <param name="enabled" type="bool" desc="True to enable hostname verification, false to disable. Default is enabled."/>
                </function>
                <function name="connect">
                    <desc>Connects to an MQTT Server. The OnConnected and OnDisconnected events are thrown when the connection gets connected or disconnected. Important: Connection is not re-established automatically if connecting fails or connection gets lost later.
This should be done manually using a Timer instead. Subscriptions must be made again after reconnecting (see function MQTTClient.subscribe).</desc>
                    <sample for="lua">MQTTClient.connect(handle)
          </sample>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance handle of the MQTTClient."/>
                    <param name="timeoutMs" type="int" multiplicity="?" desc="The timeout to wait initially until the client gets connected. If not set, 5000ms is the default. Check function isConnected afterwards if was successful. If a host name is used instead of an IP address, the time needed to resolve the hostname via DNS is not subject to the timeout."/>
                </function>
                <function name="isConnected">
                    <desc>Returns true if the client is connected.</desc>
                    <sample for="lua">bConnected = MQTTClient.isConnected(handle)</sample>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance handle of the MQTTClient"/>
                    <return name="isConnected" type="bool" desc="True if the client is connected"/>
                </function>
                <function name="publish">
                    <desc>Publishes a message on a topic to an MQTT server.</desc>
                    <sample for="lua">MQTTClient.publish(handle, "/test/topic1", "Hello World")</sample>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance handle of the MQTTClient."/>
                    <param name="topic" type="string" desc="The Topic under which to publish the message"/>
                    <param name="data" type="binary" desc="The message payload to publish"/>
                    <param name="qos" type="enum" multiplicity="?" ref="QOS" desc="The Quality of Service level. Default is QOS0"/>
                    <param name="retain" type="enum" multiplicity="?" ref="Retain" desc="Retaining a message means that the server stores the message and sends it to future subscribers of this topic. Default is NO_RETAIN"/>
                </function>
                <function name="subscribe">
                    <desc>Subscribes to topic(s) on an MQTT server. Client must be already connected to the server to to do this. Subscriptions are lost when connection goes down, so they must be done again after connecting again. It is recommended to do the subscribe calls in a callback function registered to the event MQTTClient.OnConnected.</desc>
                    <sample for="lua">MQTTClient.subscribe(handle, "/test/#") -- subscribe to all topics under /test</sample>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance handle of the MQTTClient."/>
                    <param name="topicFilter" type="string" desc="The topic which to subscribe to. It is possible to use the standard MQTT wildcards: Single topic level wildcard '+', Multi-level wildcard '#'. '#' can only be used at the end of the topic filter string."/>
                    <param name="qos" type="enum" multiplicity="?" ref="QOS" desc="Quality of Service level. Default is QOS0"/>
                </function>
                <function name="unsubscribe">
                    <desc>Unsubscribes from topic on an MQTT server. Client must be already connected to the server to to do this.</desc>
                    <sample for="lua"></sample>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance of the MQTTClient."/>
                    <param name="topicFilter" type="string" desc="The topic which to unsubscribe from."/>
                </function>
                <function name="register">
                    <desc>This function is used to register for any event of the handle.</desc>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to register to"/>
                    <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                    <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                </function>
                <function name="deregister">
                    <desc>This function is used to deregister from any registered event of the handle.</desc>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to deregister from"/>
                    <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                    <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                </function>
                <function name="disconnect">
                    <desc>Disconnects from an MQTT server</desc>
                    <sample for="lua">MQTTClient.disconnect(handle)</sample>
                    <param name="handle" type="handle" alias="MQTTClient" desc="The instance handle of the MQTTClient."/>
                </function>
            </serves>
        </crown>
        <crown name="OPCUA">
            <trait>released</trait>
            <desc>Provides OPC UA server functionality.

OPC UA Overview:
The OPC Unified Architecture (UA), released in 2008, is a platform independent
service-oriented architecture that integrates all the functionality of the individual OPC
Classic specifications into one extensible framework. It is developed by the OPC Foundation.
See reference document 1 for more details about the protocol.

API Overview:
This API implements all the functions that are required to start a OPC UA server.
It allows to create nodes of different classes, e.g. variables, objects or methods,
and connect them via references to build up a custom information model.
Nodes are grouped together into a namespace. A server can have one or more namespaces.

The provided functions can be categorized into three groups:
1. Server management and server configuration: OPCUA.Server.*
2. Creating and managing namespaces: OPCUA.Server.Namespace.*
3. Creating, managing and using nodes and references: OPCUA.Server.Node.*

According to internal, unofficial tests, this OPC UA CROWN can be used to fulfill the following OPC UA Profiles:
- Nano Embedded Device Server Profile (Compliance Test Tool version 1.3.340.380)
- SecurityPolicy - None (requires openSSL library)
- SecurityPolicy - Basic128Rsa15 (requires openSSL library)
- SecurityPolicy - Basic256 (requires openSSL library)
- SecurityPolicy - Basic256Sha256 (requires openSSL library)
So far, no other profiles are fulfilled. Please note that profile compliance was tested with a reference server
implementation using this OPC UA CROWN. Other server implementations using this CROWN need to be tested separately
according to the official OPC UA certification procedure in order to officially claim compliance.

The server allows the following user token policies:
- anonymous
- user name / password
So far, no other user token policies (e.g., x509, token, ...) are supported.

Limitations:
- The server does not fulfill the other OPC UA Profiles for servers: Micro Embedded Device Server, Embedded UA Server
and Standard UA Server.
- loading of NodeSet2 files supported only if server supports the objects and value in the file (e.g., it does not support loading of 2-dimensional values)
- If a target device platform does not provide openSSL library, then all security features are disabled.
- Only one transport type is supported: UA TCP - UA Secure Conversation - UA Binary.
- It is possible to use custom structured data types, however these types must be loaded from XML files. Access to these
data types can be done through Value CROWN.
- Only one-dimensional arrays are supported.
- Unsupported service sets:
-- NodeManagement Service Set: AddNodes, AddReferences, DeleteNodes, DeleteReferences
-- View Service Set: RegisterNodes, UnregisterNodes, Query Service Set, QueryFirst, QueryNext
-- Attribute Service Set: HistoryRead, HistoryUpdate
- Unsupported built-in data types:
-- XmlElement
-- ExtensionObject (but enumerations are supported)
-- DataValue
-- Variant
-- nested DiagnosticInfos

Reference Documents:
1. OPC Unified Architecture Specification, Parts 1-13,
https://opcfoundation.org/developer-tools/specifications-unified-architecture</desc>
            <enum name="NodeIDType">
                <desc>Possible types of OPC UA node ID</desc>
                <item name="Numeric" desc="An unsigned number is used; value range: 0-4294967295">NUMERIC</item>
                <item name="String" desc="A string should be used">STRING</item>
            </enum>
            <enum name="NodeClass">
                <desc>All possible OPC UA node classes</desc>
                <item name="Object" desc="Node representing an object">OBJECT</item>
                <item name="Variable" desc="Node representing a (data) variable">VARIABLE</item>
                <item name="Method" desc="Node representing a method">METHOD</item>
                <item name="ObjectType" desc="Node representing an object type">OBJECT_TYPE</item>
                <item name="VariableType" desc="Node representing a variable type">VARIABLE_TYPE</item>
                <item name="ReferenceType" desc="Node representing a reference type">REFERENCE_TYPE</item>
                <item name="DataType" desc="Node representing a data type">DATA_TYPE</item>
                <item name="View" desc="Node representing a view">VIEW</item>
            </enum>
            <enum name="AccessLevel">
                <desc>Possibilities to access a VARIABLE node value</desc>
                <item name="Read" desc="The value is read only">READ</item>
                <item name="ReadWrite" desc="The value can be read and written">READ_WRITE</item>
            </enum>
            <enum name="DataType">
                <desc>Enumeration of the supported OPC UA built-in data types</desc>
                <item name="ByteString" desc="An array of unsigned bytes">BYTE_STRING</item>
                <item name="Bool" desc="A boolean value">BOOL</item>
                <item name="Byte" desc="An unsigned byte">BYTE</item>
                <item name="SByte" desc="A signed byte">SBYTE</item>
                <item name="Int16" desc="A 16 bit signed integer">INT16</item>
                <item name="UInt16" desc="A 16 bit unsigned integer">UINT16</item>
                <item name="Int32" desc="A 32 bit signed integer">INT32</item>
                <item name="UInt32" desc="A 32 bit unsigned integer">UINT32</item>
                <item name="Int64" desc="A 64 bit signed integer">INT64</item>
                <item name="UInt64" desc="A 64 bit unsigned integer">UINT64</item>
                <item name="Float" desc="A 32 bit IEEE-754 floating point number">FLOAT</item>
                <item name="Double" desc="A 64 bit IEEE-754 floating point number">DOUBLE</item>
                <item name="String" desc="An UTF-8 String">STRING</item>
                <item name="StatusCode" desc="OPC UA StatusCode (see OPC UA specification part 4 (7.34))">STATUS_CODE</item>
                <item name="DateTime" desc="An instance in time (e.g., 1988-04-30T03:04:05Z; see OPC UA specification part 6 (5.2.2.5))">DATE_TIME</item>
                <item name="Guid" desc="A globally unique identifier encoded as string (e.g., {72962B91-FA75-4AE6-8D28-B404DC7DAF63}, see OPC UA specification part 6 (5.2.2.6))">GUID</item>
                <item name="NodeId" desc="A node identifier encoded as string (e.g., &quot;i=13&quot; or &quot;ns=12;s=Hello:World&quot;; see OPC UA specification part 6 (5.3.1.10))">NODE_ID</item>
                <item name="ExpandedNodeId" desc="An expanded node identifier encoded as string (e.g., &quot;svr=1;ns=2;s=Hello:World&quot; or &quot;svr=1;nsu=http://example.uri.com;s=Hello:World&quot;; see OPC UA specification part 6 (5.3.1.11))">EXPANDED_NODE_ID</item>
                <item name="QualifiedName" desc="A qualified name encoded as string of the form &quot;&gt;namespaceindex&lt;:&gt;name&lt;&quot; where namespace index is an unsigned 16 bit integer and name is a string (e.g., &quot;1:some name&quot;; see OPC UA specification part 3 (8.3))">QUALIFIED_NAME</item>
                <item name="LocalizedText" desc="A localized text as string of the form &quot;&gt;locale id&lt;:&gt;text&lt;&quot; where locale id is a locale string according to https://www.io.org/standard/57469.html and the actual localized text (e.g., &quot;en-US:Hello World!&quot; or &quot;de:Hallo Welt!&quot;; see OPC UA specification part 3 (8.4 and 8.5))">LOCALIZED_TEXT</item>
            </enum>
            <enum name="NodeType">
                <desc>All supported OPC UA standard node types</desc>
                <item name="BaseDataVariableType" desc="The variable contains a potentially changeable value that represents data">BASE_DATA_VARIABLE_TYPE</item>
                <item name="PropertyType" desc="The variable contains unchangeable data that expresses a property of another node">PROPERTY_TYPE</item>
                <item name="FolderType" desc="The object represents a folder">FOLDER_TYPE</item>
            </enum>
            <enum name="ReferenceType">
                <desc>Possible types of references from one OPC UA node to another</desc>
                <item name="HasComponent" desc="The child node is a part of the parent node">HAS_COMPONENT</item>
                <item name="HasOrderedComponent" desc="The child node is a part of the parent node; the child nodes are always returned in the same order on discovery">HAS_ORDERED_COMPONENT</item>
                <item name="HasProperty" desc="The child node describes a property of the parent node, e.g. Input or Output arguments of a method">HAS_PROPERTY</item>
                <item name="HasSubtype" desc="The child node is a subtype of the parent node">HAS_SUBTYPE</item>
                <item name="HasEventSource" desc="The child node causes the parent node to generate an event">HAS_EVENT_SOURCE</item>
                <item name="HasNotifier" desc="The child node causes the parent node to generate an event, but generates also events itself">HAS_NOTIFIER</item>
                <item name="Organizes" desc="The parent node is a folder which contains the child node">ORGANIZES</item>
                <item name="GeneratesEvent" desc="The child node describes which event is generated by the parent node (ObjectType, VariableType, Method)">GENERATES_EVENT</item>
                <item name="AlwaysGeneratesEvent" desc="The parent node (method) generates this event on each call">ALWAYS_GENERATES_EVENT</item>
                <item name="HasTypeDefinition" desc="The definition of the type of the parent node (variable or object)">HAS_TYPE_DEFINITION</item>
            </enum>
            <enum name="EventSeverity">
                <desc>Is mapped to OPC UA event severity (0 ... 1000)</desc>
                <item name="Highest" desc="Highest severity (1000)">HIGHEST</item>
                <item name="Higher" desc="Higher severity (900)">HIGHER</item>
                <item name="High" desc="High severity (800)">HIGH</item>
                <item name="HigherMedium" desc="Higher than medium severity (650)">HIGHER_MEDIUM</item>
                <item name="Medium" desc="Medium severity (500)">MEDIUM</item>
                <item name="LowerMedium" desc="Lower than medium severity (350)">LOWER_MEDIUM</item>
                <item name="Low" desc="Low severity (200)">LOW</item>
                <item name="Lower" desc="Lower severity (100)">LOWER</item>
                <item name="Lowest" desc="Lowest severity (0)">LOWEST</item>
            </enum>
            <crown name="Server">
                <trait>released</trait>
                <desc>Provides OPC UA Server functionality.</desc>
                <serves>
                    <function name="create">
                        <desc>Create a new OPC UA Server instance. Server address space is in a default state (i.e., a pristine NS0). Network communication is not active.</desc>
                        <sample for="lua">handle = OPCUA.Server.create()</sample>
                        <return name="handle" type="handle" multiplicity="?" alias="OPCUA.Server" desc="The instance handle of the OPC UA Server. Currently, it is only possible to create a single instance handle. Fails with return value nil when another instance handle already exists."/>
                    </function>
                    <function name="start">
                        <desc>Start the network communication. After a successful start, OPC UA clients can connect to server via network.</desc>
                        <sample for="lua">success = OPCUA.Server.start(handle)</sample>
                        <param name="handle" type="handle" alias="OPCUA.Server" desc="The instance handle of the OPC UA Server"/>
                        <return name="success" type="bool" desc="Is true when the OPC UA server has been started successfully, false if an error occurred."/>
                    </function>
                    <function name="resetAddressSpace">
                        <desc>Reset the OPC UA server. Whole address space is reset to default state (i.e., a pristine NS0). All CROWN instances to existing nodes become invalid. Other settings (e.g., network settings) are not affected by reset. Call reset() only when server is stopped.</desc>
                        <sample for="lua">success = OPCUA.Server.resetAddressSpace(handle)</sample>
                        <param name="handle" type="handle" alias="OPCUA.Server" desc="The instance handle of the OPC UA Server"/>
                        <return name="success" type="bool" desc="Is true when the OPC UA server has been reset successfully, false if an error occurred."/>
                    </function>
                    <function name="stop">
                        <desc>Stop the OPC UA server's network communication.</desc>
                        <sample for="lua">OPCUA.Server.stop(handle)</sample>
                        <param name="handle" type="handle" alias="OPCUA.Server" desc="The instance handle of the OPC UA Server"/>
                        <return name="success" type="bool" desc="Is true when the OPC UA server has been stopped successfully, false if an error occurred."/>
                    </function>
                    <function name="setNamespaces">
                        <desc>Set all OPC UA Namespaces the server should use. Please note that his removes any nodes that are neither in standard namespace NS0 nor in the namespaces parameter.</desc>
                        <sample for="lua">OPCUA.Server.setNamespaces(handle, {namespace1, namespace2})</sample>
                        <param name="handle" type="handle" alias="OPCUA.Server" desc="The instance handle of the OPC UA Server"/>
                        <param name="namespaces" type="object" multiplicity="[1+]" alias="OPCUA.Server.Namespace" desc="The Namespace objects the server should use. All Namespaces which have been added previously are removed."/>
                    </function>
                    <function name="setPort">
                        <desc>Set the port on which the server should listen. Call to this function is optional. By default, port is 4840.

This function will become deprecated soon. See description of OPCUA CROWN for more details.</desc>
                        <sample for="lua">OPCUA.Server.setPort(handle, 4840)</sample>
                        <param name="handle" type="handle" alias="OPCUA.Server" desc="The instance handle of the OPC UA Server"/>
                        <param name="port" type="int" constraint="1-65535" desc="The server port between 1 and 65535. "/>
                    </function>
                    <function name="setInterface">
                        <desc>Set the interface on which the server should listen. Call to this function is optional. By
default, server listens all interfaces. On multi-homed hosts, it is recommended to bind the
server to one specific interface. Otherwise, one OPC UA EndPoint is created for each IP
address and the client has to select the right one manually.

This function will become deprecated soon. See description of OPCUA CROWN for more details.</desc>
                        <sample for="lua">OPCUA.Server.setInterface(handle, "ETH1")</sample>
                        <param name="handle" type="handle" alias="OPCUA.Server" desc="The instance handle of the OPC UA Server"/>
                        <param name="ifName" type="enum" ref="EthernetInterfaces" desc="One of the available interfaces"/>
                    </function>
                    <function name="setApplicationName">
                        <desc>Set the name of the application. This name is shown to clients as the name of the server and
should describe what the server actually does.</desc>
                        <sample for="lua">OPCUA.Server.setApplicationName(handle, "MyApplication")</sample>
                        <param name="handle" type="handle" alias="OPCUA.Server" desc="The instance handle of the OPC UA Server"/>
                        <param name="name" type="string" desc="Name of the application that is shown to clients"/>
                    </function>
                    <function name="setApplicationURI">
                        <desc>Set the Application URI. Call to this function is optional. The Application URI of a server
represents a globally-unique logical name for a Server within the scope of the network in
which it is installed. This identifier should be a fully qualified domain name; however, it
may be a GUID or similar construct that ensures global uniqueness.
If this function is not called, the following default ApplicationURI
urn://sick.com/opc/ua/serial/${DEVICE_PRODUCT}/${SERIAL_NUMBER} is used, where the variable
${DEVICE_PRODUCT} is replaced by the device name and ${SERIAL_NUMBER} is replaced by the
serial number. Example for a SIM4000 device: urn://sick.com/opc/ua/serial/SIM4000/12345678</desc>
                        <sample for="lua">OPCUA.Server.setApplicationURI(handle, "urn://sick.com/opc/ua/app/sim/sim4000/my_application_uid")</sample>
                        <param name="handle" type="handle" alias="OPCUA.Server" desc="The instance handle of the OPC UA Server"/>
                        <param name="uri" type="string" desc="Application URI. Can be chosen freely, but SICK recommends to use the following format: urn://sick.com/opc/ua/app/[product/]unique_identifier. The unique_identifier should not change on device reset."/>
                    </function>
                    <function name="loadNodeSet2File">
                        <desc>Load a NodeSet2 XML file. This method can be called multiple times to load different files. In case of an error during loading (e.g, due to invalid file contents), loading stops when the error is encountered. Consider using resetAddressSpace() to remove partially loaded files from address space. Please note that setting initial values is  not supported via xml. Use setValue() for this.</desc>
                        <param name="handle" type="handle" alias="OPCUA.Server" desc="The instance handle of the OPC UA Server"/>
                        <param name="fileName" type="string" desc="NodeSet2 XML file to load"/>
                        <return name="status" type="bool" desc="True if loaded successfully, false otherwise"/>
                    </function>
                    <function name="getNamespace">
                        <desc>Retrieve a namespace from the server</desc>
                        <param name="handle" type="handle" alias="OPCUA.Server" desc="The instance handle of the OPC UA Server"/>
                        <param name="index" type="int" multiplicity="1" constraint="0-65535" desc="The index of the namespace to get."/>
                        <return name="namespace" type="object" multiplicity="?" alias="OPCUA.Server.Namespace" desc="The requested namespace or nil if the namespace can not be found"/>
                    </function>
                    <function name="setConfiguration">
                        <desc>Set a ServerConfiguration. Please note that server copies the configuration when this function is called.</desc>
                        <param name="handle" type="handle" alias="OPCUA.Server" desc="The instance handle of the OPC UA Server"/>
                        <param name="config" type="object" alias="OPCUA.Server.ServerConfiguration" desc="The configuration for the OPC UA Server"/>
                    </function>
                </serves>
                <crown name="SecurityConfiguration">
                    <trait>released</trait>
                    <desc>A security configuration consists of (1) a set of credentials (a certificate and a private key
representing the server), (2) a SecurityPolicy, (3) a set of MessageSecurityModes and (4) a set of
UserTokenPolicies. Each endpoint has one or more SecurityConfigurations.</desc>
                    <enum name="MessageSecurityMode">
                        <desc>This enum defines all possible message security modes to secure the message exchange between server and client. (cf. OPC UA specification, part 4, 7.15)</desc>
                        <item name="None" desc="Do not sign or encrypt the messages.">NONE</item>
                        <item name="Sign" desc="Sign the messages.">SIGN</item>
                        <item name="SignAndEncrypt" desc="Sign and encrypt the messages.">SIGN_AND_ENCRYPT</item>
                    </enum>
                    <enum name="SecurityPolicy">
                        <desc>This enum defines all security policies that can be used by a client to connect to the server.</desc>
                        <item name="None" desc="Use the http://opcfoundation.org/UA/SecurityPolicy#None security policy, i.e. do not use any security.">NONE</item>
                        <item name="Basic128Rsa15" desc="Use the http://opcfoundation.org/UA/SecurityPolicy#Basic128Rsa15 security policy.">BASIC_128_RSA_15</item>
                        <item name="Basic256" desc="Use the http://opcfoundation.org/UA/SecurityPolicy#Basic256 security policy.">BASIC_256</item>
                        <item name="Basic256Sha256" desc="Use the http://opcfoundation.org/UA/SecurityPolicy#Basic256Sha256 security policy.">BASIC_256_SHA_256</item>
                    </enum>
                    <enum name="UserTokenPolicy">
                        <desc>Defines all possible user token policies / authentication modes that the client can use to establish a connection to the server. (cf. OPC UA specification, part 4, 7.36.1)</desc>
                        <item name="Anonymous" desc="Use anonymous authentication.">ANONYMOUS</item>
                        <item name="Username" desc="Use user name and password for authentication.">USERNAME</item>
                    </enum>
                    <serves>
                        <function name="create">
                            <desc>Creates a SecurityConfiguration with default settings. Default settings are: (1)
UserTokenPolicy = ANONYMOUS, (2) MessageSecurityMode = NONE, (3) no server credentials and (4)
SecurityPolicy = NONE</desc>
                            <sample for="lua">handle = OPCUA.Server.SecurityConfiguration.create()</sample>
                            <return name="config" type="object" alias="OPCUA.Server.SecurityConfiguration" desc="Default SecurityConfiguration instance"/>
                        </function>
                        <function name="setUserTokenPolicies">
                            <desc>Sets a set of UserTokenPolicies.</desc>
                            <param name="config" type="object" alias="OPCUA.Server.SecurityConfiguration" desc="The configuration instance whose UserTokenPolicies should be set"/>
                            <param name="policies" type="enum" multiplicity="+" ref="UserTokenPolicy" desc="Non-empty, duplicate-free list of UserTokenPolicies"/>
                        </function>
                        <function name="setMessageSecurityModes">
                            <desc>Sets a set of MessageSecurityModes.</desc>
                            <param name="config" type="object" alias="OPCUA.Server.SecurityConfiguration" desc="The configuration instance whose MessageSecurityModes should be set"/>
                            <param name="modes" type="enum" multiplicity="+" ref="MessageSecurityMode" desc="Non-empty, duplicate-free list of MessageSecurityModes"/>
                        </function>
                        <function name="setServerCredentials">
                            <desc>Sets the server credentials. The certificate and the private key have to match. Either specify
both or none. Specify none in case that no server credentials should be used (i.e., no signing and/or
encryption is used).
Parameters certificate and privateKey are interpreted in the context of the used certificate store.
When used together with a FileCertificateStoreConfiguration, certificate and privateKey parameters are
interpreted as files. However, future releases might introduce different types of key stores (e.g.,
remote certificate stores or hardware key stores). In that case, parameters certificate and privateKey
specify something different than file names.</desc>
                            <param name="config" type="object" alias="OPCUA.Server.SecurityConfiguration" desc="The configuration instance whose server credentials should be set"/>
                            <param name="certificate" type="string" multiplicity="?" desc="When using FileCertificateStoreConfiguration, this parameter specifies the name of the file where the certificate to be used for the server is stored in DER format. Use empty string (&quot;&quot;) if no certificate shall be used."/>
                            <param name="privateKey" type="string" multiplicity="?" desc="When using FileCertificateStoreConfiguration, this parameter specifies the name of the file where the private key to be used for the server is stored in PEM format. Use empty string (&quot;&quot;) if no private key shall be used."/>
                        </function>
                        <function name="setSecurityPolicy">
                            <desc>Sets the security policy</desc>
                            <param name="config" type="object" alias="OPCUA.Server.SecurityConfiguration" desc="The configuration instance whose SecurityPolicy should be set"/>
                            <param name="securityPolicy" type="enum" ref="SecurityPolicy" desc="The SecurityPolicy to use"/>
                        </function>
                    </serves>
                </crown>
                <crown name="EndpointConfiguration">
                    <trait>released</trait>
                    <desc>An EndpointConfiguration consists of (1) a certificate store configuration, (2) a non-empty set of
SecurityConfigurations, (3) a boolean flag for enabling application authentication, (4) a reference to an
UserTokenDatabase and (5) a bind URL.</desc>
                    <serves>
                        <function name="create">
                            <desc>Create an EndpointConfiguration with default values. Default values are:
(1) no certificate store, (2) one SecurityConfiguration with default values,
(3) application authentication = disabled, (4) empty UserTokenDatabase (5) interface ="ALL" and
(6) port = 4840.</desc>
                            <sample for="lua">obj = OPCUA.EndpointConfiguration.create()</sample>
                            <return name="config" type="object" alias="OPCUA.Server.EndpointConfiguration" desc="Configuration with default values"/>
                        </function>
                        <function name="setInterface">
                            <desc>Sets the interface to bind the Endpoint to. If interface is set to "ALL", then the
Endpoint binds to all network interfaces. In such a case there can only be one EndpointConfiguration
in a ServerConfiguration.</desc>
                            <param name="config" type="object" alias="OPCUA.Server.EndpointConfiguration" desc="The configuration whose bind URL should be set."/>
                            <param name="interface" type="enum" ref="EthernetInterfaces" desc="The interface to bind to (e.g., ETH1)."/>
                        </function>
                        <function name="setPort">
                            <desc>Sets the port to listen to.</desc>
                            <param name="config" type="object" alias="OPCUA.Server.EndpointConfiguration" desc="The configuration whose bind URL should be set."/>
                            <param name="port" type="int" desc="The server port between 1 and 65535."/>
                        </function>
                        <function name="setSecurityConfigurations">
                            <desc>Sets the SecurityConfigurations.</desc>
                            <param name="config" type="object" alias="OPCUA.Server.EndpointConfiguration" desc="The configuration whose SecurityConfigurations should be set."/>
                            <param name="securityConfigurations" type="object" multiplicity="+" alias="OPCUA.Server.SecurityConfiguration" desc="Non-empty set of security configurations."/>
                        </function>
                        <function name="enableApplicationAuthentication">
                            <desc>Enable or disable application authentication.</desc>
                            <param name="config" type="object" alias="OPCUA.Server.EndpointConfiguration" desc="The configuration whose application authentication should be enabled / disabled."/>
                            <param name="enabled" type="bool" desc="Set to true to enable application authentication."/>
                        </function>
                        <function name="setUserTokenDatabase">
                            <desc>Sets the UserTokenDatabase. Please note that the behavior of this setter only stores a reference to the UserTokenDatabase.
This allows the sharing of one UserTokenDatabase among multiple EndPoints. Consequences are: (1) if a server S is configured to
use a UserTokenDatabase instance U and U.addUserPassword("x", "y") is called, then S immediately accepts the user x.</desc>
                            <param name="config" type="object" alias="OPCUA.Server.EndpointConfiguration" desc="The configuration whose UserTokenDatabase should be set."/>
                            <param name="userTokenDatabase" type="object" multiplicity="?" alias="OPCUA.Server.UserTokenDatabase" desc="The UserTokenDatabase to set. Pass nil to indicate that no UserTokenDatabase should be used."/>
                        </function>
                        <function name="setCertificateStoreConfiguration">
                            <desc>Sets the CertificateStoreConfiguration.</desc>
                            <param name="config" type="object" alias="OPCUA.Server.EndpointConfiguration" desc="The configuration whose CertificateStoreConfiguration should be set."/>
                            <param name="certificateStoreConfiguration" type="object" multiplicity="?" desc="The CertificateStoreConfiguration to set. Pass nil to indicate that no certificate store should be used."/>
                        </function>
                    </serves>
                </crown>
                <crown name="UserTokenDatabase">
                    <trait>released</trait>
                    <desc>UserTokenDatabase is used for maintaining a set of user credentials that can be used to authenticate
at an OPC UA Endpoint. UserTokenDatabases are set to EndpointConfigurations in a reference-like manner.
This was done to allow several endpoints to use the same UserTokenDatabase. When endpoints are created
from a ServerConfiguration, server starts to uses the references UserTokenDatabase(s). As consequences,
any changes to a user database apply directly to the (running) server.</desc>
                    <serves>
                        <function name="create">
                            <desc>Creates an empty database.</desc>
                            <sample for="lua">obj = OPCUA.UserTokenDatabase.create()</sample>
                            <return name="database" type="object" alias="OPCUA.Server.UserTokenDatabase" desc="The created database."/>
                        </function>
                        <function name="addUserPassword">
                            <desc>Add a user with a password to the database.</desc>
                            <param name="database" type="object" alias="OPCUA.Server.UserTokenDatabase" desc="The database to add the user to."/>
                            <param name="userName" type="string" desc="Name of the user."/>
                            <param name="password" type="string" desc="Password of the user"/>
                        </function>
                    </serves>
                </crown>
                <crown name="FileCertificateStoreConfiguration">
                    <trait>released</trait>
                    <desc>FileCertificateStoreConfiguration contains information about a file-based certificate store. The only
parameter of this certificate store type is the root directory. All other directories should be created with fixed
names below root directory.
Directory layout:
- ${rootDir}/issuer/certs:  The issuer directory contains non-trusted issuer / certificate authority (CA) certificates
- ${rootDir}/issuer/crl:    The issuer CRL directory contains the CRLs of the CA certs from issuer directory.
- ${rootDir}/trusted/certs: The trusted directory contains trusted CA certificates and self-signed certificates.
- ${rootDir}/trusted/crl:   The trusted CRL directory contains the CRLs of the CA certs from trusted directory.
Please note that FileCertificateStoreConfiguration only holds the information where to look for certificates.
The app developer is responsible for ensuring that the directories exist and contain the required files.</desc>
                    <serves>
                        <function name="create">
                            <desc>Creates a file store configuration with root directory = "."</desc>
                            <sample for="lua">obj = OPCUA.FileCertificateStoreConfiguration.create()</sample>
                            <return name="config" type="object" alias="OPCUA.Server.FileCertificateStoreConfiguration" desc="The created FileCertificateStoreConfiguration instance."/>
                        </function>
                        <function name="setRootDirectory">
                            <desc>Sets the root directory.</desc>
                            <param name="database" type="object" alias="OPCUA.Server.FileCertificateStoreConfiguration" desc="The configuration whose root directory should be set."/>
                            <param name="rootDir" type="string" desc="The root directory."/>
                        </function>
                    </serves>
                </crown>
                <crown name="ServerConfiguration">
                    <trait>released</trait>
                    <desc>Configuration of an OPC UA server. Default server configuration has (1) a list with one
EndpointConfiguration set to default values.</desc>
                    <serves>
                        <function name="create">
                            <desc>Creates a server configuration with default parameters.</desc>
                            <sample for="lua">obj = OPCUA.Server.ServerConfiguration.create()</sample>
                            <return name="config" type="object" alias="OPCUA.Server.ServerConfiguration" desc="The created configuration."/>
                        </function>
                        <function name="setEndpointConfigurations">
                            <desc>Sets the endpoint configurations.</desc>
                            <param name="config" type="object" alias="OPCUA.Server.ServerConfiguration" desc="The ServerConfigration whose EndpointConfigurations should be set."/>
                            <param name="endpointConfigurations" type="object" multiplicity="+" alias="OPCUA.Server.EndpointConfiguration" desc="Non-empty list of EndpointConfigurations."/>
                        </function>
                    </serves>
                </crown>
                <crown name="Namespace">
                    <trait>released</trait>
                    <desc>Represents a OPC UA namespace. A OPC UA Server can work with one or more user defined namespaces.
Namespaces can be added to the server using the function OPCUA.Server.setNamespaces.</desc>
                    <serves>
                        <function name="create">
                            <desc>Create a new OPC UA Namespace instance.</desc>
                            <sample for="lua">handle = OPCUA.Server.Namespace.create()</sample>
                            <return name="handle" type="handle" alias="OPCUA.Server.Namespace" desc="The instance handle of the OPC UA Namespace"/>
                        </function>
                        <function name="setIndex">
                            <desc>Sets the index of the namespace. Calling this function. By default, namespace indices are
assigned automatically in the order of namespace creation, starting with index 2.</desc>
                            <sample for="lua">OPCUA.Server.Namespace.setIndex(handle, 3)</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Namespace" desc="The instance handle of the OPC UA Namespace"/>
                            <param name="index" type="int" constraint="2-65535" desc="The namespace index to use. Must not be in use by any other namespace."/>
                            <param name="url" type="string" multiplicity="?" desc="URL that identifies the namespace, is shown to clients for a better understanding of the namespace index. Should start with urn://. If not provided, default is http://sick.com/opc/ua/namespace/[device_product/]namespace_index_as_string"/>
                        </function>
                        <function name="getNode">
                            <desc>Retrieve an OPC UA node that is inside the namespace.</desc>
                            <sample for="lua">local node = OPCUA.Server.Namespace.getNode(handle, "STRING", "MySimpleVariableNode")</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Namespace" desc="The instance handle of the OPC UA Namespace"/>
                            <param name="idType" type="enum" ref="NodeIDType" desc="Type of the ID"/>
                            <param name="id" type="auto" desc="The ID of the Node to get"/>
                            <return name="node" type="object" multiplicity="?" alias="OPCUA.Server.Node" desc="The requested node or nil if the node can not be found"/>
                        </function>
                        <function name="getNodeFromStandardNamespace">
                            <desc>Retrieve a node that is part of the standard namespace NS0. The available Node IDs are
listed in the OPC Unified Architecture Specification, Part 6: Mappings, Annex B: OPC UA Nodeset.</desc>
                            <sample for="lua">local node = OPCUA.Server.Namespace.getNodeFromStandardNamespace(handle, "NUMERIC", 5)</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Namespace" desc="The instance handle of the OPC UA Namespace"/>
                            <param name="idType" type="enum" ref="NodeIDType" desc="Type of the ID"/>
                            <param name="id" type="auto" desc="The ID of the Node to get"/>
                            <return name="node" type="object" multiplicity="?" alias="OPCUA.Server.Node" desc="The requested node or nil if the node can not be found"/>
                        </function>
                        <function name="setRootNode">
                            <desc>Sets the root node of the namespace.</desc>
                            <sample for="lua">OPCUA.Server.Namespace.setRootNode(handle, rootNode)</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Namespace" desc="The instance handle of the OPC UA Namespace"/>
                            <param name="root" type="object" alias="OPCUA.Server.Node" desc="The root node. It is recommended to use a folder node as root"/>
                            <param name="suspensionFolder" type="object" multiplicity="?" alias="OPCUA.Server.Node" desc="Optional. The node (folder) that is the parent node of root. Default is the global root node of the OPC UA default namespace"/>
                        </function>
                        <function name="setNodes">
                            <desc>Set all nodes that belong to this namespace.</desc>
                            <sample for="lua">OPCUA.Server.Namespace.setNodes(handle, {node1, node2})</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Namespace" desc="The instance handle of the OPC UA Namespace"/>
                            <param name="nodes" type="object" multiplicity="+" alias="OPCUA.Server.Node" desc="All nodes that should belong to this namespace, including the root node."/>
                        </function>
                    </serves>
                </crown>
                <crown name="Node">
                    <trait>released</trait>
                    <desc>Represents a single node in the address space of a OPC UA server. Some node types (of type
"Variable" and "VariableType") contain values. These can be accessed via getValue(),
setValue() and getValueHandle(). For more information on value handling see OPCUA.Server.Value CROWN.</desc>
                    <serves>
                        <event name="OnWrite">
                            <desc>This event is thrown when a Node of type VARIABLE is written by a OPC UA client. It is not
thrown when a Node is written internally via API function OPCUA.Server.Node.setValue(). If
the write does not change the value, the event is thrown anyway.</desc>
                            <param name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle of the OPC UA Node"/>
                        </event>
                        <function name="create">
                            <desc>Creates a new OPC UA node.</desc>
                            <sample for="lua">handle = OPCUA.Server.Node.create("VARIABLE")</sample>
                            <param name="class" type="enum" ref="NodeClass" desc="Class of the node"/>
                            <return name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle of the OPC UA Node"/>
                        </function>
                        <function name="setID">
                            <desc>Sets the ID of the OPC UA node.</desc>
                            <sample for="lua">OPCUA.Server.Node.setID(handle, "STRING", "MySimpleVariableNode")</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle of the OPC UA Node"/>
                            <param name="type" type="enum" ref="NodeIDType" desc="Which type of ID to use"/>
                            <param name="id" type="auto" desc="The ID. Must be unique within a namespace"/>
                        </function>
                        <function name="setDataType">
                            <desc>Set the data type of the OPC UA node to one of the standard node types. Arbitrary types
can be set by using the function setDataTypeByNode instead. Only applies to nodes of type
VARIABLE or VARIABLE_TYPE.</desc>
                            <sample for="lua">OPCUA.Server.Node.setDataType(handle, "UINT32")</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle of the OPC UA Node"/>
                            <param name="type" type="enum" ref="DataType" desc="The type of this node"/>
                        </function>
                        <function name="setDataTypeByNode">
                            <desc>Set the type of the OPC UA node. For standard node types use the function setDataType
instead. Only applies to nodes of type VARIABLE or VARIABLE_TYPE.</desc>
                            <sample for="lua">OPCUA.Server.Node.setDataTypeByNode(handle, typeNode)</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle of the OPC UA Node"/>
                            <param name="type" type="object" alias="OPCUA.Server.Node" desc="The OPC UA Node which represents the type"/>
                        </function>
                        <function name="setTypeDefinition">
                            <desc>Set the type of the OPC UA node to one of the standard node types. Arbitrary types can be
set by using the function setTypeDefinitionByNode instead.</desc>
                            <sample for="lua">OPCUA.Server.Node.setTypeDefinition(handle, "FOLDER_TYPE")</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle of the OPC UA Node"/>
                            <param name="type" type="enum" ref="NodeType" desc="The type of this node"/>
                        </function>
                        <function name="setTypeDefinitionByNode">
                            <desc>Set the type of the OPC UA node. For standard node types, the function setTypeDefinition
can be used instead.</desc>
                            <sample for="lua">OPCUA.Server.Node.setTypeDefinitionByNode(handle, typeNode)</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle of the OPC UA Node"/>
                            <param name="type" type="object" alias="OPCUA.Server.Node" desc="The OPC UA Node which represents the type"/>
                        </function>
                        <function name="setBrowseName">
                            <desc>Sets the name of the node that is used for browsing.</desc>
                            <sample for="lua">OPCUA.Server.Node.setBrowseName(handle, "MySimpleVariableNode")</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle of the OPC UA Node"/>
                            <param name="browseName" type="string" desc="The browse name to use"/>
                        </function>
                        <function name="setDisplayName">
                            <desc>Sets the name of the node that is used for displaying at clients. Optional. If not called,
BrowseName is used.</desc>
                            <sample for="lua">OPCUA.Server.Node.setDisplayName(handle, "MySimpleVariableNode")</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle of the OPC UA Node"/>
                            <param name="displayName" type="string" desc="The display name to use"/>
                        </function>
                        <function name="setDescription">
                            <desc>Sets the description (explaining text) of the node. Optional. If not called, BrowseName is
used.</desc>
                            <sample for="lua">OPCUA.Server.Node.setDescription(handle, "Description of this node.")</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle of the OPC UA Node"/>
                            <param name="description" type="string" desc="The description text"/>
                        </function>
                        <function name="addReference">
                            <desc>Create a reference from this node to another node. An inverse reference from the target
node to this node is created automatically, if possible. Example: When creating a
reference from folderNode to otherNode with reference type "Organizes", otherNode
automatically gets an inverse reference of type "OrganizedBy" to folderNode.</desc>
                            <sample for="lua">OPCUA.Server.Node.addReference(folderHandle, "ORGANIZES", simpleVariable)</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle of the OPC UA Node"/>
                            <param name="type" type="enum" ref="ReferenceType" desc="Type of the reference between this node and the target node"/>
                            <param name="other" type="object" alias="OPCUA.Server.Node" desc="The target node to which the reference points"/>
                        </function>
                        <function name="getValue">
                            <desc>Gets the current value of the OPC UA node. Only works if NodeClass is VARIABLE or OBJECT.</desc>
                            <sample for="lua">local value = OPCUA.Server.Node.getValue(handle)</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle of the OPC UA Node"/>
                            <return name="value" type="auto" multiplicity="[?*]" desc="The value of the node"/>
                        </function>
                        <function name="getValueHandle">
                            <desc>Gets the current value (a handle for the value) of the OPC UA node. Only works if
NodeClass is VARIABLE or VARIABLE_TYPE.</desc>
                            <sample for="lua">local value = OPCUA.Server.Node.getValueHandle(handle)</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle of the OPC UA Node"/>
                            <return name="value" type="handle" alias="OPCUA.Server.Value" desc="The value of the node"/>
                        </function>
                        <function name="setValue">
                            <desc>Sets the current value of the OPC UA node. Only works if NodeClass is VARIABLE or OBJECT.</desc>
                            <sample for="lua">OPCUA.Server.Node.setValue(handle, 123)</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle of the OPC UA Node"/>
                            <param name="value" type="auto" multiplicity="[1+]" desc="The new value for the node"/>
                        </function>
                        <function name="registerCallbacks">
                            <desc>Register functions that should be called to get or set the value of the OPC UA node.

The getter function has the following signature: no input parameters. Getter returns a value of type OPCUA.Server.Value.
For legacy compatibility it is still possible to return builtin values. It is strongly recommended to return OPCUA.Server.Value,
because legacy behaviour is deprecated and will be removed soon.

The setter function has the following signature: one OPCUA.Server.Value value as input parameter. Setter returns true if value
was set successful, false otherwise. Please note that OPCUA.Server.Value is used to enable setting of complex types (e.g.,
structures or unions).

There is not guarantee on the number of getter/setter callback invocations by internal mechanism. In general, lua callbacks
should not be used for runtime performace crtical features.

This functionality is not available for nodes instantiated via loadNodeSet2File().</desc>
                            <sample for="lua">OPCUA.Server.Node.registerCallbacks(handle, getter, setter)</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle of the OPC UA Node"/>
                            <param name="getter" type="string" alias="function" desc="Name of the Getter function"/>
                            <param name="setter" type="string" alias="function" desc="Name of the Setter function. The function must return a bool value that indicates success (true) or failure (false)"/>
                        </function>
                        <function name="setAccessLevel">
                            <desc>Function to set access level to values of VARIABLE nodes.</desc>
                            <sample for="lua">OPCUA.Server.Node.setAccessLevel(handle, "READ_WRITE")</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle of the OPC UA Node"/>
                            <param name="accessLevel" type="enum" ref="AccessLevel" desc="Access level for the variable"/>
                        </function>
                        <function name="setEnumChoices">
                            <desc>Function to an enum choice to a DATA_TYPE node. Will make the node automatically sub node
of Enumeration type (i=29). The same name must not be given multiple times.</desc>
                            <sample for="lua">OPCUA.Server.Node.setEnumChoices(handle, {"NAME OF THE CHOICE", "NAME OF CHOICE 2"})</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle of the OPC UA Node"/>
                            <param name="value" type="string" multiplicity="+" desc="Name of the choice to add"/>
                        </function>
                        <function name="setMethodBehavior">
                            <desc>This function is used to register a callback that is executed when a client calls the
method. Optionally, it is possible to set one or more return values and parameters for the
method.
Please note that type-correctness of return value types has to be ensured by callback.</desc>
                            <sample for="lua">OPCUA.Server.Node.setMethodBehavior(handle, "callbackFunctionName", {"BOOL"}, {"INT32"}) -- This method takes one INT32 as argument and returns BOOL</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle of the OPC UA Node"/>
                            <param name="callback" type="string" multiplicity="?" alias="function" desc="Function name to call when client calls the method. Is optional, a callback is not needed if this METHOD node is part of an OBJECT_TYPE."/>
                            <param name="returnValues" type="enum" multiplicity="[?*]" ref="DataType" desc="Specifies number and data type of the method return values"/>
                            <param name="parameters" type="enum" multiplicity="[?*]" ref="DataType" desc="Specifies number and data type of method parameters"/>
                        </function>
                        <function name="callMethod">
                            <desc>Call the method on the node</desc>
                            <sample for="lua">OPCUA.Server.Node.callMethod(handle, {paramValueHandle1, paramValueHandle2}) -- This method takes two parameters</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle of the OPC UA Node"/>
                            <param name="parameters" type="object" multiplicity="[?*]" alias="OPCUA.Server.Value" desc="The parameters that should be used for the call. Might be omitted (nil) if there are no parameters."/>
                            <return name="returnValues" type="object" multiplicity="[?*]" alias="OPCUA.Server.Value" desc="The return values of the call. Might be omitted (nil) if there are no return values."/>
                        </function>
                        <function name="createMethodParameters">
                            <desc>Create the default parameters for a method</desc>
                            <sample for="lua">OPCUA.Server.Node.createMethodParameters(handle)</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle of the OPC UA Node"/>
                            <return name="parameters" type="object" multiplicity="[?*]" alias="OPCUA.Server.Value" desc="The return values of the call. Might be omitted (nil) if there are no return values."/>
                        </function>
                        <function name="notifyEvent">
                            <desc>Let the node notify the given event if it is a source of this event. (All Notifier nodes
are informed)</desc>
                            <sample for="lua">OPCUA.Server.Node.notifyEvent(handle, eventTypeNode, "MEDIUM", "demoEvent occurred.")</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle of the OPC UA Node"/>
                            <param name="fireEventType" type="object" alias="OPCUA.Server.Node" desc="Type of the event to be notified (instance of EventType (ObjectType))"/>
                            <param name="severity" type="enum" ref="EventSeverity" desc="How severe is the event to be notified"/>
                            <param name="message" type="string" desc="Message to be transferred (human readable)"/>
                            <param name="parameters" type="object" multiplicity="[?*]" alias="OPCUA.Server.Node" desc="The additional parameters of the event"/>
                        </function>
                        <function name="createEventParameters">
                            <trait>deprecated</trait>
                            <desc>Create the parameters for an event; only works for event type nodes. This function is deprecated and will be removed soon. Use createEventFields() instead.</desc>
                            <sample for="lua">OPCUA.Server.Node.createEventParameters(handle)</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle of the OPC UA Node"/>
                            <return name="parameters" type="object" multiplicity="[?*]" alias="OPCUA.Server.Value" desc="The parameters of the call."/>
                        </function>
                        <function name="setArrayDimensions">
                            <desc>Specify the size of an array. For each dimension of the array, a corresponding value in
the list specifies the length of the dimension. Currently, only one-dimensional arrays are
supported. A data type must be set before setting the dimensions.</desc>
                            <sample for="lua">OPCUA.Server.Node.setArrayDimensions(handle, {3})</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle of the OPC UA Node"/>
                            <param name="dimensions" type="int" multiplicity="+" desc="The dimensions with specified length. If the first dimension is zero, scalar value is used."/>
                        </function>
                        <function name="register">
                            <desc>This function is used to register for any event of the handle.</desc>
                            <param name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle to use"/>
                            <param name="eventname" type="string" desc="The event to register to"/>
                            <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                            <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                        </function>
                        <function name="deregister">
                            <desc>This function is used to deregister from any registered event of the handle.</desc>
                            <param name="handle" type="handle" alias="OPCUA.Server.Node" desc="The instance handle to use"/>
                            <param name="eventname" type="string" desc="The event to deregister from"/>
                            <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                            <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                        </function>
                    </serves>
                </crown>
                <crown name="Value">
                    <trait>released</trait>
                    <desc>The Value crown allows to create, access and modify OPC UA values as specified in OPC UA
specification parts 3, 4 and 6. Values can be
(1) used to set or get the value of OPC UA variable or variable type nodes,
(2) used as parameters to OPC UA method calls,
(3) or used as parameters to OPC UA events.

Values can be
(1) simple, built-in OPC UA data types (e.g., int16, string, an enumeration value),
(2) OPC UA structures containing (optional) named fields,
(3) OPC UA unions,
(4) or arrays of the aforementioned value types.

Fields of a Value are addressed by paths. The empty path "" addresses the current element. All
OPC UA built-in data types are accessed through using an empty path. In structures and unions, fields
have unique names. They can be addressed by their names. Nested fields are separated by dots
("."). Array members are addressed by zero-based indices in brackets ([]).</desc>
                    <enum name="UnionField">
                        <item name="NO_FIELD" desc="NO_FIELD">NO_FIELD</item>
                        <item name="FIELD_1" desc="FIELD_1">FIELD_1</item>
                        <item name="FIELD_2" desc="FIELD_2">FIELD_2</item>
                        <item name="FIELD_3" desc="FIELD_3">FIELD_3</item>
                        <item name="FIELD_4" desc="FIELD_4">FIELD_4</item>
                        <item name="FIELD_5" desc="FIELD_5">FIELD_5</item>
                        <item name="FIELD_6" desc="FIELD_6">FIELD_6</item>
                        <item name="FIELD_7" desc="FIELD_7">FIELD_7</item>
                        <item name="FIELD_8" desc="FIELD_8">FIELD_8</item>
                        <item name="FIELD_9" desc="FIELD_9">FIELD_9</item>
                        <item name="FIELD_10" desc="FIELD_10">FIELD_10</item>
                        <item name="FIELD_11" desc="FIELD_11">FIELD_11</item>
                        <item name="FIELD_12" desc="FIELD_12">FIELD_12</item>
                        <item name="FIELD_13" desc="FIELD_13">FIELD_13</item>
                        <item name="FIELD_14" desc="FIELD_14">FIELD_14</item>
                        <item name="FIELD_15" desc="FIELD_15">FIELD_15</item>
                        <item name="FIELD_16" desc="FIELD_16">FIELD_16</item>
                        <item name="FIELD_17" desc="FIELD_17">FIELD_17</item>
                        <item name="FIELD_18" desc="FIELD_18">FIELD_18</item>
                        <item name="FIELD_19" desc="FIELD_19">FIELD_19</item>
                        <item name="FIELD_20" desc="FIELD_20">FIELD_20</item>
                        <item name="FIELD_21" desc="FIELD_21">FIELD_21</item>
                        <item name="FIELD_22" desc="FIELD_22">FIELD_22</item>
                        <item name="FIELD_23" desc="FIELD_23">FIELD_23</item>
                        <item name="FIELD_24" desc="FIELD_24">FIELD_24</item>
                        <item name="FIELD_25" desc="FIELD_25">FIELD_25</item>
                        <item name="FIELD_26" desc="FIELD_26">FIELD_26</item>
                        <item name="FIELD_27" desc="FIELD_27">FIELD_27</item>
                        <item name="FIELD_28" desc="FIELD_28">FIELD_28</item>
                        <item name="FIELD_29" desc="FIELD_29">FIELD_29</item>
                        <item name="FIELD_30" desc="FIELD_30">FIELD_30</item>
                        <item name="FIELD_31" desc="FIELD_31">FIELD_31</item>
                        <item name="FIELD_32" desc="FIELD_32">FIELD_32</item>
                    </enum>
                    <enum name="OptionalFieldState">
                        <item name="DISABLED" desc="The field is not present">DISABLED</item>
                        <item name="ENABLED" desc="The field ism present">ENABLED</item>
                    </enum>
                    <serves>
                        <function name="getValue">
                            <desc>Get the builtin value(s) contained in the Value instance.</desc>
                            <sample for="lua">local value = OPCUA.Server.Value.getValue(handle, "some_field.an_integer")</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Value" desc="The instance handle of the OPC UA Value"/>
                            <param name="path" type="string" multiplicity="?" desc="The path of the member"/>
                            <return name="value" type="auto" multiplicity="[?*]" desc="The builtin value"/>
                        </function>
                        <function name="setValue">
                            <desc>Sets the builtin value of the Value instance.</desc>
                            <sample for="lua">OPCUA.Server.Value.setValue(handle, 123, "some_field.an_integer")</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Value" desc="The instance handle of the OPC UA Value"/>
                            <param name="value" type="auto" multiplicity="[1+]" desc="The builtin value"/>
                            <param name="path" type="string" multiplicity="?" desc="The path of the member"/>
                        </function>
                        <function name="resizeArray">
                            <desc>Set the new element count of an array</desc>
                            <sample for="lua">OPCUA.Server.Value.resizeArray(handle, 10, "")</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Value" desc="The instance handle of the OPC UA Value"/>
                            <param name="newSize" type="int" desc="The new element count of the array"/>
                            <param name="path" type="string" multiplicity="?" desc="The path of the member"/>
                        </function>
                        <function name="getArrayLength">
                            <desc>Get the current element count of an array</desc>
                            <sample for="lua">OPCUA.Server.Value.getArrayLength(handle, "")</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Value" desc="The instance handle of the OPC UA Value"/>
                            <param name="path" type="string" multiplicity="?" desc="The path of the member to be resized"/>
                            <return name="length" type="int" desc="The current element count of the array or -1 if the selected path is not an array or NULL"/>
                        </function>
                        <function name="setArrayToNull">
                            <desc>Set an array to NULL. (In OPC UA, array can have length 0 OR be null.)</desc>
                            <sample for="lua">OPCUA.Server.Value.setArrayToNull(handle, "")</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Value" desc="The instance handle of the OPC UA Value"/>
                            <param name="path" type="string" multiplicity="?" desc="The path of the member to be nulled"/>
                        </function>
                        <function name="switchUnionField">
                            <desc>Set the field of a union that is active</desc>
                            <sample for="lua">OPCUA.Server.Value.switchUnionField(handle, "FIELD_1", "")</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Value" desc="The instance handle of the OPC UA Value"/>
                            <param name="field" type="enum" ref="UnionField" desc="The field to be set active"/>
                            <param name="path" type="string" multiplicity="?" desc="The path of the member to be activated"/>
                        </function>
                        <function name="getActiveUnionField">
                            <desc>Get the field that is currently active at the union</desc>
                            <sample for="lua">OPCUA.Server.Value.getActiveUnionField(handle, "")</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Value" desc="The instance handle of the OPC UA Value"/>
                            <param name="path" type="string" multiplicity="?" desc="The path of the member"/>
                            <return name="field" type="enum" ref="UnionField" desc="The field that is currently set active"/>
                        </function>
                        <function name="setOptionalFieldState">
                            <desc>Enable / disable an optional field of a structure</desc>
                            <sample for="lua">OPCUA.Server.Value.setOptionalFieldState(handle, "ENABLED", "")</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Value" desc="The instance handle of the OPC UA Value"/>
                            <param name="state" type="enum" ref="OptionalFieldState" desc="The new field state"/>
                            <param name="path" type="string" multiplicity="?" desc="The path of the member to be enabled/ disabled"/>
                        </function>
                        <function name="getOptionalFieldState">
                            <desc>Get the state of an optional structure field</desc>
                            <sample for="lua">OPCUA.Server.Value.getOptionalFieldState(handle, "")</sample>
                            <param name="handle" type="handle" alias="OPCUA.Server.Value" desc="The instance handle of the OPC UA Value"/>
                            <param name="path" type="string" multiplicity="?" desc="The path of the member to be enabled/ disable"/>
                            <return name="state" type="auto" desc="The current state of the field, or nil if field is non-optional."/>
                        </function>
                    </serves>
                </crown>
            </crown>
        </crown>
        <crown name="WebsocketClient">
            <trait>released</trait>
            <desc>Provides Websocket Client functionality.</desc>
            <enum name="WebsocketMessageFormat">
                <desc>Format of a websocket message.</desc>
                <item name="A text message">TEXT</item>
                <item name="A binary message">BINARY</item>
            </enum>
            <serves>
                <event name="OnConnected">
                    <desc></desc>
                    <sample for="lua">WebsocketClient.register(handle, "OnConnected", "OnConnectedFunctionName")</sample>
                    <param name="handle" type="handle" alias="WebsocketClient" desc="The instance handle of the WebsocketClient."/>
                </event>
                <event name="OnDisconnected">
                    <desc></desc>
                    <sample for="lua">WebsocketClient.register(handle, "OnDisconnected", "OnDisconnectedFunctionName")</sample>
                    <param name="handle" type="handle" alias="WebsocketClient" desc="The instance handle of the WebsocketClient."/>
                </event>
                <event name="OnError">
                    <desc></desc>
                    <sample for="lua">WebsocketClient.register(handle, "OnError", "OnErrorFunctionName")</sample>
                    <param name="handle" type="handle" alias="WebsocketClient" desc="The instance handle of the WebsocketClient."/>
                </event>
                <event name="OnReceive">
                    <desc></desc>
                    <sample for="lua">WebsocketClient.register(handle, "OnReceive", "OnReceiveFunctionName")</sample>
                    <param name="handle" type="handle" alias="WebsocketClient" desc="The instance handle of the WebsocketClient."/>
                    <param name="message" type="binary" desc="The received message from the server, which actually sent us the message."/>
                    <param name="format" type="enum" ref="WebsocketMessageFormat" desc="Message format."/>
                </event>
                <function name="create">
                    <desc>Creates a WebsocketClient handle.</desc>
                    <sample for="lua">handle = WebsocketClient.create()</sample>
                    <return name="handle" type="handle" alias="WebsocketClient" desc="The instance handle of the WebsocketClient."/>
                </function>
                <function name="addHeader">
                    <desc>Adds a HTTP header field to the HTTP request that is sent to establish the Websocket connection. There may be multiple header fields with the same key.</desc>
                    <sample for="lua">WebsocketClient.addHeader(handle, "Authorization", "Basic aTjDoe8g2==")</sample>
                    <param name="handle" type="handle" alias="WebsocketClient" desc="The instance handle of the WebsocketClient."/>
                    <param name="key" type="string" desc="Key of the header field."/>
                    <param name="value" type="string" desc="Value of the header field."/>
                </function>
                <function name="connect">
                    <desc>Open the connection to the server. setURL must be called before connect can be called. The OnConnected and OnDisconnected events are thrown when the connection gets connected or disconnected. Important: Connection is not re-established automatically if connecting fails or connection gets lost later. This should be done manually using a Timer instead.</desc>
                    <sample for="lua">WebsocketClient.connect(handle)</sample>
                    <param name="handle" type="handle" alias="WebsocketClient" desc="The instance handle of the WebsocketClient."/>
                    <param name="timeout" type="int" multiplicity="?" desc="The timeout to wait initially until the client gets connected. If not set, 5000ms is the default."/>
                    <return name="success" type="bool" desc="True if successfully connected. False if configuration isn't valid"/>
                </function>
                <function name="disconnect">
                    <desc>Close the connection to the server.</desc>
                    <sample for="lua">WebsocketClient.disconnect(handle)</sample>
                    <param name="handle" type="handle" alias="WebsocketClient" desc="The instance handle of the WebsocketClient."/>
                </function>
                <function name="setURL">
                    <desc>Sets the URL of the Websocket server which is to be contacted. Mandatory call.</desc>
                    <sample for="lua">WebsocketClient.setURL(handle, "ws://192.168.0.1:8080")</sample>
                    <param name="handle" type="handle" alias="WebsocketClient" desc="The instance handle of the WebsocketClient."/>
                    <param name="url" type="string" desc="URL in the format ws://[hostname]:[port]/[application specific path]. "/>
                </function>
                <function name="transmit">
                    <desc>Send data to the server.</desc>
                    <sample for="lua">WebsocketClient.transmit(handle, "My Example Message.")</sample>
                    <param name="handle" type="handle" alias="WebsocketClient" desc="The instance handle of the WebsocketClient."/>
                    <param name="message" type="binary" desc="The message to be sent to the server."/>
                    <param name="format" type="enum" multiplicity="?" ref="WebsocketMessageFormat" desc="Message format."/>
                    <return name="success" type="bool" desc="True if the data could be successfully sent to the server."/>
                </function>
                <function name="isConnected">
                    <desc>Returns true if the client is connected.</desc>
                    <sample for="lua">bConnected = WebsocketClient.isConnected(handle)</sample>
                    <param name="handle" type="handle" alias="WebsocketClient" desc="The instance handle of the WebsocketClient."/>
                    <return name="isConnected" type="bool" desc="True if the client is connected"/>
                </function>
                <function name="register">
                    <desc>This function is used to register for any event of the handle.</desc>
                    <param name="handle" type="handle" alias="WebsocketClient" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to register to"/>
                    <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                    <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                </function>
                <function name="deregister">
                    <desc>This function is used to deregister from any registered event of the handle.</desc>
                    <param name="handle" type="handle" alias="WebsocketClient" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to deregister from"/>
                    <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                    <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                </function>
            </serves>
        </crown>
        <crown name="HTTPClient">
            <trait>released</trait>
            <desc>Provides HTTP/HTTPS client functionality.</desc>
            <serves>
                <function name="create">
                    <desc>Creates a HTTPClient handle.</desc>
                    <sample for="lua">handle = HTTPClient.create()</sample>
                    <return name="handle" type="handle" alias="HTTPClient" desc="The instance handle of the HTTPClient."/>
                </function>
                <function name="setInterface">
                    <desc>Sets the interface to be used for connecting.</desc>
                    <sample for="lua">HTTPClient.setInterface(handle, "ETH1")</sample>
                    <param name="handle" type="handle" alias="HTTPClient" desc=""/>
                    <param name="ifName" type="enum" ref="EthernetInterfaces" desc="One of the available interfaces."/>
                </function>
                <function name="setProxy">
                    <desc>Configures a proxy server to be used for the HTTP connections.</desc>
                    <sample for="lua">HTTPClient.setProxy(handle, "http://my.proxy", 8080)</sample>
                    <param name="handle" type="handle" alias="HTTPClient" desc="The instance handle of the HTTPClient."/>
                    <param name="url" type="string" desc="Proxy URL in the format [protocol]://[hostname], e.g. http://my-proxy.domain.de"/>
                    <param name="port" type="int" desc="Proxy port number"/>
                </function>
                <function name="setProxyAuth">
                    <desc>Configures the proxy authentification settings to be used for the HTTP connections.</desc>
                    <sample for="lua">HTTPClient.setProxyAuth(handle, "username", "password")</sample>
                    <param name="handle" type="handle" alias="HTTPClient" desc="The instance handle of the HTTPClient."/>
                    <param name="username" type="string" desc="Username for the proxy."/>
                    <param name="password" type="string" desc="Password for the proxy."/>
                </function>
                <function name="setClientCertificate">
                    <desc>Enables client authentication. A client certificate and a private key must be provided. The passphrase for the private key is optional. Supported file formats are PEM, DER and PKCS#12 (depending on SSL engine) for the client certificate and PEM and DER for the private key. The format is selected by inspecting the extension of the provided file. If no valid extension is specified the engine defaults to PEM format.</desc>
                    <sample for="lua">HTTPClient.setClientCertificate(handle, "private/cert.pem", "private/privateKey.pem", "mypassphrase")</sample>
                    <param name="handle" type="handle" alias="HTTPClient" desc="The instance handle of the HTTPClient."/>
                    <param name="certificateFile" type="string" desc="Path to a certificate file in PEM/DER/PKCS#12 format."/>
                    <param name="keyFile" type="string" desc="Path to file containing the client's private key in PEM/DER format."/>
                    <param name="passphrase" type="string" multiplicity="?" desc="Optional passphrase for the private key."/>
                </function>
                <function name="setCABundle">
                    <desc>Configures the certificate authority bundle to be used for verifying server certificates.</desc>
                    <sample for="lua">HTTPClient.setCABundle(handle, "private/CA.pem")</sample>
                    <param name="handle" type="handle" alias="HTTPClient" desc="The instance handle of the HTTPClient."/>
                    <param name="bundleFile" type="string" desc="Path to a certificate bundle in PEM format."/>
                </function>
                <function name="setCookieStore">
                    <desc>Enables cookie handling and configures a file to be used as local cookie storage. Received cookies are stored in the file and when performing a request, valid cookies matching the server domain will be read from it.</desc>
                    <sample for="lua">HTTPClient.setCookieStore(handle, "private/cookies.txt")</sample>
                    <param name="handle" type="handle" alias="HTTPClient" desc="The instance handle of the HTTPClient."/>
                    <param name="cookieFile" type="string" desc="Path to file where the client's cookies should be stored."/>
                </function>
                <function name="setPeerVerification">
                    <desc>Enables/disables peer verification. This can be useful when connecting to a site that is not using a certificate signed by one of the certs in the CA bundle. Disabling this verification makes the connection A LOT LESS SECURE.</desc>
                    <sample for="lua">HTTPClient.setPeerVerification(handle, false)</sample>
                    <param name="handle" type="handle" alias="HTTPClient" desc="The instance handle of the HTTPClient."/>
                    <param name="enabled" type="bool" desc="True to enable peer verification, false to disable. Default is enabled."/>
                </function>
                <function name="setHostnameVerification">
                    <desc>Enables/disables hostname verification. This can be useful if the site to connect to uses a different host name than what is mentioned in the server certificate commonName (or subjectAltName) fields. Disabling this verification makes the connection less secure.</desc>
                    <sample for="lua">HTTPClient.setHostnameVerification(handle, false)</sample>
                    <param name="handle" type="handle" alias="HTTPClient" desc="The instance handle of the HTTPClient."/>
                    <param name="enabled" type="bool" desc="True to enable hostname verification, false to disable. Default is enabled."/>
                </function>
                <function name="setTimeout">
                    <desc>Sets the timeout for execution of HTTP requests in milliseconds. Default is 5000 milliseconds. If a host name is used instead of an IP address, the time needed to resolve the hostname via DNS is not subject to the timeout.</desc>
                    <sample for="lua">HTTPClient.setTimeout(handle, 5000)</sample>
                    <param name="handle" type="handle" alias="HTTPClient" desc="The instance handle of the HTTPClient."/>
                    <param name="timeout" type="int" desc="Timeout in milliseconds."/>
                </function>
                <function name="setVerbose">
                    <trait>hidden</trait>
                    <desc>Enables/disable the verbose mode which prints a lot of debug information on the console during the execution of a request.</desc>
                    <sample for="lua">HTTPClient.setVerbose(handle, true)</sample>
                    <param name="handle" type="handle" alias="HTTPClient" desc="The instance handle of the HTTPClient."/>
                    <param name="enabled" type="bool" desc="True to enable verbose mode, false to disable. Default is disabled."/>
                </function>
                <function name="execute">
                    <desc>Execute a HTTP/HTTPS request synchronously</desc>
                    <sample for="lua">HTTPClient.execute(handle)</sample>
                    <param name="handle" type="handle" alias="HTTPClient" desc="The instance handle of the HTTPClient."/>
                    <param name="request" type="object" alias="HTTPClient.Request" desc="Instance handle of the request to execute."/>
                    <return name="response" type="object" alias="HTTPClient.Response" desc="Instance handle of the response."/>
                </function>
            </serves>
            <crown name="Request">
                <trait>released</trait>
                <desc>Encapsulates the properties of a HTTP/HTTPS request.</desc>
                <enum name="HTTPMethodType">
                    <item name="GET" desc="GET">GET</item>
                    <item name="POST" desc="POST">POST</item>
                    <item name="HEAD" desc="HEAD">HEAD</item>
                    <item name="PUT" desc="PUT">PUT</item>
                    <item name="PATCH" desc="PATCH">PATCH</item>
                    <item name="DELETE" desc="DELETE">DELETE</item>
                    <item name="TRACE" desc="TRACE">TRACE</item>
                    <item name="OPTIONS" desc="OPTIONS">OPTIONS</item>
                </enum>
                <serves>
                    <function name="create">
                        <desc>Creates a request handle.</desc>
                        <sample for="lua">handle = HTTPClient.Request.create()</sample>
                        <return name="handle" type="handle" alias="HTTPClient.Request" desc="The instance handle of the request."/>
                    </function>
                    <function name="setMethod">
                        <desc>Sets the HTTP method to be used.</desc>
                        <sample for="lua">HTTPClient.Request.setMethod(handle, "GET")</sample>
                        <param name="handle" type="handle" alias="HTTPClient.Request" desc="The instance handle of the request."/>
                        <param name="method" type="enum" ref="HTTPMethodType" desc="Method type to be used."/>
                    </function>
                    <function name="setURL">
                        <desc>Sets the URL of the HTTP server which is to be contacted.</desc>
                        <sample for="lua">HTTPClient.Request.setURL(handle, "http://www.google.de")</sample>
                        <param name="handle" type="handle" alias="HTTPClient.Request" desc="The instance handle of the request."/>
                        <param name="url" type="string" desc="URL in the format [protocol]://[hostname]. The protocol can be 'http' or 'https'."/>
                    </function>
                    <function name="setPort">
                        <desc>Sets the port to be used for connecting to the HTTP server.</desc>
                        <sample for="lua">HTTPClient.Request.setPort(handle, 8080)</sample>
                        <param name="handle" type="handle" alias="HTTPClient.Request" desc="The instance handle of the request"/>
                        <param name="port" type="int" desc="Port to connect to. Defaults to 80 for HTTP and 443 for HTTPS."/>
                    </function>
                    <function name="setContentType">
                        <desc>Sets the content type.</desc>
                        <sample for="lua">HTTPClient.Request.setContentType(handle, "application/json")</sample>
                        <param name="handle" type="handle" alias="HTTPClient.Request" desc="The instance handle of the request."/>
                        <param name="contentType" type="string" desc="Content mime-type specifier as described in RFC 2045/2046."/>
                    </function>
                    <function name="setContentBuffer">
                        <desc>Sets the content payload from a buffer.</desc>
                        <sample for="lua">HTTPClient.Request.setContentBuffer(handle, "{}")</sample>
                        <param name="handle" type="handle" alias="HTTPClient.Request" desc="The instance handle of the request."/>
                        <param name="content" type="binary" desc="Binary or string containing the payload. The payload format must match the mime-type configured as content type."/>
                    </function>
                    <function name="setContentFile">
                        <desc>Sets the content payload from a file.</desc>
                        <sample for="lua">HTTPClient.Request.setContentFile(handle, "private/content.json")</sample>
                        <param name="handle" type="handle" alias="HTTPClient.Request" desc="The instance handle of the request."/>
                        <param name="file" type="string" desc="Path to a file with the content that should be transferred as HTTP request payload."/>
                    </function>
                    <function name="addHeader">
                        <desc>Adds a header field to the request. There may be multiple header fields with the same key.</desc>
                        <sample for="lua">HTTPClient.Request.addHeader(handle, "Authorization", "Basic aTjDoe8g2==")</sample>
                        <param name="handle" type="handle" alias="HTTPClient.Request" desc="The instance handle of the request."/>
                        <param name="key" type="string" desc="Key of the header field."/>
                        <param name="value" type="string" desc="Value of the header field."/>
                    </function>
                </serves>
            </crown>
            <crown name="Response">
                <trait>released</trait>
                <desc>Encapsulates a HTTP response.</desc>
                <serves>
                    <function name="create">
                        <desc>Creates a response handle. Typically, response objects are returned by the HTTPClient.execute() function.</desc>
                        <sample for="lua">handle = HTTPClient.Response.create()</sample>
                        <return name="handle" type="handle" alias="HTTPClient.Response" desc="The instance handle of the response."/>
                    </function>
                    <function name="getSuccess">
                        <desc>Checks if the request was successful.</desc>
                        <sample for="lua">success = HTTPClient.Response.getSuccess(handle)</sample>
                        <param name="handle" type="handle" alias="HTTPClient.Response" desc="The instance handle of the response."/>
                        <return name="success" type="bool" desc="True if the request was successful, false if not. Refer to the getError() and getErrorDetail() methods in case of failure."/>
                    </function>
                    <function name="getError">
                        <desc>Retrieves the error message describing the cause of the failure. If the request was successful (getSuccess() == true) this property is an empty string.</desc>
                        <sample for="lua">error = HTTPClient.Response.getError(handle)</sample>
                        <param name="handle" type="handle" alias="HTTPClient.Response" desc="The instance handle of the response."/>
                        <return name="message" type="string" desc="Error message describing the cause of the failure or an empty string if the request was successful."/>
                    </function>
                    <function name="getErrorDetail">
                        <desc>Retrieves an informational message describing the details of the error.</desc>
                        <sample for="lua">errorDetail = HTTPClient.Response.getErrorDetail(handle)</sample>
                        <param name="handle" type="handle" alias="HTTPClient.Response" desc="The instance handle of the response."/>
                        <return name="message" type="string" desc="Error message describing details of the failure."/>
                    </function>
                    <function name="getStatusCode">
                        <desc>Retrieves the HTTP status code returned by the server.</desc>
                        <sample for="lua">code = HTTPClient.Response.getStatusCode(handle)</sample>
                        <param name="handle" type="handle" alias="HTTPClient.Response" desc="The instance handle of the response."/>
                        <return name="statusCode" type="int" desc="HTTP status code as specified in RFC 2616."/>
                    </function>
                    <function name="getContentType">
                        <desc>Retrieves the Content-Type property of the content sent by the server.</desc>
                        <sample for="lua">contentType = HTTPClient.Response.getContentType(handle)</sample>
                        <param name="handle" type="handle" alias="HTTPClient.Response" desc="The instance handle of the response."/>
                        <return name="contentType" type="string" desc="Mime-type describing the content type of the response payload."/>
                    </function>
                    <function name="getContent">
                        <desc>Retrieves the content payload of the response as binary.</desc>
                        <sample for="lua">content = HTTPClient.Response.getContent(handle)</sample>
                        <param name="handle" type="handle" alias="HTTPClient.Response" desc="The instance handle of the response."/>
                        <return name="content" type="binary" desc="Content payload as binary."/>
                    </function>
                    <function name="getHeaderKeys">
                        <desc>Retrieves the list of header keys in the response.</desc>
                        <sample for="lua">keys = HTTPClient.Response.getHeaderKeys(handle)</sample>
                        <param name="handle" type="handle" alias="HTTPClient.Response" desc="The instance handle of the response."/>
                        <return name="headerKeys" type="string" multiplicity="*" desc="List of header keys."/>
                    </function>
                    <function name="getHeaderValues">
                        <desc>Retrieves the values for a given header entry in the response. There may be multiple values for a single entry.</desc>
                        <sample for="lua">success, values = HTTPClient.Response.getHeaderValues(handle, "Authorization")</sample>
                        <param name="handle" type="handle" alias="HTTPClient.Response" desc="The instance handle of the response."/>
                        <param name="key" type="string" desc="Key of the entry to retrieve."/>
                        <return name="success" type="bool" desc="True if the key exists, false if not."/>
                        <return name="value" type="string" multiplicity="*" desc="The values of the header entry or an empty list if the key didn't exist."/>
                    </function>
                </serves>
            </crown>
        </crown>
        <crown name="IOLink">
            <trait>released</trait>
            <desc>Namespace for IOLink functionality.</desc>
            <crown name="RemoteDevice">
                <trait>released</trait>
                <desc>IOLink master function to control one connected device per IOLink port.

Limitations:
- It is not possible to load IODD files
- Data Storage is not supported</desc>
                <enum name="ReturnCodes">
                    <item name="Result success" desc="Service has been started successfully">RESULT_SUCCESS</item>
                    <item name="Result state conflict" desc="The command cannot be executed in the actual state">RESULT_STATE_CONFLICT</item>
                    <item name="Result not supported" desc="The service is not supported by the sensor because it does not support ISDU transfer">RESULT_NOT_SUPPORTED</item>
                    <item name="Result service pending" desc="The service cannot be started because another acyclic service is running">RESULT_SERVICE_PENDING</item>
                    <item name="Result wrong parameter" desc="One of the function parameters is invalid">RESULT_WRONG_PARAMETER</item>
                    <item name="Error" desc="Error in the driver: Connection problem or data sent/received invalid">ERROR</item>
                </enum>
                <enum name="ProcessDataValidity">
                    <item name="Process values valid">PI_STATUS_VALID</item>
                    <item name="Process values invalid">PI_STATUS_INVALID</item>
                    <item name="Error reading process data">ERROR</item>
                </enum>
                <serves>
                    <event name="OnDisconnected">
                        <desc>The OnDisconnected event which is thrown if a IOLink slave device was disconnected.</desc>
                        <sample for="lua">IOLink.RemoteDevice.register(handle, "OnDisconnected", "OnSensorDisconnected")</sample>
                        <param name="handle" type="handle" alias="IOLink.RemoteDevice" desc="Unique handle to the IOLink.RemoteDevice instance"/>
                    </event>
                    <event name="OnConnected">
                        <desc>The OnConnected event which is thrown if a IOLink slave device was connected.</desc>
                        <sample for="lua">IOLink.RemoteDevice.register(handle, "OnConnected", "OnSensorConnected")</sample>
                        <param name="handle" type="handle" alias="IOLink.RemoteDevice" desc="Unique handle to the IOLink.RemoteDevice instance"/>
                    </event>
                    <event name="OnPowerFault">
                        <desc>The OnPowerFault event which is thrown if a IOLink slave device was disconnected.</desc>
                        <sample for="lua">IOLink.RemoteDevice.register(handle, "OnPowerFault", "OnSensorPowerFault")</sample>
                        <param name="handle" type="handle" alias="IOLink.RemoteDevice" desc="Unique handle to the IOLink.RemoteDevice instance"/>
                    </event>
                    <function name="create">
                        <desc>Creates a new IOLink.RemoteDevice instance if exists and not already in use. Stays active as long as this handle exists.</desc>
                        <sample for="lua">handle = IOLink.RemoteDevice.create("S1")</sample>
                        <param name="port" type="enum" ref="IOLinkMasterPorts" desc="Specifies the IOLink port."/>
                        <return name="handle" type="handle" multiplicity="?" alias="IOLink.RemoteDevice" desc="Unique handle to the IOLink.RemoteDevice instance. Nil if not available or already in use."/>
                    </function>
                    <function name="register">
                        <desc>This function is used to register for any event of the handle.</desc>
                        <param name="handle" type="handle" alias="IOLink.RemoteDevice" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to register to"/>
                        <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                        <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                    </function>
                    <function name="deregister">
                        <desc>This function is used to deregister from any registered event of the handle.</desc>
                        <param name="handle" type="handle" alias="IOLink.RemoteDevice" desc="The instance handle to use"/>
                        <param name="eventname" type="string" desc="The event to deregister from"/>
                        <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                        <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                    </function>
                    <function name="readProcessData">
                        <desc>This function is used to read the cyclic process data from the IOLink.RemoteDevice.
The process data of the devices are transmitted cyclically in a data frame in which the size of the process data is specified by the device.</desc>
                        <sample for="lua">data, status = IOLink.RemoteDevice.readProcessData(handle)</sample>
                        <param name="handle" type="handle" alias="IOLink.RemoteDevice" desc="Unique handle to the IOLink.RemoteDevice instance"/>
                        <return name="data" type="binary" desc="Process data from the device, binary object"/>
                        <return name="processDataValid" type="enum" ref="ProcessDataValidity" desc="Return status of function call."/>
                    </function>
                    <function name="writeProcessData">
                        <desc>This function is used to write the cyclic process data to the IOLink.RemoteDevice.
The process data of the devices are transmitted cyclically in a data frame in which the size of the process data is specified by the device.</desc>
                        <sample for="lua">IOLink.RemoteDevice.writeProcessData(handle, data)</sample>
                        <param name="handle" type="handle" alias="IOLink.RemoteDevice" desc="Unique handle to the IOLink.RemoteDevice instance"/>
                        <param name="data" type="binary" desc="Process data from the device, binary object"/>
                    </function>
                    <function name="readData">
                        <desc>This function is used to read data (e.g. parameters) from the IOLink.RemoteDevice.
Device data can be parameters, identification data, and diagnostic information. They are exchanged acyclically and at the request
of the IO-Link master. Device data can be written to the device (Write) and also read from the device (Read). Acyclic data, such as device
parameters or events, are exchanged using a specified index and sub-index range. The controller accesses these using system mechanisms
(e.g., in the case of online functions such as the reading out of the status). The use of the index and sub-index ranges allows a targeted
access to the device data (e.g., for reassigning the device or master parameters during operation).</desc>
                        <sample for="lua">data, status = IOLink.RemoteDevice.readData(handle, index, subIndex)</sample>
                        <param name="handle" type="handle" alias="IOLink.RemoteDevice" desc="Unique handle to the IOLink.RemoteDevice instance"/>
                        <param name="index" type="int" desc="Index of data to read"/>
                        <param name="subIndex" type="int" desc="Sub index of data to read"/>
                        <return name="data" type="binary" desc="Data"/>
                        <return name="returnCode" type="enum" ref="ReturnCodes" desc="Return status of function call."/>
                    </function>
                    <function name="writeData">
                        <desc>This function is used to write data (e.g. parameters) to the IOLink.RemoteDevice.
Device data can be parameters, identification data, and diagnostic information. They are exchanged acyclically and at the request
of the IO-Link master. Device data can be written to the device (Write) and also read from the device (Read). Acyclic data, such as device
parameters or events, are exchanged using a specified index and sub-index range. The controller accesses these using system mechanisms
(e.g., in the case of online functions such as the reading out of the status). The use of the index and sub-index ranges allows a targeted
access to the device data (e.g., for reassigning the device or master parameters during operation).</desc>
                        <sample for="lua">status = IOLink.RemoteDevice.writeData(handle, index, subIndex, data)</sample>
                        <param name="handle" type="handle" alias="IOLink.RemoteDevice" desc="Unique handle to the IOLink.RemoteDevice instance"/>
                        <param name="index" type="int" desc="Index of data to write"/>
                        <param name="subIndex" type="int" desc="Sub index of data to write"/>
                        <param name="data" type="binary" desc="Data"/>
                        <return name="returnCode" type="enum" ref="ReturnCodes" desc="Return status of function call."/>
                    </function>
                    <function name="getProductName">
                        <desc>This function is used to get the product name of the IOLink.RemoteDevice.</desc>
                        <sample for="lua">name, status = IOLink.RemoteDevice.getProductName(handle)</sample>
                        <param name="handle" type="handle" alias="IOLink.RemoteDevice" desc="Unique handle to the IOLink.RemoteDevice instance"/>
                        <return name="data" type="string" desc="Product name of the connected slave device."/>
                        <return name="returnCode" type="enum" ref="ReturnCodes" desc="Return status of function call."/>
                    </function>
                    <function name="readEMCCounter">
                        <trait>hidden</trait>
                        <desc>This function is used to read the EMC counter from the IOLink.RemoteDevice.</desc>
                        <sample for="lua">cycleCounter, retryCounter, abortCounter, status = IOLink.RemoteDevice.readEMCCounter(handle, reset)</sample>
                        <param name="handle" type="handle" alias="IOLink.RemoteDevice" desc="Unique handle to the IOLink.RemoteDevice instance"/>
                        <param name="reset" type="bool" desc="if true the counter values are reset by the function call"/>
                        <return name="cycleCounter" type="int" desc="Cycle counter"/>
                        <return name="retryCounter" type="int" desc="Retry counter"/>
                        <return name="abortCounter" type="int" desc="Abort counter"/>
                        <return name="returnCode" type="enum" ref="ReturnCodes" desc="Return status of function call."/>
                    </function>
                </serves>
            </crown>
        </crown>
        <crown name="SensorNetwork">
            <trait>released</trait>
            <desc>Offers inter-device communication to the application.
The available data transport possibilities are application specific and cover all application functionality of the SICK SensorNetwork on CAN-Bus.</desc>
            <enum name="MonitoringState">
                <item>DISABLE</item>
                <item>ENABLE</item>
            </enum>
            <enum name="MasterSlaveArrangement">
                <item>MASTER</item>
                <item>SLAVE</item>
            </enum>
            <enum name="MultiplexerArrangement">
                <item>MULTIPLEXER</item>
                <item>CLIENT</item>
            </enum>
            <enum name="TimeSyncState">
                <desc>deprecated; replaced by TimeSyncUtcState and TimeSyncHighPrecState</desc>
                <item>DISABLE</item>
                <item>SERVER</item>
                <item>CLIENT</item>
                <item>CONTINUOUS_CLOCK</item>
            </enum>
            <enum name="TimeSyncUtcState">
                <item>DISABLE</item>
                <item>SERVER</item>
                <item>CLIENT</item>
            </enum>
            <enum name="TimeSyncHighPrecState">
                <item>DISABLE</item>
                <item>SERVER</item>
                <item>CLIENT</item>
            </enum>
            <enum name="TriggerState">
                <item>OBJ_TRIG_ON</item>
                <item>OBJ_TRIG_OFF</item>
                <item>CLUSTER_TRIG_ON</item>
                <item>CLUSTER_TRIG_OFF</item>
                <item>SYSTEM_TRIG_ON</item>
                <item>SYSTEM_TRIG_OFF</item>
                <item>TRAY_TRIG_ON</item>
                <item>TRAY_TRIG_OFF</item>
            </enum>
            <enum name="IncrementMode">
                <item>DISABLE</item>
                <item>TRANSMIT</item>
                <item>RECEIVE</item>
            </enum>
            <enum name="ImageOutputRequestMode">
                <item>DISABLE</item>
                <item>TRANSMIT</item>
                <item>RECEIVE</item>
            </enum>
            <enum name="CleanupCommandMode">
                <item>DISABLE</item>
                <item>TRANSMIT</item>
                <item>RECEIVE</item>
            </enum>
            <enum name="VmsIndicationMode">
                <item>DISABLE</item>
                <item>RECEIVE</item>
            </enum>
            <serves>
                <event name="OnCodeData">
                    <desc>The on code result event which is thrown for every new received code data.</desc>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="This is a handle event and must be registered on the handle"/>
                    <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                </event>
                <event name="OnBinaryData">
                    <desc>The on code result string event which is thrown for every new received multiplexer code data string.</desc>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="This is a handle event and must be registered on the handle"/>
                    <param name="serverData" type="binary" desc="The server data"/>
                </event>
                <event name="OnConnected">
                    <desc>The on device connected event which is thrown for every connect of a network device.</desc>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="This is a handle event and must be registered on the handle"/>
                    <param name="deviceConnected" type="int" desc="Device ID of the connected device."/>
                    <param name="deviceError" type="int" desc="Error flags of the device."/>
                </event>
                <event name="OnDisconnected">
                    <desc>The on device disconnected event which is thrown for every disconnect of a network device.</desc>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="This is a handle event and must be registered on the handle"/>
                    <param name="deviceDisconnected" type="int" desc="Device ID of the disconnected device."/>
                </event>
                <event name="OnError">
                    <desc>The on device error which is thrown for every error change of a network device.</desc>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="This is a handle event and must be registered on the handle"/>
                    <param name="deviceId" type="int" desc="Device ID of the device."/>
                    <param name="deviceError" type="int" desc="Error flags of the device."/>
                </event>
                <event name="OnImageOutputRequest">
                    <links>SensorNetwork.setImageOutputRequestMode, SensorNetwork.sendImageOutputRequest</links>
                    <desc>The image output request event which is thrown for every request from the controller. For this event to work, the function SensorNetwork.setImageOutputRequestMode needs to be used to set imageOutputRequestMode to RECEIVE.</desc>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="This is a handle event and must be registered on the handle"/>
                    <param name="imageRequestObjectNumber" type="int" desc="The object number for the image output request"/>
                    <param name="imageRequestFileName" type="string" desc="File name the image provider must use for the output image"/>
                    <param name="imageRequestFilePath" type="string" desc="Destination path where image file must be stored "/>
                    <param name="imageRequestFileOperation" type="string" desc="File handling on server side: OP_COPY/OP_DELETE/OP_NONE"/>
                    <param name="imageRequestDeviceSelection" type="int" desc="Binary device selection code 0x01=TOP/BOTTOM/LEFT/RIGHT/FRONT/REAR/0x3F=ALL"/>
                </event>
                <event name="OnObjectIdentification">
                    <links>SensorNetwork.setImageOutputRequestMode, SensorNetwork.sendObjectIdentification</links>
                    <desc>The object identification event with the custom id string. For this event to work, the function SensorNetwork.setImageOutputRequestMode needs to be used to set imageOutputRequestMode to RECEIVE.</desc>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="This is a handle event and must be registered on the handle"/>
                    <param name="identificationStringObjectNumber" type="int" desc="The object number for the identification string"/>
                    <param name="objectIdentificationString" type="string" desc="The object identification string (customer ID string)"/>
                </event>
                <event name="OnCustomData">
                    <links>SensorNetwork.setImageOutputRequestMode, SensorNetwork.sendCustomData</links>
                    <desc>The event with the custom data string. For this event to work, the function SensorNetwork.setImageOutputRequestMode needs to be used to set imageOutputRequestMode to RECEIVE.</desc>
                    <sample for="lua">SensorNetwork.register(handle, "OnCustomData", "onNewCustomData")</sample>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="This is a handle event and must be registered on the handle"/>
                    <param name="customDataStringObjectNumber" type="int" desc="The object number for the custom data string"/>
                    <param name="customDataString" type="string" desc="The object identification string (customer ID string)"/>
                </event>
                <event name="OnTrigger">
                    <desc>Incoming object trigger from trigger master. See setTriggerSource().</desc>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="This is a handle event and must be registered on the handle"/>
                    <param name="triggerState" type="enum" ref="TriggerState" desc="The trigger state"/>
                    <param name="objectNumber" type="int" desc="Object number"/>
                    <param name="trayNumber" type="int" desc="Tray number; optional, if empty the object number will be used"/>
                    <param name="incrementValue" type="int" desc="Increment Value"/>
                </event>
                <event name="OnCleanupCommand">
                    <desc>The on Cleanup Command event which is thrown for every reveive of a cleanup command</desc>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="This is a handle event and must be registered on the handle"/>
                </event>
                <event name="OnVmsIndication">
                    <desc>The on VMS indication event which is thrown for every reveive of a VMS indication PDO</desc>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="This is a handle event and must be registered on the handle"/>
                </event>
                <function name="create">
                    <desc>Creates a new SensorNetwork instance. Stays active as long as this handle exists.</desc>
                    <sample for="lua">handle = SensorNetwork.create("CAN1")</sample>
                    <param name="network" type="enum" ref="SensorNetworks" desc="The demanded network."/>
                    <return name="handle" type="handle" multiplicity="?" alias="SensorNetwork" desc="The instance handle of the network"/>
                </function>
                <function name="register">
                    <desc>This function is used to register for any event of the handle.</desc>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to register to"/>
                    <param name="callback" type="string" alias="function" desc="The function name to call on the event occurrence"/>
                    <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                </function>
                <function name="deregister">
                    <desc>This function is used to deregister from any registered event of the handle.</desc>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to deregister from"/>
                    <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                    <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                </function>
                <function name="sendBinaryData">
                    <desc>Send data to the network.</desc>
                    <sample for="lua">SensorNetwork.sendBinaryData(handle,"This is an example.")</sample>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="The instance handle of the network"/>
                    <param name="data" type="binary" desc="The data which is to be transmitted"/>
                </function>
                <function name="sendTrigger">
                    <desc>Send a trigger PDO</desc>
                    <sample for="lua">SensorNetwork.sendTrigger(handle, "OBJ_TRIG_ON", objectNumber")</sample>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="The instance handle of the network"/>
                    <param name="triggerState" type="enum" ref="TriggerState" desc="The trigger state"/>
                    <param name="objectNumber" type="int" desc="Object number (max. 1023). Caution: While it is possible to send larger numbers, some devices like Lector6xx and CLV can only deal with object numbers up to 1023."/>
                    <param name="trayNumber" type="int" multiplicity="?" desc="Tray number; optional, if empty the object number will be used"/>
                    <param name="incrementValue" type="int" multiplicity="?" desc="Increment Value; optional, if empty the current increment value will be used"/>
                    <return name="success" type="bool" desc="If true, the trigger was sent successfully."/>
                </function>
                <function name="setConfig">
                    <desc>Applies the configuration to the sensor network.</desc>
                    <sample for="lua">success = SensorNetwork.setConfig(handle, config)</sample>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="The instance handle of the network"/>
                    <param name="configHandle" type="object" desc="Handle of config instance to apply."/>
                    <return name="success" type="bool" desc="If true, the configuration was set successfully and the sensor network is configured."/>
                </function>
                <function name="setMonitoring">
                    <desc>Sets the network monitoring state.</desc>
                    <sample for="lua">success = SensorNetwork.setMonitoring(handle, "ENABLE")</sample>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="The instance handle of the network"/>
                    <param name="monitorState" type="enum" ref="MonitoringState" desc="The network monitor state (DISABLE/ENABLE)."/>
                    <param name="slaveSet" type="auto" multiplicity="[?*]" desc="Flexible parameter to set the slave set. Could be a string containing a SOPAS-like comma-separated list, or a vector of ints."/>
                    <return name="success" type="bool" desc="If true, the property was set successfully."/>
                </function>
                <function name="setTimeSync">
                    <trait>deprecated</trait>
                    <desc>Sets the time sync framing which is to be used.</desc>
                    <sample for="lua">success = SensorNetwork.setTimeSync(handle, "SERVER", 600)</sample>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="The instance handle of the network"/>
                    <param name="timeSyncState" type="enum" ref="TimeSyncState" desc="State of the time synchronisation (Disable/Server/ContinuousClock)."/>
                    <param name="updateTime" type="int" multiplicity="?" desc="The update time of the time sync signal in seconds"/>
                    <return name="success" type="bool" desc="If true, the property was set successfully."/>
                </function>
                <function name="setTimeSyncUtc">
                    <desc>Sets the mode for UTC time synchronisation which is to be used.</desc>
                    <sample for="lua">success = SensorNetwork.setTimeSyncUtc(handle, "SERVER", 600)</sample>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="The instance handle of the network"/>
                    <param name="timeSyncStateUtc" type="enum" ref="TimeSyncUtcState" desc="State of the time synchronisation (Disable/Server/Client)."/>
                    <param name="updateTime" type="int" multiplicity="?" desc="The update time of the time sync signal in seconds"/>
                    <return name="success" type="bool" desc="If true, the property was set successfully."/>
                </function>
                <function name="setTimeSyncHighPrec">
                    <desc>Sets the mode for high precision time synchronisation.</desc>
                    <sample for="lua">success = SensorNetwork.setTimeSyncHighPrec(handle, "SERVER", 600)</sample>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="The instance handle of the network"/>
                    <param name="timeSyncStateHighPrec" type="enum" ref="TimeSyncHighPrecState" desc="State of the time synchronisation (Disable/Server/Client)."/>
                    <param name="updateTime" type="int" multiplicity="?" desc="The update time of the time sync signal in seconds"/>
                    <return name="success" type="bool" desc="If true, the property was set successfully."/>
                </function>
                <function name="setIncrementMode">
                    <desc>Increment transmit/receive/disable</desc>
                    <sample for="lua">success = SensorNetwork.setIncrementMode(handle, "TRANSMIT", 20)</sample>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="The instance handle of the network"/>
                    <param name="incrementTransmitState" type="enum" ref="IncrementMode" desc="State of the increment sending (Disable/Transmit/Receive)."/>
                    <param name="maxUpdateTime" type="int" multiplicity="?" desc="The minimum update time between two increment PDO in milliseconds"/>
                    <return name="success" type="bool" desc="If true, the property was set successfully."/>
                </function>
                <function name="setImageOutputRequestMode">
                    <links>SensorNetwork.sendImageOutputRequest, SensorNetwork.sendObjectIdentification, SensorNetwork.OnImageOutputRequest, SensorNetwork.OnObjectIdentification</links>
                    <desc>Image output request transmit/receive/disable. This setting decides if the function SensorNetwork.sendImageOutputRequest or the event SensorNetwork.OnImageOutputRequest is possible to use. Also affects SensorNetwork.sendObjectIdentification vs. SensorNetwork.OnObjectIdentification.</desc>
                    <sample for="lua">success = SensorNetwork.setImageOutputRequestMode(handle, "TRANSMIT")</sample>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="The instance handle of the network"/>
                    <param name="imageOutputRequestMode" type="enum" ref="ImageOutputRequestMode" desc="Handling of image output request (Disable/Transmit/Receive)."/>
                    <return name="success" type="bool" desc="If true, the property was set successfully."/>
                </function>
                <function name="setTriggerSource">
                    <desc>Set the device ID to subscribe reading trigger from. Needs to be done after setConfig.</desc>
                    <sample for="lua">SensorNetwork.setTriggerSource(csn, 31)</sample>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="The instance handle of the network"/>
                    <param name="deviceID" type="int" desc="Device ID of the trigger master"/>
                </function>
                <function name="setObjectDimensionSliceDataSourceId">
                    <desc>Set the device id(s) for the object dimension slice data</desc>
                    <sample for="lua">success = SensorNetwork.setObjectDimensionSliceDataSourceId(handle, 2)</sample>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="The instance handle of the network"/>
                    <param name="deviceId1" type="int" multiplicity="?" desc="Device id of the first source"/>
                    <param name="deviceId2" type="int" multiplicity="?" desc="Device id of the second source"/>
                    <param name="deviceId3" type="int" multiplicity="?" desc="Device id of the thired source"/>
                    <return name="success" type="bool" desc="If true, the property was set successfully."/>
                </function>
                <function name="setNetworkMode">
                    <desc>Change between Master/Slave mode</desc>
                    <sample for="lua">success = SensorNetwork.setNetworkMode(handle, "SLAVE")</sample>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="The instance handle of the network"/>
                    <param name="mode" type="enum" ref="MasterSlaveArrangement" desc="Master or Slave?"/>
                    <param name="slaveSet" type="auto" multiplicity="[?*]" desc="The set of nodes to receive from. Defaults to empty for SLAVE and all nodes for MASTER. Can be a string containing a SOPAS-like comma-separated list, or a vector of ints."/>
                    <return name="success" type="bool" desc="If true, the property was set successfully."/>
                </function>
                <function name="setMultiplexerMode">
                    <desc>Change between Client/Server mode</desc>
                    <sample for="lua">success = SensorNetwork.setMultiplexerMode(handle, "CLIENT")</sample>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="The instance handle of the network"/>
                    <param name="mode" type="enum" ref="MultiplexerArrangement" desc="Multiplexer or Client?"/>
                    <param name="muxSet" type="auto" multiplicity="[?*]" desc="The set of nodes to receive from. Defaults to empty for CLIENT and all nodes for MULTIPLEXER. Can be a string containing a SOPAS-like comma-separated list, or a vector of ints."/>
                    <return name="success" type="bool" desc="If true, the property was set successfully."/>
                </function>
                <function name="setCleanupCommandMode">
                    <desc>Cleanup command transmit/receive/disable</desc>
                    <sample for="lua">success = SensorNetwork.setCleanupCommandMode(handle, "TRANSMIT")</sample>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="The instance handle of the network"/>
                    <param name="cleanupCommandState" type="enum" ref="CleanupCommandMode" desc="State of the cleanup command (Disable/Transmit/Receive)."/>
                    <return name="success" type="bool" desc="If true, the property was set successfully."/>
                </function>
                <function name="setVmsIndicationMode">
                    <desc>VMS indication receive/disable</desc>
                    <sample for="lua">success = SensorNetwork.setVmsIndicationMode(handle, "RECEIVE")</sample>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="The instance handle of the network"/>
                    <param name="vmsIndicationMode" type="enum" ref="VmsIndicationMode" desc="State of the vms indication mode (Disable/Receive)."/>
                    <return name="success" type="bool" desc="If true, the property was set successfully."/>
                </function>
                <function name="sendCodeData">
                    <desc>Send a CodeData to the Master</desc>
                    <sample for="lua">SensorNetwork.sendCodeData(handle, codeDataHandle)</sample>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="The instance handle of the network"/>
                    <param name="codeDataHandle" type="handle" alias="SensorNetwork.CodeData" desc="The instance handle of a CodeData object"/>
                    <return name="success" type="bool" desc="If true, the CodeData was sent successfully."/>
                </function>
                <function name="sendImageOutputRequest">
                    <links>SensorNetwork.setImageOutputRequestMode, SensorNetwork.OnImageOutputRequest</links>
                    <desc>Initiates an image output on the connected device. For this function to work, the function SensorNetwork.setImageOutputRequestMode needs to be used to set imageOutputRequestMode to TRANSMIT.</desc>
                    <sample for="lua">SensorNetwork.sendImageOutputRequest(handle, objectNumber, "FileName")</sample>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="The instance handle of the network"/>
                    <param name="imageRequestObjectNumber" type="int" desc="The object number for the image request"/>
                    <param name="imageRequestFileName" type="string" desc="File name the image provider will use to output the image"/>
                    <param name="imageRequestDeviceSelection" type="int" multiplicity="?" desc="Binary device selection code 0x01=TOP/BOTTOM/LEFT/RIGHT/FRONT/REAR/0x3F=ALL. Optional, default is 0x3F=ALL."/>
                    <return name="success" type="bool" desc="If true, the image request was sent successfully."/>
                </function>
                <function name="sendImageDeleteRequest">
                    <trait>deprecated</trait>
                    <desc>Initiates an image delete on the connected device.</desc>
                    <sample for="lua">SensorNetwork.sendImageDeleteRequest(handle, objectNumber)</sample>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="The instance handle of the network"/>
                    <param name="imageDeleteRequestObjectNumber" type="int" desc="The object number for the image delete request"/>
                    <param name="imageDeleteFileName" type="string" multiplicity="?" desc="File name the image provider will use to output the image"/>
                    <param name="imageRequestDeviceSelection" type="int" multiplicity="?" desc="Binary device selection code 0x01=TOP/BOTTOM/LEFT/RIGHT/FRONT/REAR/0x3F=ALL. Optional, default is 0x3F=ALL."/>
                    <return name="success" type="bool" desc="If true, the image request was sent successfully."/>
                </function>
                <function name="sendObjectIdentification">
                    <links>SensorNetwork.setImageOutputRequestMode, SensorNetwork.OnObjectIdentification</links>
                    <desc>Sends an object identification string (customer ID string). For this function to work, the function SensorNetwork.setImageOutputRequestMode needs to be used to set imageOutputRequestMode to TRANSMIT.</desc>
                    <sample for="lua">SensorNetwork.sendObjectIdentification(handle, objectNumber, "ObjectIdentificationString")</sample>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="The instance handle of the network"/>
                    <param name="identificationStringObjectNumber" type="int" desc="The object number for the identification string"/>
                    <param name="objectIdentificationString" type="string" desc="The object identification string (customer ID string)"/>
                    <return name="success" type="bool" desc="If true, the id string was sent successfully."/>
                </function>
                <function name="sendCustomData">
                    <links>SensorNetwork.setImageOutputRequestMode, SensorNetwork.OnObjectIdentification</links>
                    <desc>Sends an custom data string (customer data string). For this function to work, the function SensorNetwork.setImageOutputRequestMode needs to be used to set imageOutputRequestMode to TRANSMIT.</desc>
                    <sample for="lua">SensorNetwork.sendCustomData(handle, objectNumber, "CustomDataString")</sample>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="The instance handle of the network"/>
                    <param name="identificationStringObjectNumber" type="int" desc="The object number for the identification string"/>
                    <param name="customDataString" type="string" desc="The custom data string"/>
                    <return name="success" type="bool" desc="If true, the id string was sent successfully."/>
                </function>
                <function name="sendCleanupCommand">
                    <desc>Send a cleanup command</desc>
                    <sample for="lua">SensorNetwork.sendCleanupCommand(handle)</sample>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="The instance handle of the network"/>
                    <return name="success" type="bool" desc="If true, the cleanup command was sent successfully."/>
                </function>
                <function name="sendTimeSyncHighPrecSignal">
                    <desc>Trigger sending of a high precision time synchronisation signal manually.
Only works when SERVER mode is selected as parameter for function setTimeSyncHighPrec.</desc>
                    <sample for="lua">SensorNetwork.sendTimeSyncHighPrecSignal(handle)</sample>
                    <param name="handle" type="handle" alias="SensorNetwork" desc="The instance handle of the network"/>
                </function>
            </serves>
            <crown name="CANConfig">
                <trait>released</trait>
                <desc>Provides functionality to configure the CAN bus. Call SensorNetwork.setConfig() to enable changes</desc>
                <enum name="CANbaudRate" type="int">
                    <item name="20kBit/sec">20</item>
                    <item name="50kBit/sec">50</item>
                    <item name="100kBit/sec">100</item>
                    <item name="125kBit/sec">125</item>
                    <item name="250kBit/sec">250</item>
                    <item name="500kBit/sec">500</item>
                    <item name="800kBit/sec">800</item>
                    <item name="1000kBit/sec">1000</item>
                </enum>
                <serves>
                    <function name="create">
                        <desc>Creates an instance of a CANConfig.</desc>
                        <sample for="lua">canCfg = SensorNetwork.CANConfig.create()</sample>
                        <return name="handle" type="object" alias="SensorNetwork.CANConfig" desc="Instance handle of the CANConfig."/>
                    </function>
                    <function name="setBaudrate">
                        <desc>Sets the CAN baud rate</desc>
                        <sample for="lua">valid = SensorNetwork.CANConfig.setBaudrate(handle, "500" )</sample>
                        <param name="handle" type="handle" alias="SensorNetwork.CANConfig" desc="The instance handle of the CAN config"/>
                        <param name="canBaudRate" type="enum" ref="CANbaudRate" desc="The CAN baud rate"/>
                        <return name="valid" type="bool" desc="Setting of CAN baud rate valid"/>
                    </function>
                    <function name="setTermination">
                        <desc>Sets the CAN termination</desc>
                        <sample for="lua">valid = SensorNetwork.CANConfig.setTermination(handle, true)</sample>
                        <param name="handle" type="handle" alias="SensorNetwork.CANConfig" desc="The instance handle of the CAN config"/>
                        <param name="canTerminationSet" type="bool" desc="CAN termination set"/>
                    </function>
                    <function name="setDeviceID">
                        <desc>Sets the CAN device ID</desc>
                        <sample for="lua">valid = SensorNetwork.CANConfig.setDeviceID(handle, 2)</sample>
                        <param name="handle" type="handle" alias="SensorNetwork.CANConfig" desc="The instance handle of the CAN config"/>
                        <param name="canDeviceID" type="int" desc="The CAN device ID"/>
                    </function>
                </serves>
            </crown>
            <crown name="CodeData">
                <trait>released</trait>
                <desc>Contains the data of a barcode</desc>
                <enum name="CodeType">
                    <item name="CODABAR">CBAR</item>
                    <item name="CODE 39">C39</item>
                    <item name="UPC A">UPCA</item>
                    <item name="UPC E">UPCE</item>
                    <item name="UPC E expanded">UPCEEXP</item>
                    <item name="EAN 8">EAN8</item>
                    <item name="EAN 13">EAN13</item>
                    <item name="INTERLEAVED 2/5">25IL</item>
                    <item name="CODE 93">C93</item>
                    <item name="CODE 128">C128</item>
                    <item name="EAN 128">EAN128</item>
                    <item name="PDF417">PDF</item>
                    <item name="QR CODE">QRC</item>
                    <item name="DATAMATRIX">DATX</item>
                    <item name="MAXICODE">MAXI</item>
                    <item name="AUSTRALIA POSTAL">AUPO</item>
                    <item name="ROYAL MAIL 4SCC">RM4S</item>
                    <item name="INFOMAIL">INFM</item>
                    <item name="JAPANESE POSTAL">JAPO</item>
                    <item name="KIX">KIX</item>
                    <item name="PLANET">PLNT</item>
                    <item name="USPS 4-STATE">US4S</item>
                    <item name="UPU">UPU</item>
                    <item name="POSTNET">PNET</item>
                    <item name="PROFILE 1D">PRF1</item>
                    <item name="POST SWEDEN">SWPO</item>
                    <item name="ADDON CODE">ADDON</item>
                    <item name="PHARMA">PHRM</item>
                    <item name="GS1_EXPANDED">GS1EXP</item>
                    <item name="GS1_DATABAR">GS114</item>
                    <item name="GS1_LIMITED">GS1LIM</item>
                    <item name="MSI">MSI</item>
                    <item name="MSI Plessey">PLSY</item>
                    <item name="TELEPEN">TELEPEN</item>
                    <item name="AZTEC">AZTEC</item>
                    <item name="POST SINGAPORE">SIPO</item>
                    <item name="DOT CODE">DOT</item>
                    <item name="RAW BAR 2 STATE">RB2ST</item>
                    <item name="RAW BAR 4 STATE">RB4ST</item>
                    <item name="OBJECT" desc="Any objects like letters, parcels,...">OBJECT</item>
                    <item name="OBJECT_PARCEL" desc="Any parcels like objects">OBJECT_PARCEL</item>
                    <item name="OBJECT_TOTE" desc="Any DHL tote like objects">OBJECT_TOTE</item>
                    <item name="OBJECT_TOTE2" desc="Any POST Ch tote like objects">OBJECT_TOTE2</item>
                    <item name="OBJECT_TRAY" desc="Any tray objects">OBJECT_TRAY</item>
                    <item name="ITEM" desc="Any item">ITEM</item>
                    <item name="ITEM_ADDRESS_LABEL" desc="An address label">ITEM_ADDRESS_LABEL</item>
                    <item name="ITEM_HAZMAT" desc="IATA label">ITEM_HAZMAT</item>
                </enum>
                <enum name="CodeDecodability">
                    <item>DECODABLE</item>
                    <item>UNDECODABLE</item>
                </enum>
                <enum name="CornerPosition">
                    <item name="top left">TOP_LEFT</item>
                    <item name="top right">TOP_RIGHT</item>
                    <item name="bottom left">BOTTOM_LEFT</item>
                    <item name="bottom right">BOTTOM_RIGHT</item>
                    <item name="center">CENTER</item>
                    <item name="center closest">CENTER_CLOSEST</item>
                </enum>
                <enum name="ScanDirection">
                    <item>SCAN_DIR_NOT_KNOWN</item>
                    <item>SCAN_FWD</item>
                    <item>SCAN_BWD</item>
                </enum>
                <enum name="AppendDirection">
                    <item>APPEND_DIR_NOT_KNOWN</item>
                    <item>APPEND_FWD</item>
                    <item>APPEND_BWD</item>
                </enum>
                <serves>
                    <function name="create">
                        <desc>Creates an instance of CodeData.</desc>
                        <sample for="lua">cd = SensorNetwork.CodeData.create()</sample>
                        <return name="handle" type="object" alias="SensorNetwork.CodeData" desc="Instance handle of the new object."/>
                    </function>
                    <function name="getCodeContent">
                        <desc>Returns the content of a particular result</desc>
                        <sample for="lua">codeContent = SensorNetwork.CodeData.getCodeContent(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance (result) to use"/>
                        <return name="content" type="binary" desc="The content of the result"/>
                    </function>
                    <function name="getCodeContentLength">
                        <desc>Returns the content of a particular result</desc>
                        <sample for="lua">local length = SensorNetwork.CodeData.getCodeContentLength(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance (result) to use"/>
                        <return name="contentlength" type="int" desc="The content length of the result"/>
                    </function>
                    <function name="getCodeType">
                        <desc>Returns the code type of a particular result</desc>
                        <sample for="lua">codeType, decodability = SensorNetwork.CodeData.getCodeType(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance (result) to use"/>
                        <return name="typeName" type="enum" ref="CodeType" desc="The code type of the result"/>
                        <return name="decodability" type="enum" ref="CodeDecodability" desc="decodability of the code"/>
                    </function>
                    <function name="getMultiread">
                        <desc>Returns the number of multiple reads of the data</desc>
                        <sample for="lua">csValue = SensorNetwork.CodeData.getMultiread(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="multipleRead" type="int" desc="The multiple read value of the data"/>
                    </function>
                    <function name="getDeviceID">
                        <desc>Returns the device Id</desc>
                        <sample for="lua">id = SensorNetwork.CodeData.getDeviceID(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance (result) to use"/>
                        <return name="deviceID" type="int" desc="The device ID"/>
                    </function>
                    <function name="getObjectID">
                        <desc>Returns the object Id</desc>
                        <sample for="lua">objectId = SensorNetwork.CodeData.getObjectID(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance (result) to use"/>
                        <return name="objectID" type="int" desc="The object ID"/>
                    </function>
                    <function name="getSymbolSize">
                        <desc>Returns the number of modules in horizontal direction</desc>
                        <sample for="lua">sizeX, sizeY = SensorNetwork.CodeData.getSymbolSize(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance (result) to use"/>
                        <return name="symbolsizeX" type="int" desc="The number of modules in horizontal direction"/>
                        <return name="symbolsizeY" type="int" desc="The number of modules in vertical direction"/>
                    </function>
                    <function name="getContrast">
                        <desc>Returns the contrast PCS value of the code</desc>
                        <sample for="lua">local contrast = SensorNetwork.CodeData.getContrast(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance (result) to use"/>
                        <return name="contrast" type="int" desc="The contrast value of the code"/>
                    </function>
                    <function name="getPosition">
                        <desc>Returns the position of the code; x,y,z of corners top left, top right, bottom left, bottom right, center</desc>
                        <sample for="lua">x = SensorNetwork.CodeData.getPosition(codeData, "CENTER")</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="corner" type="enum" ref="CornerPosition" desc="Corner of the barcode which position to get (1 to 5)"/>
                        <return name="positionX" type="int" desc="X position"/>
                        <return name="positionY" type="int" desc="Y position"/>
                        <return name="positionZ" type="int" desc="Z position"/>
                    </function>
                    <function name="getPositionIncrement">
                        <desc>Returns the increment value of the result position</desc>
                        <sample for="lua">x = SensorNetwork.CodeData.getPositionIncrement(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="increment" type="int" desc="The increment value of the code position"/>
                    </function>
                    <function name="getPositionDistance">
                        <desc>Returns the distance values of the result position</desc>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="distTolerance" type="int" desc="Distance between closest and farthest possible center of gravity point  / -1: Invalid"/>
                        <return name="focusDistance" type="int" desc="Focus distance in mm / -1: Invalid"/>
                        <return name="readingDistance" type="int" desc="Reading distance in mm / -1: Invalid"/>
                    </function>
                    <function name="getSymbolID">
                        <desc>Returns the SymbolID of the code</desc>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="symbolID" type="int" desc="SymbolID generated by the decoder for every read. Decoder has support this, otherwise 0."/>
                    </function>
                    <function name="getTiltAngle">
                        <desc>Returns the tilt angle of the code in degree.</desc>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="tiltAngle" type="float" desc="Tilt angle of the code in degree."/>
                    </function>
                    <function name="getItemData">
                        <desc>Returns item data</desc>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="itemData" type="object" multiplicity="?" alias="SensorNetwork.CodeData.ItemData" desc="Item data if available."/>
                    </function>
                    <function name="getObjectData">
                        <desc>Returns object data</desc>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="objectData" type="object" multiplicity="?" alias="SensorNetwork.CodeData.ObjectData" desc="Object data if available."/>
                    </function>
                    <function name="getDirection">
                        <desc>Returns the direction of the code.</desc>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="scanDirection" type="enum" ref="ScanDirection" desc="Direction of scanning object."/>
                        <return name="appendDirection" type="enum" ref="AppendDirection" desc="Direction of smart decoders appending of fragments."/>
                    </function>
                    <function name="getUsedErrorCorrection">
                        <desc>Returns the used error correction of the code in percent.</desc>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="usedErrorCorrection" type="int" desc="Used error correction in percent."/>
                    </function>
                    <function name="getModuleSize">
                        <desc>Returns the module size of the code.</desc>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="moduleSizeX" type="int" desc="Average module size in pixels"/>
                        <return name="moduleSizeY" type="int" desc="Average module size in pixels"/>
                    </function>
                    <function name="setCodeContent">
                        <desc>Sets the binary code content for a particular result</desc>
                        <sample for="lua">SensorNetwork.CodeData.setCodeContent(codeData, codeContent)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance (result) to use"/>
                        <param name="content" type="binary" desc="The content of the result"/>
                    </function>
                    <function name="setCodeType">
                        <desc>Sets the code type of a particular result</desc>
                        <sample for="lua">SensorNetwork.CodeData.setCodeType(codeData,"INSERT_YOUR_CODE_TYPE_HERE","DECODABLE")</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance (result) to use"/>
                        <param name="typeName" type="enum" ref="CodeType" desc="The code type of the result"/>
                        <param name="decodability" type="enum" ref="CodeDecodability" desc="Decodability of the code"/>
                    </function>
                    <function name="setMultiread">
                        <desc>Sets the number of multiple reads of the data</desc>
                        <sample for="lua">SensorNetwork.CodeData.setMultiread(codeData,multipleRead)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="multipleRead" type="int" desc="The multiple read value of the data"/>
                    </function>
                    <function name="setDeviceID">
                        <desc>Sets the device Id</desc>
                        <sample for="lua">SensorNetwork.CodeData.setDeviceID(codeData,deviceID)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance (result) to use"/>
                        <param name="deviceID" type="int" desc="The device ID"/>
                    </function>
                    <function name="setObjectID">
                        <desc>Sets the object Id</desc>
                        <sample for="lua">SensorNetwork.CodeData.setObjectID(codeData,objectID)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance (result) to use"/>
                        <param name="objectID" type="int" desc="The object ID"/>
                    </function>
                    <function name="setSymbolSize">
                        <desc>Sets the number of modules of the code</desc>
                        <sample for="lua">SensorNetwork.CodeData.setSymbolSize(codeData,symbolsizeX,symbolsizeY)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance (result) to use"/>
                        <param name="symbolsizeX" type="int" desc="The number of modules in horizontal direction"/>
                        <param name="symbolsizeY" type="int" desc="The number of modules in vertical direction"/>
                    </function>
                    <function name="setContrast">
                        <desc>Sets the contrast PCS value of the code</desc>
                        <sample for="lua">SensorNetwork.CodeData.setContrast(codeData,contrast)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance (result) to use"/>
                        <param name="contrast" type="int" desc="The contrast value of the code"/>
                    </function>
                    <function name="setPosition">
                        <desc>Sets the position of the code; x,y,z of corners top left, top right, bottom left, bottom right, center</desc>
                        <sample for="lua">SensorNetwork.CodeData.setPosition(codeData, "CENTER", x, y, z)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="corner" type="enum" ref="CornerPosition" desc="Corner of the barcode which position to set (1 to 5)"/>
                        <param name="positionX" type="int" desc="X position"/>
                        <param name="positionY" type="int" desc="Y position"/>
                        <param name="positionZ" type="int" desc="Z position"/>
                    </function>
                    <function name="setPositionIncrement">
                        <desc>Sets the increment value of the result position</desc>
                        <sample for="lua">SensorNetwork.CodeData.setPositionIncrement(codeData,increment)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="increment" type="int" desc="The increment value of the code position"/>
                    </function>
                    <function name="setPositionDistance">
                        <desc>Sets the distance values of the result position</desc>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="distTolerance" type="int" desc="Distance between closest and farthest possible center of gravity point  / -1: Invalid"/>
                        <param name="focusDistance" type="int" desc="Focus distance in mm / -1: Invalid"/>
                        <param name="readingDistance" type="int" desc="Reading distance in mm / -1: Invalid"/>
                    </function>
                    <function name="setSymbolID">
                        <desc>Sets the SymbolID of the code</desc>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="symbolID" type="int" desc="SymbolID generated by the decoder for every read. Decoder has support this, otherwise 0."/>
                    </function>
                    <function name="setTiltAngle">
                        <desc>Sets the tilt angle of the code in degree.</desc>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="tiltAngle" type="float" desc="Tilt angle of the code in degree."/>
                    </function>
                    <function name="setItemData">
                        <desc>Sets item data.
The SensorNetwork.CodeData.ItemData objects that are passed into this function are copied, so future changes to the SensorNetwork.CodeData.ItemData object does not have an effect.</desc>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="itemData" type="object" alias="SensorNetwork.CodeData.ItemData" desc="Item data to set."/>
                    </function>
                    <function name="setObjectData">
                        <desc>Sets object data.
The objects that are passed into this function are copied, so future changes to the objects do not have an effect.</desc>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="objectData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="Object data to set."/>
                    </function>
                    <function name="setDirection">
                        <desc>Sets the direction of the code</desc>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="scanDirection" type="enum" ref="ScanDirection" desc="Direction of scanning object."/>
                        <param name="appendDirection" type="enum" ref="AppendDirection" desc="Direction of smart decoders appending of fragments."/>
                    </function>
                    <function name="setUsedErrorCorrection">
                        <desc>Sets the used error correction of the code in percent.</desc>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="usedErrorCorrection" type="int" desc="Used error correction in percent."/>
                    </function>
                    <function name="setModuleSize">
                        <desc>Sets the module size of the code.</desc>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="moduleSizeX" type="int" desc="Average module size in pixels"/>
                        <param name="moduleSizeY" type="int" desc="Average module size in pixels"/>
                    </function>
                    <function name="getNorcaFeatureVectorValid">
                        <desc>Returns the NORCA feature vector</desc>
                        <sample for="lua">x = SensorNetwork.CodeData.getNorcaFeatureVectorValid(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="featureVectorValid" type="bool" desc="Validity of the NORCA feature vector"/>
                    </function>
                    <function name="getNorcaFeatureVector">
                        <desc>Returns the NORCA feature vector</desc>
                        <sample for="lua">x = SensorNetwork.CodeData.getNorcaFeatureVector(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="featureVector" type="int" desc="The NORCA feature vector"/>
                    </function>
                    <function name="getNorcaVerifierValid">
                        <desc>Returns the NORCA verifier values</desc>
                        <sample for="lua">x = SensorNetwork.CodeData.getNorcaVerifierValid(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="verifierValid" type="bool" desc="Validity of the NORCA verifier values"/>
                    </function>
                    <function name="getNorcaVerifierDecode">
                        <desc>Returns the NORCA verifier decode</desc>
                        <sample for="lua">x = SensorNetwork.CodeData.getNorcaVerifierDecode(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="verifierDecodeValue" type="int" desc="The NORCA verifier decode value"/>
                        <return name="verifierDecodeGrade" type="int" desc="The NORCA verifier decode grade"/>
                    </function>
                    <function name="getNorcaVerifierSC">
                        <desc>Returns the NORCA verifier SC</desc>
                        <sample for="lua">x = SensorNetwork.CodeData.getNorcaVerifierSC(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="verifierSCValue" type="int" desc="The NORCA verifier SC value"/>
                        <return name="verifierSCGrade" type="int" desc="The NORCA verifier SC grade"/>
                    </function>
                    <function name="getNorcaVerifierRmin">
                        <desc>Returns the NORCA verifier Rmin</desc>
                        <sample for="lua">x = SensorNetwork.CodeData.getNorcaVerifierRmin(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="verifierRminValue" type="int" desc="The NORCA verifier Rmin value"/>
                        <return name="verifierRminGrade" type="int" desc="The NORCA verifier Rmin grade"/>
                    </function>
                    <function name="getNorcaVerifierMod">
                        <desc>Returns the NORCA verifier Mod</desc>
                        <sample for="lua">x = SensorNetwork.CodeData.getNorcaVerifierMod(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="verifierModValue" type="int" desc="The NORCA verifier Mod value"/>
                        <return name="verifierModGrade" type="int" desc="The NORCA verifier Mod grade"/>
                    </function>
                    <function name="getNorcaVerifierDecodability">
                        <desc>Returns the NORCA verifier Decodability</desc>
                        <sample for="lua">x = SensorNetwork.CodeData.getNorcaVerifierDecodability(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="verifierDecodabilityValue" type="int" desc="The NORCA verifier Decodability value"/>
                        <return name="verifierDecodabilityGrade" type="int" desc="The NORCA verifier Decodability grade"/>
                    </function>
                    <function name="getNorcaVerifierOSG">
                        <desc>Returns the NORCA verifier OSG</desc>
                        <sample for="lua">x = SensorNetwork.CodeData.getNorcaVerifierOSG(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="verifierOSGGrade" type="int" desc="The NORCA verifier OSG grade"/>
                    </function>
                    <function name="getNorcaResultQuality">
                        <desc>Returns the NORCA result quality</desc>
                        <sample for="lua">x = SensorNetwork.CodeData.getNorcaResultQuality(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="resultQuality" type="int" desc="The NORCA result quality"/>
                    </function>
                    <function name="getNorcaVerifierECmin">
                        <desc>Returns the NORCA verifier ECmin</desc>
                        <sample for="lua">x = SensorNetwork.CodeData.getNorcaVerifierECmin(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="verifierECminValue" type="int" desc="The NORCA verifier ECmin value"/>
                        <return name="verifierECminGrade" type="int" desc="The NORCA verifier ECmin grade"/>
                    </function>
                    <function name="getNorcaVerifierDefects">
                        <desc>Returns the NORCA verifier Defects</desc>
                        <sample for="lua">x = SensorNetwork.CodeData.getNorcaVerifierDefects(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="verifierDefectsValue" type="int" desc="The NORCA verifier Defects value"/>
                        <return name="verifierDefectsGrade" type="int" desc="The NORCA verifier Defects grade"/>
                    </function>
                    <function name="getNorcaQuietZone">
                        <desc>Returns the NORCA quiet zone</desc>
                        <sample for="lua">x = SensorNetwork.CodeData.getNorcaQuietZone(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="quietZone" type="int" desc="The NORCA quiet zone"/>
                    </function>
                    <function name="getNorcaModuleSize">
                        <desc>Returns the NORCA module size</desc>
                        <sample for="lua">x = SensorNetwork.CodeData.getNorcaModuleSize(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="moduleSize" type="int" desc="The NORCA module size"/>
                    </function>
                    <function name="getNorcaVerifierPG">
                        <desc>Returns the NORCA verifier PG</desc>
                        <sample for="lua">x = SensorNetwork.CodeData.getNorcaVerifierPG(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="verifierPGValue" type="int" desc="The NORCA verifier PG value"/>
                        <return name="verifierPGGrade" type="int" desc="The NORCA verifier PG grade"/>
                    </function>
                    <function name="getNorcaVerifierUEC">
                        <desc>Returns the NORCA verifier UEC</desc>
                        <sample for="lua">x = SensorNetwork.CodeData.getNorcaVerifierUEC(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="verifierUECValue" type="int" desc="The NORCA verifier UEC value"/>
                        <return name="verifierUECGrade" type="int" desc="The NORCA verifier UEC grade"/>
                    </function>
                    <function name="getNorcaVerifierANU">
                        <desc>Returns the NORCA verifier ANU</desc>
                        <sample for="lua">x = SensorNetwork.CodeData.getNorcaVerifierANU(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="verifierANUValue" type="int" desc="The NORCA verifier ANU value"/>
                        <return name="verifierANUGrade" type="int" desc="The NORCA verifier ANU grade"/>
                    </function>
                    <function name="getNorcaVerifierLAN">
                        <desc>Returns the NORCA verifier LAN</desc>
                        <sample for="lua">x = SensorNetwork.CodeData.getNorcaVerifierLAN(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="verifierLANValue" type="int" desc="The NORCA verifier LAN value"/>
                        <return name="verifierLANGrade" type="int" desc="The NORCA verifier LAN grade"/>
                    </function>
                    <function name="getNorcaVerifierGNU">
                        <desc>Returns the NORCA verifier GNU</desc>
                        <sample for="lua">x = SensorNetwork.CodeData.getNorcaVerifierGNU(codeData)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <return name="verifierGNUValue" type="int" desc="The NORCA verifier GNU value"/>
                        <return name="verifierGNUGrade" type="int" desc="The NORCA verifier GNU grade"/>
                    </function>
                    <function name="setNorcaFeatureVectorValid">
                        <desc>Sets the NORCA feature vector validity</desc>
                        <sample for="lua">SensorNetwork.CodeData.setNorcaFeatureVectorValid(codeData,featureVectorValid)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="featureVectorValid" type="bool" desc="Validity of the NORCA feature vector"/>
                    </function>
                    <function name="setNorcaFeatureVector">
                        <desc>Sets the NORCA feature vector</desc>
                        <sample for="lua">SensorNetwork.CodeData.setNorcaFeatureVector(codeData,featureVector)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="featureVector" type="int" desc="The NORCA feature vector"/>
                    </function>
                    <function name="setNorcaVerifierValid">
                        <desc>Sets the NORCA verifier values validity</desc>
                        <sample for="lua">SensorNetwork.CodeData.setNorcaVerifierValid(codeData,verifierValid)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="verifierValid" type="bool" desc="Validity of the NORCA verifier values"/>
                    </function>
                    <function name="setNorcaVerifierDecode">
                        <desc>Sets the NORCA verifier decode value and grade</desc>
                        <sample for="lua">SensorNetwork.CodeData.setNorcaVerifierDecode(codeData,verifierDecodeValue,verifierDecodeGrade)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="verifierDecodeValue" type="int" desc="The NORCA verifier decode value"/>
                        <param name="verifierDecodeGrade" type="int" desc="The NORCA verifier decode grade"/>
                    </function>
                    <function name="setNorcaVerifierSC">
                        <desc>Sets the NORCA verifier SC value and grade</desc>
                        <sample for="lua">SensorNetwork.CodeData.setNorcaVerifierSC(codeData,verifierSCValue,verifierSCGrade)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="verifierSCValue" type="int" desc="The NORCA verifier SC value"/>
                        <param name="verifierSCGrade" type="int" desc="The NORCA verifier SC grade"/>
                    </function>
                    <function name="setNorcaVerifierRmin">
                        <desc>Sets the NORCA verifier Rmin value and grade</desc>
                        <sample for="lua">SensorNetwork.CodeData.setNorcaVerifierRmin(codeData,verifierRminValue,verifierRminGrade)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="verifierRminValue" type="int" desc="The NORCA verifier Rmin value"/>
                        <param name="verifierRminGrade" type="int" desc="The NORCA verifier Rmin grade"/>
                    </function>
                    <function name="setNorcaVerifierMod">
                        <desc>Sets the NORCA verifier Mod value and grade</desc>
                        <sample for="lua">SensorNetwork.CodeData.setNorcaVerifierMod(codeData,verifierModValue,verifierModGrade)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="verifierModValue" type="int" desc="The NORCA verifier Mod value"/>
                        <param name="verifierModGrade" type="int" desc="The NORCA verifier Mod grade"/>
                    </function>
                    <function name="setNorcaVerifierDecodability">
                        <desc>Sets the NORCA verifier Decodability value and grade</desc>
                        <sample for="lua">SensorNetwork.CodeData.setNorcaVerifierDecodability(codeData,verifierDecodabilityValue,verifierDecodabilityGrade)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="verifierDecodabilityValue" type="int" desc="The NORCA verifier Decodability value"/>
                        <param name="verifierDecodabilityGrade" type="int" desc="The NORCA verifier Decodability grade"/>
                    </function>
                    <function name="setNorcaVerifierOSG">
                        <desc>Sets the NORCA verifier OSG grade</desc>
                        <sample for="lua">SensorNetwork.CodeData.setNorcaVerifierOSG(codeData,verifierOSGGrade)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="verifierOSGGrade" type="int" desc="The NORCA verifier OSG grade"/>
                    </function>
                    <function name="setNorcaResultQuality">
                        <desc>Sets the NORCA result quality</desc>
                        <sample for="lua">SensorNetwork.CodeData.setNorcaResultQuality(codeData,resultQuality)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="resultQuality" type="int" desc="The NORCA result quality"/>
                    </function>
                    <function name="setNorcaVerifierECmin">
                        <desc>Sets the NORCA verifier ECmin value and grade</desc>
                        <sample for="lua">SensorNetwork.CodeData.setNorcaVerifierECmin(codeData,verifierECminValue,verifierECminGrade)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="verifierECminValue" type="int" desc="The NORCA verifier ECmin value"/>
                        <param name="verifierECminGrade" type="int" desc="The NORCA verifier ECmin grade"/>
                    </function>
                    <function name="setNorcaVerifierDefects">
                        <desc>Sets the NORCA verifier Defects value and grade</desc>
                        <sample for="lua">SensorNetwork.CodeData.setNorcaVerifierDefects(codeData,verifierDefectsValue,verifierDefectsGrade)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="verifierDefectsValue" type="int" desc="The NORCA verifier Defects value"/>
                        <param name="verifierDefectsGrade" type="int" desc="The NORCA verifier Defects grade"/>
                    </function>
                    <function name="setNorcaQuietZone">
                        <desc>Sets the NORCA quiet zone</desc>
                        <sample for="lua">SensorNetwork.CodeData.setNorcaQuietZone(codeData,quietZone)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="quietZone" type="int" desc="The NORCA quiet zone"/>
                    </function>
                    <function name="setNorcaModuleSize">
                        <desc>Sets the NORCA module size</desc>
                        <sample for="lua">SensorNetwork.CodeData.setNorcaModuleSize(codeData,moduleSize)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="moduleSize" type="int" desc="The NORCA module size"/>
                    </function>
                    <function name="setNorcaVerifierPG">
                        <desc>Sets the NORCA verifier PG value and grade</desc>
                        <sample for="lua">SensorNetwork.CodeData.setNorcaVerifierPG(codeData,verifierPGValue,verifierPGGrade)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="verifierPGValue" type="int" desc="The NORCA verifier PG value"/>
                        <param name="verifierPGGrade" type="int" desc="The NORCA verifier PG grade"/>
                    </function>
                    <function name="setNorcaVerifierUEC">
                        <desc>Sets the NORCA verifier UEC value and grade</desc>
                        <sample for="lua">SensorNetwork.CodeData.setNorcaVerifierUEC(codeData,verifierUECValue,verifierUECGrade)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="verifierUECValue" type="int" desc="The NORCA verifier UEC value"/>
                        <param name="verifierUECGrade" type="int" desc="The NORCA verifier UEC grade"/>
                    </function>
                    <function name="setNorcaVerifierANU">
                        <desc>Sets the NORCA verifier ANU value and grade</desc>
                        <sample for="lua">SensorNetwork.CodeData.setNorcaVerifierANU(codeData,verifierANUValue,verifierANUGrade)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="verifierANUValue" type="int" desc="The NORCA verifier ANU value"/>
                        <param name="verifierANUGrade" type="int" desc="The NORCA verifier ANU grade"/>
                    </function>
                    <function name="setNorcaVerifierLAN">
                        <desc>Sets the NORCA verifier LAN value and grade</desc>
                        <sample for="lua">SensorNetwork.CodeData.setNorcaVerifierLAN(codeData,verifierLANValue,verifierLANGrade)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="verifierLANValue" type="int" desc="The NORCA verifier LAN value"/>
                        <param name="verifierLANGrade" type="int" desc="The NORCA verifier LAN grade"/>
                    </function>
                    <function name="setNorcaVerifierGNU">
                        <desc>Sets the NORCA verifier GNU value and grade</desc>
                        <sample for="lua">SensorNetwork.CodeData.setNorcaVerifierGNU(codeData,verifierGNUValue,verifierGNUGrade)</sample>
                        <param name="codeData" type="object" alias="SensorNetwork.CodeData" desc="The instance to use"/>
                        <param name="verifierGNUValue" type="int" desc="The NORCA verifier GNU value"/>
                        <param name="verifierGNUGrade" type="int" desc="The NORCA verifier GNU grade"/>
                    </function>
                </serves>
                <crown name="ItemData">
                    <trait>released</trait>
                    <desc>Contains the data of an item read result</desc>
                    <serves>
                        <function name="create">
                            <desc>Creates an instance of ItemData.</desc>
                            <sample for="lua">id = SensorNetwork.CodeData.ItemData.create()</sample>
                            <return name="handle" type="object" alias="SensorNetwork.CodeData.ItemData" desc="Instance handle of the new object."/>
                        </function>
                        <function name="getWidth">
                            <desc>Returns the width of the item</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ItemData" desc="The instance to use"/>
                            <return name="width" type="int" desc="Width of the item"/>
                        </function>
                        <function name="setWidth">
                            <desc>Sets the width of the item</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ItemData" desc="The instance to use"/>
                            <param name="width" type="int" desc="Width of the item"/>
                        </function>
                        <function name="getHeight">
                            <desc>Returns the height of the item</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ItemData" desc="The instance to use"/>
                            <return name="height" type="int" desc="Height of the item"/>
                        </function>
                        <function name="setHeight">
                            <desc>Sets the height of the item</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ItemData" desc="The instance to use"/>
                            <param name="height" type="int" desc="Height of the item"/>
                        </function>
                        <function name="getUnitsDimension">
                            <desc>Returns the units dimension of the item</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ItemData" desc="The instance to use"/>
                            <return name="unitsDimension" type="int" desc="Units dimension of the item"/>
                        </function>
                        <function name="setUnitsDimension">
                            <desc>Sets the unitsDimension of the item</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ItemData" desc="The instance to use"/>
                            <param name="unitsDimension" type="int" desc="Units dimension of the item"/>
                        </function>
                        <function name="getQuality">
                            <desc>Returns the quality of the item</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ItemData" desc="The instance to use"/>
                            <return name="quality" type="int" desc="Quality of the item"/>
                        </function>
                        <function name="setQuality">
                            <desc>Sets the quality of the item</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ItemData" desc="The instance to use"/>
                            <param name="quality" type="int" desc="Quality of the item"/>
                        </function>
                        <function name="getItemGroup">
                            <desc>Returns the item group of the item</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ItemData" desc="The instance to use"/>
                            <return name="itemGroup" type="int" desc="Item group of the item"/>
                        </function>
                        <function name="setItemGroup">
                            <desc>Sets the item group of the item</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ItemData" desc="The instance to use"/>
                            <param name="itemGroup" type="int" desc="Item group of the item"/>
                        </function>
                        <function name="getItemType">
                            <desc>Returns the item type of the item</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ItemData" desc="The instance to use"/>
                            <return name="itemType" type="int" desc="Item type of the item"/>
                        </function>
                        <function name="setItemType">
                            <desc>Sets the item type of the item</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ItemData" desc="The instance to use"/>
                            <param name="itemType" type="int" desc="Item type of the item"/>
                        </function>
                        <function name="getProcessingTime">
                            <desc>Returns the processing time of the item</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ItemData" desc="The instance to use"/>
                            <return name="processingTime" type="int" desc="Processing time of the item"/>
                        </function>
                        <function name="setProcessingTime">
                            <desc>Sets the processing time of the item</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ItemData" desc="The instance to use"/>
                            <param name="processingTime" type="int" desc="Processing time of the item"/>
                        </function>
                        <function name="getFeatureVector">
                            <desc>Returns the feature vector of the item</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ItemData" desc="The instance to use"/>
                            <return name="featureVector" type="int" desc="Feature vector of the item"/>
                        </function>
                        <function name="setFeatureVector">
                            <desc>Sets the feature vector of the item</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ItemData" desc="The instance to use"/>
                            <param name="featureVector" type="int" desc="Feature vector of the item"/>
                        </function>
                    </serves>
                </crown>
                <crown name="ObjectData">
                    <trait>released</trait>
                    <desc>Contains the data of an item read result</desc>
                    <serves>
                        <function name="create">
                            <desc>Creates an instance of ObjectData.</desc>
                            <sample for="lua">od = SensorNetwork.CodeData.ObjectData.create()</sample>
                            <return name="handle" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="Instance handle of the new object."/>
                        </function>
                        <function name="getFeatureVector">
                            <desc>Returns the feature vector of the object</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="The instance to use"/>
                            <return name="featureVector" type="int" desc="Feature vector of the object"/>
                        </function>
                        <function name="setFeatureVector">
                            <desc>Sets the feature vector of the object</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="The instance to use"/>
                            <param name="featureVector" type="int" desc="Feature vector of the object"/>
                        </function>
                        <function name="getWidth">
                            <desc>Returns the width of the object</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="The instance to use"/>
                            <return name="width" type="int" desc="Width of the object"/>
                        </function>
                        <function name="setWidth">
                            <desc>Sets the width of the object</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="The instance to use"/>
                            <param name="width" type="int" desc="Width of the object"/>
                        </function>
                        <function name="getLength">
                            <desc>Returns the length of the object</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="The instance to use"/>
                            <return name="length" type="int" desc="Length of the object"/>
                        </function>
                        <function name="setLength">
                            <desc>Sets the length of the object</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="The instance to use"/>
                            <param name="length" type="int" desc="Length of the object"/>
                        </function>
                        <function name="getHeight">
                            <desc>Returns the height of the object</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="The instance to use"/>
                            <return name="height" type="int" desc="Height of the object"/>
                        </function>
                        <function name="setHeight">
                            <desc>Sets the height of the object</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="The instance to use"/>
                            <param name="height" type="int" desc="Height of the object"/>
                        </function>
                        <function name="getResolution">
                            <desc>Returns the resolution of the object</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="The instance to use"/>
                            <return name="resolution" type="int" desc="Resolution of the object"/>
                        </function>
                        <function name="setResolution">
                            <desc>Sets the resolution of the object</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="The instance to use"/>
                            <param name="resolution" type="int" desc="Resolution of the object"/>
                        </function>
                        <function name="getDeviceID">
                            <desc>Returns the device ID of the object</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="The instance to use"/>
                            <return name="deviceID" type="int" desc="Device ID of the object"/>
                        </function>
                        <function name="setDeviceID">
                            <desc>Sets the device ID of the object</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="The instance to use"/>
                            <param name="deviceID" type="int" desc="Device ID of the object"/>
                        </function>
                        <function name="getObjectID">
                            <desc>Returns the object ID of the object</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="The instance to use"/>
                            <return name="objectID" type="int" desc="Object ID of the object"/>
                        </function>
                        <function name="setObjectID">
                            <desc>Sets the object ID of the object</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="The instance to use"/>
                            <param name="objectID" type="int" desc="Object ID of the object"/>
                        </function>
                        <function name="getQuality">
                            <desc>Returns the quality of the object</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="The instance to use"/>
                            <return name="quality" type="int" desc="Quality of the object"/>
                        </function>
                        <function name="setQuality">
                            <desc>Sets the quality of the object</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="The instance to use"/>
                            <param name="quality" type="int" desc="Quality of the object"/>
                        </function>
                        <function name="getUnitsDimension">
                            <desc>Returns the units dimension of the object</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="The instance to use"/>
                            <return name="unitsDimension" type="int" desc="Units dimension of the object"/>
                        </function>
                        <function name="setUnitsDimension">
                            <desc>Sets the unitsDimension of the object</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="The instance to use"/>
                            <param name="unitsDimension" type="int" desc="Units dimension of the object"/>
                        </function>
                        <function name="getVolume">
                            <desc>Returns the volume of the object</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="The instance to use"/>
                            <return name="volume" type="int" desc="Volume of the object"/>
                        </function>
                        <function name="setVolume">
                            <desc>Sets the volume of the object</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="The instance to use"/>
                            <param name="volume" type="int" desc="Volume of the object"/>
                        </function>
                        <function name="getUnitsVolume">
                            <desc>Returns the units volume of the object</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="The instance to use"/>
                            <return name="unitsVolume" type="int" desc="Units volume of the object"/>
                        </function>
                        <function name="setUnitsVolume">
                            <desc>Sets the unitsVolume of the object</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="The instance to use"/>
                            <param name="unitsVolume" type="int" desc="Units volume of the object"/>
                        </function>
                        <function name="getPosition">
                            <desc>Returns the position of the object; x,y,z of four possible corners</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="The instance to use"/>
                            <param name="corner" type="int" desc="Corner of the object to get (1 to 4)"/>
                            <return name="positionX" type="int" desc="X position"/>
                            <return name="positionY" type="int" desc="Y position"/>
                            <return name="positionZ" type="int" desc="Z position"/>
                        </function>
                        <function name="setPosition">
                            <desc>Sets the position of the object; x,y,z of four possible corners</desc>
                            <param name="codeData" type="object" alias="SensorNetwork.CodeData.ObjectData" desc="The instance to use"/>
                            <param name="corner" type="int" desc="Corner of the object to set (1 to 4)"/>
                            <param name="positionX" type="int" desc="X position"/>
                            <param name="positionY" type="int" desc="Y position"/>
                            <param name="positionZ" type="int" desc="Z position"/>
                        </function>
                    </serves>
                </crown>
            </crown>
        </crown>
        <crown name="LightGridData">
            <trait>hidden</trait>
            <desc>Representation of data from a light grid sensor. It is encoded as the number of sequentially uninterrupted beams
before each obstacle in the grid. The following example describes the encoding in detail. Here '|' denotes an uninterrupted beam
whereas 'x' indicates an interruption:

|||||xx|||xxxxx|x|||

This would result in the RLC data array [5, 3, 1, 3].</desc>
            <crown name="Provider">
                <trait>hidden</trait>
                <desc>Providers for light grid sensor data</desc>
                <crown name="RemoteLightGrid">
                    <trait>hidden</trait>
                    <desc>Provider for a light grid device connected remotely</desc>
                    <enum name="Interface">
                        <item desc="Default">SERIAL</item>
                        <item>ETHERNET</item>
                    </enum>
                    <enum name="Type">
                        <item desc="Default">RS485</item>
                        <item>RS232</item>
                        <item>RS422</item>
                    </enum>
                    <enum name="Parity">
                        <item desc="Default">NONE</item>
                        <item>ODD</item>
                        <item>EVEN</item>
                        <item>MARK</item>
                        <item>SPACE</item>
                    </enum>
                    <serves>
                        <event name="OnNewData">
                            <include>data-flow</include>
                            <desc>The event which is triggered when new data has arrived.</desc>
                            <param name="handle" type="handle" alias="LightGridData.Provider.RemoteLightGrid" desc="The instance handle"/>
                            <param name="flowCounter" type="int" desc="Flow counter value"/>
                            <param name="systemStatus" type="int" desc="System status flags"/>
                            <param name="rlcData" type="int" multiplicity="*" desc="RLC data"/>
                        </event>
                        <function name="create">
                            <desc>Creates a new instance.</desc>
                            <sample for="lua">local handle = LightGridData.Provider.RemoteLightGrid.create()</sample>
                            <return name="handle" type="handle" alias="LightGridData.Provider.RemoteLightGrid" desc="Handle to the new instance"/>
                        </function>
                        <function name="register">
                            <desc>This function is used to register for any event of the RemoteLightGrid. The event name is specified as parameter</desc>
                            <sample for="lua">LightGridData.Provider.RemoteLightGrid.register(handle, "OnNewData", "OnNewData")</sample>
                            <param name="handle" type="handle" alias="LightGridData.Provider.RemoteLightGrid" desc="The instance handle"/>
                            <param name="eventname" type="string" desc="The event to register to"/>
                            <param name="callback" type="string" alias="function" desc="Function name to call on the event"/>
                            <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                        </function>
                        <function name="deregister">
                            <desc>This function is used to deregister from any registered event of the handle.</desc>
                            <sample for="lua">LightGridData.Provider.RemoteLightGrid.deregister(handle, "OnNewScan", "OnNewData")</sample>
                            <param name="handle" type="handle" alias="LightGridData.Provider.RemoteLightGrid" desc="The instance handle to use"/>
                            <param name="eventname" type="string" desc="The event to deregister from"/>
                            <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                            <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                        </function>
                        <function name="setInterface">
                            <desc>Sets the interface of the connected RemoteLightGrid device. Default is SERIAL. Please note that you must call configureSerial
resp. configureEthernet to set the connection options if you don't want the default settings described there.</desc>
                            <sample for="lua">LightGridData.Provider.RemoteLightGrid.setInterface(handle, "ETHERNET")</sample>
                            <param name="handle" type="handle" alias="LightGridData.Provider.RemoteLightGrid" desc="The instance handle"/>
                            <param name="interface" type="enum" ref="Interface" desc="The interface to use. Default is SERIAL."/>
                        </function>
                        <function name="configureSerial">
                            <desc>Configure parameters for serial connection. Default settings are (0, "RS485", 57600, NONE, 8, 1) which are
used when starting the provider in SERIAL mode without calling configureSerial before.</desc>
                            <sample for="lua">LightGridData.Provider.RemoteLightGrid.configureSerial(handle, 0, "RS232", 57600, NONE, 7, 1)</sample>
                            <param name="handle" type="handle" alias="LightGridData.Provider.RemoteLightGrid" desc="The instance handle"/>
                            <param name="portNumber" type="int" desc="Number of serial port to use."/>
                            <param name="interfaceType" type="enum" ref="Type" desc="Interface type."/>
                            <param name="baudRate" type="int" desc="Desired baudrate for the serial connection."/>
                            <param name="parity" type="enum" ref="Parity" desc="Parity of the serial connection."/>
                            <param name="dataBits" type="int" desc="Number of data bits (8 or 7)."/>
                            <param name="stopBits" type="int" desc="Number of stop bits (1, 2, 3)."/>
                        </function>
                        <function name="configureEthernet">
                            <desc>Configure parameters for ethernet connection. There are no default settings i.e. you must call this function before attempting to
start the provider in ETHERNET mode.</desc>
                            <sample for="lua">LightGridData.Provider.RemoteLightGrid.configureEthernet(handle, "10.0.0.1", 123)</sample>
                            <param name="handle" type="handle" alias="LightGridData.Provider.RemoteLightGrid" desc="The instance handle."/>
                            <param name="ipAddress" type="string" desc="IP address to connect to."/>
                            <param name="port" type="int" desc="TCP port number to connect to."/>
                        </function>
                        <function name="start">
                            <desc>Starts data acquisition.</desc>
                            <sample for="lua">LightGridData.Provider.RemoteLightGrid.start(handle)</sample>
                            <param name="handle" type="handle" alias="LightGridData.Provider.RemoteLightGrid" desc="The instance handle"/>
                            <return name="success" type="bool" desc="True if successful, false if not."/>
                        </function>
                        <function name="stop">
                            <desc>Stops data acquisition.</desc>
                            <sample for="lua">LightGridData.Provider.RemoteLightGrid.stop(handle)</sample>
                            <param name="handle" type="handle" alias="LightGridData.Provider.RemoteLightGrid" desc="The instance handle"/>
                            <return name="success" type="bool" desc="True if successful, false if not."/>
                        </function>
                    </serves>
                </crown>
                <crown name="File">
                    <trait>hidden</trait>
                    <desc>Provider for a light grid device which reads data from a file. The file format is defined as follows:

flowCounter;systemStatus;RLC1;RLC2;RLC3;...;RLCN
flowCounter;systemStatus;RLC1;RLC2;RLC3;...;RLCN
...

There is no limit on the number of RLC data items per line.</desc>
                    <serves>
                        <event name="OnNewData">
                            <include>data-flow</include>
                            <desc>The event which is triggered when new data has arrived.</desc>
                            <param name="handle" type="handle" alias="LightGridData.Provider.File" desc="The instance handle"/>
                            <param name="flowCounter" type="int" desc="Flow counter value"/>
                            <param name="systemStatus" type="int" desc="System status flags"/>
                            <param name="rlcData" type="int" multiplicity="*" desc="RLC data"/>
                        </event>
                        <function name="create">
                            <desc>Creates a new instance.</desc>
                            <sample for="lua">local handle = LightGridData.Provider.File.create()</sample>
                            <return name="handle" type="handle" alias="LightGridData.Provider.File" desc="Handle to the new instance"/>
                        </function>
                        <function name="register">
                            <desc>This function is used to register for any event of the File driver. The event name is specified as parameter</desc>
                            <sample for="lua">LightGridData.Provider.File.register(handle, "OnNewData", "OnNewData")</sample>
                            <param name="handle" type="handle" alias="LightGridData.Provider.File" desc="The instance handle"/>
                            <param name="eventname" type="string" desc="The event to register to"/>
                            <param name="callback" type="string" alias="function" desc="Function name to call on the event"/>
                            <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                        </function>
                        <function name="deregister">
                            <desc>This function is used to deregister from any registered event of the handle.</desc>
                            <sample for="lua">LightGridData.Provider.File.deregister(handle, "OnNewScan", "OnNewData")</sample>
                            <param name="handle" type="handle" alias="LightGridData.Provider.File" desc="The instance handle to use"/>
                            <param name="eventname" type="string" desc="The event to deregister from"/>
                            <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                            <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                        </function>
                        <function name="setFile">
                            <desc>Sets the file to read data from.</desc>
                            <sample for="lua">LightGridData.Provider.File.setFile(handle, "private/LightGridData.txt")</sample>
                            <param name="handle" type="handle" alias="LightGridData.Provider.File" desc="The instance handle"/>
                            <param name="filePath" type="string" desc="Path to file containing LightGridData."/>
                        </function>
                        <function name="setDelayMs">
                            <desc>Sets the time interval in ms.</desc>
                            <sample for="lua">LightGridData.Provider.File.setDelayMs(handle, 2000)</sample>
                            <param name="handle" type="handle" alias="LightGridData.Provider.File" desc="The instance handle"/>
                            <param name="delay" type="int" desc="Interval in ms."/>
                        </function>
                        <function name="start">
                            <desc>Starts data acquisition.</desc>
                            <sample for="lua">LightGridData.Provider.File.start(handle)</sample>
                            <param name="handle" type="handle" alias="LightGridData.Provider.File" desc="The instance handle"/>
                            <return name="success" type="bool" desc="True if successful, false if not."/>
                        </function>
                        <function name="stop">
                            <desc>Stops data acquisition.</desc>
                            <sample for="lua">LightGridData.Provider.File.stop(handle)</sample>
                            <param name="handle" type="handle" alias="LightGridData.Provider.File" desc="The instance handle"/>
                            <return name="success" type="bool" desc="True if successful, false if not."/>
                        </function>
                    </serves>
                </crown>
            </crown>
        </crown>
        <crown name="IOStateView">
            <trait>hidden</trait>
            <desc>Send state of I/Os as SOPAS telegram if changed</desc>
            <serves>
                <function name="create">
                    <desc>Create instance</desc>
                    <return name="handle" type="handle" desc="Handle to the instance"/>
                </function>
                <function name="view">
                    <desc>Send I/O state telegram to SOPAS</desc>
                    <param name="handle" type="handle" desc="Handle of instance"/>
                    <param name="physicalState" type="bool" multiplicity="*" desc="Physical IO-state"/>
                    <param name="logicallState" type="bool" multiplicity="*" desc="Physical IO-state"/>
                </function>
                <function name="init">
                    <desc>Initialize with number of ports on device</desc>
                    <param name="handle" type="handle" desc="Handle of instance"/>
                    <param name="portCount" type="int" desc="Number of ports on device"/>
                </function>
                <function name="setIOMapping">
                    <desc>set special io mapping</desc>
                    <param name="handle" type="handle" desc="Handle of instance"/>
                    <param name="ioStateIndex" type="int" multiplicity="*" desc="index for access state array"/>
                </function>
                <function name="updateConfiguration">
                    <desc>Change configuration of ports (which one is input or output)</desc>
                    <param name="handle" type="handle" desc="Handle of instance"/>
                    <param name="ioConfig" type="int" multiplicity="*" desc="Configuration of ports (0 = input, 1 = output)"/>
                    <param name="inputWithEdgeMode" type="bool" multiplicity="*" desc="True if according port is an input using edge mode"/>
                </function>
            </serves>
        </crown>
        <crown name="CustomerError">
            <trait>hidden</trait>
            <desc>Provides Device Errors</desc>
            <enum name="CustomerErrorEnum">
                <item name="DeviceOK">DeviceOK</item>
                <item name="FWUpdateFailure">FWUpdateFailure</item>
                <item name="CheckParameter">CheckParameter</item>
                <item name="CheckIOConfig">CheckIOConfig</item>
                <item name="SlaveSyncLost">SlaveSyncLost</item>
                <item name="DeviceNotReady">DeviceNotReady</item>
                <item name="NTPSyncFailure">NTPSyncFailure</item>
                <item name="MonitoringDeviceError">MonitoringDeviceError</item>
                <item name="DeviceContaminationWarning">DeviceContaminationWarning</item>
                <item name="DeviceContaminationError">DeviceContaminationError</item>
                <item name="DeviceFailure">DeviceFailure</item>
                <item name="DeviceTempFailure">DeviceTempFailure</item>
                <item name="HeatingFailure">HeatingFailure</item>
                <item name="DefectiveDevice">DefectiveDevice</item>
            </enum>
            <serves>
                <event name="OnCustomerErrorRaised">
                    <desc>Notifies a new customer error</desc>
                    <param name="ErrorName" type="enum" ref="CustomerErrorEnum" desc="Customer Error"/>
                </event>
                <event name="OnCustomerErrorResolved">
                    <desc>Notifies a resovled customer error</desc>
                    <param name="ErrorName" type="enum" ref="CustomerErrorEnum" desc="Customer Error"/>
                </event>
                <function name="isAnyErrorActive">
                    <desc>Check if the requested error is active or not</desc>
                    <param name="ErrorName" type="enum" ref="CustomerErrorEnum" desc="Customer Error"/>
                    <return name="success" type="bool" desc="True if the error is active"/>
                </function>
                <function name="calcDateTimeValuesFromUTC">
                    <desc>Returns the individual parts (d, mo, y, h, m, s, ms) of the datetime from an input timestamp in UTC time.</desc>
                    <param name="unixUTCTime" type="int" desc="The timestamp in UTC to get the individual parts from"/>
                    <return name="day" type="int" desc="Day"/>
                    <return name="month" type="int" desc="Month"/>
                    <return name="year" type="int" desc="Year"/>
                    <return name="hour" type="int" desc="Hour"/>
                    <return name="minute" type="int" desc="Minute"/>
                    <return name="second" type="int" desc="Second"/>
                </function>
            </serves>
        </crown>
        <crown name="ControlChannel">
            <trait>hidden</trait>
            <desc>Provides access to parameters and methods of the measurement module. Typically this should only be used in Developer or Production Apps!</desc>
            <serves>
                <function name="create">
                    <desc>Create instance of control channel instance. Will sync parameters and methods upon creation.
So after creation all variables and methods of the measurement module that are published in
a parameter cid file of the app will be automatically forwarded to the measurement module.
So you can talk to the measurement module using Cola or REST API.</desc>
                    <return name="handle" type="handle" desc="Handle to the instance"/>
                </function>
                <function name="readParameter">
                    <desc>Read parameter of measurement module. Returns value as json string.</desc>
                    <param name="handle" type="handle" desc="Handle to the instance"/>
                    <param name="name" type="string" desc="Name of the parameter."/>
                    <return name="valueJson" type="string" desc="Json String of the value"/>
                </function>
                <function name="getParameterNames">
                    <desc>Read parameter of measurement module. Returns value as json string.</desc>
                    <param name="handle" type="handle" desc="Handle to the instance"/>
                    <return name="names" type="string" multiplicity="*" desc="Array of parameter names that are available in measurement module."/>
                </function>
                <function name="writeParameter">
                    <desc>Write parameter of measurement module. Value is passed as json string.</desc>
                    <param name="handle" type="handle" desc="Handle to the instance"/>
                    <param name="name" type="string" desc="Name of the parameter."/>
                    <param name="valueJson" type="string" desc="Json String of the value"/>
                    <return name="success" type="bool" desc="True on success"/>
                </function>
                <function name="getMethodNames">
                    <desc>Read parameter of measurement module. Returns value as json string.</desc>
                    <param name="handle" type="handle" desc="Handle to the instance"/>
                    <return name="names" type="string" multiplicity="*" desc="Array of method names that are available in measurement module."/>
                </function>
                <function name="executeMethod">
                    <desc>Write parameter of measurement module. Value is passed as json string.</desc>
                    <param name="handle" type="handle" desc="Handle to the instance"/>
                    <param name="name" type="string" desc="Name of the method."/>
                    <param name="valueJson" type="string" desc="Json String of the parameter value"/>
                    <return name="resultJson" type="string" desc="Json String of the result value"/>
                </function>
                <function name="saveCalib">
                    <desc>Save calib parameters in persistent storage of measurement module.</desc>
                    <param name="handle" type="handle" desc="Handle to the instance"/>
                </function>
                <function name="readHwParameter">
                    <desc>Read parameter of measurement module. Returns value as json string.</desc>
                    <param name="handle" type="handle" desc="Handle to the instance"/>
                    <param name="name" type="string" desc="Name of the parameter."/>
                    <return name="valueJson" type="string" desc="Json String of the value"/>
                </function>
                <function name="getHwParameterNames">
                    <desc>Read parameter of measurement module. Returns value as json string.</desc>
                    <param name="handle" type="handle" desc="Handle to the instance"/>
                    <return name="names" type="string" multiplicity="*" desc="Array of parameter names that are available in measurement module."/>
                </function>
                <function name="getHwMonitorParameterNames">
                    <desc>Read parameter of measurement module. Returns value as json string.</desc>
                    <param name="handle" type="handle" desc="Handle to the instance"/>
                    <return name="names" type="string" multiplicity="*" desc="Array of parameter names that are available in measurement module."/>
                </function>
                <function name="writeHwParameter">
                    <desc>Write parameter of measurement module. Value is passed as json string.</desc>
                    <param name="handle" type="handle" desc="Handle to the instance"/>
                    <param name="name" type="string" desc="Name of the parameter."/>
                    <param name="valueJson" type="string" desc="Json String of the value"/>
                    <return name="success" type="bool" desc="True on success"/>
                </function>
                <function name="loadHwParameter">
                    <desc>Load hw parameters</desc>
                    <return name="success" type="bool" desc="True on success"/>
                </function>
                <function name="saveHwParameter">
                    <desc>save hw parameters</desc>
                    <return name="success" type="bool" desc="True on success"/>
                </function>
                <function name="isConnected">
                    <desc>connection state to house keeper</desc>
                    <param name="handle" type="handle" desc="Handle to the instance"/>
                    <return name="connected" type="bool" desc="True on success"/>
                </function>
                <function name="getNumberTimeouts">
                    <desc>Number of timeouts after control commands</desc>
                    <param name="handle" type="handle" desc="Handle to the instance"/>
                    <return name="numberTimeouts" type="int" desc=""/>
                </function>
                <function name="getNumberDisconnects">
                    <desc>Number of disconnects of housekeeper</desc>
                    <param name="handle" type="handle" desc="Handle to the instance"/>
                    <return name="numberDisconnects" type="int" desc=""/>
                </function>
            </serves>
        </crown>
        <crown name="DataChannel">
            <trait>hidden</trait>
            <desc>Provides events of device status data. Typically this should only be used in Developer or Production Apps!</desc>
            <serves>
                <event name="OnNewStatusData">
                    <desc>Notifies new status data as json struct '{ "status" : { "name1" : "val1", "name2" : "val2"}}'</desc>
                    <param name="handle" type="handle" desc="Handle to the instance"/>
                    <param name="StatusData" type="string" desc="status data json struct"/>
                </event>
                <event name="OnNewLogData">
                    <desc>Notifies new log msgs as string array</desc>
                    <param name="handle" type="handle" desc="Handle to the instance"/>
                    <param name="LogData" type="string" multiplicity="*" desc="string array"/>
                </event>
                <function name="create">
                    <desc>Create instance of data channel instance.</desc>
                    <return name="handle" type="handle" desc="Handle to the instance"/>
                </function>
                <function name="register">
                    <desc>This function is used to register for any event of the crown. The event name is specified as parameter</desc>
                    <sample for="lua">DataChannel.register(handle, "OnNewStatusData", "handleOnNewStatusData")</sample>
                    <param name="handle" type="handle" alias="DataChannel" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to register to"/>
                    <param name="callback" type="string" alias="function" desc="function name to call on the event"/>
                    <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                </function>
                <function name="deregister">
                    <desc>This function is used to deregister from any registered event of the handle.</desc>
                    <sample for="lua">DataChannel.deregister(handle, "OnNewStatusData", "handleOnNewStatusData")</sample>
                    <param name="handle" type="handle" alias="DataChannel" desc="The instance handle to use"/>
                    <param name="eventname" type="string" desc="The event to deregister from"/>
                    <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                    <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                </function>
                <function name="getNumberCrcFail">
                    <desc>Number of data failures</desc>
                    <param name="handle" type="handle" desc="Handle to the instance"/>
                    <return name="number" type="int" desc=""/>
                </function>
                <function name="getNumberFragmentTimeout">
                    <desc>Number of data failures</desc>
                    <param name="handle" type="handle" desc="Handle to the instance"/>
                    <return name="number" type="int" desc=""/>
                </function>
                <function name="getNumberMagicFail">
                    <desc>Number of data failures</desc>
                    <param name="handle" type="handle" desc="Handle to the instance"/>
                    <return name="number" type="int" desc=""/>
                </function>
                <function name="getNumberMissedPackets">
                    <desc>Number of data failures</desc>
                    <param name="handle" type="handle" desc="Handle to the instance"/>
                    <return name="number" type="int" desc=""/>
                </function>
                <function name="getNumberParsingError">
                    <desc>Number of data failures</desc>
                    <param name="handle" type="handle" desc="Handle to the instance"/>
                    <return name="number" type="int" desc=""/>
                </function>
                <function name="getNumberStatusDataParsingError">
                    <desc>Number of data failures</desc>
                    <param name="handle" type="handle" desc="Handle to the instance"/>
                    <return name="number" type="int" desc=""/>
                </function>
                <function name="getNumberUnknownTelegrams">
                    <desc>Number of data failures</desc>
                    <param name="handle" type="handle" desc="Handle to the instance"/>
                    <return name="number" type="int" desc=""/>
                </function>
            </serves>
        </crown>
        <crown name="ScanImages">
            <trait>released</trait>
            <desc>Data type produced by Ranger/Ruler cameras containing multiple different measurements of the same object.
In addition to a basic 3D measurement of the observed objects (obtained by use of laser triangulation) there can be
intensity, color and scatter measurements stored inside the ScanImages container. The functions provided by the
ScanImages Crown can be used to extract individual measurements from a data object returned by one of the providers.</desc>
            <serves>
                <function name="getImage">
                    <desc>Extract an Image from a given result object.</desc>
                    <sample for="lua">img = ScanImages.getImage(result, "ComponentName", "SubComponentName")</sample>
                    <param name="result" type="object" alias="ScanImages" desc="A scan images result."/>
                    <param name="component" type="string" desc="Component to get the result for."/>
                    <param name="subComponent" type="string" desc="Subcomponent to get the result for."/>
                    <return name="image" type="object" alias="Image" desc="Extracted image."/>
                </function>
                <function name="toPointCloud">
                    <desc>Extract a point cloud from a 3D component of a given result object.</desc>
                    <sample for="lua">pointCloud, encoderValue = ScanImages.toPointCloud(result, "ComponentName", 10)</sample>
                    <param name="result" type="object" alias="ScanImages" desc="A scan images result."/>
                    <param name="component" type="string" desc="The 3D component to convert to point cloud."/>
                    <param name="encoderResolution" type="float" desc="Encoder resolution in millimeters per encoder tick."/>
                    <param name="startIndex" type="int" multiplicity="?" desc="Index of the first profile to extract from the component (zero based)"/>
                    <param name="endIndex" type="int" multiplicity="?" desc="Index of the last profile to extract from the component (zero based)"/>
                    <return name="pointCloud" type="object" alias="PointCloud" desc="Extracted point cloud."/>
                    <return name="encoderValue" type="int" desc="Encoder value corresponding to mark value of first scan or internally generated otherwise."/>
                </function>
                <function name="getHorThr">
                    <trait>hidden</trait>
                    <desc>Retrieves a HorThr component from a given result object.</desc>
                    <sample for="lua">rangeX, rangeR, mark = ScanImages.getHorThr(result, "ComponentName")</sample>
                    <param name="result" type="object" alias="ScanImages" desc="A scan images result."/>
                    <param name="component" type="string" desc="Component to get the result for."/>
                    <return name="rangeX" type="object" alias="Image" desc="The range X data."/>
                    <return name="rangeR" type="object" alias="Image" desc="The range R data."/>
                    <return name="mark" type="object" alias="Image" desc="The mark data."/>
                </function>
                <function name="getHorMax">
                    <trait>hidden</trait>
                    <desc>Retrieves a HorMax component from a given result object.</desc>
                    <sample for="lua">rangeX, rangeR, intensity, mark = ScanImages.getHorMax(result, "ComponentName")</sample>
                    <param name="result" type="object" alias="ScanImages" desc="A scan images result."/>
                    <param name="component" type="string" desc="Component to get the result for."/>
                    <return name="rangeX" type="object" alias="Image" desc="The range X data."/>
                    <return name="rangeR" type="object" alias="Image" desc="The range R data."/>
                    <return name="intensity" type="object" alias="Image" desc="The intensity data."/>
                    <return name="mark" type="object" alias="Image" desc="The mark data."/>
                </function>
                <function name="getHorThrMax">
                    <trait>hidden</trait>
                    <desc>Retrieves a HorThrMax component from a given result object.</desc>
                    <sample for="lua">rangeX, rangeR, intensity, mark = ScanImages.getHorThrMax(result, "ComponentName")</sample>
                    <param name="result" type="object" alias="ScanImages" desc="A scan images result."/>
                    <param name="component" type="string" desc="Component to get the result for."/>
                    <return name="rangeX" type="object" alias="Image" desc="The range X data."/>
                    <return name="rangeR" type="object" alias="Image" desc="The range R data."/>
                    <return name="intensity" type="object" alias="Image" desc="The intensity data."/>
                    <return name="mark" type="object" alias="Image" desc="The mark data."/>
                </function>
                <function name="get3DData">
                    <desc>Retrieves a Hi3D component from a given result object.</desc>
                    <sample for="lua">rangeX, rangeR, intensity, mark, scatter = ScanImages.get3DData(result, "ComponentName")</sample>
                    <param name="result" type="object" alias="ScanImages" desc="A scan images result."/>
                    <param name="component" type="string" desc="Component to get the result for."/>
                    <return name="rangeX" type="object" alias="Image" desc="The range X data."/>
                    <return name="rangeR" type="object" alias="Image" desc="The range R data."/>
                    <return name="intensity" type="object" alias="Image" desc="The intensity data."/>
                    <return name="mark" type="object" alias="Image" desc="The mark data."/>
                    <return name="scatter" type="object" multiplicity="?" alias="Image" desc="The scatter data."/>
                </function>
                <function name="getHi3DCOG">
                    <trait>hidden</trait>
                    <desc>Retrieves a Hi3DCOG component from a given result object.</desc>
                    <sample for="lua">rangeX, rangeR, intensity, mark = ScanImages.getHi3DCOG(result, "ComponentName")</sample>
                    <param name="result" type="object" alias="ScanImages" desc="A scan images result."/>
                    <param name="component" type="string" desc="Component to get the result for."/>
                    <return name="rangeX" type="object" alias="Image" desc="The range X data."/>
                    <return name="rangeR" type="object" alias="Image" desc="The range R data."/>
                    <return name="intensity" type="object" alias="Image" desc="The intensity data."/>
                    <return name="mark" type="object" alias="Image" desc="The mark data."/>
                </function>
                <function name="getGray">
                    <trait>hidden</trait>
                    <desc>Retrieves a Gray component from a given result object.</desc>
                    <sample for="lua">intensity, mark = ScanImages.getGray(result, "ComponentName")</sample>
                    <param name="result" type="object" alias="ScanImages" desc="A scan images result."/>
                    <param name="component" type="string" desc="Component to get the result for."/>
                    <return name="intensity" type="object" alias="Image" desc="The intensity data."/>
                    <return name="mark" type="object" alias="Image" desc="The mark data."/>
                </function>
                <function name="getMark">
                    <trait>hidden</trait>
                    <desc>Retrieves mark information as an array from a given result object for a specific component.
The size of the mark array is equal to the configured number of profiles per buffer.</desc>
                    <sample for="lua">encoder, trigger = ScanImages.getMark(result, "Hi3D 1")</sample>
                    <param name="result" type="object" alias="ScanImages" desc="A scan images result."/>
                    <param name="component" type="string" desc="Component to get the result for."/>
                    <return name="encoder" type="int" multiplicity="+" desc="Array of encoder values"/>
                    <return name="enabled" type="bool" multiplicity="+" desc="Array of booleans indicating if enabled signal was high or low."/>
                </function>
                <function name="getScanStatus">
                    <trait>hidden</trait>
                    <desc>Retrieve the status for each profile. Either valid or invalid.</desc>
                    <sample for="lua">isProfileValid = ScanImages.getScanStatus(result)</sample>
                    <param name="result" type="object" alias="ScanImages" desc="A scan images result."/>
                    <return name="isProfileValid" type="bool" multiplicity="+" desc="Array of booleans indicating if profile is valid"/>
                </function>
                <function name="getHiResGray">
                    <trait>hidden</trait>
                    <desc>Retrieves a HiResGray component from a given result object.</desc>
                    <sample for="lua">intensity, mark = ScanImages.getHiResGray(result, "ComponentName")</sample>
                    <param name="result" type="object" alias="ScanImages" desc="A scan images result."/>
                    <param name="component" type="string" desc="Component to get the result for."/>
                    <return name="intensity" type="object" alias="Image" desc="The intensity data."/>
                    <return name="mark" type="object" alias="Image" desc="The mark data."/>
                </function>
                <function name="getScatter">
                    <trait>hidden</trait>
                    <desc>Retrieves a Scatter component from a given result object.</desc>
                    <sample for="lua">intensity, mark, scatter = ScanImages.getScatter(result, "ComponentName")</sample>
                    <param name="result" type="object" alias="ScanImages" desc="A scan images result."/>
                    <param name="component" type="string" desc="Component to get the result for."/>
                    <return name="intensity" type="object" alias="Image" desc="The intensity data."/>
                    <return name="mark" type="object" alias="Image" desc="The mark data."/>
                    <return name="scatter" type="object" alias="Image" desc="The scatter data."/>
                </function>
            </serves>
            <crown name="Provider">
                <trait>released</trait>
                <desc>Providers for ScanImages data.</desc>
                <crown name="RemoteRangerRuler">
                    <trait>released</trait>
                    <desc>Interface for remotely connected Ranger/Ruler devices. In order to connect to a sensor its IP address must be known and set on
the provider handle before calling the start function. Device configuration is done on a RangerCulerConfig object (see documentation there) and
applied to the sensor using the setConfig function. Acquired data is published through the OnNewData event.</desc>
                    <enum name="Mode">
                        <item>IMAGE</item>
                        <item>MEASUREMENT</item>
                    </enum>
                    <enum name="RectificationMode">
                        <item>MEAN</item>
                        <item>BOTTOM_MOST</item>
                        <item>TOP_MOST</item>
                    </enum>
                    <serves>
                        <event name="OnNewData">
                            <desc>The event which is thrown for every new image/scan.</desc>
                            <param name="handle" type="handle" alias="ScanImages.Provider.RemoteRangerRuler" desc="Instance handle of the RemoteRangerRuler provider."/>
                            <param name="data" type="object" desc="The data captured by the sensor."/>
                        </event>
                        <event name="OnCaptureError">
                            <desc>The event which is thrown after encountering an error during capture phase.</desc>
                            <param name="handle" type="handle" alias="ScanImages.Provider.RemoteRangerRuler" desc="Instance handle of the RemoteRangerRuler provider."/>
                        </event>
                        <function name="create">
                            <desc>Creates an instance of a RemoteRangerRuler provider.</desc>
                            <sample for="lua">handle = ScanImages.Provider.RemoteRangerRuler.create()</sample>
                            <return name="handle" type="handle" alias="ScanImages.Provider.RemoteRangerRuler" desc="Instance handle of the RemoteRangerRuler provider."/>
                        </function>
                        <function name="setMaxNumberOfThreads">
                            <desc>Sets maximum number of threads used for parallell computing.
Used for limiting the number of cores used for processing image data.
Note that no more than the number of cores available on the system will be used for parallell computing.</desc>
                            <sample for="lua">ScanImages.Provider.RemoteRangerRuler.setMaxNumberOfThreads(handle, 4)</sample>
                            <param name="handle" type="handle" alias="ScanImages.Provider.RemoteRangerRuler" desc="Instance handle of the RemoteRangerRuler provider."/>
                            <param name="num_of_threads" type="int" desc="Numbers of threads to use, from 1 to the number of cores in the system. For better performance, use a multiple of two (2)."/>
                            <return name="success" type="bool" desc="true if maximum number of threads has been set successfully, false if not."/>
                        </function>
                        <function name="setIPAddress">
                            <desc>Sets the IP address of the remote Ranger/Ruler to connect to.</desc>
                            <sample for="lua">ScanImages.Provider.RemoteRangerRuler.setIPAddress(handle, "192.168.0.100")</sample>
                            <param name="handle" type="handle" alias="ScanImages.Provider.RemoteRangerRuler" desc="Instance handle of the RemoteRangerRuler provider."/>
                            <param name="ip" type="string" desc="IP address of the remote device."/>
                            <return name="success" type="bool" desc="true if ip address has been set successfully, false if not."/>
                        </function>
                        <function name="setMode">
                            <desc>Sets the mode of the remote device (Image or Measurement).</desc>
                            <sample for="lua">ScanImages.Provider.RemoteRangerRuler.setMode(handle, "MEASUREMENT")</sample>
                            <param name="handle" type="handle" alias="ScanImages.Provider.RemoteRangerRuler" desc="Instance handle of the RemoteRangerRuler provider."/>
                            <param name="mode" type="enum" ref="Mode" desc="The mode to set."/>
                            <return name="success" type="bool" desc="true if mode has been set successfully, false if not."/>
                        </function>
                        <function name="setConfig">
                            <desc>Applies the configuration to the remote device and (re)initializes it.</desc>
                            <sample for="lua">ScanImages.Provider.RemoteRangerRuler.setConfig(handle, config)</sample>
                            <param name="handle" type="handle" alias="ScanImages.Provider.RemoteRangerRuler" desc="Instance handle of the RemoteRangerRuler provider."/>
                            <param name="configHandle" type="object" alias="ScanImages.Provider.RangerRulerConfig" desc="Handle of config instance to apply."/>
                            <return name="success" type="bool" desc="true if initial config has been applied successfully, false if not."/>
                        </function>
                        <function name="setParameter">
                            <desc>Sets a single parameter without reinitializing the device.</desc>
                            <sample for="lua">local success = ScanImages.Provider.RemoteRangerRuler.setParameter(handle, "path as xml", "parameter name", "value")</sample>
                            <param name="handle" type="handle" alias="ScanImages.Provider.RemoteRangerRuler" desc="Instance handle of the RemoteRangerRuler provider."/>
                            <param name="path" type="string" desc="Path of the parameter to set."/>
                            <param name="name" type="string" desc="Name of the parameter to set."/>
                            <param name="value" type="string" desc="Value to set."/>
                            <return name="success" type="bool" desc="true if parameter has been set successfully, false if not."/>
                        </function>
                        <function name="setRectificationFilter">
                            <desc>Sets up parameters for calibration.</desc>
                            <sample for="lua">ScanImages.Provider.RemoteRangerRuler.setRectificationFilter(handle, bRectify,0,1536)</sample>
                            <param name="handle" type="handle" alias="ScanImages.Provider.RemoteRangerRuler" desc="Instance handle of the RemoteRangerRuler provider."/>
                            <param name="bRectify" type="bool" desc="Use rectification."/>
                            <param name="RectificationMode" type="enum" ref="RectificationMode" desc="The rectification mode (mean, top-most or bottom-most)"/>
                            <param name="RectificationWidth" type="int" desc="Number of pixels in result image (e.g. 1536)"/>
                            <return name="success" type="bool" desc="true unless setup fails"/>
                        </function>
                        <function name="getFovSize">
                            <desc>Retrieves the Width (X) and Height (Z) limitations of the calibrated Range data.
Camera must be initialized.</desc>
                            <sample for="lua">local widthMin, widthMax, heightMin, heightMax = ScanImages.Provider.RemoteRangerRuler.getFovSize(handle)</sample>
                            <param name="handle" type="handle" alias="ScanImages.Provider.RemoteRangerRuler" desc="Instance handle of the RemoteRangerRuler provider."/>
                            <return name="widthMin" type="float" desc="Minimum field of view width"/>
                            <return name="widthMax" type="float" desc="Maximum field of view width"/>
                            <return name="heightMin" type="float" desc="Minimum field of view height"/>
                            <return name="heightMax" type="float" desc="Maximum field of view height"/>
                        </function>
                        <function name="isRunning">
                            <desc>Check wether the driver is capturing</desc>
                            <sample for="lua">local isRunning = ScanImages.Provider.RemoteRangerRuler.isRunning(handle)</sample>
                            <param name="handle" type="handle" alias="ScanImages.Provider.RemoteRangerRuler" desc="Instance handle of the RemoteRangerRuler provider."/>
                            <return name="isRunning" type="bool" desc="true if the driver is capturing"/>
                        </function>
                        <function name="setProfilesPerBuffer">
                            <desc>Set the number of profiles that will be delivered as a single frame from the driver.</desc>
                            <sample for="lua">local success = ScanImages.Provider.RemoteRangerRuler.setProfilesPerBuffer(handle, 512)</sample>
                            <param name="handle" type="handle" alias="ScanImages.Provider.RemoteRangerRuler" desc="Instance handle of the RemoteRangerRuler provider."/>
                            <param name="profiles" type="int" desc="The number or profiles that will be delivered as a single frame from the driver."/>
                            <return name="success" type="bool" desc="true if image acquisition has been started successfully, false if not."/>
                        </function>
                        <function name="start">
                            <desc>Starts image acquisition.</desc>
                            <sample for="lua">local success = ScanImages.Provider.RemoteRangerRuler.start(handle)</sample>
                            <param name="handle" type="handle" alias="ScanImages.Provider.RemoteRangerRuler" desc="Instance handle of the RemoteRangerRuler provider."/>
                            <return name="success" type="bool" desc="true if image acquisition has been started successfully, false if not."/>
                        </function>
                        <function name="stop">
                            <desc>Stops image acquisition.</desc>
                            <sample for="lua">local stopped = ScanImages.Provider.RemoteRangerRuler.stop(handle)</sample>
                            <param name="handle" type="handle" alias="ScanImages.Provider.RemoteRangerRuler" desc="Instance handle of the RemoteRangerRuler provider."/>
                            <return name="success" type="bool" desc="true if image acquisition has been stopped successfully, false if not."/>
                        </function>
                        <function name="register">
                            <desc>This function is used to register for any event of the image provider. The event name is specified as parameter.</desc>
                            <sample for="lua">ScanImages.Provider.register(handle, "OnNewData", "HandleNewData")</sample>
                            <param name="handle" type="handle" alias="ScanImages.Provider.RemoteRangerRuler" desc="Instance handle of the RemoteRangerRuler provider."/>
                            <param name="eventname" type="string" desc="The event to register to."/>
                            <param name="callback" type="string" alias="function" desc="Function name to call when the event occurs."/>
                            <return name="success" type="bool" desc="True if successfully registered. False if event does not exist."/>
                        </function>
                        <function name="deregister">
                            <desc>This function is used to deregister from any registered event of the handle.</desc>
                            <param name="handle" type="handle" alias="ScanImages.Provider.RemoteRangerRuler" desc="The instance handle to use"/>
                            <param name="eventname" type="string" desc="The event to deregister from"/>
                            <param name="callback" type="string" alias="function" desc="The function name which was registered on the event"/>
                            <return name="success" type="bool" desc="True if successfully deregistered. False if event does not exist or callback wasn't registered."/>
                        </function>
                    </serves>
                </crown>
                <crown name="RangerRulerConfig">
                    <trait>released</trait>
                    <desc>Configuration object for the RemoteRangerRuler provider. Currently there are only functions for loading configuration from a
Ranger/Ruler config XML respectively loading calibration data from LUT files. The config object stores the state of the configuration and must
be applied to the provider object by calling the setConfig function on the RemoteRangerRuler instance.</desc>
                    <serves>
                        <function name="create">
                            <desc>Creates an instance of a RangerRulerConfig.</desc>
                            <sample for="lua">config = ScanImages.Provider.RangerRulerConfig.create()</sample>
                            <return name="handle" type="object" alias="ScanImages.Provider.RangerRulerConfig" desc="Instance handle of the RangerRulerConfig."/>
                        </function>
                        <function name="loadConfigXML">
                            <desc>Loads full sensor configuration from a parameter XML file.</desc>
                            <sample for="lua">local success = ScanImages.Provider.RangerRulerConfig.loadConfigXML(config, "resources/Config.prm")</sample>
                            <param name="handle" type="object" alias="ScanImages.Provider.RangerRulerConfig" desc="Instance handle of the RangerRulerConfig."/>
                            <param name="xmlPath" type="string" desc="Location of the parameter XML file."/>
                            <return name="success" type="bool" desc="true if sensor configuration has been loaded successfully, false if not."/>
                        </function>
                        <function name="loadCalibrationLUT">
                            <desc>Loads full sensor calibration from a LUT file specified in the path instead of using the LUT from the device.</desc>
                            <sample for="lua">local success = ScanImages.Provider.RangerRulerConfig.loadCalibrationLUT(config, "resources/Calib.lut")</sample>
                            <param name="handle" type="object" alias="ScanImages.Provider.RangerRulerConfig" desc="Instance handle of the RangerRulerConfig."/>
                            <param name="lutPath" type="string" desc="Location of the calibration LUT file."/>
                            <return name="success" type="bool" desc="true if sensor configuration has been loaded successfully, false if not."/>
                        </function>
                    </serves>
                </crown>
            </crown>
        </crown>
        <data_format name="Recording.Provider">
            <trait>released</trait>
            <sample for="json">
{
  "class":"Recording.Provider",
  "data":
  {
    "EngineName": "",
    "AppName": "App_A",
    "CrownName": "Image.Provider.Directory",
    "EventName": "OnNewImage",
    "ConfigData": "",
    "InstanceCount": 1,
    "Topic":"",
    "Selected": false
  }
}
      </sample>
            <item>
                <struct>
                    <item name="EngineName">
                        <string/>
                    </item>
                    <item name="AppName">
                        <string/>
                    </item>
                    <item name="CrownName">
                        <string/>
                    </item>
                    <item name="EventName">
                        <string/>
                    </item>
                    <item name="ConfigData">
                        <string/>
                    </item>
                    <item name="InstanceCount">
                        <int signed="true" width="64"/>
                    </item>
                    <item name="Topic">
                        <string/>
                    </item>
                    <item name="Selected">
                        <bool/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="PrimitiveType">
            <trait>released</trait>
            <sample for="json">
        42
      </sample>
            <item>
                <any_of>
                    <item>
                        <int signed="true" width="64"/>
                    </item>
                    <item>
                        <int signed="false" width="64"/>
                    </item>
                    <item>
                        <float width="64"/>
                    </item>
                    <item>
                        <string/>
                    </item>
                    <item>
                        <bool/>
                    </item>
                </any_of>
            </item>
        </data_format>
        <data_format name="Recording.StampInfo">
            <trait>released</trait>
            <sample for="json">
        { "class":"Recording.StampInfo",
          "data":
          { "Name": "TimeUs",
            "MinValue": 0,
            "CurrentValue": 14322,
            "MaxValue": 50000
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="Name" desc="Name of the stamp">
                        <string/>
                    </item>
                    <item name="MinValue" desc="Minimum stamp value">
                        <data_format_ref name="PrimitiveType"/>
                    </item>
                    <item name="CurrentValue" desc="Current stamp value">
                        <data_format_ref name="PrimitiveType"/>
                    </item>
                    <item name="MaxValue" desc="Maximum stamp value">
                        <data_format_ref name="PrimitiveType"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Recording.Recorder">
            <trait>released</trait>
            <sample for="json">
{
  "class": "Recording.Recorder",
  "data": {
    "Mode": "STOP_BASED_ITEMS",
    "ModeParam": {
      "HasValue": true,
      "Value": 10
    },
    "DataFormat": "MSGPACK",
    "SelectedProviders": [
      {
        "class": "Recording.Provider",
        "data": {
          "EngineName": "",
          "AppName": "mockApp",
          "CrownName": "Payload",
          "EventName": "OnNewData",
          "ConfigData": "",
          "InstanceCount": 0,
          "Selected": true
        }
      },
      {
        "class": "Recording.Provider",
        "data": {
          "EngineName": "",
          "AppName": "mockApp",
          "CrownName": "Payload",
          "EventName": "OnNewVectorData",
          "ConfigData": "",
          "InstanceCount": 0,
          "Selected": true
        }
      },
      {
        "class": "Recording.Provider",
        "data": {
          "EngineName": "",
          "AppName": "",
          "CrownName": "Payload",
          "EventName": "StaticEvent",
          "ConfigData": "",
          "InstanceCount": 0,
          "Selected": true
        }
      }
    ],
    "MetaInfos": [
      {
        "Name": "a",
        "MimeType": "text/plain",
        "StringData": "Hello, World!",
        "BinaryData": {
          "numOfElems": 0,
          "elemSz": 1,
          "endian": "neutral",
          "elemTypes": [
            "uint8"
          ],
          "data": ""
        },
        "Comment": "MyComment"
      },
      {
        "Name": "b",
        "MimeType": "application/octet-stream",
        "StringData": "",
        "BinaryData": {
          "numOfElems": 2,
          "elemSz": 1,
          "endian": "neutral",
          "elemTypes": [
            "uint8"
          ],
          "data": "AQI="
        },
        "Comment": ""
      }
    ]
  }
}
      </sample>
            <item>
                <struct>
                    <item name="Mode">
                        <any_of>
                            <item>
<string value="CONTINUOUS"/>
                            </item>
                            <item>
<string value="STOP_BASED_TIME"/>
                            </item>
                            <item>
<string value="STOP_BASED_ITEMS"/>
                            </item>
                        </any_of>
                    </item>
                    <item name="ModeParam">
                        <struct>
                            <item name="HasValue">
<bool/>
                            </item>
                            <item name="Value">
<int signed="true" width="64"/>
                            </item>
                        </struct>
                    </item>
                    <item name="DataFormat">
                        <any_of>
                            <item>
<string value="JSON"/>
                            </item>
                            <item>
<string value="MSGPACK"/>
                            </item>
                        </any_of>
                    </item>
                    <item name="SelectedProviders">
                        <array>
                            <item>
<polymorphic>
    <data_format_ref name="Recording.Provider"/>
</polymorphic>
                            </item>
                        </array>
                    </item>
                    <item name="MetaInfos">
                        <array>
                            <item>
<struct>
    <item name="Name">
        <string/>
    </item>
    <item name="MimeType">
        <string/>
    </item>
    <item name="StringData">
        <string/>
    </item>
    <item name="BinaryData">
        <big_data_array>
            <element_type name="uint8" desc="Single bytes of the BLOB"/>
        </big_data_array>
    </item>
    <item name="Comment">
        <string/>
    </item>
</struct>
                            </item>
                        </array>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Parameters.Node">
            <trait>released</trait>
            <sample for="json">
// Sample for Int:
{
  "class":"Parameters.Node",
  "data":
  {
    "type": "Int", "value": 0
  }
}
// Sample for Struct:
{
  "class":"Parameters.Node",
  "data":
  {
    "type": "Struct",
    "value":
    [
      { "name":"member1", "type":"Int", "value":1 },
      { "name":"member2", "type":"String", "value":2 },
    ]
  }
}
// Sample for Array:
{
  "class":"Parameters.Node",
  "data":
  {
    "type": "Array",
    "value":
    {
      "type":"Int",
      "value": [ 1, 1, 3 ]
    }
  }
}
      </sample>
            <item>
                <struct>
                    <item name="type">
                        <any_of>
                            <item>
<string value="SInt"/>
                            </item>
                            <item>
<string value="Int"/>
                            </item>
                            <item>
<string value="DInt"/>
                            </item>
                            <item>
<string value="LInt"/>
                            </item>
                            <item>
<string value="USInt"/>
                            </item>
                            <item>
<string value="UInt"/>
                            </item>
                            <item>
<string value="UDInt"/>
                            </item>
                            <item>
<string value="ULInt"/>
                            </item>
                            <item>
<string value="Real"/>
                            </item>
                            <item>
<string value="LReal"/>
                            </item>
                            <item>
<string value="Bool"/>
                            </item>
                            <item>
<string value="String"/>
                            </item>
                            <item>
<string value="Array"/>
                            </item>
                            <item>
<string value="Struct"/>
                            </item>
                        </any_of>
                    </item>
                    <item name="value">
                        <data_format_ref name="Parameters.Node.Variant"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Parameters.Node.Array">
            <trait>released</trait>
            <sample for="json">{ "type":"Int", "value": [ 1, 1, 3 ] }</sample>
            <item>
                <struct>
                    <item name="type">
                        <string/>
                    </item>
                    <item name="value">
                        <array>
                            <item>
<data_format_ref name="Parameters.Node.Variant"/>
                            </item>
                        </array>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Parameters.Node.Struct">
            <trait>released</trait>
            <sample for="json">[ { "name":"member1", "type":"Int", "value":1 } ]</sample>
            <item>
                <array>
                    <item>
                        <struct>
                            <item name="name">
<string/>
                            </item>
                            <item name="type">
<any_of>
    <item>
        <string value="SInt"/>
    </item>
    <item>
        <string value="Int"/>
    </item>
    <item>
        <string value="DInt"/>
    </item>
    <item>
        <string value="LInt"/>
    </item>
    <item>
        <string value="USInt"/>
    </item>
    <item>
        <string value="UInt"/>
    </item>
    <item>
        <string value="UDInt"/>
    </item>
    <item>
        <string value="ULInt"/>
    </item>
    <item>
        <string value="Real"/>
    </item>
    <item>
        <string value="LReal"/>
    </item>
    <item>
        <string value="Bool"/>
    </item>
    <item>
        <string value="String"/>
    </item>
    <item>
        <string value="Array"/>
    </item>
    <item>
        <string value="Struct"/>
    </item>
</any_of>
                            </item>
                            <item name="value">
<data_format_ref name="Parameters.Node.Variant"/>
                            </item>
                        </struct>
                    </item>
                </array>
            </item>
        </data_format>
        <data_format name="Parameters.Node.Variant">
            <trait>released</trait>
            <sample for="json">1</sample>
            <item>
                <any_of>
                    <item>
                        <int signed="true" width="64"/>
                    </item>
                    <item>
                        <int signed="false" width="64"/>
                    </item>
                    <item>
                        <float width="64"/>
                    </item>
                    <item>
                        <bool/>
                    </item>
                    <item>
                        <string/>
                    </item>
                    <item>
                        <data_format_ref name="Parameters.Node.Struct"/>
                    </item>
                    <item>
                        <data_format_ref name="Parameters.Node.Array"/>
                    </item>
                </any_of>
            </item>
        </data_format>
        <data_format name="Container">
            <trait>released</trait>
            <sample for="json">
// Sample for Container with 4 keys: one int, one string, one object and one float vector
{
  "class":"Container",
  "data":
  {
    "Content": [
      { "Key": "valKey1", "Type": "int", "IsVector": false, "Value": 5 },
      { "Key": "valKey2", "Type": "string", "IsVector": false, "Value": "stringval" },
      { "Key": "valKey3", "Type": "object", "IsVector": false, "Value": { "class": "MyObject", "data": { "somevalue": "stringval" } } },
      { "Key": "valKey4", "Type": "float", "IsVector": true, "Value": [ 1.0, 2.0, 3.0 ] }
    ]
  }
}
      </sample>
            <item>
                <struct>
                    <item name="Content">
                        <array>
                            <item>
<struct>
    <item name="Key">
        <string/>
    </item>
    <item name="Type">
        <string/>
    </item>
    <item name="IsVector">
        <bool/>
    </item>
    <item name="Value">
        <any_of>
            <item>
                <int signed="true" width="64"/>
            </item>
            <item>
                <int signed="false" width="64"/>
            </item>
            <item>
                <float width="64"/>
            </item>
            <item>
                <bool/>
            </item>
            <item>
                <string/>
            </item>
            <item>
                <polymorphic/>
            </item>
            <item>
                <array>
                    <item>
                        <int signed="true" width="64"/>
                    </item>
                </array>
            </item>
            <item>
                <array>
                    <item>
                        <int signed="false" width="64"/>
                    </item>
                </array>
            </item>
            <item>
                <array>
                    <item>
                        <float width="64"/>
                    </item>
                </array>
            </item>
            <item>
                <array>
                    <item>
                        <bool/>
                    </item>
                </array>
            </item>
            <item>
                <array>
                    <item>
                        <string/>
                    </item>
                </array>
            </item>
            <item>
                <array>
                    <item>
                        <polymorphic/>
                    </item>
                </array>
            </item>
        </any_of>
    </item>
</struct>
                            </item>
                        </array>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Object.Binary">
            <trait>hidden</trait>
            <sample for="json">
// Sample for a binary object with small byte array member with content "some value"
{
  "class":"Object.Binary",
  "data":
  {
    "Value": "c29tZSB2YWx1ZQ=="
  }
}
      </sample>
            <item>
                <struct>
                    <item name="Value">
                        <string/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="DateTime">
            <trait>released</trait>
            <sample for="json">
{
  "class": "DateTime",
  "data": {
    "ExtendedUnixTime": 1570779685.528
  }
}
      </sample>
            <item>
                <struct>
                    <item name="ExtendedUnixTime" desc="Unix time plus fraction of a second">
                        <float width="64"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Shape">
            <trait>released</trait>
            <sample for="json">
        { "class":"Shape.Circle",
          "data":
          { "cx": 0.0,
            "cy": 1.0,
            "radius": 2.0
          }
        }
      </sample>
            <item>
                <polymorphic>
                    <data_format_ref name="Shape.Arc"/>
                    <data_format_ref name="Shape.Circle"/>
                    <data_format_ref name="Shape.Composite"/>
                    <data_format_ref name="Shape.Ellipse"/>
                    <data_format_ref name="Shape.Line"/>
                    <data_format_ref name="Shape.LineSegment"/>
                    <data_format_ref name="Shape.PolyLine"/>
                    <data_format_ref name="Shape.Rectangle"/>
                    <data_format_ref name="Shape.Sector"/>
                </polymorphic>
            </item>
        </data_format>
        <data_format name="Shape.Circle">
            <trait>released</trait>
            <sample for="json">
        { "class":"Shape.Circle",
          "data":
          { "cx": 0.0,
            "cy": 1.0,
            "radius": 2.0
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="cx" desc="Center point X coordinate">
                        <float width="64"/>
                    </item>
                    <item name="cy" desc="Center point Y coordinate">
                        <float width="64"/>
                    </item>
                    <item name="radius" desc="Radius">
                        <float width="64"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Shape.Composite">
            <trait>released</trait>
            <sample for="json">
        { "class":"Shape.Composite",
          "data":
          {
            "shapes": [ { "isPositive": true, "shape": { "class": "Shape.Circle", "data": { "cx":1, "cy":2, "radius":3 } } },
                        { "isPositive": false, "shape": { "class": "Shape.Circle", "data": { "cx":2, "cy":3, "radius":4 } } }
             ]
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="shapes">
                        <array>
                            <item>
<struct>
    <item name="isPositive">
        <bool/>
    </item>
    <item name="shape">
        <data_format_ref name="Shape"/>
    </item>
</struct>
                            </item>
                        </array>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Shape.Ellipse">
            <trait>released</trait>
            <sample for="json">
        { "class":"Shape.Ellipse",
          "data":
          {
            "cx": 1.0,
            "cy": 2.0,
            "radiusX": 3.0,
            "radiusY": 4.0,
            "orientationRad": 0.0
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="cx" desc="Center point X coordinate">
                        <float width="64"/>
                    </item>
                    <item name="cy" desc="Center point Y coordinate">
                        <float width="64"/>
                    </item>
                    <item name="radiusX" desc="Radius in X direction">
                        <float width="64"/>
                    </item>
                    <item name="radiusY" desc="Radius in Y direction">
                        <float width="64"/>
                    </item>
                    <item name="orientationRad" desc="Orientation angle in radians">
                        <float width="64"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Shape.Line">
            <trait>released</trait>
            <sample for="json">
        { "class":"Shape.Line",
          "data":
          {
            "x1": 1.0,
            "y1": 2.0,
            "xDir": 1.0,
            "yDir": 1.0
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="x1" desc="Line starting point X coordinate">
                        <float width="64"/>
                    </item>
                    <item name="y1" desc="Line starting point Y coordinate">
                        <float width="64"/>
                    </item>
                    <item name="xDir" desc="Direction vector X coordinate">
                        <float width="64"/>
                    </item>
                    <item name="yDir" desc="Direction vector Y coordinate">
                        <float width="64"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Shape.LineSegment">
            <trait>released</trait>
            <sample for="json">
        { "class":"Shape.LineSegment",
          "data":
          {
            "x1": 1.0,
            "y1": 2.0,
            "x2": 2.0,
            "y2": 3.0
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="x1" desc="Line starting point X coordinate">
                        <float width="64"/>
                    </item>
                    <item name="y1" desc="Line starting point Y coordinate">
                        <float width="64"/>
                    </item>
                    <item name="x2" desc="Line ending point X coordinate">
                        <float width="64"/>
                    </item>
                    <item name="y2" desc="Line ending point X coordinate">
                        <float width="64"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Shape.PolyLine">
            <trait>released</trait>
            <sample for="json">
        { "class":"Shape.PolyLine",
          "data":
          {
            "points": [ {"x": 1.0, "y": 2.0}, {"x": 3.0, "y": 4.0} ],
            "isClosed": false
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="points">
                        <array>
                            <item>
<data_format_ref name="Point2D"/>
                            </item>
                        </array>
                    </item>
                    <item name="isClosed">
                        <bool/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Shape.Rectangle">
            <trait>released</trait>
            <sample for="json">
        { "class":"Shape.Rectangle",
          "data":
          {
            "cx": 1.0,
            "cy": 2.0,
            "width": 3.0,
            "height": 4.0,
            "orientationRad": 0.0
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="cx" desc="Center point X coordinate">
                        <float width="64"/>
                    </item>
                    <item name="cy" desc="Center point Y coordinate">
                        <float width="64"/>
                    </item>
                    <item name="width" desc="Rectangle width">
                        <float width="64"/>
                    </item>
                    <item name="height" desc="Rectangle height">
                        <float width="64"/>
                    </item>
                    <item name="orientationRad" desc="Orientation angle in radians">
                        <float width="64"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Shape.Arc">
            <trait>released</trait>
            <sample for="json">
        { "class":"Shape.Arc",
          "data":
          {
            "cx": 10.0,
            "cy": 10.0,
            "radius": 1.0,
            "angle": 0.0,
            "deltaAngle": 3.1415927
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="cx" desc="Center point X coordinate">
                        <float width="64"/>
                    </item>
                    <item name="cy" desc="Center point Y coordinate">
                        <float width="64"/>
                    </item>
                    <item name="radius" desc="Radius">
                        <float width="64"/>
                    </item>
                    <item name="angle" desc="Initial angle of the arc in radians">
                        <float width="64"/>
                    </item>
                    <item name="deltaAngle" desc="Angular size of the arc in radians">
                        <float width="64"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Shape.Sector">
            <trait>released</trait>
            <sample for="json">
        { "class":"Shape.Sector",
          "data":
          {
            "cx": 10.0,
            "cy": 10.0,
            "innerRadius": 1.0,
            "outerRadius": 2.0,
            "angle": 0.0,
            "deltaAngle": 3.1415927
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="cx" desc="Center point X coordinate">
                        <float width="64"/>
                    </item>
                    <item name="cy" desc="Center point Y coordinate">
                        <float width="64"/>
                    </item>
                    <item name="innerRadius" desc="Inner radius of the sector">
                        <float width="64"/>
                    </item>
                    <item name="outerRadius" desc="Outer radius of the sector">
                        <float width="64"/>
                    </item>
                    <item name="angle" desc="Initial angle of the arc in radians">
                        <float width="64"/>
                    </item>
                    <item name="deltaAngle" desc="Angular size of the arc in radians">
                        <float width="64"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Shape3D">
            <trait>released</trait>
            <sample for="json">
        { "class":"Shape3D.Box",
          "data":
          { "sizeX":10,
            "sizeY":11,
            "sizeZ":12,
            "pose":
            { "Type":"TRANSLATION",
              "Matrix":[[1,0,0,5],[0,1,0,6],[0,0,1,7],[0,0,0,1]]
            }
          }
        }
      </sample>
            <item>
                <polymorphic>
                    <data_format_ref name="Shape3D.Box"/>
                    <data_format_ref name="Shape3D.Circle"/>
                    <data_format_ref name="Shape3D.Cone"/>
                    <data_format_ref name="Shape3D.Cylinder"/>
                    <data_format_ref name="Shape3D.Ellipse"/>
                    <data_format_ref name="Shape3D.EllipticCylinder"/>
                    <data_format_ref name="Shape3D.Line"/>
                    <data_format_ref name="Shape3D.LineSegment"/>
                    <data_format_ref name="Shape3D.Plane"/>
                    <data_format_ref name="Shape3D.Polygon"/>
                    <data_format_ref name="Shape3D.Polyline"/>
                    <data_format_ref name="Shape3D.Rectangle"/>
                    <data_format_ref name="Shape3D.Sphere"/>
                </polymorphic>
            </item>
        </data_format>
        <data_format name="Shape3D.Box">
            <trait>released</trait>
            <sample for="json">
        { "class":"Shape3D.Box",
          "data":
          { "sizeX":10,
            "sizeY":11,
            "sizeZ":12,
            "pose":
            { "Type":"TRANSLATION",
              "Matrix":[[1,0,0,5],[0,1,0,6],[0,0,1,7],[0,0,0,1]]
            }
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="sizeX" desc="Total extent of the box along its local x-direction">
                        <float width="64"/>
                    </item>
                    <item name="sizeY" desc="Total extent of the box along its local y-direction">
                        <float width="64"/>
                    </item>
                    <item name="sizeZ" desc="Total extent of the box along its local z-direction">
                        <float width="64"/>
                    </item>
                    <item name="pose" desc="Position and orientation of the shape">
                        <data_format_ref name="Transform3D"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Shape3D.Circle">
            <trait>released</trait>
            <sample for="json">
        { "class":"Shape3D.Circle",
          "data":
          { "radius":10,
            "pose":
            { "Type":"TRANSLATION",
              "Matrix":[[1,0,0,5],[0,1,0,6],[0,0,1,7],[0,0,0,1]]
            }
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="radius" desc="Radius of the circle">
                        <float width="64"/>
                    </item>
                    <item name="pose" desc="Position and orientation of the shape">
                        <data_format_ref name="Transform3D"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Shape3D.Cone">
            <trait>released</trait>
            <sample for="json">
        { "class":"Shape3D.Cone",
          "data":
          { "radius":10,
            "height":4,
            "pose":
            { "Type":"TRANSLATION",
              "Matrix":[[1,0,0,5],[0,1,0,6],[0,0,1,7],[0,0,0,1]]
            }
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="radius" desc="Radius of the cone">
                        <float width="64"/>
                    </item>
                    <item name="height" desc="Height of the cone along its local z-direction">
                        <float width="64"/>
                    </item>
                    <item name="pose" desc="Position and orientation of the shape">
                        <data_format_ref name="Transform3D"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Shape3D.Cylinder">
            <trait>released</trait>
            <sample for="json">
        { "class":"Shape3D.Cylinder",
          "data":
          { "radius":10,
            "height":4,
            "pose":
            { "Type":"TRANSLATION",
              "Matrix":[[1,0,0,5],[0,1,0,6],[0,0,1,7],[0,0,0,1]]
            }
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="radius" desc="Radius of the cylinder">
                        <float width="64"/>
                    </item>
                    <item name="height" desc="Height of the cylinder along its local z-direction">
                        <float width="64"/>
                    </item>
                    <item name="pose" desc="Position and orientation of the shape">
                        <data_format_ref name="Transform3D"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Shape3D.Ellipse">
            <trait>released</trait>
            <sample for="json">
        { "class":"Shape3D.Ellipse",
          "data":
          { "radiusX":10,
            "radiusY":5,
            "pose":
            { "Type":"TRANSLATION",
              "Matrix":[[1,0,0,5],[0,1,0,6],[0,0,1,7],[0,0,0,1]]
            }
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="radiusX" desc="Radius of the ellipse in the local x-direction">
                        <float width="64"/>
                    </item>
                    <item name="radiusY" desc="Radius of the ellipse in the local y-direction">
                        <float width="64"/>
                    </item>
                    <item name="pose" desc="Position and orientation of the shape">
                        <data_format_ref name="Transform3D"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Shape3D.EllipticCylinder">
            <trait>released</trait>
            <sample for="json">
        { "class":"Shape3D.EllipticCylinder",
          "data":
          { "radiusX":10,
            "radiusY":5,
            "height":7,
            "pose":
            { "Type":"TRANSLATION",
              "Matrix":[[1,0,0,5],[0,1,0,6],[0,0,1,7],[0,0,0,1]]
            }
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="radiusX" desc="Radius of the elliptic cylinder in the local x-direction">
                        <float width="64"/>
                    </item>
                    <item name="radiusY" desc="Radius of the elliptic cylinder in the local y-direction">
                        <float width="64"/>
                    </item>
                    <item name="height" desc="Height of the elliptic cylinder in the local z-direction">
                        <float width="64"/>
                    </item>
                    <item name="pose" desc="Position and orientation of the shape">
                        <data_format_ref name="Transform3D"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Shape3D.Line">
            <trait>released</trait>
            <sample for="json">
        { "class":"Shape3D.Line",
          "data":
          { "point":{"x":11,"y":12,"z":13},
            "direction":{"x":0,"y":1,"z":0}
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="point" desc="A point on the line">
                        <data_format_ref name="Point3D"/>
                    </item>
                    <item name="direction" desc="The direction of the line, unit vector">
                        <data_format_ref name="Point3D"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Shape3D.LineSegment">
            <trait>released</trait>
            <sample for="json">
        { "class":"Shape3D.LineSegment",
          "data":
          { "point1":{"x":11,"y":12,"z":13},
            "point2":{"x":10,"y":-2,"z":0}
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="point1" desc="The first end point of the line segment">
                        <data_format_ref name="Point3D"/>
                    </item>
                    <item name="point2" desc="The other end point of the line segment">
                        <data_format_ref name="Point3D"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Shape3D.Plane">
            <trait>released</trait>
            <sample for="json">
        { "class":"Shape3D.Plane",
          "data":
          { "normal":{"x":11,"y":12,"z":13},
            "distance":5
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="normal" desc="The plane normal">
                        <data_format_ref name="Point3D"/>
                    </item>
                    <item name="distance" desc="The distance from the origin to the plane">
                        <float width="64"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Shape3D.Polygon">
            <trait>released</trait>
            <sample for="json">
        { "class":"Shape3D.Polygon",
          "data":
          {
            "points": [ {"x": 1.0, "y": 2.0}, {"x": 4.0, "y": 5.0} ],
            "pose":
            { "Type":"TRANSLATION",
              "Matrix":[[1,0,0,5],[0,1,0,6],[0,0,1,7],[0,0,0,1]]
            }
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="points">
                        <array>
                            <item>
<data_format_ref name="Point2D"/>
                            </item>
                        </array>
                    </item>
                    <item name="pose" desc="Position and orientation of the shape">
                        <data_format_ref name="Transform3D"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Shape3D.Polyline">
            <trait>released</trait>
            <sample for="json">
        { "class":"Shape3D.Polyline",
          "data":
          {
            "points": [ {"x": 1.0, "y": 2.0, "z": 3.0}, {"x": 4.0, "y": 5.0, "z": 6.0} ]
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="points">
                        <array>
                            <item>
<data_format_ref name="Point3D"/>
                            </item>
                        </array>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Shape3D.Rectangle">
            <trait>released</trait>
            <sample for="json">
        { "class":"Shape3D.Rectangle",
          "data":
          { "sizeX":10,
            "sizeY":4,
            "pose":
            { "Type":"TRANSLATION",
              "Matrix":[[1,0,0,5],[0,1,0,6],[0,0,1,7],[0,0,0,1]]
            }
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="sizeX" desc="Total extent of the rectangle along its local x-direction">
                        <float width="64"/>
                    </item>
                    <item name="sizeY" desc="Total extent of the rectangle along its local y-direction">
                        <float width="64"/>
                    </item>
                    <item name="pose" desc="Position and orientation of the shape">
                        <data_format_ref name="Transform3D"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Shape3D.Sphere">
            <trait>released</trait>
            <sample for="json">
        { "class":"Shape3D.Sphere",
          "data":
          { "radius":10,
            "pose":
            { "Type":"TRANSLATION",
              "Matrix":[[1,0,0,5],[0,1,0,6],[0,0,1,7],[0,0,0,1]]
            }
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="radius" desc="Radius of the sphere">
                        <float width="64"/>
                    </item>
                    <item name="pose" desc="Position and orientation of the shape">
                        <data_format_ref name="Transform3D"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Point">
            <trait>released</trait>
            <item>
                <polymorphic>
                    <data_format_ref name="Point2D"/>
                    <data_format_ref name="Point3D"/>
                </polymorphic>
            </item>
        </data_format>
        <data_format name="Point2D">
            <trait>released</trait>
            <sample for="json">
        { "class":"Point2D",
          "data":
          { "x": 1.0,
            "y": 2.0
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="x" desc="X coordinate">
                        <float width="64"/>
                    </item>
                    <item name="y" desc="Y coordinate">
                        <float width="64"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Point3D">
            <trait>released</trait>
            <sample for="json">
        { "class":"Point3D",
          "data":
          { "x": 1.0,
            "y": 2.0,
            "z": 3.0
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="x" desc="X coordinate">
                        <float width="64"/>
                    </item>
                    <item name="y" desc="Y coordinate">
                        <float width="64"/>
                    </item>
                    <item name="z" desc="Z coordinate">
                        <float width="64"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Point3D_32">
            <trait>released</trait>
            <sample for="json">
        { "class":"Point3D_32",
          "data":
          { "x": 1.0,
            "y": 2.0,
            "z": 3.0
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="x" desc="X coordinate">
                        <float width="32"/>
                    </item>
                    <item name="y" desc="Y coordinate">
                        <float width="32"/>
                    </item>
                    <item name="z" desc="Z coordinate">
                        <float width="32"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Image">
            <trait>released</trait>
            <sample for="json">
        { "class":"Image",
          "data":
          { "PixelSize":{"x":1,"y":1,"z":1},
            "Origin":{"x":0,"y":0,"z":0},
            "HandleZeroPixels":"Default",
            "Data":
            { "ImageType":"RGB24",
              "Width":2,
              "Height":2,
              "Pixels":
              { "numOfElems":4,
                "elemSz":3,
                "endian":"neutral",
                "elemTypes":["uint8","uint8","uint8"],
                "data":"AgEABQQDCAcGCwoJ"
              }
            }
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="PixelSize" desc="Size of the image pixel in some coordinate system (application defined). Usage is optional.">
                        <data_format_ref name="Point3D"/>
                    </item>
                    <item name="Origin" desc="Application defined coordinate of the top left pixel. Usage is optional.">
                        <data_format_ref name="Point3D"/>
                    </item>
                    <item name="HandleZeroPixels" desc="How pixels with value zero are interpreted">
                        <any_of>
                            <item desc="Pixels with value 0 are real pixels">
<string value="Default"/>
                            </item>
                            <item desc="Pixels with value 0 indicate missing data and are no 'real' value">
<string value="MissingData"/>
                            </item>
                        </any_of>
                    </item>
                    <item name="Data">
                        <struct>
                            <item name="ImageType">
<any_of>
    <item>
        <string value="uint8"/>
    </item>
    <item>
        <string value="uint16"/>
    </item>
    <item>
        <string value="uint32"/>
    </item>
    <item>
        <string value="uint64"/>
    </item>
    <item>
        <string value="int8"/>
    </item>
    <item>
        <string value="int16"/>
    </item>
    <item>
        <string value="int32"/>
    </item>
    <item>
        <string value="int64"/>
    </item>
    <item>
        <string value="float32"/>
    </item>
    <item>
        <string value="float64"/>
    </item>
    <item>
        <string value="RGB24"/>
    </item>
</any_of>
                            </item>
                            <item name="Width">
<int signed="true" width="32"/>
                            </item>
                            <item name="Height">
<int signed="true" width="32"/>
                            </item>
                            <item name="Pixels">
<any_of>
    <item>
        <big_data_array>
            <element_type name="uint8" desc="The pixel content"/>
        </big_data_array>
    </item>
    <item>
        <big_data_array>
            <element_type name="uint16" desc="The pixel content"/>
        </big_data_array>
    </item>
    <item>
        <big_data_array>
            <element_type name="uint32" desc="The pixel content"/>
        </big_data_array>
    </item>
    <item>
        <big_data_array>
            <element_type name="uint64" desc="The pixel content"/>
        </big_data_array>
    </item>
    <item>
        <big_data_array>
            <element_type name="int8" desc="The pixel content"/>
        </big_data_array>
    </item>
    <item>
        <big_data_array>
            <element_type name="int16" desc="The pixel content"/>
        </big_data_array>
    </item>
    <item>
        <big_data_array>
            <element_type name="int32" desc="The pixel content"/>
        </big_data_array>
    </item>
    <item>
        <big_data_array>
            <element_type name="int64" desc="The pixel content"/>
        </big_data_array>
    </item>
    <item>
        <big_data_array>
            <element_type name="float32" desc="The pixel content"/>
        </big_data_array>
    </item>
    <item>
        <big_data_array>
            <element_type name="float64" desc="The pixel content"/>
        </big_data_array>
    </item>
    <item>
        <big_data_array>
            <element_type name="uint8" desc="The BLUE pixel content"/>
            <element_type name="uint8" desc="The GREEN pixel content"/>
            <element_type name="uint8" desc="The RED pixel content"/>
        </big_data_array>
    </item>
</any_of>
                            </item>
                        </struct>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Profile">
            <trait>released</trait>
            <sample for="json">
        { "class":"Profile",
          "data":
          { "IsClosed":false,
            "UseValidFlags":true,
            "Values":[2,2,2],
            "ValidFlags":[1,1,1],
            "StartImplicit1D":0,
            "DeltaImplicit1D":1,
            "CoordinatesExplicit1D":[0,1,2],
            "StartImplicit2D":{"x":0, "y":0},
            "DeltaImplicit2D":{"x":1, "y":0},
            "CoordinatesExplicit2D":[],
            "CoordinateType":"EXPLICIT_1D"
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="IsClosed">
                        <bool/>
                    </item>
                    <item name="UseValidFlags">
                        <bool/>
                    </item>
                    <item name="Values">
                        <array>
                            <item>
<float width="32"/>
                            </item>
                        </array>
                    </item>
                    <item name="ValidFlags">
                        <array>
                            <item>
<int signed="false" width="8"/>
                            </item>
                        </array>
                    </item>
                    <item name="StartImplicit1D">
                        <float width="64"/>
                    </item>
                    <item name="DeltaImplicit1D">
                        <float width="64"/>
                    </item>
                    <item name="CoordinatesExplicit1D">
                        <array>
                            <item>
<float width="32"/>
                            </item>
                        </array>
                    </item>
                    <item name="StartImplicit2D">
                        <data_format_ref name="Point2D"/>
                    </item>
                    <item name="DeltaImplicit2D">
                        <data_format_ref name="Point2D"/>
                    </item>
                    <item name="CoordinatesExplicit2D">
                        <array>
                            <item>
<data_format_ref name="Point2D"/>
                            </item>
                        </array>
                    </item>
                    <item name="CoordinateType">
                        <any_of>
                            <item>
<string value="IMPLICIT_1D"/>
                            </item>
                            <item>
<string value="EXPLICIT_1D"/>
                            </item>
                            <item>
<string value="IMPLICIT_2D"/>
                            </item>
                            <item>
<string value="EXPLICIT_2D"/>
                            </item>
                        </any_of>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Profile.Curve">
            <trait>released</trait>
            <sample for="json">
        { "class":"Profile.Curve.Polynomial",
          "data":
          {
            "coefficients": [ 1.0, 2.0, 3.0 ]
          }
        }
      </sample>
            <item>
                <polymorphic>
                    <data_format_ref name="Profile.Curve.Polynomial"/>
                    <data_format_ref name="Profile.Curve.Exponential"/>
                    <data_format_ref name="Profile.Curve.Gaussian"/>
                </polymorphic>
            </item>
        </data_format>
        <data_format name="Profile.Curve.Polynomial">
            <trait>released</trait>
            <sample for="json">
        { "class":"Profile.Curve.Polynomial",
          "data":
          {
            "Coefficients": [ 1.0, 2.0, 3.0 ]
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="Coefficients">
                        <array>
                            <item>
<float width="64"/>
                            </item>
                        </array>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Profile.Curve.Exponential">
            <trait>released</trait>
            <sample for="json">
        { "class":"Profile.Curve.Exponential",
          "data":
          {
            "Coefficients": [ 1.0, 2.0, 3.0 ]
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="Coefficients">
                        <array length="3">
                            <item>
<float width="64"/>
                            </item>
                        </array>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Profile.Curve.Gaussian">
            <trait>released</trait>
            <sample for="json">
        { "class":"Profile.Curve.Gaussian",
          "data":
          {
            "Coefficients": [ 1.0, 2.0, 3.0, 4.0 ]
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="Coefficients">
                        <array length="4">
                            <item>
<float width="64"/>
                            </item>
                        </array>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Profile.Log">
            <trait>released</trait>
            <sample for="json">
        {
        "class": "Profile.Log",
        "data": {
          "RecentValuesEnabled": false,
          "Values": [],
          "Coordinates": [],
          "Min": -3.200000047,
          "MinCoord": 3.140000104,
          "Max": 1.200000047,
          "MaxCoord": 0,
          "Mean": -0.56666666269302368,
          "M2": 10.80666710694631404,
          "Count": 3,
          "HistogramEnabled": false,
          "Histogram": [],
          "HistogramMinValue": 0,
          "HistogramDelta": 0,
          "RecentBack": 0,
          "HistoricStatisticsEnabled": true,
          "HistoricValueBuffer": [0.300000011],
          "HistoricCoordBuffer": [0],
          "HistoricCoordinates": [1.570000052],
          "HistoricMeanValues": [-1],
          "HistoricStdDevValues": [2.200000047],
          "HistoricMaxValues": [1.200000047],
          "HistoricMinValues": [-3.200000047],
          "HistoricQuanta": 2,
          "PeriodCount": 4
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="RecentValuesEnabled">
                        <bool/>
                    </item>
                    <item name="Values">
                        <array>
                            <item>
<float width="32"/>
                            </item>
                        </array>
                    </item>
                    <item name="Coordinates">
                        <array>
                            <item>
<float width="32"/>
                            </item>
                        </array>
                    </item>
                    <item name="Count">
                        <int signed="false" width="64"/>
                    </item>
                    <item name="M2">
                        <float width="64"/>
                    </item>
                    <item name="Mean">
                        <float width="64"/>
                    </item>
                    <item name="Min">
                        <float width="32"/>
                    </item>
                    <item name="MinCoord">
                        <float width="32"/>
                    </item>
                    <item name="Max">
                        <float width="32"/>
                    </item>
                    <item name="MaxCoord">
                        <float width="32"/>
                    </item>
                    <item name="HistogramEnabled">
                        <bool/>
                    </item>
                    <item name="Histogram">
                        <array>
                            <item>
<float width="32"/>
                            </item>
                        </array>
                    </item>
                    <item name="HistogramMinValue">
                        <float width="32"/>
                    </item>
                    <item name="HistogramDelta">
                        <float width="32"/>
                    </item>
                    <item name="RecentBack">
                        <int signed="false" width="unspecified"/>
                    </item>
                    <item name="HistoricStatisticsEnabled">
                        <bool/>
                    </item>
                    <item name="HistoricValueBuffer">
                        <array>
                            <item>
<float width="32"/>
                            </item>
                        </array>
                    </item>
                    <item name="HistoricCoordBuffer">
                        <array>
                            <item>
<float width="32"/>
                            </item>
                        </array>
                    </item>
                    <item name="HistoricCoordinates">
                        <array>
                            <item>
<float width="32"/>
                            </item>
                        </array>
                    </item>
                    <item name="HistoricMeanValues">
                        <array>
                            <item>
<float width="32"/>
                            </item>
                        </array>
                    </item>
                    <item name="HistoricStdDevValues">
                        <array>
                            <item>
<float width="32"/>
                            </item>
                        </array>
                    </item>
                    <item name="HistoricMaxValues">
                        <array>
                            <item>
<float width="32"/>
                            </item>
                        </array>
                    </item>
                    <item name="HistoricMinValues">
                        <array>
                            <item>
<float width="32"/>
                            </item>
                        </array>
                    </item>
                    <item name="HistoricQuanta">
                        <int signed="false" width="64"/>
                    </item>
                    <item name="PeriodCount">
                        <int signed="false" width="32"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="View.GraphDecoration.RGBA">
            <trait>released</trait>
            <item>
                <struct>
                    <item name="R" desc="Red component">
                        <int signed="false" width="8"/>
                    </item>
                    <item name="G" desc="Green component">
                        <int signed="false" width="8"/>
                    </item>
                    <item name="B" desc="Blue component">
                        <int signed="false" width="8"/>
                    </item>
                    <item name="A" desc="Alpha component">
                        <int signed="false" width="8"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="View.GraphDecoration.GRAPHTYPE">
            <trait>released</trait>
            <item>
                <any_of>
                    <item>
                        <string value="DOT"/>
                    </item>
                    <item>
                        <string value="LINE"/>
                    </item>
                    <item>
                        <string value="BAR"/>
                    </item>
                </any_of>
            </item>
        </data_format>
        <data_format name="View.GraphDecoration.ASPECTRATIO">
            <trait>released</trait>
            <item>
                <any_of>
                    <item>
                        <string value="EQUAL"/>
                    </item>
                    <item>
                        <string value="SQUARE"/>
                    </item>
                    <item>
                        <string value="FIT"/>
                    </item>
                </any_of>
            </item>
        </data_format>
        <data_format name="View.GraphDecoration">
            <trait>released</trait>
            <sample for="json">
        {  
          "class":"View.GraphDecoration",
          "data":{  
            "AxisColor":{  
              "R":255,
              "G":255,
              "B":0,
              "A":255
            },
            "BackgroundColor":{  
              "R":255,
              "G":0,
              "B":255,
              "A":255
            },
            "GraphColor":{  
              "R":0,
              "G":255,
              "B":255,
              "A":255
            },
            "GridColor":{  
              "R":255,
              "G":255,
              "B":0,
              "A":0
            },
            "LabelColor":{  
              "R":0,
              "G":255,
              "B":0,
              "A":255
            },
            "GraphType":"DOT",
            "AspectRatio":"EQUAL",
            "AxisVisible":false,
            "BackgroundVisible":false,
            "GridVisible":false,
            "LabelsVisible":false,
            "TicksVisible":false,
            "UseIndexCoordinates":true,
            "UsePolarPlot":true,
            "DynamicSizing":true,
            "DrawSize":5,
            "AxisWidth":2.5,
            "LabelSize":7,
            "TitleSize":9,
            "LowerXBound":-100,
            "LowerYBound":-200,
            "UpperXBound":100,
            "UpperYBound":200,
            "XLabel":"x-axis",
            "YLabel":"y-axis",
            "Title":"Test Title"
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="AxisColor">
                        <data_format_ref name="View.GraphDecoration.RGBA"/>
                    </item>
                    <item name="BackgroundColor">
                        <data_format_ref name="View.GraphDecoration.RGBA"/>
                    </item>
                    <item name="GraphColor">
                        <data_format_ref name="View.GraphDecoration.RGBA"/>
                    </item>
                    <item name="GridColor">
                        <data_format_ref name="View.GraphDecoration.RGBA"/>
                    </item>
                    <item name="LabelColor">
                        <data_format_ref name="View.GraphDecoration.RGBA"/>
                    </item>
                    <item name="GraphType">
                        <data_format_ref name="View.GraphDecoration.GRAPHTYPE"/>
                    </item>
                    <item name="AspectRatio">
                        <data_format_ref name="View.GraphDecoration.ASPECTRATIO"/>
                    </item>
                    <item name="AxisVisible">
                        <bool/>
                    </item>
                    <item name="BackgroundVisible">
                        <bool/>
                    </item>
                    <item name="GridVisible">
                        <bool/>
                    </item>
                    <item name="LabelsVisible">
                        <bool/>
                    </item>
                    <item name="TicksVisible">
                        <bool/>
                    </item>
                    <item name="UseIndexCoordinates">
                        <bool/>
                    </item>
                    <item name="UsePolarPlot">
                        <bool/>
                    </item>
                    <item name="DynamicSizing">
                        <bool/>
                    </item>
                    <item name="DrawSize">
                        <float width="32"/>
                    </item>
                    <item name="AxisWidth">
                        <float width="32"/>
                    </item>
                    <item name="LabelSize">
                        <float width="32"/>
                    </item>
                    <item name="TitleSize">
                        <float width="32"/>
                    </item>
                    <item name="LowerXBound">
                        <float width="32"/>
                    </item>
                    <item name="LowerYBound">
                        <float width="32"/>
                    </item>
                    <item name="UpperXBound">
                        <float width="32"/>
                    </item>
                    <item name="UpperYBound">
                        <float width="32"/>
                    </item>
                    <item name="XLabel">
                        <string/>
                    </item>
                    <item name="YLabel">
                        <string/>
                    </item>
                    <item name="Title">
                        <string/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Matrix">
            <trait>released</trait>
            <sample for="json">
        { "class":"Matrix",
          "data":
          { "Rows":2,
            "Columns":2,
            "Elements":
            { "numOfElems":4,
              "elemSz":8,
              "endian":"little",
              "elemTypes":["float64"],
              "data":"kiRJkiRJwj+SJEmSJEnSP9u2bdu2bds/kiRJkiRJ4j8="
            }
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="Rows" desc="Matrix height (in number of elements)">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="Columns" desc="Matrix width (in number of elements)">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="Elements" desc="Matrix elements in row-major storage order">
                        <big_data_array>
                            <element_type name="float64" desc="Single matrix element"/>
                        </big_data_array>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Image.PixelRegion">
            <trait>released</trait>
            <sample for="json">
        {
          "class":"Image.PixelRegion",
          "data":
          {
            "segments":
            {
              "numOfElems":2,
              "elemSz":12,
              "endian":"little",
              "elemTypes":["int32","int32","int32"],
              "data":"AQAAAAIAAAADAAAABAAAAAUAAAAGAAAA"
            }
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="segments" desc="Structs for individual segments of a run-length coded region">
                        <big_data_array>
                            <element_type name="int32" desc="y: Image row of the segment"/>
                            <element_type name="int32" desc="xStart: x-coordinate of first included pixel"/>
                            <element_type name="int32" desc="xStop: x-coordinate of last included pixel"/>
                        </big_data_array>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="View.PixelRegionDecoration.RGBA">
            <trait>released</trait>
            <item>
                <struct>
                    <item name="R" desc="Red component">
                        <int signed="false" width="8"/>
                    </item>
                    <item name="G" desc="Green component">
                        <int signed="false" width="8"/>
                    </item>
                    <item name="B" desc="Blue component">
                        <int signed="false" width="8"/>
                    </item>
                    <item name="A" desc="Alpha component">
                        <int signed="false" width="8"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="View.PixelRegionDecoration">
            <trait>released</trait>
            <sample for="json">
        {
          "class": "View.PixelRegionDecoration",
          "data": {
            "Color": {
              "R": 0,
              "G": 127,
              "B": 195,
              "A": 255
            }
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="Color">
                        <data_format_ref name="View.PixelRegionDecoration.RGBA"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="View.ImageDecoration.DataRange">
            <trait>released</trait>
            <item>
                <struct>
                    <item name="Min">
                        <float width="64"/>
                    </item>
                    <item name="Max">
                        <float width="64"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Profile.IndexRegion">
            <trait>released</trait>
            <sample for="json">
        {
          "class":"Profile.IndexRegion",
          "data":
          {
            "Segments":
            {
              "numOfElems":2,
              "elemSz":8,
              "endian":"little",
              "elemTypes":["int32","int32"],
              "data":"AAAABBBB"
            }
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="Segments" desc="Structs for individual segments of a run-length coded region">
                        <big_data_array>
                            <element_type name="int32" desc="Start: The first included index"/>
                            <element_type name="int32" desc="Stop: The last included index"/>
                        </big_data_array>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="View.ImageDecoration">
            <trait>released</trait>
            <sample for="json">
        {
          "class": "View.ImageDecoration",
          "data":
          {
            "DataRange": 
            {
              "Min": 0,
              "Max": 255
            },
            "ColorMap": 0
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="DataRange">
                        <data_format_ref name="View.ImageDecoration.DataRange"/>
                    </item>
                    <item name="ColorMap">
                        <int signed="true" width="32"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="PointCloud">
            <trait>released</trait>
            <item>
                <polymorphic>
                    <data_format_ref name="PointCloud.XYZI"/>
                </polymorphic>
            </item>
        </data_format>
        <data_format name="PointCloud.XYZI">
            <trait>released</trait>
            <sample for="json">
        {
          "class":" PointCloud.XYZI",
          "data":
          {
            "Width": 2,
            "Height": 1,
            "IsDense": true,
            "ColorMode": "INTENSITY",
            "Number": 42,
            "TimeStamp": 2880154539,
            "SensorIDs": [1,2],
            "SensorPositions": [{"x":1,"y":2,"z":3},{"x":7,"y":8,"z":9}],
            "SensorOrientations":[{"x":4,"y":5,"z":6},{"x":10,"y":11,"z":12}],
            "Points":
            {
              "numOfElems":2,
              "elemSz":16,
              "endian":"little",
              "elemTypes":["float32","float32","float32","float32"],
              "data":"AACAPwAAAEAAAEBAAACAPwAAgEAAAKBAAADAQAAAgD8="
            }
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="Width" desc="Width of the data matrix if organized, total size if not">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="Height" desc="Height of the data matrix if organized, 1 if not">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="IsDense" desc="True if no points are invalid">
                        <bool/>
                    </item>
                    <item name="ColorMode" desc="Point cloud color mode">
                        <any_of>
                            <item>
<string value="INTENSITY"/>
                            </item>
                            <item>
<string value="RGBA"/>
                            </item>
                        </any_of>
                    </item>
                    <item name="Number" desc="Point cloud identifier (e.g. object ID or sequence number)">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="TimeStamp" desc="Time stamp in microseconds">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="SensorIDs" desc="ID(s) of the sensor(s)">
                        <array>
                            <item>
<int signed="false" width="32"/>
                            </item>
                        </array>
                    </item>
                    <item name="SensorPositions" desc="Position of the sensor(s) (x, y, z in mm)">
                        <array>
                            <item>
<data_format_ref name="Point3D_32"/>
                            </item>
                        </array>
                    </item>
                    <item name="SensorOrientations" desc="Orientation of the sensor(s) (yaw, pitch, roll in radians)">
                        <array>
                            <item>
<data_format_ref name="Point3D_32"/>
                            </item>
                        </array>
                    </item>
                    <item name="Points" desc="Each point has a size of 16 bytes, the format of the last 4 bytes depends on the ColorMode">
                        <any_of>
                            <item>
<big_data_array>
    <element_type name="float32" desc="X coordinate"/>
    <element_type name="float32" desc="Y coordinate"/>
    <element_type name="float32" desc="Z coordinate"/>
    <element_type name="float32" desc="Intensity value"/>
</big_data_array>
                            </item>
                            <item>
<big_data_array>
    <element_type name="float32" desc="X coordinate"/>
    <element_type name="float32" desc="Y coordinate"/>
    <element_type name="float32" desc="Z coordinate"/>
    <element_type name="uint8" desc="Red"/>
    <element_type name="uint8" desc="Green"/>
    <element_type name="uint8" desc="Blue"/>
    <element_type name="uint8" desc="Alpha"/>
</big_data_array>
                            </item>
                        </any_of>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Mesh">
            <trait>released</trait>
            <sample for="json">
        {
          "class": "Mesh",
          "data": {
            "Indices": {
              "numOfElems": 6,
              "elemSz": 4,
              "endian": "little",
              "elemTypes": ["uint32"],
              "data": "AAAAAAEAAAACAAAAAQAAAAIAAAADAAAA"
            },
            "Vertices": {
              "numOfElems": 4,
              "elemSz": 12,
              "endian": "little",
              "elemTypes": ["float32", "float32", "float32"],
              "data": "AAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAACAPwAAAAAAAAAAAACAPwAAgD8AAAAA"
            },
            "Normals": {
              "numOfElems": 4,
              "elemSz": 12,
              "endian": "little",
              "elemTypes": ["float32", "float32", "float32"],
              "data": "AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/AAAAAAAAAAAAAIA/"
            },
            "Colors": {
              "numOfElems": 4,
              "elemSz": 4,
              "endian": "neutral",
              "elemTypes": ["uint8", "uint8", "uint8", "uint8"],
              "data": "/wAA////AP///wD/AP8A/w=="
            },
            "Intensities": {
              "numOfElems": 4,
              "elemSz": 4,
              "endian": "little",
              "elemTypes": ["float32"],
              "data": "zczMPc3MTD6amZk+zczMPg=="
            },
            "TexCoords": {
              "numOfElems": 4,
              "elemSz": 8,
              "endian": "little",
              "elemTypes": ["float32", "float32"],
              "data": "AAAAAAAAAAAAAAAAAACAPwAAgD8AAAAAAAAAAAAAgD8="
            }
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="Indices" desc="List of triangle indices">
                        <big_data_array>
                            <element_type name="uint32" desc="Vertex index"/>
                        </big_data_array>
                    </item>
                    <item name="Vertices" desc="Vertex position coordinates">
                        <big_data_array>
                            <element_type name="float32" desc="X coordinate"/>
                            <element_type name="float32" desc="Y coordinate"/>
                            <element_type name="float32" desc="Z coordinate"/>
                        </big_data_array>
                    </item>
                    <item name="Normals" desc="Vertex normal vectors">
                        <big_data_array>
                            <element_type name="float32" desc="X coordinate"/>
                            <element_type name="float32" desc="Y coordinate"/>
                            <element_type name="float32" desc="Z coordinate"/>
                        </big_data_array>
                    </item>
                    <item name="Colors" desc="Vertex color vectors">
                        <big_data_array>
                            <element_type name="uint8" desc="Red"/>
                            <element_type name="uint8" desc="Green"/>
                            <element_type name="uint8" desc="Blue"/>
                            <element_type name="uint8" desc="Alpha"/>
                        </big_data_array>
                    </item>
                    <item name="Intensities" desc="Vertex intensities">
                        <big_data_array>
                            <element_type name="float32" desc="Intensity"/>
                        </big_data_array>
                    </item>
                    <item name="TexCoords" desc="Vertex texture coordinates">
                        <big_data_array>
                            <element_type name="float32" desc="S coordinate"/>
                            <element_type name="float32" desc="T coordinate"/>
                        </big_data_array>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="View.Present.Add">
            <trait>released</trait>
            <sample for="json">
        {
          "class": "View.Present.Add",
          "data":
          {
            "Type": "SHAPE",
            "Iconics":
            [
              {
                "class": "Shape.Circle",
                "data":
                {
                  "cx": 3,
                  "cy": 3,
                  "radius": 4
                }
              }
            ],
            "Decorations":
            [
              {
                "class": "View.ShapeDecoration",
                "data":
                {
                  "LineColor": 
                  {
                    "R": 0,
                    "G": 127,
                    "B": 195,
                    "A": 255
                  },
                  "FillColor": 
                  {
                    "R": 0,
                    "G": 127,
                    "B": 195,
                    "A": 0
                  },
                  "LineWidth": 1,
                  "PointSize": 3,
                  "PointType": "DOT"
                }
              }
            ],
            "CameraModel":null,
            "Labels": [],
            "IconicId": "_ID_ICONIC_2",
            "ParentId": "_ID_ICONIC_1"
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="Type">
                        <any_of>
                            <item>
<string value="HEIGHTMAP"/>
                            </item>
                            <item>
<string value="IMAGE"/>
                            </item>
                            <item>
<string value="PIXEL_REGION"/>
                            </item>
                            <item>
<string value="POINT_CLOUD"/>
                            </item>
                            <item>
<string value="SHAPE"/>
                            </item>
                            <item>
<string value="TEXT"/>
                            </item>
                            <item>
<string value="PROFILE"/>
                            </item>
                            <item>
<string value="POLAR_SCAN"/>
                            </item>
                            <item>
<string value="MESH"/>
                            </item>
                            <item>
<string value="CAMERAMODEL"/>
                            </item>
                            <item>
<string value="UNDEFINED"/>
                            </item>
                        </any_of>
                    </item>
                    <item name="Iconics">
                        <array>
                            <item>
<polymorphic/>
                            </item>
                        </array>
                    </item>
                    <item name="Decorations">
                        <array>
                            <item>
<polymorphic/>
                            </item>
                        </array>
                    </item>
                    <item name="CameraModel">
                        <polymorphic can_be_null="true">
                            <data_format_ref name="Image.Calibration.CameraModel"/>
                        </polymorphic>
                    </item>
                    <item name="Labels">
                        <array>
                            <item>
<string/>
                            </item>
                        </array>
                    </item>
                    <item name="IconicId">
                        <string/>
                    </item>
                    <item name="ParentId">
                        <string/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="View.Present.Clear">
            <trait>released</trait>
            <sample for="json">
        {
          "class": "View.Present.Clear",
          "data":
          {
          }
        }
      </sample>
            <item>
                <struct/>
            </item>
        </data_format>
        <data_format name="View.Present.Editor">
            <trait>released</trait>
            <sample for="json">
        {
          "class": "View.Present.Editor",
          "data":
          {
            "Type": "INSTALL",
            "IconicId": "_ID_ICONIC_1"
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="Type">
                        <any_of>
                            <item>
<string value="INSTALL"/>
                            </item>
                            <item>
<string value="UNINSTALL"/>
                            </item>
                        </any_of>
                    </item>
                    <item name="IconicId">
                        <string/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="View.Present.Remove">
            <trait>released</trait>
            <sample for="json">
        {
          "class": "View.Present.Remove",
          "data":
          {
            "IconicId": "_ID_ICONIC_1"
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="IconicId">
                        <string/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="View.Camera">
            <trait>released</trait>
            <sample for="json">
        {
          "class": "View.Camera",
          "data":
          {
            "Position":
            {
              "x": 0,
              "y": -1,
              "z": 2000
            },
            "Target":
            {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "Up":
            {
              "x": 0,
              "y": 0,
              "z": 1
            },
            "PositionSet": true,
            "TargetSet": true,
            "UpSet": true
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="Position">
                        <data_format_ref name="Point3D"/>
                    </item>
                    <item name="Target">
                        <data_format_ref name="Point3D"/>
                    </item>
                    <item name="Up">
                        <data_format_ref name="Point3D"/>
                    </item>
                    <item name="PositionSet">
                        <bool/>
                    </item>
                    <item name="TargetSet">
                        <bool/>
                    </item>
                    <item name="UpSet">
                        <bool/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="View.ShapeDecoration.Pixel.RGBA">
            <trait>released</trait>
            <item>
                <struct>
                    <item name="R" desc="Red component">
                        <int signed="false" width="8"/>
                    </item>
                    <item name="G" desc="Green component">
                        <int signed="false" width="8"/>
                    </item>
                    <item name="B" desc="Blue component">
                        <int signed="false" width="8"/>
                    </item>
                    <item name="A" desc="Alpha component">
                        <int signed="false" width="8"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="View.ShapeDecoration.PointType">
            <trait>released</trait>
            <item>
                <any_of>
                    <item>
                        <string value="DOT"/>
                    </item>
                    <item>
                        <string value="CROSS"/>
                    </item>
                </any_of>
            </item>
        </data_format>
        <data_format name="View.ShapeDecoration">
            <trait>released</trait>
            <sample for="json">
      {
        "class":"View.ShapeDecoration",
        "data":
        {
          "LineColor":
          {
            "R":0,
            "G":127,
            "B":195,
            "A":255
          },
          "FillColor":
          {
            "R":0,
            "G":127,
            "B":195,
            "A":0
          },
          "LineWidth":1,
          "PointSize":3,
          "PointType":"DOT"
        }
      }
      </sample>
            <item>
                <struct>
                    <item name="LineColor">
                        <data_format_ref name="View.ShapeDecoration.Pixel.RGBA"/>
                    </item>
                    <item name="FillColor">
                        <data_format_ref name="View.ShapeDecoration.Pixel.RGBA"/>
                    </item>
                    <item name="LineWidth">
                        <float width="32"/>
                    </item>
                    <item name="PointSize">
                        <float width="32"/>
                    </item>
                    <item name="PointType">
                        <data_format_ref name="View.ShapeDecoration.PointType"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="View.MeshDecoration.VisibleFaces">
            <trait>released</trait>
            <item>
                <any_of>
                    <item>
                        <string value="FRONT"/>
                    </item>
                    <item>
                        <string value="BACK"/>
                    </item>
                    <item>
                        <string value="FRONT_AND_BACK"/>
                    </item>
                    <item>
                        <string value="NONE"/>
                    </item>
                </any_of>
            </item>
        </data_format>
        <data_format name="View.MeshDecoration">
            <trait>released</trait>
            <sample for="json">
      {
        "class": "View.MeshDecoration",
        "data": {
          "SurfaceColor": {
            "R": 255,
            "G": 255,
            "B": 255,
            "A": 255
          },
          "VisibleFaces": "FRONT_AND_BACK"
        }
      }
      </sample>
            <item>
                <struct>
                    <item name="SurfaceColor">
                        <struct>
                            <item name="R" desc="Red component">
<int signed="false" width="8"/>
                            </item>
                            <item name="G" desc="Green component">
<int signed="false" width="8"/>
                            </item>
                            <item name="B" desc="Blue component">
<int signed="false" width="8"/>
                            </item>
                            <item name="A" desc="Alpha component">
<int signed="false" width="8"/>
                            </item>
                        </struct>
                    </item>
                    <item name="VisibleFaces">
                        <data_format_ref name="View.MeshDecoration.VisibleFaces"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="View.TextDecoration.HorizontalAlignment">
            <trait>released</trait>
            <item>
                <any_of>
                    <item>
                        <string value="LEFT"/>
                    </item>
                    <item>
                        <string value="CENTERH"/>
                    </item>
                    <item>
                        <string value="RIGHT"/>
                    </item>
                    <item>
                        <string value="JUSTIFY"/>
                    </item>
                </any_of>
            </item>
        </data_format>
        <data_format name="View.TextDecoration.VerticalAlignment">
            <trait>released</trait>
            <item>
                <any_of>
                    <item>
                        <string value="BOTTOM"/>
                    </item>
                    <item>
                        <string value="CENTERV"/>
                    </item>
                    <item>
                        <string value="TOP"/>
                    </item>
                </any_of>
            </item>
        </data_format>
        <data_format name="View.TextDecoration.FontWeight">
            <trait>released</trait>
            <item>
                <any_of>
                    <item>
                        <string value="NORMAL"/>
                    </item>
                    <item>
                        <string value="BOLD"/>
                    </item>
                </any_of>
            </item>
        </data_format>
        <data_format name="View.TextDecoration.FontFamily">
            <trait>released</trait>
            <item>
                <any_of>
                    <item>
                        <string value="SANSSERIF"/>
                    </item>
                    <item>
                        <string value="MONOSPACE"/>
                    </item>
                    <item>
                        <string value="SERIF"/>
                    </item>
                </any_of>
            </item>
        </data_format>
        <data_format name="View.TextDecoration.RGBA">
            <trait>released</trait>
            <item>
                <struct>
                    <item name="R" desc="Red component">
                        <int signed="false" width="8"/>
                    </item>
                    <item name="G" desc="Green component">
                        <int signed="false" width="8"/>
                    </item>
                    <item name="B" desc="Blue component">
                        <int signed="false" width="8"/>
                    </item>
                    <item name="A" desc="Alpha component">
                        <int signed="false" width="8"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="View.TextDecoration.Bounds">
            <trait>released</trait>
            <item>
                <struct>
                    <item name="Width" desc="Width component">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="Height" desc="Height component">
                        <int signed="false" width="32"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="View.TextDecoration">
            <trait>released</trait>
            <sample for="json">
        {
          "class": "View.TextDecoration",
          "data":
          {
            "FontSize": 10,
            "Position": 
            {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "HorizontalAlignment": "LEFT",
            "VerticalAlignment": "BOTTOM",
            "FontWeight": "NORMAL",
            "FontFamily": "SANSSERIF",
            "Rotation": 0,
            "RotationAxis":
            {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "BillboardActive": true,
            "Bounds":
            {
              "Width": 42,
              "Height": 46
            },
            "LineSpacing": 1.10000000000000,
            "Color": 
            {
              "R": 0,
              "G": 127,
              "B": 195,
              "A": 255
            }
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="FontSize">
                        <int signed="true" width="64"/>
                    </item>
                    <item name="Position">
                        <data_format_ref name="Point3D_32"/>
                    </item>
                    <item name="HorizontalAlignment">
                        <data_format_ref name="View.TextDecoration.HorizontalAlignment"/>
                    </item>
                    <item name="VerticalAlignment">
                        <data_format_ref name="View.TextDecoration.VerticalAlignment"/>
                    </item>
                    <item name="FontWeight">
                        <data_format_ref name="View.TextDecoration.FontWeight"/>
                    </item>
                    <item name="FontFamily">
                        <data_format_ref name="View.TextDecoration.FontFamily"/>
                    </item>
                    <item name="Rotation">
                        <float width="64"/>
                    </item>
                    <item name="RotationAxis">
                        <data_format_ref name="Point3D"/>
                    </item>
                    <item name="BillboardActive">
                        <bool/>
                    </item>
                    <item name="Bounds">
                        <data_format_ref name="View.TextDecoration.Bounds"/>
                    </item>
                    <item name="LineSpacing">
                        <float width="64"/>
                    </item>
                    <item name="Color">
                        <data_format_ref name="View.TextDecoration.RGBA"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="View.PointCloudDecoration">
            <trait>released</trait>
            <sample for="json">
      {
        "class":"View.PointCloudDecoration",
        "data":
        {
          "XMax":100,
          "YMax":100,
          "ZMax":100,
          "IMax":100,
          "XMin":-100,
          "YMin":-100,
          "ZMin":-100,
          "IMin":-100,
          "XRangeSet":true,
          "YRangeSet":true,
          "ZRangeSet":true,
          "IRangeSet":true,
          "XColorMap":0,
          "YColorMap":0,
          "ZColorMap":0,
          "IColorMap":0,
          "PointSize":1
        }
      }
      </sample>
            <item>
                <struct>
                    <item name="XMax">
                        <float width="64"/>
                    </item>
                    <item name="YMax">
                        <float width="64"/>
                    </item>
                    <item name="ZMax">
                        <float width="64"/>
                    </item>
                    <item name="IMax">
                        <float width="64"/>
                    </item>
                    <item name="XMin">
                        <float width="64"/>
                    </item>
                    <item name="YMin">
                        <float width="64"/>
                    </item>
                    <item name="ZMin">
                        <float width="64"/>
                    </item>
                    <item name="IMin">
                        <float width="64"/>
                    </item>
                    <item name="XRangeSet">
                        <bool/>
                    </item>
                    <item name="YRangeSet">
                        <bool/>
                    </item>
                    <item name="ZRangeSet">
                        <bool/>
                    </item>
                    <item name="IRangeSet">
                        <bool/>
                    </item>
                    <item name="XColorMap">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="YColorMap">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="ZColorMap">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="IColorMap">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="PointSize">
                        <float width="64"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="View.ScanDecoration">
            <trait>released</trait>
            <sample for="json">
      {
        "class":"View.ScanDecoration",
        "data":
        {
          "Colors":
          [
            {
              "R": 255,
              "G": 0,
              "B":0,
              "Echo": 1,
              "ChannelType": "PROPERTIES",
              "ChannelTypeKey": "VALID_ECHO"
            },
            {
              "R": 0,
              "G": 0,
              "B":255,
              "Echo": 1,
              "ChannelType": "PROPERTIES",
              "ChannelTypeKey": "REFLECTOR"
            }
          ],
          "ColorMaps":[],
          "PointSize":1,
          "Id": 42
        }
      }
      </sample>
            <item>
                <struct>
                    <item name="PointSize">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="Colors">
                        <array>
                            <item>
<struct>
    <item name="R">
        <int signed="false" width="8"/>
    </item>
    <item name="G">
        <int signed="false" width="8"/>
    </item>
    <item name="B">
        <int signed="false" width="8"/>
    </item>
    <item name="Echo">
        <int signed="false" width="32"/>
    </item>
    <item name="ChannelType">
        <any_of>
            <item>
                <string value="PROPERTIES"/>
            </item>
        </any_of>
    </item>
    <item name="ChannelTypeKey">
        <string/>
    </item>
</struct>
                            </item>
                        </array>
                    </item>
                    <item name="ColorMaps">
                        <array>
                            <item>
<data_format_ref name="View.ColorMap"/>
                            </item>
                        </array>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="View.ColorMap">
            <trait>released</trait>
            <sample for="json">
        {
          "class":"View.ColorMap",
          "data":
          {
            "ColorMapType": "LINEAR",
            "ColorStops":[
              {
                "Value": 0.0,
                "R": 255,
                "G": 0,
                "B": 0,
                "A": 255
              },
              {
                "Value": 1.0,
                "R": 0,
                "G": 255,
                "B": 0,
                "A": 255
              }
            ],
            "Id": 6235,
            "RangeStart": 0.0,
            "RangeStop": 1.0
          }
        }
        </sample>
            <item>
                <struct>
                    <item name="ColorMapType">
                        <any_of>
                            <item>
<string value="LINEAR"/>
                            </item>
                            <item>
<string value="DISCRETE"/>
                            </item>
                        </any_of>
                    </item>
                    <item name="ColorStops">
                        <array>
                            <item>
<struct>
    <item name="Value">
        <float width="64"/>
    </item>
    <item name="R">
        <int signed="false" width="8"/>
    </item>
    <item name="G">
        <int signed="false" width="8"/>
    </item>
    <item name="B">
        <int signed="false" width="8"/>
    </item>
    <item name="A">
        <int signed="false" width="8"/>
    </item>
</struct>
                            </item>
                        </array>
                    </item>
                    <item name="RangeStart">
                        <float width="64"/>
                    </item>
                    <item name="RangeStop">
                        <float width="64"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="EncoderData">
            <trait>released</trait>
            <sample for="json">
        {
          "class": "EncoderData",
          "data":
          {
            "Position":0,
            "Speed":0,
            "SystemIncrement":0,
            "TimestampUTC":0,
            "TimestampUS":0,
            "xValue":0
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="Position" desc="Encoder position incremental value">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="Speed" desc="Speed in m/s">
                        <float width="32"/>
                    </item>
                    <item name="SystemIncrement" desc="System increment value; application specific">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="TimestampUTC" desc="UTC time stamp in floating-point seconds">
                        <float width="64"/>
                    </item>
                    <item name="TimestampUS" desc="Application specific, relative time stamp in microseconds">
                        <int signed="false" width="64"/>
                    </item>
                    <item name="xValue" desc="Corresponding x-value if available. Application specific">
                        <int signed="false" width="32"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="SensorData">
            <trait>released</trait>
            <sample for="json">
        {
          "class":"SensorData",
          "data":
          {
            "Encoder":
            {
              "Position":0,
              "Speed":0,
              "SystemIncrement":0,
              "TimestampUTC":0,
              "TimestampUS":0,
              "xValue":0
            },
            "Timestamp":0,
            "FrameNo":0,
            "Ident":-1,
            "Origin":"",
            "Name":""
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="Encoder" desc="Encoder data. May be optional and filled with default values when not available">
                        <data_format_ref name="EncoderData"/>
                    </item>
                    <item name="Timestamp" desc="Application specific time stamp in microseconds">
                        <int signed="false" width="64"/>
                    </item>
                    <item name="FrameNo" desc="Capture driver specific frame number">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="Ident" desc="Application specific ID where the corresponding image can be assigned to. Is -1 when not used or invalid.">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="Origin" desc="Dot separated list of image providers where the image originated from">
                        <string/>
                    </item>
                    <item name="Name" desc="Name of the corresponding data object">
                        <string/>
                    </item>
                    <item name="MetaData">
                        <polymorphic can_be_null="true">
                            <data_format_ref name="Container"/>
                        </polymorphic>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Transform">
            <trait>released</trait>
            <sample for="json">
        { "class":"Transform2D",
          "data":
          {
            "Type":"IDENTITY",
            "Matrix":[[1,0,0],[0,1,0],[0,0,1]]
          }
        }
      </sample>
            <item>
                <polymorphic>
                    <data_format_ref name="Transform2D"/>
                    <data_format_ref name="Transform3D"/>
                </polymorphic>
            </item>
        </data_format>
        <data_format name="Transform2D">
            <trait>released</trait>
            <sample for="json">
        { "class":"Transform2D",
          "data":
          {
            "Type":"IDENTITY",
            "Matrix":[[1,0,0],[0,1,0],[0,0,1]]
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="Type">
                        <any_of>
                            <item>
<string value="IDENTITY"/>
                            </item>
                            <item>
<string value="TRANSLATION"/>
                            </item>
                            <item>
<string value="RIGID"/>
                            </item>
                            <item>
<string value="SIMILARITY"/>
                            </item>
                            <item>
<string value="AFFINE"/>
                            </item>
                            <item>
<string value="HOMOGRAPHY"/>
                            </item>
                        </any_of>
                    </item>
                    <item name="Matrix">
                        <array>
                            <item>
<array>
    <item>
        <float width="64"/>
    </item>
</array>
                            </item>
                        </array>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Transform3D">
            <trait>released</trait>
            <sample for="json">
        { "class":"Transform3D",
          "data":
          {
            "Type":"IDENTITY",
            "Matrix":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="Type">
                        <any_of>
                            <item>
<string value="IDENTITY"/>
                            </item>
                            <item>
<string value="TRANSLATION"/>
                            </item>
                            <item>
<string value="RIGID"/>
                            </item>
                            <item>
<string value="SIMILARITY"/>
                            </item>
                            <item>
<string value="AFFINE"/>
                            </item>
                            <item>
<string value="HOMOGRAPHY"/>
                            </item>
                        </any_of>
                    </item>
                    <item name="Matrix">
                        <array>
                            <item>
<array>
    <item>
        <float width="64"/>
    </item>
</array>
                            </item>
                        </array>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Image.Calibration.CameraModel">
            <trait>released</trait>
            <sample for="json">
      {
        "class":"Image.Calibration.CameraModel",
        "data":
        {
          "CameraID":"",
          "ImageWidth":0,
          "ImageHeight":0,
          "FocalDistance":0,
          "FocalDistanceUnit":"",
          "IntrinsicK":[[1,0,0],[0,1,0],[0,0,1]],
          "WorldToSensorDistortion":[[0],[0],[0],[0],[0]],
          "SensorToWorldDistortion":[[0],[0],[0],[0],[0]],
          "WorldToView":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]
        }
      }
      </sample>
            <item>
                <struct>
                    <item name="CameraID" desc="Unique camera identifier">
                        <string/>
                    </item>
                    <item name="ImageWidth" desc="Image width for which the calibration is valid">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="ImageHeight" desc="Image height for which the calibration is valid">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="FocalDistance" desc="Distance from the camera to the plane of best image sharpness">
                        <float width="64"/>
                    </item>
                    <item name="FocalDistanceUnit" desc="Focus distance unit (Default is mm)">
                        <string/>
                    </item>
                    <item name="IntrinsicK">
                        <array>
                            <item>
<array>
    <item>
        <float width="64"/>
    </item>
</array>
                            </item>
                        </array>
                    </item>
                    <item name="WorldToSensorDistortion">
                        <array>
                            <item>
<array>
    <item>
        <float width="64"/>
    </item>
</array>
                            </item>
                        </array>
                    </item>
                    <item name="SensorToWorldDistortion">
                        <array>
                            <item>
<array>
    <item>
        <float width="64"/>
    </item>
</array>
                            </item>
                        </array>
                    </item>
                    <item name="WorldToView">
                        <array>
                            <item>
<array>
    <item>
        <float width="64"/>
    </item>
</array>
                            </item>
                        </array>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Scan">
            <trait>released</trait>
            <sample for="json">
      {
        "class": "Scan",
        "data": {
          "TimestampStart": 27000779,
          "TimestampStop": 27000779,
          "ThetaStart": -2.35,
          "ThetaStop": 2.35,
          "ScanNumber": 1,
          "ModuleID": 0,
          "ChannelTheta": {
            "numOfElems": 10,
            "elemSz": 4,
            "endian": "little",
            "elemTypes": [
              "float32"
            ],
            "data": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
          },
          "ChannelPhi": {
            "numOfElems": 10,
            "elemSz": 4,
            "endian": "little",
            "elemTypes": [
              "float32"
            ],
            "data": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
          },
          "DistValues": [
            {
              "numOfElems": 10,
              "elemSz": 4,
              "endian": "little",
              "elemTypes": [
                "float32"
              ],
              "data": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
            },
            {
              "numOfElems": 10,
              "elemSz": 4,
              "endian": "little",
              "elemTypes": [
                "float32"
              ],
              "data": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
            },
            {
              "numOfElems": 10,
              "elemSz": 4,
              "endian": "little",
              "elemTypes": [
                "float32"
              ],
              "data": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
            }
          ],
          "RssiValues": [
            {
              "numOfElems": 10,
              "elemSz": 4,
              "endian": "little",
              "elemTypes": [
                "float32"
              ],
              "data": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
            },
            {
              "numOfElems": 10,
              "elemSz": 4,
              "endian": "little",
              "elemTypes": [
                "float32"
              ],
              "data": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
            },
            {
              "numOfElems": 10,
              "elemSz": 4,
              "endian": "little",
              "elemTypes": [
                "float32"
              ],
              "data": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
            }
          ],
          "PropertiesValues": [
            {
              "numOfElems": 10,
              "elemSz": 4,
              "endian": "little",
              "elemTypes": [
                "uint32"
              ],
              "data": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
            },
            {
              "numOfElems": 10,
              "elemSz": 4,
              "endian": "little",
              "elemTypes": [
                "uint32"
              ],
              "data": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
            },
            {
              "numOfElems": 10,
              "elemSz": 4,
              "endian": "little",
              "elemTypes": [
                "uint32"
              ],
              "data": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="
            }
          ],
          "BeamCount": 10,
          "EchoCount": 3
        }
      }
      </sample>
            <item>
                <struct>
                    <item name="TimestampStart" desc="System-dependent internal start timestamp in microsecond resolution">
                        <int signed="false" width="64"/>
                    </item>
                    <item name="TimestampStop" desc="System-dependent internal stop timestamp in microsecond resolution">
                        <int signed="false" width="64"/>
                    </item>
                    <item name="ThetaStart" desc="Original angle of first beam (matching TimestampStart)">
                        <float width="32"/>
                    </item>
                    <item name="ThetaStop" desc="Original angle of last beam (matching TimestampStop)">
                        <float width="32"/>
                    </item>
                    <item name="ScanNumber" desc="Scan ID">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="ModuleID" desc="Module ID of measurement core (e.g. receiver module, facet, ...) starting with 1. 0 = no defined module (e.g. merged scan, ...).">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="ChannelTheta" desc="Channel with theta angle information [rad], -Pi...PI">
                        <big_data_array>
                            <element_type name="float32"/>
                        </big_data_array>
                    </item>
                    <item name="ChannelPhi" desc="Channel with phi angle information [rad], -Pi/2...PI/2">
                        <big_data_array>
                            <element_type name="float32"/>
                        </big_data_array>
                    </item>
                    <item name="DistValues" desc="Distance values, first indexed by echo, then by beam count">
                        <array>
                            <item>
<big_data_array>
    <element_type name="float32"/>
</big_data_array>
                            </item>
                        </array>
                    </item>
                    <item name="RssiValues" desc="RSSI values, first indexed by echo, then by beam count">
                        <array>
                            <item>
<big_data_array>
    <element_type name="float32"/>
</big_data_array>
                            </item>
                        </array>
                    </item>
                    <item name="PropertiesValues" desc="Properties values, first indexed by echo, then by angle. Each Properties is represented by an unsigned integer bitmask, poperties must not have exactly one of these values and can be used like a bitmask.">
                        <array>
                            <item>
<big_data_array>
    <element_type name="uint32"/>
</big_data_array>
                            </item>
                        </array>
                    </item>
                    <item name="BeamCount" desc="Number of beams in the scan">
                        <int signed="false" width="unspecified"/>
                    </item>
                    <item name="EchoCount" desc="Number of echoes in the scan">
                        <int signed="false" width="unspecified"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Image.SheetOfLight.Model">
            <trait>released</trait>
            <sample for="json">
{
  "class": "Image.SheetOfLight.Model",
  "data": {
    "FileVersion": 2,
    "CurrentState": "CALIBRATED",
    "SkewMode": "XZ_IN_LIGHT_PLANE",
    "CalibrationError": 0.037069686274551109,
    "CalibrationErrorMax": 0.13363166408845933,
    "AlignmentError": 1.7976931348623157e+308,
    "AlignmentErrorMax": 1.7976931348623157e+308,
    "FocalLength": 10000,
    "SensorSize": {
      "x": 2560,
      "y": 832
    },
    "LensCenter": {
      "x": 1283.6641142183876,
      "y": 556.24145560867373
    },
    "Skew": {
      "x": 0,
      "y": 1,
      "z": 0
    },
    "Homography": [[871.61358725051991, 61.879366018956475, 4.7901623971258811], [-135.52524885597637, 4390.9119712326301, 40.182224458479205], [-0.040446896652581929, 11.942246764006217, 1]],
    "Pose": [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]],
    "LensCoefficients": [3.3292324216642002, -33.84639056500496, -817.32236159607737, 0, 0, 0.0041033587870835794, -0.005255687093170756],
    "SheetCurve": [1115.5342649794834, -0.00019501536744151229, -9.8094881282456861, -0.43400050744524432, -0.00053366897013259551, -1.6449628579226567e-07],
    "CalibratedRegion": {
      "PointCount": {
        "class": "Image",
        "data": {
          "PixelSize": {
            "x": 500.42076513520095,
            "y": 59.527235670809716,
            "z": 1
          },
          "Origin": {
            "x": 266.05778629852512,
            "y": 440.572677287489,
            "z": 1
          },
          "HandleZeroPixels": "Default",
          "Data": {
            "ImageType": "int32",
            "Width": 5,
            "Height": 5,
            "Pixels": {
              "numOfElems": 25,
              "elemSz": 4,
              "endian": "little",
              "elemTypes": ["int32"],
              "data": "CwAAAAwAAAAIAAAADAAAAAkAAAAIAAAACQAAAAkAAAAJAAAABwAAAAkAAAAFAAAABgAAAAYAAAAGAAAABQAAAAYAAAAJAAAACAAAAAcAAAAFAAAABgAAAAQAAAAEAAAABgAAAA=="
            }
          }
        }
      },
      "AverageResidualX": {
        "class": "Image",
        "data": {
          "PixelSize": {
            "x": 500.42076513520095,
            "y": 59.527235670809716,
            "z": 1
          },
          "Origin": {
            "x": 266.05778629852512,
            "y": 440.572677287489,
            "z": 1
          },
          "HandleZeroPixels": "Default",
          "Data": {
            "ImageType": "float32",
            "Width": 5,
            "Height": 5,
            "Pixels": {
              "numOfElems": 25,
              "elemSz": 4,
              "endian": "little",
              "elemTypes": ["float32"],
              "data": "zMI/O3BBWTs67Vi8HpuGvDrFHLuZdSU8V8VoPGFMYDylbh8794jlOZVbg7zzChW8YSASO+yQ8DznF6a7cMa4vIP/Cr3bfqm8ODw3PFaUHDyjBQQ9S3iXO7QHNDxEV448YOehuw=="
            }
          }
        }
      },
      "AverageResidualZ": {
        "class": "Image",
        "data": {
          "PixelSize": {
            "x": 500.42076513520095,
            "y": 59.527235670809716,
            "z": 1
          },
          "Origin": {
            "x": 266.05778629852512,
            "y": 440.572677287489,
            "z": 1
          },
          "HandleZeroPixels": "Default",
          "Data": {
            "ImageType": "float32",
            "Width": 5,
            "Height": 5,
            "Pixels": {
              "numOfElems": 25,
              "elemSz": 4,
              "endian": "little",
              "elemTypes": ["float32"],
              "data": "Fg0GPFMh0rzIwDo5FClHPMer/7xFi5Q8Z6nnu1IxEjwHGW88WzVxOiW2gLtu2TC8tYbcO1iqKzzMZwo9Go5VPMESNrzieRs81gS3ua9aQTz7Fys7I3CKu8xSRLtbN+C8te0MvQ=="
            }
          }
        }
      },
      "MaximumResidualX": {
        "class": "Image",
        "data": {
          "PixelSize": {
            "x": 500.42076513520095,
            "y": 59.527235670809716,
            "z": 1
          },
          "Origin": {
            "x": 266.05778629852512,
            "y": 440.572677287489,
            "z": 1
          },
          "HandleZeroPixels": "Default",
          "Data": {
            "ImageType": "float32",
            "Width": 5,
            "Height": 5,
            "Pixels": {
              "numOfElems": 25,
              "elemSz": 4,
              "endian": "little",
              "elemTypes": ["float32"],
              "data": "aOOVPcrDhz0GSls9YbVQPREYAT3uHkg9Ff10PY110jx55MU8lNT/PAglfz2xji89ekx/PKVjZD2VlIs9O5YiPXAGYD1FbUk9bJf9PA4cWT0+X4Y9IRrbPGHO3TwzciY9P1rtPA=="
            }
          }
        }
      },
      "MaximumResidualZ": {
        "class": "Image",
        "data": {
          "PixelSize": {
            "x": 500.42076513520095,
            "y": 59.527235670809716,
            "z": 1
          },
          "Origin": {
            "x": 266.05778629852512,
            "y": 440.572677287489,
            "z": 1
          },
          "HandleZeroPixels": "Default",
          "Data": {
            "ImageType": "float32",
            "Width": 5,
            "Height": 5,
            "Pixels": {
              "numOfElems": 25,
              "elemSz": 4,
              "endian": "little",
              "elemTypes": ["float32"],
              "data": "syeQPaAm8D27eoU9hxc1PfHxwD2JR4k9o50tPZ2mLz0vVUM9u9hbPbUS1z2Ruy89RWttPQJ58zxcaOs9iZx7PQ1uyTxY7VY9EcIjPQzzkj2R24U9gs+EPI3zQz3V7IU96JKDPQ=="
            }
          }
        }
      }
    }
  }
}
      </sample>
            <item>
                <struct>
                    <item name="FileVersion" desc="The file version.">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="CurrentState" desc="Calibration state.">
                        <string/>
                    </item>
                    <item name="SkewMode" desc="Specifies how calibration was performed.">
                        <string/>
                    </item>
                    <item name="CalibrationError" desc="If the model has been calibrated. This is the average error per point after calibration.">
                        <float width="64"/>
                    </item>
                    <item name="CalibrationErrorMax" desc="If the model has been calibrated. This is the maximum error over all points after calibration.">
                        <float width="64"/>
                    </item>
                    <item name="AlignmentError" desc="If the model has been aligned. This is the average error per point after alignment.">
                        <float width="64"/>
                    </item>
                    <item name="AlignmentErrorMax" desc="If the model has been aligned. This is the maximum error over all points after alignment.">
                        <float width="64"/>
                    </item>
                    <item name="FocalLength" desc="An approximate focal length in pixels.">
                        <float width="64"/>
                    </item>
                    <item name="SensorSize" desc="The sensor size of the calibrated device.">
                        <struct>
                            <item name="x" desc="Width of image sensor">
<int signed="true" width="32"/>
                            </item>
                            <item name="y" desc="Height of image sensor">
<int signed="true" width="32"/>
                            </item>
                        </struct>
                    </item>
                    <item name="LensCenter" desc="The optical distortion center location on the image sensor in pixels.">
                        <struct>
                            <item name="x" desc="U coordinate">
<float width="64"/>
                            </item>
                            <item name="y" desc="V coordinate">
<float width="64"/>
                            </item>
                        </struct>
                    </item>
                    <item name="Skew" desc="The sheet of light plane normal in the calibrated coordinate system prior to alignment.">
                        <struct>
                            <item name="x" desc="X component of the plane normal vector">
<float width="64"/>
                            </item>
                            <item name="y" desc="Y component of the plane normal vector">
<float width="64"/>
                            </item>
                            <item name="z" desc="Y component of the plane normal vector">
<float width="64"/>
                            </item>
                        </struct>
                    </item>
                    <item name="Homography">
                        <array>
                            <item>
<array>
    <item>
        <float width="64"/>
    </item>
</array>
                            </item>
                        </array>
                    </item>
                    <item name="Pose">
                        <array>
                            <item>
<array>
    <item>
        <float width="64"/>
    </item>
</array>
                            </item>
                        </array>
                    </item>
                    <item name="LensCoefficients">
                        <array>
                            <item>
<float width="64"/>
                            </item>
                        </array>
                    </item>
                    <item name="SheetCurve">
                        <array>
                            <item>
<float width="64"/>
                            </item>
                        </array>
                    </item>
                    <item name="CalibratedRegion" desc="A set of images describing properties of the calibrated area on the sensor.">
                        <struct>
                            <item name="PointCount" desc="The number of points on the sensor used for calibration.">
<data_format_ref name="Image"/>
                            </item>
                            <item name="AverageResidualX" desc="The average of the residual in the X direction.">
<data_format_ref name="Image"/>
                            </item>
                            <item name="AverageResidualZ" desc="The average of the residual in the Z direction.">
<data_format_ref name="Image"/>
                            </item>
                            <item name="MaximumResidualX" desc="The maximum of the absolute value of the residual in the X direction.">
<data_format_ref name="Image"/>
                            </item>
                            <item name="MaximumResidualZ" desc="The maximum of the absolute value of the residual in the Z direction.">
<data_format_ref name="Image"/>
                            </item>
                        </struct>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Image.CodeReader.Result.Point">
            <trait>released</trait>
            <sample for="json">
        { "class":"Image.CodeReader.Result.Point", "data": { "x": 0.0, "y": 1.0 } }
      </sample>
            <item>
                <struct>
                    <item name="x">
                        <float width="32"/>
                    </item>
                    <item name="y">
                        <float width="32"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Image.CodeReader.Result.Roi">
            <trait>released</trait>
            <sample for="json">
        { "class":"Image.CodeReader.Result.Roi", "data": { "Vertex0" : { "x": 0.0, "y": 1.0 } }, "Vertex1" : { "x": 0.0, "y": 1.0 } }, "Vertex2" : { "x": 0.0, "y": 1.0 } }, "Vertex3" : { "x": 0.0, "y": 1.0 } } }
      </sample>
            <item>
                <struct>
                    <item name="Vertex0">
                        <data_format_ref name="Image.CodeReader.Result.Point"/>
                    </item>
                    <item name="Vertex1">
                        <data_format_ref name="Image.CodeReader.Result.Point"/>
                    </item>
                    <item name="Vertex2">
                        <data_format_ref name="Image.CodeReader.Result.Point"/>
                    </item>
                    <item name="Vertex3">
                        <data_format_ref name="Image.CodeReader.Result.Point"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Image.CodeReader.Result.Type">
            <trait>released</trait>
            <sample for="json">
        { "class": "Image.CodeReader.Result.Type", "data": "Codabar" }
      </sample>
            <item>
                <any_of>
                    <item>
                        <string value="Codabar"/>
                    </item>
                    <item>
                        <string value="Code39"/>
                    </item>
                    <item>
                        <string value="EAN/UPC"/>
                    </item>
                    <item>
                        <string value="Interleaved 2/5"/>
                    </item>
                    <item>
                        <string value="Code93"/>
                    </item>
                    <item>
                        <string value="Code128"/>
                    </item>
                    <item>
                        <string value="GS1"/>
                    </item>
                    <item>
                        <string value="Pharma"/>
                    </item>
                    <item>
                        <string value="PDF417"/>
                    </item>
                    <item>
                        <string value="DMx"/>
                    </item>
                    <item>
                        <string value="QR"/>
                    </item>
                    <item>
                        <string value="MaxiCode"/>
                    </item>
                    <item>
                        <string value="Dotcode"/>
                    </item>
                    <item>
                        <string value="Aztec"/>
                    </item>
                    <item desc="Describes a undecodable object - its type is contained in TypeExpected">
                        <string value="Undecodable"/>
                    </item>
                    <item desc="No Code in Image - this is actually not a code type">
                        <string value="NCII"/>
                    </item>
                </any_of>
            </item>
        </data_format>
        <data_format name="Image.CodeReader.Result.SubType">
            <trait>released</trait>
            <sample for="json">
        { "class": "Image.CodeReader.Result.SubType", "data": "Codabar" }
      </sample>
            <item>
                <any_of>
                    <item>
                        <string value="Codabar"/>
                    </item>
                    <item>
                        <string value="Code39"/>
                    </item>
                    <item>
                        <string value="Code32"/>
                    </item>
                    <item>
                        <string value="EAN/UPC.IDT"/>
                    </item>
                    <item>
                        <string value="EAN8.DT"/>
                    </item>
                    <item>
                        <string value="EAN13.DT"/>
                    </item>
                    <item>
                        <string value="UPCe.DT"/>
                    </item>
                    <item>
                        <string value="UPCe.EXP"/>
                    </item>
                    <item>
                        <string value="UPCa.DT"/>
                    </item>
                    <item>
                        <string value="AddOn"/>
                    </item>
                    <item>
                        <string value="Interleaved 2/5"/>
                    </item>
                    <item>
                        <string value="Code93.Conv"/>
                    </item>
                    <item>
                        <string value="Code93.Raw"/>
                    </item>
                    <item>
                        <string value="Code128.Conv"/>
                    </item>
                    <item>
                        <string value="Code128.Raw"/>
                    </item>
                    <item>
                        <string value="EAN128.Conv"/>
                    </item>
                    <item desc="Profile Code handled as a subtype of Code128">
                        <string value="Prof1D"/>
                    </item>
                    <item>
                        <string value="GS1.14"/>
                    </item>
                    <item>
                        <string value="GS1.Databar"/>
                    </item>
                    <item>
                        <string value="GS1.EXP"/>
                    </item>
                    <item>
                        <string value="GS1.Inc.Core"/>
                    </item>
                    <item>
                        <string value="GS1.Inc.Mem"/>
                    </item>
                    <item>
                        <string value="GS1.Limited"/>
                    </item>
                    <item>
                        <string value="Pharma"/>
                    </item>
                    <item>
                        <string value="PDF417"/>
                    </item>
                    <item>
                        <string value="DMx"/>
                    </item>
                    <item>
                        <string value="QR"/>
                    </item>
                    <item>
                        <string value="MaxiCode"/>
                    </item>
                    <item>
                        <string value="Dotcode"/>
                    </item>
                    <item>
                        <string value="Aztec"/>
                    </item>
                    <item>
                        <string value="Undecodable"/>
                    </item>
                    <item>
                        <string value="NCII"/>
                    </item>
                </any_of>
            </item>
        </data_format>
        <data_format name="Image.CodeReader.Result.UserDataList">
            <trait>released</trait>
            <sample for="json">
        { "class": "Image.CodeReader.Result.UserDataList", "data": { "m_Size":0 } }
      </sample>
            <item>
                <struct>
                    <item name="m_Size" desc="Number of list elements">
                        <int signed="false" width="32"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Image.CodeReader.Result">
            <trait>released</trait>
            <sample for="json">
        {
        "class":"Image.CodeReader.Results",
        "data":
        {
        "UniqueIdentifier":"1234709277672",
        "Type":"CODE128",
        "SubType":"CODE128CONV",
        "TypeExpected":"CODE128",
        "SubTypeExpected":"CODE128CONV",
        "ContentLength":6,
        "Content":
        {
        "numOfElems":6,
        "elemSz":1,
        "endian":"neutral",
        "elemTypes":["uint8"],"data":"QUJDYWJj"
        },
        "Region":
        {
        "Blank":false,
        "Value":
        {
        "Vertex0":{"x":4033,"y":2977},
        "Vertex1":{"x":4032,"y":3014},
        "Vertex2":{"x":3692,"y":3008},
        "Vertex3":{"x":3693,"y":2971}
        }
        },
        "AddonRegion":
        {
        "Blank":true,
        "Value":
        {
        "Vertex0":{"x":0,"y":0},
        "Vertex1":{"x":0,"y":0},
        "Vertex2":{"x":0,"y":0},
        "Vertex3":{"x":0,"y":0}
        }
        },
        "ModuleSizeX":3.88235282897949218,
        "ModuleSizeY":37.01351104664349378,
        "ModuleAspectRatio":0,
        "SymbolSizeX":0,
        "SymbolSizeY":1,
        "MaxNumErrors":0,
        "ErrorCorrectionLevel":"",
        "NumErrors":0,
        "ScanRatio":80,
        "ScanRatioGrade":"F",
        "QuietzoneLeft":100,
        "QuietzoneRight":100,
        "FeatureVector":0,
        "MultiRead":8,
        "MultiReadBase":10,
        "ScansOnRoi":10,
        "CoherentGoodReads":2,
        "RequiredScans":3,
        "UsableScans":2,
        "ResultQuality":80,
        "CodeSecurity":7,
        "UserDataList":
        {
        "UserDataList.m_Size":2,
        "UserDataList.key":"YourData","UserDataList.value.type":"Int","UserDataList.value.value":278,
        "UserDataList.key":"MyData","UserDataList.value.type":"String","UserDataList.value.value":"Test!"
        },
        "VerifierResult":
        {
        "Dimension":"NONE",
        "MinGray":18,
        "MaxGray":97,
        "Contrast":{"Value":78,"RawValue":30},
        "ContrastGrade":"A",
        "Modulation":57,
        "ModulationGrade":"C",
        "SymbolGrade":"F",
        "MinEdgeContrast":45,
        "MinEdgeContrastGrade":"A",
        "Defect":7,
        "DefectGrade":"A",
        "Decodability":5,
        "DecodabilityGrade":"F",
        "PrintGrowth":0,
        "PrintGrowthGrade":"X",
        "AxialNonUniformity":0,
        "AxialNonUniformityGrade":"X",
        "UnusedErrorCorrection":0,
        "UnusedErrorCorrectionGrade":"X",
        "FixedPatternDamage":0,
        "GridNonUniformity":0,
        "GridNonUniformityGrade":0,
        "CellContrastDPM":0,
        "MinimumReflectanceDPM":0,
        "CellModulationDPM":0,
        "FixedPatternDamageDPM":0
        }
        }
        }
      </sample>
            <item>
                <struct>
                    <item name="UniqueIdentifier" desc="A unique identifier of the result. For debug purposes.">
                        <int signed="true" width="64"/>
                    </item>
                    <item name="Type" desc="The type of the code result">
                        <data_format_ref name="Image.CodeReader.Result.Type"/>
                    </item>
                    <item name="SubType" desc="The subtype of the code result.">
                        <data_format_ref name="Image.CodeReader.Result.SubType"/>
                    </item>
                    <item name="TypeExpected" desc="The type of the code result.">
                        <data_format_ref name="Image.CodeReader.Result.Type"/>
                    </item>
                    <item name="SubTypeExpected" desc="The subtype of the code result.">
                        <data_format_ref name="Image.CodeReader.Result.SubType"/>
                    </item>
                    <item name="ContentLength">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="Content">
                        <big_data_array>
                            <element_type name="uint8" desc="The content of the code result. It may contain non-printable and multibyte characters."/>
                        </big_data_array>
                    </item>
                    <item name="Region">
                        <struct>
                            <item name="Blank">
<bool/>
                            </item>
                            <item name="Value">
<data_format_ref name="Image.CodeReader.Result.Roi"/>
                            </item>
                        </struct>
                    </item>
                    <item name="AddonRegion">
                        <struct>
                            <item name="Blank">
<bool/>
                            </item>
                            <item name="Value">
<data_format_ref name="Image.CodeReader.Result.Roi"/>
                            </item>
                        </struct>
                    </item>
                    <item name="ModuleSizeX">
                        <float width="32"/>
                    </item>
                    <item name="ModuleSizeY">
                        <float width="32"/>
                    </item>
                    <item name="ModuleAspectRatio">
                        <float width="32"/>
                    </item>
                    <item name="SymbolSizeX">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="SymbolSizeY">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="MaxNumErrors">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="ErrorCorrectionLevel">
                        <string/>
                    </item>
                    <item name="NumErrors">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="ScanRatio">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="ScanRatioGrade">
                        <int signed="true" width="8"/>
                    </item>
                    <item name="QuietzoneLeft">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="QuietzoneRight">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="FeatureVector">
                        <int signed="false" width="64"/>
                    </item>
                    <item name="MultiRead">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="MultiReadBase">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="ScansOnRoi">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="CoherentGoodReads">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="RequiredScans">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="UsableScans">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="ResultQuality">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="CodeSecurity">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="UserDataList" desc="A collection of additional user defined results.">
                        <data_format_ref name="Image.CodeReader.Result.UserDataList"/>
                    </item>
                    <item name="VerifierResult">
                        <data_format_ref name="Image.CodeReader.VerifierResult"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Image.CodeReader.VerifierResult.Dimension">
            <trait>released</trait>
            <sample for="json">
        { "class": "Image.CodeReader.VerifierResult.Dimension", "data": "CodeDimNone" }
      </sample>
            <item>
                <any_of>
                    <item>
                        <string value="CodeDimNone"/>
                    </item>
                    <item>
                        <string value="CodeDim1D"/>
                    </item>
                    <item>
                        <string value="CodeDim2D"/>
                    </item>
                    <item>
                        <string value="CodeDimPostal"/>
                    </item>
                </any_of>
            </item>
        </data_format>
        <data_format name="Image.CodeReader.VerifierResult">
            <trait>released</trait>
            <sample for="json">
        {
          "class":"Image.CodeReader.VerifierResults",
          "data":
          {
            "Dimension":"NONE",
            "MinGray":18,
            "MaxGray":97,
            "Contrast":{"Value":78,"RawValue":30},
            "ContrastGrade":"A",
            "Modulation":57,
            "ModulationGrade":"C",
            "SymbolGrade":"F",
            "MinEdgeContrast":45,
            "MinEdgeContrastGrade":"A",
            "Defect":7,
            "DefectGrade":"A",
            "Decodability":5,
            "DecodabilityGrade":"F",
            "PrintGrowth":0,
            "PrintGrowthGrade":"X",
            "AxialNonUniformity":0,
            "AxialNonUniformityGrade":"X",
            "UnusedErrorCorrection":0,
            "UnusedErrorCorrectionGrade":"X",
            "FixedPatternDamage":0,
            "GridNonUniformity":0,
            "CellContrastDPM":0,
            "MinimumReflectanceDPM":0,
            "CellModulationDPM":0,
            "FixedPatternDamageDPM":0
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="Dimension" desc="The dimension (type) the verifier result belongs to.">
                        <data_format_ref name="Image.CodeReader.VerifierResult.Dimension"/>
                    </item>
                    <item name="MinGray">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="MaxGray">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="Contrast">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="ContrastGrade">
                        <int signed="true" width="8"/>
                    </item>
                    <item name="Modulation">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="ModulationGrade">
                        <int signed="true" width="8"/>
                    </item>
                    <item name="SymbolGrade">
                        <int signed="true" width="8"/>
                    </item>
                    <item name="MinReflectionGrade">
                        <int signed="true" width="8"/>
                    </item>
                    <item name="MinEdgeContrast">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="MinEdgeContrastGrade">
                        <int signed="true" width="8"/>
                    </item>
                    <item name="Defect">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="DefectGrade">
                        <int signed="true" width="8"/>
                    </item>
                    <item name="Decodability">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="DecodabilityGrade">
                        <int signed="true" width="8"/>
                    </item>
                    <item name="PrintGrowth">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="PrintGrowthGrade">
                        <int signed="true" width="8"/>
                    </item>
                    <item name="AxialNonUniformity">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="AxialNonUniformityGrade">
                        <int signed="true" width="8"/>
                    </item>
                    <item name="UnusedErrorCorrection">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="UnusedErrorCorrectionGrade">
                        <int signed="true" width="8"/>
                    </item>
                    <item name="FixedPatternDamage">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="GridNonUniformity">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="GridNonUniformityGrade">
                        <int signed="true" width="8"/>
                    </item>
                    <item name="CellContrastDPM">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="MinimumReflectanceDPM">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="CellModulationDPM">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="FixedPatternDamageDPM">
                        <int signed="true" width="32"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Image.CodeReader.TimeMeasurement">
            <trait>hidden</trait>
            <sample for="json">
        {
          "class":"Image.CodeReader.TimeMeasurement",
          "data":
          {
            "Name":"Decode",
            "Description":"Start of Decoder",
            "Duration":128
          }
        }
      </sample>
            <item>
                <struct>
                    <item name="Name" desc="The name of the particular time measurement.">
                        <string/>
                    </item>
                    <item name="Description" desc="A more detailed description of the particular time measurement.">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="Duration">
                        <int signed="true" width="64"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="MachineLearning.DataSet">
            <trait>released</trait>
            <sample for="json">
      {
        "class":"MachineLearning.DataSet",
        "data":
        {
          "Revision":0,
          "Width":0,
          "Height":0,
          "LabelType":"Classification",
          "WeightsExist":false,
          "Samples":
          {
            "numOfElems":0,
            "elemSz":4,
            "endian":"little",
            "elemTypes":["float32"],
            "data":""
          },
          "Labels":
          {
            "numOfElems":0,
            "elemSz":4,
            "endian":"little",
            "elemTypes":["int32"],
            "data":""
          },
          "Weights":
          {
            "numOfElems":0,
            "elemSz":4,
            "endian":"little",
            "elemTypes":["float32"],
            "data":""
          }
        }
      }
      </sample>
            <item>
                <struct>
                    <item name="Revision">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="Width">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="Height">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="LabelType">
                        <any_of>
                            <item>
<string value="Classification"/>
                            </item>
                            <item>
<string value="Regression"/>
                            </item>
                        </any_of>
                    </item>
                    <item name="WeightsExist">
                        <bool/>
                    </item>
                    <item name="Samples">
                        <big_data_array>
                            <element_type name="float32"/>
                        </big_data_array>
                    </item>
                    <item name="Labels">
                        <any_of>
                            <item>
<big_data_array>
    <element_type name="float32"/>
</big_data_array>
                            </item>
                            <item>
<big_data_array>
    <element_type name="int32"/>
</big_data_array>
                            </item>
                        </any_of>
                    </item>
                    <item name="Weights">
                        <big_data_array>
                            <element_type name="float32"/>
                        </big_data_array>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Image.Matching.EdgeMatcher">
            <trait>released</trait>
            <sample for="json">
      {
        "class":"Image.Matching.EdgeMatcher",
        "data": {
          "Params":{
            "Version":2,
            "EdgeThreshold":{"x":50,"y":1000},
            "ProcessingUnit":1
          },
          "TimeoutSeconds":5,
          "Matcher":"aa"
        }
      }
      </sample>
            <item>
                <struct>
                    <item name="Version">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="Params">
                        <struct>
                            <item name="EdgeThreshold">
<struct>
    <item name="x">
        <float width="64"/>
    </item>
    <item name="y">
        <float width="64"/>
    </item>
</struct>
                            </item>
                            <item name="ProcessingUnit">
<int signed="true" width="32"/>
                            </item>
                        </struct>
                    </item>
                    <item name="TimeoutSeconds">
                        <float width="64"/>
                    </item>
                    <item name="Matcher">
                        <string/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Image.Matching.EdgeMatcher3D">
            <trait>released</trait>
            <sample for="json">
      {
        "class":"Image.Matching.EdgeMatcher3D",
        "data": {
          "Version":2,
          "Params":{
            "EdgeThreshold":{"x":50,"y":1000},
            "ProcessingUnit":1
          },
          "TimeoutSeconds":5,
          "ReferencePlaneSet":true,
          "Matcher":"aa"
        }
      }
      </sample>
            <item>
                <struct>
                    <item name="Version">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="Params">
                        <struct>
                            <item name="EdgeThreshold">
<struct>
    <item name="x">
        <float width="64"/>
    </item>
    <item name="y">
        <float width="64"/>
    </item>
</struct>
                            </item>
                            <item name="ProcessingUnit">
<int signed="true" width="32"/>
                            </item>
                        </struct>
                    </item>
                    <item name="TimeoutSeconds">
                        <float width="64"/>
                    </item>
                    <item name="ReferencePlaneSet">
                        <bool/>
                    </item>
                    <item name="Matcher">
                        <string/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Image.Matching.PointMatcher">
            <trait>released</trait>
            <sample for="json">
      {
        "class":"Image.Matching.PointMatcher",
        "data": {
          "Version":2,
          "Matcher":"aa"
        }
      }
      </sample>
            <item>
                <struct>
                    <item name="Version">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="Matcher">
                        <string/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Image.Fixture">
            <trait>released</trait>
            <sample for="json">
      {
        "class":"Image.Fixture",
        "data": {
          "PointsNames":[ "thePoint_0", "thePoint_1"],
          "Points":[{"x":50,"y":1000}, {"x":51,"y":1001}],
          "ShapesNames":[ "theShape_0", "theShape_1"],
          "Shapes":[ "Shape.Circle", "Shape.Line"],
          "CompositeShapesNames":[ "theCompositeShape_0", "theCompositeShape_1"],
          "CompositeShapes":[ "Shape.Composite", "Shape.Composite"],
          "AnglesNames":[ "theAngle_0", "theAngle_1"],
          "Angles":[ 1.1, 1.2],
          "PosesNames":[ "thePose_0", "thePose_1"],
          "Pose":[ "Transform2D", "Transform2D"],
          "TeachPoseSet": "true",
          "TransformSet": "true",
          "TeachToMatch": "Transform2D",
          "TeachToModel": "Transform2D"
        }
      }
      </sample>
            <item>
                <struct>
                    <item name="PointsNames">
                        <array>
                            <item>
<string/>
                            </item>
                        </array>
                    </item>
                    <item name="Points">
                        <array>
                            <item>
<struct>
    <item name="x">
        <float width="64"/>
    </item>
    <item name="y">
        <float width="64"/>
    </item>
</struct>
                            </item>
                        </array>
                    </item>
                    <item name="ShapesNames">
                        <array>
                            <item>
<string/>
                            </item>
                        </array>
                    </item>
                    <item name="Shapes">
                        <array>
                            <item>
<polymorphic/>
                            </item>
                        </array>
                    </item>
                    <item name="CompositeShapesNames">
                        <array>
                            <item>
<string/>
                            </item>
                        </array>
                    </item>
                    <item name="CompositeShapes">
                        <array>
                            <item>
<polymorphic/>
                            </item>
                        </array>
                    </item>
                    <item name="AnglesNames">
                        <array>
                            <item>
<string/>
                            </item>
                        </array>
                    </item>
                    <item name="Angles">
                        <array>
                            <item>
<float width="64"/>
                            </item>
                        </array>
                    </item>
                    <item name="PosesNames">
                        <array>
                            <item>
<string/>
                            </item>
                        </array>
                    </item>
                    <item name="Poses">
                        <array>
                            <item>
<polymorphic/>
                            </item>
                        </array>
                    </item>
                    <item name="TeachPoseSet">
                        <bool/>
                    </item>
                    <item name="TransformSet">
                        <bool/>
                    </item>
                    <item name="TeachToMatch">
                        <polymorphic/>
                    </item>
                    <item name="TeachToModel">
                        <polymorphic/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Image.Fixture3D">
            <trait>released</trait>
            <sample for="json">
      {
        "class":"Image.Fixture3D",
        "data": {
          "PointsNames":[ "thePoint_0", "thePoint_1"],
          "Points":[{"x":50,"y":1000}, {"x":51,"y":1001}],
          "ShapesNames":[ "theShape_0", "theShape_1"],
          "Shapes":[ "Shape.Circle", "Shape.Line"],
          "PosesNames":[ "thePose_0", "thePose_1"],
          "Pose":[ "Transform3D", "Transform3D"],
          "TeachPoseSet": "true",
          "TransformSet": "true",
          "TeachToMatch": "Transform3D",
          "TeachToModel": "Transform3D"
        }
      }
      </sample>
            <item>
                <struct>
                    <item name="PointsNames">
                        <array>
                            <item>
<string/>
                            </item>
                        </array>
                    </item>
                    <item name="Points">
                        <array>
                            <item>
<struct>
    <item name="x">
        <float width="64"/>
    </item>
    <item name="y">
        <float width="64"/>
    </item>
    <item name="z">
        <float width="64"/>
    </item>
</struct>
                            </item>
                        </array>
                    </item>
                    <item name="ShapesNames">
                        <array>
                            <item>
<string/>
                            </item>
                        </array>
                    </item>
                    <item name="Shapes">
                        <array>
                            <item>
<polymorphic/>
                            </item>
                        </array>
                    </item>
                    <item name="PosesNames">
                        <array>
                            <item>
<string/>
                            </item>
                        </array>
                    </item>
                    <item name="Poses">
                        <array>
                            <item>
<polymorphic/>
                            </item>
                        </array>
                    </item>
                    <item name="TeachPoseSet">
                        <bool/>
                    </item>
                    <item name="TransformSet">
                        <bool/>
                    </item>
                    <item name="TeachToMatch">
                        <polymorphic/>
                    </item>
                    <item name="TeachToModel">
                        <polymorphic/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Image.Benchmark">
            <trait>hidden</trait>
            <sample for="json">
      {
        "class":"Image.Benchmark",
        "data": {
          "Version":1
        }
      }
      </sample>
            <item>
                <struct>
                    <item name="Version">
                        <int signed="true" width="32"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Image.BackgroundModel">
            <trait>released</trait>
            <sample for="json">
      {
        "class":"Image.BackgroundModel.Average",
        "data":{
          "ImageCount":0,
          "LineMode":true,
          "ValidCount":{
            "class":"Image",
            "data":{
              "PixelSize":{"x":1,"y":1,"z":1},
              "Origin":{"x":0,"y":0,"z":0},
              "HandleZeroPixels":"Default",
              "Data":
              { "ImageType":"uint8",
                "Width":1,
                "Height":1,
                "Pixels":
                { "numOfElems":1,
                  "elemSz":1,
                  "endian":"neutral",
                  "elemTypes":["uint8"],
                  "data":"AA=="
                }
              }
            }
          },
          "RegionOfInterest":{
            "class":"Image.PixelRegion",
            "data":{
              "segments":
              {
                "numOfElems":0,
                "elemSz":12,
                "endian":"little",
                "elemTypes":["int32","int32","int32"],
                "data":""
              }
            }
          },
          "Average":{
            "class":"Image",
            "data":{
              "PixelSize":{"x":1,"y":1,"z":1},
              "Origin":{"x":0,"y":0,"z":0},
              "HandleZeroPixels":"Default",
              "Data":
              { "ImageType":"float32",
                "Width":0,
                "Height":0,
                "Pixels":
                { "numOfElems":0,
                  "elemSz":4,
                  "endian":"little",
                  "elemTypes":["float32"],
                  "data":""
                }
              }
            }
          }
        }
      }
      </sample>
            <item>
                <polymorphic>
                    <data_format_ref name="Image.BackgroundModel.Average"/>
                    <data_format_ref name="Image.BackgroundModel.Gaussian"/>
                    <data_format_ref name="Image.BackgroundModel.RunningGaussian"/>
                </polymorphic>
            </item>
        </data_format>
        <data_format name="Image.BackgroundModel.Average">
            <trait>released</trait>
            <sample for="json">
      {
        "class":"Image.BackgroundModel.Average",
        "data":{
          "ImageCount":0,
          "LineMode":true,
          "ValidCount":{
            "class":"Image",
            "data":{
              "PixelSize":{"x":1,"y":1,"z":1},
              "Origin":{"x":0,"y":0,"z":0},
              "HandleZeroPixels":"Default",
              "Data":
              { "ImageType":"uint8",
                "Width":1,
                "Height":1,
                "Pixels":
                { "numOfElems":1,
                  "elemSz":1,
                  "endian":"neutral",
                  "elemTypes":["uint8"],
                  "data":"AA=="
                }
              }
            }
          },
          "RegionOfInterest":{
            "class":"Image.PixelRegion",
            "data":{
              "segments":
              {
                "numOfElems":0,
                "elemSz":12,
                "endian":"little",
                "elemTypes":["int32","int32","int32"],
                "data":""
              }
            }
          },
          "Average":{
            "class":"Image",
            "data":{
              "PixelSize":{"x":1,"y":1,"z":1},
              "Origin":{"x":0,"y":0,"z":0},
              "HandleZeroPixels":"Default",
              "Data":
              { "ImageType":"float32",
                "Width":0,
                "Height":0,
                "Pixels":
                { "numOfElems":0,
                  "elemSz":4,
                  "endian":"little",
                  "elemTypes":["float32"],
                  "data":""
                }
              }
            }
          }
        }
      }
      </sample>
            <item>
                <struct>
                    <item name="ImageCount" desc="The total number of images added to the model or in line mode the number of lines.">
                        <int signed="true" width="64"/>
                    </item>
                    <item name="LineMode" desc="States if this model uses line mode or not.">
                        <bool/>
                    </item>
                    <item name="ValidCount" desc="The total number of valid observations per pixel from all calls to add.">
                        <data_format_ref name="Image"/>
                    </item>
                    <item name="RegionOfInterest" desc="The configured pixel region where the model is used.">
                        <data_format_ref name="Image.PixelRegion"/>
                    </item>
                    <item name="Average" desc="The current average image.">
                        <data_format_ref name="Image"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Image.BackgroundModel.Gaussian">
            <trait>released</trait>
            <sample for="json">
      {
        "class":"Image.BackgroundModel.Gaussian",
        "data":{
          "ImageCount":1,
          "LineMode":false,
          "ValidCount":{
            "class":"Image",
            "data":{
              "PixelSize":{"x":1,"y":1,"z":1},
              "Origin":{"x":0,"y":0,"z":0},
              "HandleZeroPixels":"Default",
              "Data":
              { "ImageType":"uint32",
                "Width":1,
                "Height":1,
                "Pixels":
                { "numOfElems":1,
                  "elemSz":4,
                  "endian":"little",
                  "elemTypes":["uint32"],
                  "data":"AQAAAA=="
                }
              }
            }
          },
          "RegionOfInterest":{
            "class":"Image.PixelRegion",
            "data":{
              "segments":
              {
                "numOfElems":0,
                "elemSz":12,
                "endian":"little",
                "elemTypes":["int32","int32","int32"],
                "data":""
              }
            }
          },
          "Average":{
            "class":"Image",
            "data":{
              "PixelSize":{"x":1,"y":1,"z":1},
              "Origin":{"x":0,"y":0,"z":0},
              "HandleZeroPixels":"Default",
              "Data":
              { "ImageType":"float32",
                "Width":1,
                "Height":1,
                "Pixels":
                { "numOfElems":1,
                  "elemSz":4,
                  "endian":"little",
                  "elemTypes":["float32"],
                  "data":"AAAAAA=="
                }
              }
            }
          },
          "Variance":{
            "class":"Image",
            "data":{
              "PixelSize":{"x":1,"y":1,"z":1},
              "Origin":{"x":0,"y":0,"z":0},
              "HandleZeroPixels":"Default",
              "Data":
              { "ImageType":"float32",
                "Width":1,
                "Height":1,
                "Pixels":
                { "numOfElems":1,
                  "elemSz":4,
                  "endian":"little",
                  "elemTypes":["float32"],
                  "data":"AAAAAA=="
                }
              }
            }
          }
        }
      }
      </sample>
            <item>
                <struct>
                    <item name="ImageCount" desc="The total number of images added to the model or in line mode the number of lines.">
                        <int signed="true" width="64"/>
                    </item>
                    <item name="LineMode" desc="States if this model uses line mode or not.">
                        <bool/>
                    </item>
                    <item name="ValidCount" desc="The total number of valid observations per pixel from all calls to add.">
                        <data_format_ref name="Image"/>
                    </item>
                    <item name="RegionOfInterest" desc="The configured pixel region where the model is used.">
                        <data_format_ref name="Image.PixelRegion"/>
                    </item>
                    <item name="Average" desc="The current average image.">
                        <data_format_ref name="Image"/>
                    </item>
                    <item name="Variance" desc="The current variance image.">
                        <data_format_ref name="Image"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="Image.BackgroundModel.RunningGaussian">
            <trait>released</trait>
            <sample for="json">
      {
        "class":"Image.BackgroundModel.RunningGaussian",
        "data":{
          "ImageCount":1,
          "LineMode":false,
          "ValidCount":{
            "class":"Image",
            "data":{
              "PixelSize":{"x":1,"y":1,"z":1},
              "Origin":{"x":0,"y":0,"z":0},
              "HandleZeroPixels":"Default",
              "Data":
              { "ImageType":"uint32",
                "Width":1,
                "Height":1,
                "Pixels":
                { "numOfElems":1,
                  "elemSz":4,
                  "endian":"little",
                  "elemTypes":["uint32"],
                  "data":"ZQAAAA=="
                }
              }
            }
          },
          "RegionOfInterest":{
            "class":"Image.PixelRegion",
            "data":{
              "segments":
              {
                "numOfElems":0,
                "elemSz":12,
                "endian":"little",
                "elemTypes":["int32","int32","int32"],
                "data":""
              }
            }
          },
          "Average":{
            "class":"Image",
            "data":{
              "PixelSize":{"x":1,"y":1,"z":1},
              "Origin":{"x":0,"y":0,"z":0},
              "HandleZeroPixels":"Default",
              "Data":
              { "ImageType":"float32",
                "Width":1,
                "Height":1,
                "Pixels":
                { "numOfElems":1,
                  "elemSz":4,
                  "endian":"little",
                  "elemTypes":["float32"],
                  "data":"AAAAAA=="
                }
              }
            }
          },
          "Variance":{
            "class":"Image",
            "data":{
              "PixelSize":{"x":1,"y":1,"z":1},
              "Origin":{"x":0,"y":0,"z":0},
              "HandleZeroPixels":"Default",
              "Data":
              { "ImageType":"float32",
                "Width":1,
                "Height":1,
                "Pixels":
                { "numOfElems":1,
                  "elemSz":4,
                  "endian":"little",
                  "elemTypes":["float32"],
                  "data":"AAAAAA=="
                }
              }
            }
          },
          "LearningRate":0.01,
          "Memory":100,
          "VarianceIntialization":-1
        }
      }
      </sample>
            <item>
                <struct>
                    <item name="ImageCount" desc="The total number of images added to the model or in line mode the number of lines.">
                        <int signed="true" width="64"/>
                    </item>
                    <item name="LineMode" desc="States if this model uses line mode or not.">
                        <bool/>
                    </item>
                    <item name="ValidCount" desc="The total number of valid observations per pixel from all calls to add.">
                        <data_format_ref name="Image"/>
                    </item>
                    <item name="RegionOfInterest" desc="The configured pixel region where the model is used.">
                        <data_format_ref name="Image.PixelRegion"/>
                    </item>
                    <item name="Average" desc="The current average image.">
                        <data_format_ref name="Image"/>
                    </item>
                    <item name="Variance" desc="The current variance image.">
                        <data_format_ref name="Image"/>
                    </item>
                    <item name="LearningRate" desc="The rate at which values in the model are replaced by incoming images.">
                        <float width="64"/>
                    </item>
                    <item name="Memory" desc="The number of samples a pixel can lag behind before being considered outdated.">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="VarianceIntialization" desc="The total number of images added to the model.">
                        <float width="64"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="SensorNetwork.CodeData.Point3D">
            <trait>released</trait>
            <item>
                <struct>
                    <item name="x" desc="X coordinate">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="y" desc="Y coordinate">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="z" desc="Z coordinate">
                        <int signed="true" width="32"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="SensorNetwork.CodeData.CodeInfo1D">
            <trait>released</trait>
            <item>
                <struct>
                    <item name="Multiread">
                        <int signed="false" width="16"/>
                    </item>
                    <item name="ScanDirection">
                        <int signed="false" width="8"/>
                    </item>
                    <item name="AppendDirection">
                        <int signed="false" width="8"/>
                    </item>
                    <item name="NorcaData1D">
                        <any_of>
                            <item>
<struct/>
                            </item>
                            <item>
<struct>
    <item name="VerifierValueECmin">
        <int signed="true" width="8"/>
    </item>
    <item name="VerifierGradeECmin">
        <int signed="true" width="8"/>
    </item>
    <item name="VerifierValueDefects">
        <int signed="true" width="8"/>
    </item>
    <item name="VerifierGradeDefects">
        <int signed="true" width="8"/>
    </item>
    <item name="QuietZone">
        <int signed="true" width="8"/>
    </item>
    <item name="ModuleSize">
        <int signed="true" width="16"/>
    </item>
</struct>
                            </item>
                        </any_of>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="SensorNetwork.CodeData.CodeInfo2D">
            <trait>released</trait>
            <item>
                <struct>
                    <item name="CodeSizeX">
                        <int signed="false" width="8"/>
                    </item>
                    <item name="CodeSizeY">
                        <int signed="false" width="8"/>
                    </item>
                    <item name="Multiread">
                        <int signed="false" width="16"/>
                    </item>
                    <item name="UsedErrorCorrection">
                        <int signed="true" width="16"/>
                    </item>
                    <item name="ModuleSizeX">
                        <int signed="true" width="16"/>
                    </item>
                    <item name="ModuleSizeY">
                        <int signed="true" width="16"/>
                    </item>
                    <item name="Contrast">
                        <int signed="false" width="8"/>
                    </item>
                    <item name="NorcaData2D">
                        <any_of>
                            <item>
<struct/>
                            </item>
                            <item>
<struct>
    <item name="VerifierValuePG">
        <int signed="true" width="8"/>
    </item>
    <item name="VerifierGradePG">
        <int signed="true" width="8"/>
    </item>
    <item name="VerifierValueUEC">
        <int signed="true" width="8"/>
    </item>
    <item name="VerifierGradeUEC">
        <int signed="true" width="8"/>
    </item>
    <item name="VerifierValueANU">
        <int signed="true" width="8"/>
    </item>
    <item name="VerifierGradeANU">
        <int signed="true" width="8"/>
    </item>
    <item name="VerifierValueLAN">
        <int signed="true" width="8"/>
    </item>
    <item name="VerifierGradeLAN">
        <int signed="true" width="8"/>
    </item>
    <item name="VerifierValueGNU">
        <int signed="true" width="8"/>
    </item>
    <item name="VerifierGradeGNU">
        <int signed="true" width="8"/>
    </item>
</struct>
                            </item>
                        </any_of>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="SensorNetwork.CodeData.ItemData">
            <trait>released</trait>
            <item>
                <struct>
                    <item name="Width">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="Height">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="UnitsDimension">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="Quality">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="ItemGroup">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="ItemType">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="ProcessingTime">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="FeatureVector">
                        <int signed="false" width="32"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="SensorNetwork.CodeData.ObjectData">
            <trait>released</trait>
            <item>
                <struct>
                    <item name="FeatureVector">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="Width">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="Length">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="Height">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="Resolution">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="DeviceID">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="ObjectID">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="Quality">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="UnitsDimension">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="Volume">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="UnitsVolume">
                        <int signed="false" width="32"/>
                    </item>
                    <item name="Corner1">
                        <data_format_ref name="SensorNetwork.CodeData.Point3D"/>
                    </item>
                    <item name="Corner2">
                        <data_format_ref name="SensorNetwork.CodeData.Point3D"/>
                    </item>
                    <item name="Corner3">
                        <data_format_ref name="SensorNetwork.CodeData.Point3D"/>
                    </item>
                    <item name="Corner4">
                        <data_format_ref name="SensorNetwork.CodeData.Point3D"/>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="SensorNetwork.CodeData">
            <trait>released</trait>
            <item>
                <struct>
                    <item name="SymbolID">
                        <int signed="false" width="16"/>
                    </item>
                    <item name="CodeContent">
                        <string/>
                    </item>
                    <item name="ObjectID">
                        <int signed="true" width="16"/>
                    </item>
                    <item name="PositionIncrement">
                        <int signed="false" width="16"/>
                    </item>
                    <item name="Symbology">
                        <int signed="false" width="16"/>
                    </item>
                    <item name="SymbologyEx">
                        <int signed="false" width="16"/>
                    </item>
                    <item name="DeviceID">
                        <int signed="false" width="16"/>
                    </item>
                    <item name="TopLeft">
                        <data_format_ref name="SensorNetwork.CodeData.Point3D"/>
                    </item>
                    <item name="TopRight">
                        <data_format_ref name="SensorNetwork.CodeData.Point3D"/>
                    </item>
                    <item name="BottomLeft">
                        <data_format_ref name="SensorNetwork.CodeData.Point3D"/>
                    </item>
                    <item name="BottomRight">
                        <data_format_ref name="SensorNetwork.CodeData.Point3D"/>
                    </item>
                    <item name="Center">
                        <data_format_ref name="SensorNetwork.CodeData.Point3D"/>
                    </item>
                    <item name="CenterClosest">
                        <data_format_ref name="SensorNetwork.CodeData.Point3D"/>
                    </item>
                    <item name="DistTolerance">
                        <int signed="true" width="16"/>
                    </item>
                    <item name="FocusDistance">
                        <int signed="true" width="16"/>
                    </item>
                    <item name="ReadingDistance">
                        <int signed="true" width="16"/>
                    </item>
                    <item name="TiltAngle">
                        <float width="32"/>
                    </item>
                    <item name="NorcaEnable">
                        <int signed="false" width="8"/>
                    </item>
                    <item name="NorcaData">
                        <any_of>
                            <item>
<struct/>
                            </item>
                            <item>
<struct>
    <item name="ResultQuality">
        <int signed="false" width="8"/>
    </item>
    <item name="FeatureVector">
        <int signed="false" width="32"/>
    </item>
    <item name="VerifierValueDecode">
        <int signed="true" width="8"/>
    </item>
    <item name="VerifierGradeDecode">
        <int signed="true" width="8"/>
    </item>
    <item name="VerifierValueSC">
        <int signed="true" width="8"/>
    </item>
    <item name="VerifierGradeSC">
        <int signed="true" width="8"/>
    </item>
    <item name="VerifierValueRmin">
        <int signed="true" width="8"/>
    </item>
    <item name="VerifierGradeRmin">
        <int signed="true" width="8"/>
    </item>
    <item name="VerifierValueMod">
        <int signed="true" width="8"/>
    </item>
    <item name="VerifierGradeMod">
        <int signed="true" width="8"/>
    </item>
    <item name="VerifierValueDecodeability">
        <int signed="true" width="8"/>
    </item>
    <item name="VerifierGradeDecodeability">
        <int signed="true" width="8"/>
    </item>
    <item name="VerifierGradeOSG">
        <int signed="true" width="8"/>
    </item>
</struct>
                            </item>
                        </any_of>
                    </item>
                    <item name="CodeInfo">
                        <any_of>
                            <item>
<data_format_ref name="SensorNetwork.CodeData.CodeInfo1D"/>
                            </item>
                            <item>
<data_format_ref name="SensorNetwork.CodeData.CodeInfo2D"/>
                            </item>
                        </any_of>
                    </item>
                    <item name="ItemData">
                        <polymorphic can_be_null="true">
                            <data_format_ref name="SensorNetwork.CodeData.ItemData"/>
                        </polymorphic>
                    </item>
                    <item name="ObjectData">
                        <polymorphic can_be_null="true">
                            <data_format_ref name="SensorNetwork.CodeData.ObjectData"/>
                        </polymorphic>
                    </item>
                </struct>
            </item>
        </data_format>
        <data_format name="MachineLearning.DeepNeuralNetwork.Model">
            <trait>released</trait>
            <sample for="json">
      {
        "class": "MachineLearning.DeepNeuralNetwork.Model",
        "data": {
          "FileVersion": "1.0",
          "Name": "Name",
          "Encrypted": true,
          "Type": 1,
          "ColorOrderRGB": true,
          "Nodes": {
            "Input": [
              {
                "Name": "image",
                "Path": "image",
                "SourceSpecification": {
                  "Type": "uint8",
                  "Mean": [
                    0
                  ],
                  "Scale": 0.00392156862745098
                },
                "Dtype": "float32",
                "Shape": [
                  1,
                  256,
                  256,
                  1
                ]
              }
            ],
            "Output": [
              {
                "Name": "logits",
                "Path": "Squeeze:0",
                "Labels": [
                  "down",
                  "other",
                  "up"
                ],
                "Type": "ClassificationLogits"
              }
            ]
          },
          "Network": ""
        }
      }
      </sample>
            <item>
                <struct>
                    <item name="FileVersion">
                        <string/>
                    </item>
                    <item name="DLearnerVersion">
                        <string/>
                    </item>
                    <item name="DCoreVersion">
                        <string/>
                    </item>
                    <item name="Name">
                        <string/>
                    </item>
                    <item name="Encrypted">
                        <bool/>
                    </item>
                    <item name="Type">
                        <int signed="true" width="32"/>
                    </item>
                    <item name="ColorOrderRGB">
                        <bool/>
                    </item>
                    <item name="Nodes">
                        <struct>
                            <item name="Input">
<array>
    <item>
        <struct>
            <item name="Name">
                <string/>
            </item>
            <item name="Path">
                <string/>
            </item>
            <item name="SourceSpecification">
                <struct>
                    <item name="Type">
                        <string/>
                    </item>
                    <item name="Mean">
                        <array>
                            <item>
<float width="64"/>
                            </item>
                        </array>
                    </item>
                    <item name="Scale">
                        <float width="64"/>
                    </item>
                </struct>
            </item>
            <item name="DType">
                <string/>
            </item>
            <item name="Shape">
                <array>
                    <item>
                        <int signed="true" width="32"/>
                    </item>
                </array>
            </item>
            <item name="CropMode">
                <string/>
            </item>
        </struct>
    </item>
</array>
                            </item>
                            <item name="Output">
<array>
    <item>
        <struct>
            <item name="Name">
                <string/>
            </item>
            <item name="Path">
                <string/>
            </item>
            <item name="Labels">
                <array>
                    <item>
                        <string/>
                    </item>
                </array>
            </item>
            <item name="Type">
                <string/>
            </item>
        </struct>
    </item>
</array>
                            </item>
                        </struct>
                    </item>
                    <item name="Network">
                        <string/>
                    </item>
                </struct>
            </item>
        </data_format>
        <meta key="version">T1.1.1.9</meta>
        <meta key="AppEngineVersion">2.13.0</meta>
    </application>
</manifest>
